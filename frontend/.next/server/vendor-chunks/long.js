"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/long";
exports.ids = ["vendor-chunks/long"];
exports.modules = {

/***/ "(ssr)/./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/***/ ((module) => {

eval("\nmodule.exports = Long;\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */ var wasm = null;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        13,\n        2,\n        96,\n        0,\n        1,\n        127,\n        96,\n        4,\n        127,\n        127,\n        127,\n        127,\n        1,\n        127,\n        3,\n        7,\n        6,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        6,\n        6,\n        1,\n        127,\n        1,\n        65,\n        0,\n        11,\n        7,\n        50,\n        6,\n        3,\n        109,\n        117,\n        108,\n        0,\n        1,\n        5,\n        100,\n        105,\n        118,\n        95,\n        115,\n        0,\n        2,\n        5,\n        100,\n        105,\n        118,\n        95,\n        117,\n        0,\n        3,\n        5,\n        114,\n        101,\n        109,\n        95,\n        115,\n        0,\n        4,\n        5,\n        114,\n        101,\n        109,\n        95,\n        117,\n        0,\n        5,\n        8,\n        103,\n        101,\n        116,\n        95,\n        104,\n        105,\n        103,\n        104,\n        0,\n        0,\n        10,\n        191,\n        1,\n        6,\n        4,\n        0,\n        35,\n        0,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        126,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        127,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        128,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        129,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        130,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11\n    ])), {}).exports;\n} catch (e) {\n// no wasm support :(\n}\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */ function Long(low, high, unsigned) {\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */ this.low = low | 0;\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */ this.high = high | 0;\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */ this.unsigned = !!unsigned;\n}\n// The internal representation of a long is the two given signed, 32-bit values.\n// We use 32-bit pieces because these are the size of integers on which\n// Javascript performs bit-operations.  For operations like addition and\n// multiplication, we split each number into 16 bit pieces, which can easily be\n// multiplied within Javascript's floating-point representation without overflow\n// or change in sign.\n//\n// In the algorithms below, we frequently reduce the negative case to the\n// positive case by negating the input(s) and then post-processing the result.\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n// a positive number, it overflows back into a negative).  Not handling this\n// case would often result in infinite recursion.\n//\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n// methods on which they depend.\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */ Long.prototype.__isLong__;\nObject.defineProperty(Long.prototype, \"__isLong__\", {\n    value: true\n});\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */ function isLong(obj) {\n    return (obj && obj[\"__isLong__\"]) === true;\n}\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */ Long.isLong = isLong;\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */ var INT_CACHE = {};\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */ var UINT_CACHE = {};\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */ function fromInt(value, unsigned) {\n    var obj, cachedObj, cache;\n    if (unsigned) {\n        value >>>= 0;\n        if (cache = 0 <= value && value < 256) {\n            cachedObj = UINT_CACHE[value];\n            if (cachedObj) return cachedObj;\n        }\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n        if (cache) UINT_CACHE[value] = obj;\n        return obj;\n    } else {\n        value |= 0;\n        if (cache = -128 <= value && value < 128) {\n            cachedObj = INT_CACHE[value];\n            if (cachedObj) return cachedObj;\n        }\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\n        if (cache) INT_CACHE[value] = obj;\n        return obj;\n    }\n}\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */ Long.fromInt = fromInt;\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */ function fromNumber(value, unsigned) {\n    if (isNaN(value)) return unsigned ? UZERO : ZERO;\n    if (unsigned) {\n        if (value < 0) return UZERO;\n        if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n    } else {\n        if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n        if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n    }\n    if (value < 0) return fromNumber(-value, unsigned).neg();\n    return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n}\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */ Long.fromNumber = fromNumber;\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */ function fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n}\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */ Long.fromBits = fromBits;\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */ var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */ function fromString(str, unsigned, radix) {\n    if (str.length === 0) throw Error(\"empty string\");\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return ZERO;\n    if (typeof unsigned === \"number\") {\n        // For goog.math.long compatibility\n        radix = unsigned, unsigned = false;\n    } else {\n        unsigned = !!unsigned;\n    }\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n    var p;\n    if ((p = str.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n    else if (p === 0) {\n        return fromString(str.substring(1), unsigned, radix).neg();\n    }\n    // Do several (8) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\n    var result = ZERO;\n    for(var i = 0; i < str.length; i += 8){\n        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n        if (size < 8) {\n            var power = fromNumber(pow_dbl(radix, size));\n            result = result.mul(power).add(fromNumber(value));\n        } else {\n            result = result.mul(radixToPower);\n            result = result.add(fromNumber(value));\n        }\n    }\n    result.unsigned = unsigned;\n    return result;\n}\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */ Long.fromString = fromString;\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */ function fromValue(val, unsigned) {\n    if (typeof val === \"number\") return fromNumber(val, unsigned);\n    if (typeof val === \"string\") return fromString(val, unsigned);\n    // Throws for non-objects, converts non-instanceof Long:\n    return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n}\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */ Long.fromValue = fromValue;\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n// no runtime penalty for these.\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */ var TWO_PWR_16_DBL = 1 << 16;\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */ var TWO_PWR_24_DBL = 1 << 24;\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */ var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */ var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */ var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */ var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n/**\r\n * @type {!Long}\r\n * @inner\r\n */ var ZERO = fromInt(0);\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */ Long.ZERO = ZERO;\n/**\r\n * @type {!Long}\r\n * @inner\r\n */ var UZERO = fromInt(0, true);\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */ Long.UZERO = UZERO;\n/**\r\n * @type {!Long}\r\n * @inner\r\n */ var ONE = fromInt(1);\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */ Long.ONE = ONE;\n/**\r\n * @type {!Long}\r\n * @inner\r\n */ var UONE = fromInt(1, true);\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */ Long.UONE = UONE;\n/**\r\n * @type {!Long}\r\n * @inner\r\n */ var NEG_ONE = fromInt(-1);\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */ Long.NEG_ONE = NEG_ONE;\n/**\r\n * @type {!Long}\r\n * @inner\r\n */ var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */ Long.MAX_VALUE = MAX_VALUE;\n/**\r\n * @type {!Long}\r\n * @inner\r\n */ var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */ Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n/**\r\n * @type {!Long}\r\n * @inner\r\n */ var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */ Long.MIN_VALUE = MIN_VALUE;\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */ var LongPrototype = Long.prototype;\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */ LongPrototype.toInt = function toInt() {\n    return this.unsigned ? this.low >>> 0 : this.low;\n};\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */ LongPrototype.toNumber = function toNumber() {\n    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n};\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */ LongPrototype.toString = function toString(radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n    if (this.isZero()) return \"0\";\n    if (this.isNegative()) {\n        if (this.eq(MIN_VALUE)) {\n            // We need to change the Long value before it can be negated, so we remove\n            // the bottom-most digit in this base and then recurse to do the rest.\n            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n            return div.toString(radix) + rem1.toInt().toString(radix);\n        } else return \"-\" + this.neg().toString(radix);\n    }\n    // Do several (6) digits each time through the loop, so as to\n    // minimize the calls to the very expensive emulated div.\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n    var result = \"\";\n    while(true){\n        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n        rem = remDiv;\n        if (rem.isZero()) return digits + result;\n        else {\n            while(digits.length < 6)digits = \"0\" + digits;\n            result = \"\" + digits + result;\n        }\n    }\n};\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */ LongPrototype.getHighBits = function getHighBits() {\n    return this.high;\n};\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */ LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n    return this.high >>> 0;\n};\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */ LongPrototype.getLowBits = function getLowBits() {\n    return this.low;\n};\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */ LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n    return this.low >>> 0;\n};\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */ LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n    if (this.isNegative()) return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n    var val = this.high != 0 ? this.high : this.low;\n    for(var bit = 31; bit > 0; bit--)if ((val & 1 << bit) != 0) break;\n    return this.high != 0 ? bit + 33 : bit + 1;\n};\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */ LongPrototype.isZero = function isZero() {\n    return this.high === 0 && this.low === 0;\n};\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */ LongPrototype.eqz = LongPrototype.isZero;\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */ LongPrototype.isNegative = function isNegative() {\n    return !this.unsigned && this.high < 0;\n};\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */ LongPrototype.isPositive = function isPositive() {\n    return this.unsigned || this.high >= 0;\n};\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */ LongPrototype.isOdd = function isOdd() {\n    return (this.low & 1) === 1;\n};\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */ LongPrototype.isEven = function isEven() {\n    return (this.low & 1) === 0;\n};\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.equals = function equals(other) {\n    if (!isLong(other)) other = fromValue(other);\n    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n    return this.high === other.high && this.low === other.low;\n};\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.eq = LongPrototype.equals;\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.notEquals = function notEquals(other) {\n    return !this.eq(/* validates */ other);\n};\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.neq = LongPrototype.notEquals;\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.ne = LongPrototype.notEquals;\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.lessThan = function lessThan(other) {\n    return this.comp(/* validates */ other) < 0;\n};\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.lt = LongPrototype.lessThan;\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n    return this.comp(/* validates */ other) <= 0;\n};\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.lte = LongPrototype.lessThanOrEqual;\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.le = LongPrototype.lessThanOrEqual;\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.greaterThan = function greaterThan(other) {\n    return this.comp(/* validates */ other) > 0;\n};\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.gt = LongPrototype.greaterThan;\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n    return this.comp(/* validates */ other) >= 0;\n};\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */ LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */ LongPrototype.compare = function compare(other) {\n    if (!isLong(other)) other = fromValue(other);\n    if (this.eq(other)) return 0;\n    var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n    if (thisNeg && !otherNeg) return -1;\n    if (!thisNeg && otherNeg) return 1;\n    // At this point the sign bits are the same\n    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n    // Both are positive if at least one is unsigned\n    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n};\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */ LongPrototype.comp = LongPrototype.compare;\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */ LongPrototype.negate = function negate() {\n    if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n    return this.not().add(ONE);\n};\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */ LongPrototype.neg = LongPrototype.negate;\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */ LongPrototype.add = function add(addend) {\n    if (!isLong(addend)) addend = fromValue(addend);\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n    var b48 = addend.high >>> 16;\n    var b32 = addend.high & 0xFFFF;\n    var b16 = addend.low >>> 16;\n    var b00 = addend.low & 0xFFFF;\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 + b48;\n    c48 &= 0xFFFF;\n    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n};\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */ LongPrototype.subtract = function subtract(subtrahend) {\n    if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n    return this.add(subtrahend.neg());\n};\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */ LongPrototype.sub = LongPrototype.subtract;\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */ LongPrototype.multiply = function multiply(multiplier) {\n    if (this.isZero()) return ZERO;\n    if (!isLong(multiplier)) multiplier = fromValue(multiplier);\n    // use wasm support if present\n    if (wasm) {\n        var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n        return fromBits(low, wasm.get_high(), this.unsigned);\n    }\n    if (multiplier.isZero()) return ZERO;\n    if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n    if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n    if (this.isNegative()) {\n        if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n        else return this.neg().mul(multiplier).neg();\n    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n    // If both longs are small, use float multiplication\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n    // We can skip products that would overflow.\n    var a48 = this.high >>> 16;\n    var a32 = this.high & 0xFFFF;\n    var a16 = this.low >>> 16;\n    var a00 = this.low & 0xFFFF;\n    var b48 = multiplier.high >>> 16;\n    var b32 = multiplier.high & 0xFFFF;\n    var b16 = multiplier.low >>> 16;\n    var b00 = multiplier.low & 0xFFFF;\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xFFFF;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xFFFF;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xFFFF;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xFFFF;\n    return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n};\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */ LongPrototype.mul = LongPrototype.multiply;\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */ LongPrototype.divide = function divide(divisor) {\n    if (!isLong(divisor)) divisor = fromValue(divisor);\n    if (divisor.isZero()) throw Error(\"division by zero\");\n    // use wasm support if present\n    if (wasm) {\n        // guard against signed division overflow: the largest\n        // negative number / -1 would be 1 larger than the largest\n        // positive number, due to two's complement.\n        if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n            // be consistent with non-wasm code path\n            return this;\n        }\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n        return fromBits(low, wasm.get_high(), this.unsigned);\n    }\n    if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n    var approx, rem, res;\n    if (!this.unsigned) {\n        // This section is only relevant for signed longs and is derived from the\n        // closure library as a whole.\n        if (this.eq(MIN_VALUE)) {\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n            else if (divisor.eq(MIN_VALUE)) return ONE;\n            else {\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                var halfThis = this.shr(1);\n                approx = halfThis.div(divisor).shl(1);\n                if (approx.eq(ZERO)) {\n                    return divisor.isNegative() ? ONE : NEG_ONE;\n                } else {\n                    rem = this.sub(divisor.mul(approx));\n                    res = approx.add(rem.div(divisor));\n                    return res;\n                }\n            }\n        } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n        if (this.isNegative()) {\n            if (divisor.isNegative()) return this.neg().div(divisor.neg());\n            return this.neg().div(divisor).neg();\n        } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n        res = ZERO;\n    } else {\n        // The algorithm below has not been made for unsigned longs. It's therefore\n        // required to take special care of the MSB prior to running it.\n        if (!divisor.unsigned) divisor = divisor.toUnsigned();\n        if (divisor.gt(this)) return UZERO;\n        if (divisor.gt(this.shru(1))) return UONE;\n        res = UZERO;\n    }\n    // Repeat the following until the remainder is less than other:  find a\n    // floating-point that approximates remainder / other *from below*, add this\n    // into the result, and subtract it from the remainder.  It is critical that\n    // the approximate value is less than or equal to the real value so that the\n    // remainder never becomes negative.\n    rem = this;\n    while(rem.gte(divisor)){\n        // Approximate the result of division. This may be a little greater or\n        // smaller than the actual value.\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n        // We will tweak the approximate result by changing it in the 48-th digit or\n        // the smallest non-fractional digit, whichever is larger.\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), // Decrease the approximation until it is smaller than the remainder.  Note\n        // that if it is too large, the product overflows and is negative.\n        approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n        while(approxRem.isNegative() || approxRem.gt(rem)){\n            approx -= delta;\n            approxRes = fromNumber(approx, this.unsigned);\n            approxRem = approxRes.mul(divisor);\n        }\n        // We know the answer can't be zero... and actually, zero would cause\n        // infinite recursion since we would make no progress.\n        if (approxRes.isZero()) approxRes = ONE;\n        res = res.add(approxRes);\n        rem = rem.sub(approxRem);\n    }\n    return res;\n};\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */ LongPrototype.div = LongPrototype.divide;\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */ LongPrototype.modulo = function modulo(divisor) {\n    if (!isLong(divisor)) divisor = fromValue(divisor);\n    // use wasm support if present\n    if (wasm) {\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n        return fromBits(low, wasm.get_high(), this.unsigned);\n    }\n    return this.sub(this.div(divisor).mul(divisor));\n};\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */ LongPrototype.mod = LongPrototype.modulo;\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */ LongPrototype.rem = LongPrototype.modulo;\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */ LongPrototype.not = function not() {\n    return fromBits(~this.low, ~this.high, this.unsigned);\n};\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */ LongPrototype.and = function and(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n};\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */ LongPrototype.or = function or(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n};\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */ LongPrototype.xor = function xor(other) {\n    if (!isLong(other)) other = fromValue(other);\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n};\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */ LongPrototype.shiftLeft = function shiftLeft(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n    else return fromBits(0, this.low << numBits - 32, this.unsigned);\n};\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */ LongPrototype.shl = LongPrototype.shiftLeft;\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */ LongPrototype.shiftRight = function shiftRight(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;\n    else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n    else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n};\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */ LongPrototype.shr = LongPrototype.shiftRight;\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */ LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n    if (isLong(numBits)) numBits = numBits.toInt();\n    numBits &= 63;\n    if (numBits === 0) return this;\n    else {\n        var high = this.high;\n        if (numBits < 32) {\n            var low = this.low;\n            return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n        } else if (numBits === 32) return fromBits(high, 0, this.unsigned);\n        else return fromBits(high >>> numBits - 32, 0, this.unsigned);\n    }\n};\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */ LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */ LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */ LongPrototype.toSigned = function toSigned() {\n    if (!this.unsigned) return this;\n    return fromBits(this.low, this.high, false);\n};\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */ LongPrototype.toUnsigned = function toUnsigned() {\n    if (this.unsigned) return this;\n    return fromBits(this.low, this.high, true);\n};\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */ LongPrototype.toBytes = function toBytes(le) {\n    return le ? this.toBytesLE() : this.toBytesBE();\n};\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */ LongPrototype.toBytesLE = function toBytesLE() {\n    var hi = this.high, lo = this.low;\n    return [\n        lo & 0xff,\n        lo >>> 8 & 0xff,\n        lo >>> 16 & 0xff,\n        lo >>> 24,\n        hi & 0xff,\n        hi >>> 8 & 0xff,\n        hi >>> 16 & 0xff,\n        hi >>> 24\n    ];\n};\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */ LongPrototype.toBytesBE = function toBytesBE() {\n    var hi = this.high, lo = this.low;\n    return [\n        hi >>> 24,\n        hi >>> 16 & 0xff,\n        hi >>> 8 & 0xff,\n        hi & 0xff,\n        lo >>> 24,\n        lo >>> 16 & 0xff,\n        lo >>> 8 & 0xff,\n        lo & 0xff\n    ];\n};\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */ Long.fromBytes = function fromBytes(bytes, unsigned, le) {\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n};\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */ Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n};\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */ Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcyIsIm1hcHBpbmdzIjoiO0FBQUFBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakI7O0NBRUMsR0FDRCxJQUFJQyxPQUFPO0FBRVgsSUFBSTtJQUNGQSxPQUFPLElBQUlDLFlBQVlDLFFBQVEsQ0FBQyxJQUFJRCxZQUFZRSxNQUFNLENBQUMsSUFBSUMsV0FBVztRQUNwRTtRQUFHO1FBQUk7UUFBSztRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFHO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFLO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBSztRQUFHO1FBQUc7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUc7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSztLQUMzbkMsSUFBSSxDQUFDLEdBQUdOLE9BQU87QUFDbEIsRUFBRSxPQUFPTyxHQUFHO0FBQ1YscUJBQXFCO0FBQ3ZCO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU04sS0FBS08sR0FBRyxFQUFFQyxJQUFJLEVBQUVDLFFBQVE7SUFFN0I7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRixHQUFHLEdBQUdB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LENBQUMsRUFBRSxJQUFJLEtBQ1pBLEtBQUssQ0FBQyxFQUFFLElBQUksSUFDWkEsS0FBSyxDQUFDLEVBQUUsR0FDUkEsS0FBSyxDQUFDLEVBQUUsSUFBSyxJQUNiQSxLQUFLLENBQUMsRUFBRSxJQUFJLEtBQ1pBLEtBQUssQ0FBQyxFQUFFLElBQUksSUFDWi9KO0FBRVI7QUFFQTs7Ozs7Q0FLQyxHQUNEVCxLQUFLMEssV0FBVyxHQUFHLFNBQVNBLFlBQVlGLEtBQUssRUFBRS9KLFFBQVE7SUFDbkQsT0FBTyxJQUFJVCxLQUNQd0ssS0FBSyxDQUFDLEVBQUUsSUFBSSxLQUNaQSxLQUFLLENBQUMsRUFBRSxJQUFJLEtBQ1pBLEtBQUssQ0FBQyxFQUFFLElBQUssSUFDYkEsS0FBSyxDQUFDLEVBQUUsRUFDUkEsS0FBSyxDQUFDLEVBQUUsSUFBSSxLQUNaQSxLQUFLLENBQUMsRUFBRSxJQUFJLEtBQ1pBLEtBQUssQ0FBQyxFQUFFLElBQUssSUFDYkEsS0FBSyxDQUFDLEVBQUUsRUFDUi9KO0FBRVIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvbG9uZy9zcmMvbG9uZy5qcz8xYWNhIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gTG9uZztcclxuXHJcbi8qKlxyXG4gKiB3YXNtIG9wdGltaXphdGlvbnMsIHRvIGRvIG5hdGl2ZSBpNjQgbXVsdGlwbGljYXRpb24gYW5kIGRpdmlkZVxyXG4gKi9cclxudmFyIHdhc20gPSBudWxsO1xyXG5cclxudHJ5IHtcclxuICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG5ldyBXZWJBc3NlbWJseS5Nb2R1bGUobmV3IFVpbnQ4QXJyYXkoW1xyXG4gICAgMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFcclxuICBdKSksIHt9KS5leHBvcnRzO1xyXG59IGNhdGNoIChlKSB7XHJcbiAgLy8gbm8gd2FzbSBzdXBwb3J0IDooXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3RzIGEgNjQgYml0IHR3bydzLWNvbXBsZW1lbnQgaW50ZWdlciwgZ2l2ZW4gaXRzIGxvdyBhbmQgaGlnaCAzMiBiaXQgdmFsdWVzIGFzICpzaWduZWQqIGludGVnZXJzLlxyXG4gKiAgU2VlIHRoZSBmcm9tKiBmdW5jdGlvbnMgYmVsb3cgZm9yIG1vcmUgY29udmVuaWVudCB3YXlzIG9mIGNvbnN0cnVjdGluZyBMb25ncy5cclxuICogQGV4cG9ydHMgTG9uZ1xyXG4gKiBAY2xhc3MgQSBMb25nIGNsYXNzIGZvciByZXByZXNlbnRpbmcgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG93IFRoZSBsb3cgKHNpZ25lZCkgMzIgYml0cyBvZiB0aGUgbG9uZ1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBMb25nKGxvdywgaGlnaCwgdW5zaWduZWQpIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBsb3cgMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIHRoaXMubG93ID0gbG93IHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoaWdoIDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICB0aGlzLmhpZ2ggPSBoaWdoIHwgMDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxyXG4gICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xyXG59XHJcblxyXG4vLyBUaGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gb2YgYSBsb25nIGlzIHRoZSB0d28gZ2l2ZW4gc2lnbmVkLCAzMi1iaXQgdmFsdWVzLlxyXG4vLyBXZSB1c2UgMzItYml0IHBpZWNlcyBiZWNhdXNlIHRoZXNlIGFyZSB0aGUgc2l6ZSBvZiBpbnRlZ2VycyBvbiB3aGljaFxyXG4vLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcclxuLy8gbXVsdGlwbGljYXRpb24sIHdlIHNwbGl0IGVhY2ggbnVtYmVyIGludG8gMTYgYml0IHBpZWNlcywgd2hpY2ggY2FuIGVhc2lseSBiZVxyXG4vLyBtdWx0aXBsaWVkIHdpdGhpbiBKYXZhc2NyaXB0J3MgZmxvYXRpbmctcG9pbnQgcmVwcmVzZW50YXRpb24gd2l0aG91dCBvdmVyZmxvd1xyXG4vLyBvciBjaGFuZ2UgaW4gc2lnbi5cclxuLy9cclxuLy8gSW4gdGhlIGFsZ29yaXRobXMgYmVsb3csIHdlIGZyZXF1ZW50bHkgcmVkdWNlIHRoZSBuZWdhdGl2ZSBjYXNlIHRvIHRoZVxyXG4vLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cclxuLy8gTm90ZSB0aGF0IHdlIG11c3QgQUxXQVlTIGNoZWNrIHNwZWNpYWxseSB3aGV0aGVyIHRob3NlIHZhbHVlcyBhcmUgTUlOX1ZBTFVFXHJcbi8vICgtMl42MykgYmVjYXVzZSAtTUlOX1ZBTFVFID09IE1JTl9WQUxVRSAoc2luY2UgMl42MyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgYXNcclxuLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xyXG4vLyBjYXNlIHdvdWxkIG9mdGVuIHJlc3VsdCBpbiBpbmZpbml0ZSByZWN1cnNpb24uXHJcbi8vXHJcbi8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxyXG4vLyBtZXRob2RzIG9uIHdoaWNoIHRoZXkgZGVwZW5kLlxyXG5cclxuLyoqXHJcbiAqIEFuIGluZGljYXRvciB1c2VkIHRvIHJlbGlhYmx5IGRldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBMb25nIG9yIG5vdC5cclxuICogQHR5cGUge2Jvb2xlYW59XHJcbiAqIEBjb25zdFxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuTG9uZy5wcm90b3R5cGUuX19pc0xvbmdfXztcclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcblxyXG4vKipcclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xvbmcob2JqKSB7XHJcbiAgICByZXR1cm4gKG9iaiAmJiBvYmpbXCJfX2lzTG9uZ19fXCJdKSA9PT0gdHJ1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGlzIGEgTG9uZy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7Kn0gb2JqIE9iamVjdFxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmcuaXNMb25nID0gaXNMb25nO1xyXG5cclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIExvbmcgcmVwcmVzZW50YXRpb25zIG9mIHNtYWxsIGludGVnZXIgdmFsdWVzLlxyXG4gKiBAdHlwZSB7IU9iamVjdH1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQSBjYWNoZSBvZiB0aGUgTG9uZyByZXByZXNlbnRhdGlvbnMgb2Ygc21hbGwgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuXHJcbiAqIEB0eXBlIHshT2JqZWN0fVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVSU5UX0NBQ0hFID0ge307XHJcblxyXG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG5mdW5jdGlvbiBmcm9tSW50KHZhbHVlLCB1bnNpZ25lZCkge1xyXG4gICAgdmFyIG9iaiwgY2FjaGVkT2JqLCBjYWNoZTtcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIHZhbHVlID4+Pj0gMDtcclxuICAgICAgICBpZiAoY2FjaGUgPSAoMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcclxuICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgKHZhbHVlIHwgMCkgPCAwID8gLTEgOiAwLCB0cnVlKTtcclxuICAgICAgICBpZiAoY2FjaGUpXHJcbiAgICAgICAgICAgIFVJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbHVlIHw9IDA7XHJcbiAgICAgICAgaWYgKGNhY2hlID0gKC0xMjggPD0gdmFsdWUgJiYgdmFsdWUgPCAxMjgpKSB7XHJcbiAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XHJcbiAgICAgICAgICAgIGlmIChjYWNoZWRPYmopXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkT2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XHJcbiAgICAgICAgaWYgKGNhY2hlKVxyXG4gICAgICAgICAgICBJTlRfQ0FDSEVbdmFsdWVdID0gb2JqO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFRoZSAzMiBiaXQgaW50ZWdlciBpbiBxdWVzdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tSW50ID0gZnJvbUludDtcclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAoaXNOYU4odmFsdWUpKVxyXG4gICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIGlmICh1bnNpZ25lZCkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgICAgIHJldHVybiBVWkVSTztcclxuICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXHJcbiAgICAgICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcclxuICAgICAgICAgICAgcmV0dXJuIE1BWF9WQUxVRTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSA8IDApXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwpIHwgMCwgKHZhbHVlIC8gVFdPX1BXUl8zMl9EQkwpIHwgMCwgdW5zaWduZWQpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgbnVtYmVyIGluIHF1ZXN0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xyXG4gKiAgYXNzdW1lZCB0byB1c2UgMzIgYml0cy5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xyXG4gKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHMgVGhlIGhpZ2ggMzIgYml0c1xyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQml0cyA9IGZyb21CaXRzO1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcn0gYmFzZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcclxuICogQHJldHVybnMge251bWJlcn1cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcclxuICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxuZnVuY3Rpb24gZnJvbVN0cmluZyhzdHIsIHVuc2lnbmVkLCByYWRpeCkge1xyXG4gICAgaWYgKHN0ci5sZW5ndGggPT09IDApXHJcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2VtcHR5IHN0cmluZycpO1xyXG4gICAgaWYgKHN0ciA9PT0gXCJOYU5cIiB8fCBzdHIgPT09IFwiSW5maW5pdHlcIiB8fCBzdHIgPT09IFwiK0luZmluaXR5XCIgfHwgc3RyID09PSBcIi1JbmZpbml0eVwiKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKHR5cGVvZiB1bnNpZ25lZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAvLyBGb3IgZ29vZy5tYXRoLmxvbmcgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIHJhZGl4ID0gdW5zaWduZWQsXHJcbiAgICAgICAgdW5zaWduZWQgPSBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdW5zaWduZWQgPSAhISB1bnNpZ25lZDtcclxuICAgIH1cclxuICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XHJcbiAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXHJcbiAgICAgICAgdGhyb3cgUmFuZ2VFcnJvcigncmFkaXgnKTtcclxuXHJcbiAgICB2YXIgcDtcclxuICAgIGlmICgocCA9IHN0ci5pbmRleE9mKCctJykpID4gMClcclxuICAgICAgICB0aHJvdyBFcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XHJcbiAgICBlbHNlIGlmIChwID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gWkVSTztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSArPSA4KSB7XHJcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXHJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcclxuICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcclxuICAgICAgICAgICAgdmFyIHBvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCBzaXplKSk7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocG93ZXIpLmFkZChmcm9tTnVtYmVyKHZhbHVlKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXN1bHQudW5zaWduZWQgPSB1bnNpZ25lZDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gc3RyaW5nLCB3cml0dGVuIHVzaW5nIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXHJcbiAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBUaGUgcmFkaXggaW4gd2hpY2ggdGhlIHRleHQgaXMgd3JpdHRlbiAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfCF7bG93OiBudW1iZXIsIGhpZ2g6IG51bWJlciwgdW5zaWduZWQ6IGJvb2xlYW59fSB2YWxcclxuICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbmZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XHJcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XHJcbiAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxyXG4gICAgcmV0dXJuIGZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoZSBzcGVjaWZpZWQgdmFsdWUgdG8gYSBMb25nIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSBmcm9tKiBmdW5jdGlvbiBmb3IgaXRzIHR5cGUuXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmcuZnJvbVZhbHVlID0gZnJvbVZhbHVlO1xyXG5cclxuLy8gTk9URTogdGhlIGNvbXBpbGVyIHNob3VsZCBpbmxpbmUgdGhlc2UgY29uc3RhbnQgdmFsdWVzIGJlbG93IGFuZCB0aGVuIHJlbW92ZSB0aGVzZSB2YXJpYWJsZXMsIHNvIHRoZXJlIHNob3VsZCBiZVxyXG4vLyBubyBydW50aW1lIHBlbmFsdHkgZm9yIHRoZXNlLlxyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzE2X0RCTCA9IDEgPDwgMTY7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7bnVtYmVyfVxyXG4gKiBAY29uc3RcclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtudW1iZXJ9XHJcbiAqIEBjb25zdFxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBUV09fUFdSXzY0X0RCTCA9IFRXT19QV1JfMzJfREJMICogVFdPX1BXUl8zMl9EQkw7XHJcblxyXG4vKipcclxuICogQHR5cGUge251bWJlcn1cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGNvbnN0XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFRXT19QV1JfMjQgPSBmcm9tSW50KFRXT19QV1JfMjRfREJMKTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIFpFUk8gPSBmcm9tSW50KDApO1xyXG5cclxuLyoqXHJcbiAqIFNpZ25lZCB6ZXJvLlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nLlpFUk8gPSBaRVJPO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgVVpFUk8gPSBmcm9tSW50KDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIFVuc2lnbmVkIHplcm8uXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVVpFUk8gPSBVWkVSTztcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE9ORSA9IGZyb21JbnQoMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5PTkUgPSBPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcclxuXHJcbi8qKlxyXG4gKiBVbnNpZ25lZCBvbmUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuVU9ORSA9IFVPTkU7XHJcblxyXG4vKipcclxuICogQHR5cGUgeyFMb25nfVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBORUdfT05FID0gZnJvbUludCgtMSk7XHJcblxyXG4vKipcclxuICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cclxuICogQHR5cGUgeyFMb25nfVxyXG4gKi9cclxuTG9uZy5ORUdfT05FID0gTkVHX09ORTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7IUxvbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cclxudmFyIE1BWF9WQUxVRSA9IGZyb21CaXRzKDB4RkZGRkZGRkZ8MCwgMHg3RkZGRkZGRnwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWF4aW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1ZBTFVFID0gTUFYX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUFYX1VOU0lHTkVEX1ZBTFVFID0gZnJvbUJpdHMoMHhGRkZGRkZGRnwwLCAweEZGRkZGRkZGfDAsIHRydWUpO1xyXG5cclxuLyoqXHJcbiAqIE1heGltdW0gdW5zaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUFYX1VOU0lHTkVEX1ZBTFVFID0gTUFYX1VOU0lHTkVEX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICogQGlubmVyXHJcbiAqL1xyXG52YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMHwwLCBmYWxzZSk7XHJcblxyXG4vKipcclxuICogTWluaW11bSBzaWduZWQgdmFsdWUuXHJcbiAqIEB0eXBlIHshTG9uZ31cclxuICovXHJcbkxvbmcuTUlOX1ZBTFVFID0gTUlOX1ZBTFVFO1xyXG5cclxuLyoqXHJcbiAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxyXG4gKiBAaW5uZXJcclxuICovXHJcbnZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhlIExvbmcgdG8gYSAzMiBiaXQgaW50ZWdlciwgYXNzdW1pbmcgaXQgaXMgYSAzMiBiaXQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHRoZSBuZWFyZXN0IGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmFsdWUgKGRvdWJsZSwgNTMgYml0IG1hbnRpc3NhKS5cclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlcigpIHtcclxuICAgIGlmICh0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiAoKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCkgKyAodGhpcy5sb3cgPj4+IDApO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIHN0cmluZyB3cml0dGVuIGluIHRoZSBzcGVjaWZpZWQgcmFkaXguXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggUmFkaXggKDItMzYpLCBkZWZhdWx0cyB0byAxMFxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKiBAb3ZlcnJpZGVcclxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYHJhZGl4YCBpcyBvdXQgb2YgcmFuZ2VcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xyXG4gICAgcmFkaXggPSByYWRpeCB8fCAxMDtcclxuICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeClcclxuICAgICAgICB0aHJvdyBSYW5nZUVycm9yKCdyYWRpeCcpO1xyXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuICcwJztcclxuICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXHJcbiAgICAgICAgICAgIC8vIHRoZSBib3R0b20tbW9zdCBkaWdpdCBpbiB0aGlzIGJhc2UgYW5kIHRoZW4gcmVjdXJzZSB0byBkbyB0aGUgcmVzdC5cclxuICAgICAgICAgICAgdmFyIHJhZGl4TG9uZyA9IGZyb21OdW1iZXIocmFkaXgpLFxyXG4gICAgICAgICAgICAgICAgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSxcclxuICAgICAgICAgICAgICAgIHJlbTEgPSBkaXYubXVsKHJhZGl4TG9uZykuc3ViKHRoaXMpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XHJcbiAgICAgICAgfSBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEbyBzZXZlcmFsICg2KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXHJcbiAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cclxuICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKSxcclxuICAgICAgICByZW0gPSB0aGlzO1xyXG4gICAgdmFyIHJlc3VsdCA9ICcnO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICB2YXIgcmVtRGl2ID0gcmVtLmRpdihyYWRpeFRvUG93ZXIpLFxyXG4gICAgICAgICAgICBpbnR2YWwgPSByZW0uc3ViKHJlbURpdi5tdWwocmFkaXhUb1Bvd2VyKSkudG9JbnQoKSA+Pj4gMCxcclxuICAgICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcclxuICAgICAgICByZW0gPSByZW1EaXY7XHJcbiAgICAgICAgaWYgKHJlbS5pc1plcm8oKSlcclxuICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0cy5sZW5ndGggPCA2KVxyXG4gICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xyXG4gICAgICAgICAgICByZXN1bHQgPSAnJyArIGRpZ2l0cyArIHJlc3VsdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ2V0SGlnaEJpdHMgPSBmdW5jdGlvbiBnZXRIaWdoQml0cygpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2g7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGhpZ2ggYml0c1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogR2V0cyB0aGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgaW50ZWdlci5cclxuICogQHJldHVybnMge251bWJlcn0gU2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHMgPSBmdW5jdGlvbiBnZXRMb3dCaXRzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldExvd0JpdHNVbnNpZ25lZCA9IGZ1bmN0aW9uIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcclxuICAgIHJldHVybiB0aGlzLmxvdyA+Pj4gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBudW1iZXIgb2YgYml0cyBuZWVkZWQgdG8gcmVwcmVzZW50IHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xyXG4gICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcclxuICAgICAgICByZXR1cm4gdGhpcy5lcShNSU5fVkFMVUUpID8gNjQgOiB0aGlzLm5lZygpLmdldE51bUJpdHNBYnMoKTtcclxuICAgIHZhciB2YWwgPSB0aGlzLmhpZ2ggIT0gMCA/IHRoaXMuaGlnaCA6IHRoaXMubG93O1xyXG4gICAgZm9yICh2YXIgYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxyXG4gICAgICAgIGlmICgodmFsICYgKDEgPDwgYml0KSkgIT0gMClcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoICE9IDAgPyBiaXQgKyAzMyA6IGJpdCArIDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiBpc1plcm8oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB6ZXJvLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2lzWmVyb30uXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXogPSBMb25nUHJvdG90eXBlLmlzWmVybztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBuZWdhdGl2ZS5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLnVuc2lnbmVkICYmIHRoaXMuaGlnaCA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIG9kZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQoKSB7XHJcbiAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDE7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbigpIHtcclxuICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBlcXVhbHMgdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZCAhPT0gb3RoZXIudW5zaWduZWQgJiYgKHRoaXMuaGlnaCA+Pj4gMzEpID09PSAxICYmIChvdGhlci5oaWdoID4+PiAzMSkgPT09IDEpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gb3RoZXIuaGlnaCAmJiB0aGlzLmxvdyA9PT0gb3RoZXIubG93O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZXF1YWxzfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmVxID0gTG9uZ1Byb3RvdHlwZS5lcXVhbHM7XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90RXF1YWxzID0gZnVuY3Rpb24gbm90RXF1YWxzKG90aGVyKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuZXEoLyogdmFsaWRhdGVzICovIG90aGVyKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZXEgPSBMb25nUHJvdG90eXBlLm5vdEVxdWFscztcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZSA9IExvbmdQcm90b3R5cGUubm90RXF1YWxzO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmxlc3NUaGFuID0gZnVuY3Rpb24gbGVzc1RoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdCA9IExvbmdQcm90b3R5cGUubGVzc1RoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsID0gZnVuY3Rpb24gbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPD0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sdGUgPSBMb25nUHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XHJcbn07XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbn0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XHJcblxyXG4vKipcclxuICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XHJcbiAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPj0gMDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcclxuXHJcbi8qKlxyXG4gKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2dyZWF0ZXJUaGFuT3JFcXVhbH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5nZSA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsO1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcclxuICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIGlmICh0aGlzLmVxKG90aGVyKSlcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIHZhciB0aGlzTmVnID0gdGhpcy5pc05lZ2F0aXZlKCksXHJcbiAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XHJcbiAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpXHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgaWYgKCF0aGlzTmVnICYmIG90aGVyTmVnKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgc2lnbiBiaXRzIGFyZSB0aGUgc2FtZVxyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxyXG4gICAgICAgIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xyXG4gICAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXHJcbiAgICByZXR1cm4gKG90aGVyLmhpZ2ggPj4+IDApID4gKHRoaXMuaGlnaCA+Pj4gMCkgfHwgKG90aGVyLmhpZ2ggPT09IHRoaXMuaGlnaCAmJiAob3RoZXIubG93ID4+PiAwKSA+ICh0aGlzLmxvdyA+Pj4gMCkpID8gLTEgOiAxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvbXBhcmV9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXHJcbiAqICBpZiB0aGUgZ2l2ZW4gb25lIGlzIGdyZWF0ZXJcclxuICovXHJcbkxvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XHJcbiAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBNSU5fVkFMVUU7XHJcbiAgICByZXR1cm4gdGhpcy5ub3QoKS5hZGQoT05FKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBOZWdhdGVzIHRoaXMgTG9uZydzIHZhbHVlLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25lZ2F0ZX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5uZWcgPSBMb25nUHJvdG90eXBlLm5lZ2F0ZTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGFkZGVuZCBBZGRlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBTdW1cclxuICovXHJcbkxvbmdQcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGFkZGVuZCkge1xyXG4gICAgaWYgKCFpc0xvbmcoYWRkZW5kKSlcclxuICAgICAgICBhZGRlbmQgPSBmcm9tVmFsdWUoYWRkZW5kKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cclxuXHJcbiAgICB2YXIgYTQ4ID0gdGhpcy5oaWdoID4+PiAxNjtcclxuICAgIHZhciBhMzIgPSB0aGlzLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYTE2ID0gdGhpcy5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGEwMCA9IHRoaXMubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XHJcbiAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcclxuICAgIGMwMCArPSBhMDAgKyBiMDA7XHJcbiAgICBjMTYgKz0gYzAwID4+PiAxNjtcclxuICAgIGMwMCAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTE2ICsgYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiArIGIzMjtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGM0OCArPSBhNDggKyBiNDg7XHJcbiAgICBjNDggJj0gMHhGRkZGO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gc3VidHJhaGVuZCBTdWJ0cmFoZW5kXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQpIHtcclxuICAgIGlmICghaXNMb25nKHN1YnRyYWhlbmQpKVxyXG4gICAgICAgIHN1YnRyYWhlbmQgPSBmcm9tVmFsdWUoc3VidHJhaGVuZCk7XHJcbiAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBzdWJ0cmFoZW5kIFN1YnRyYWhlbmRcclxuICogQHJldHVybnMgeyFMb25nfSBEaWZmZXJlbmNlXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnN1YiA9IExvbmdQcm90b3R5cGUuc3VidHJhY3Q7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgcHJvZHVjdCBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUHJvZHVjdFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIG11bHRpcGx5KG11bHRpcGxpZXIpIHtcclxuICAgIGlmICh0aGlzLmlzWmVybygpKVxyXG4gICAgICAgIHJldHVybiBaRVJPO1xyXG4gICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpXHJcbiAgICAgICAgbXVsdGlwbGllciA9IGZyb21WYWx1ZShtdWx0aXBsaWVyKTtcclxuXHJcbiAgICAvLyB1c2Ugd2FzbSBzdXBwb3J0IGlmIHByZXNlbnRcclxuICAgIGlmICh3YXNtKSB7XHJcbiAgICAgICAgdmFyIGxvdyA9IHdhc20ubXVsKHRoaXMubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxpZXIubG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsaWVyLmhpZ2gpO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpXHJcbiAgICAgICAgcmV0dXJuIFpFUk87XHJcbiAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgIHJldHVybiBtdWx0aXBsaWVyLmlzT2RkKCkgPyBNSU5fVkFMVUUgOiBaRVJPO1xyXG4gICAgaWYgKG11bHRpcGxpZXIuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcclxuXHJcbiAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyKS5uZWcoKTtcclxuICAgIH0gZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXHJcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKG11bHRpcGxpZXIubmVnKCkpLm5lZygpO1xyXG5cclxuICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cclxuICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXHJcbiAgICAgICAgcmV0dXJuIGZyb21OdW1iZXIodGhpcy50b051bWJlcigpICogbXVsdGlwbGllci50b051bWJlcigpLCB0aGlzLnVuc2lnbmVkKTtcclxuXHJcbiAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cclxuICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXHJcblxyXG4gICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XHJcbiAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhGRkZGO1xyXG4gICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcclxuICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4RkZGRjtcclxuXHJcbiAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcclxuICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweEZGRkY7XHJcbiAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xyXG4gICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhGRkZGO1xyXG5cclxuICAgIHZhciBjNDggPSAwLCBjMzIgPSAwLCBjMTYgPSAwLCBjMDAgPSAwO1xyXG4gICAgYzAwICs9IGEwMCAqIGIwMDtcclxuICAgIGMxNiArPSBjMDAgPj4+IDE2O1xyXG4gICAgYzAwICY9IDB4RkZGRjtcclxuICAgIGMxNiArPSBhMTYgKiBiMDA7XHJcbiAgICBjMzIgKz0gYzE2ID4+PiAxNjtcclxuICAgIGMxNiAmPSAweEZGRkY7XHJcbiAgICBjMTYgKz0gYTAwICogYjE2O1xyXG4gICAgYzMyICs9IGMxNiA+Pj4gMTY7XHJcbiAgICBjMTYgJj0gMHhGRkZGO1xyXG4gICAgYzMyICs9IGEzMiAqIGIwMDtcclxuICAgIGM0OCArPSBjMzIgPj4+IDE2O1xyXG4gICAgYzMyICY9IDB4RkZGRjtcclxuICAgIGMzMiArPSBhMTYgKiBiMTY7XHJcbiAgICBjNDggKz0gYzMyID4+PiAxNjtcclxuICAgIGMzMiAmPSAweEZGRkY7XHJcbiAgICBjMzIgKz0gYTAwICogYjMyO1xyXG4gICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XHJcbiAgICBjMzIgJj0gMHhGRkZGO1xyXG4gICAgYzQ4ICs9IGE0OCAqIGIwMCArIGEzMiAqIGIxNiArIGExNiAqIGIzMiArIGEwMCAqIGI0ODtcclxuICAgIGM0OCAmPSAweEZGRkY7XHJcbiAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG11bHRpcGxpZXIgTXVsdGlwbGllclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcclxuICovXHJcbkxvbmdQcm90b3R5cGUubXVsID0gTG9uZ1Byb3RvdHlwZS5tdWx0aXBseTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoZSByZXN1bHQgaXMgc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyBzaWduZWQgb3JcclxuICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cclxuICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcclxuICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUoZGl2aXNvcikge1xyXG4gICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpXHJcbiAgICAgICAgZGl2aXNvciA9IGZyb21WYWx1ZShkaXZpc29yKTtcclxuICAgIGlmIChkaXZpc29yLmlzWmVybygpKVxyXG4gICAgICAgIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJyk7XHJcblxyXG4gICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XHJcbiAgICBpZiAod2FzbSkge1xyXG4gICAgICAgIC8vIGd1YXJkIGFnYWluc3Qgc2lnbmVkIGRpdmlzaW9uIG92ZXJmbG93OiB0aGUgbGFyZ2VzdFxyXG4gICAgICAgIC8vIG5lZ2F0aXZlIG51bWJlciAvIC0xIHdvdWxkIGJlIDEgbGFyZ2VyIHRoYW4gdGhlIGxhcmdlc3RcclxuICAgICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxyXG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxyXG4gICAgICAgICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93ID09PSAtMSAmJiBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIGJlIGNvbnNpc3RlbnQgd2l0aCBub24td2FzbSBjb2RlIHBhdGhcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKShcclxuICAgICAgICAgICAgdGhpcy5sb3csXHJcbiAgICAgICAgICAgIHRoaXMuaGlnaCxcclxuICAgICAgICAgICAgZGl2aXNvci5sb3csXHJcbiAgICAgICAgICAgIGRpdmlzb3IuaGlnaFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5pc1plcm8oKSlcclxuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgIHZhciBhcHByb3gsIHJlbSwgcmVzO1xyXG4gICAgaWYgKCF0aGlzLnVuc2lnbmVkKSB7XHJcbiAgICAgICAgLy8gVGhpcyBzZWN0aW9uIGlzIG9ubHkgcmVsZXZhbnQgZm9yIHNpZ25lZCBsb25ncyBhbmQgaXMgZGVyaXZlZCBmcm9tIHRoZVxyXG4gICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxyXG4gICAgICAgIGlmICh0aGlzLmVxKE1JTl9WQUxVRSkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgIC8vIHJlY2FsbCB0aGF0IC1NSU5fVkFMVUUgPT0gTUlOX1ZBTFVFXHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTUlOX1ZBTFVFKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBPTkU7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgaGF2ZSB8b3RoZXJ8ID49IDIsIHNvIHx0aGlzL290aGVyfCA8IHxNSU5fVkFMVUV8LlxyXG4gICAgICAgICAgICAgICAgdmFyIGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XHJcbiAgICAgICAgICAgICAgICBhcHByb3ggPSBoYWxmVGhpcy5kaXYoZGl2aXNvcikuc2hsKDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGFwcHJveC5lcShaRVJPKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbSA9IHRoaXMuc3ViKGRpdmlzb3IubXVsKGFwcHJveCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcclxuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcclxuICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IubmVnKCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvcikubmVnKCk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaXZpc29yLmlzTmVnYXRpdmUoKSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xyXG4gICAgICAgIHJlcyA9IFpFUk87XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoZSBhbGdvcml0aG0gYmVsb3cgaGFzIG5vdCBiZWVuIG1hZGUgZm9yIHVuc2lnbmVkIGxvbmdzLiBJdCdzIHRoZXJlZm9yZVxyXG4gICAgICAgIC8vIHJlcXVpcmVkIHRvIHRha2Ugc3BlY2lhbCBjYXJlIG9mIHRoZSBNU0IgcHJpb3IgdG8gcnVubmluZyBpdC5cclxuICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpXHJcbiAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcclxuICAgICAgICBpZiAoZGl2aXNvci5ndCh0aGlzKSlcclxuICAgICAgICAgICAgcmV0dXJuIFVaRVJPO1xyXG4gICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMuc2hydSgxKSkpIC8vIDE1ID4+PiAxID0gNyA7IHdpdGggZGl2aXNvciA9IDggOyB0cnVlXHJcbiAgICAgICAgICAgIHJldHVybiBVT05FO1xyXG4gICAgICAgIHJlcyA9IFVaRVJPO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlcGVhdCB0aGUgZm9sbG93aW5nIHVudGlsIHRoZSByZW1haW5kZXIgaXMgbGVzcyB0aGFuIG90aGVyOiAgZmluZCBhXHJcbiAgICAvLyBmbG9hdGluZy1wb2ludCB0aGF0IGFwcHJveGltYXRlcyByZW1haW5kZXIgLyBvdGhlciAqZnJvbSBiZWxvdyosIGFkZCB0aGlzXHJcbiAgICAvLyBpbnRvIHRoZSByZXN1bHQsIGFuZCBzdWJ0cmFjdCBpdCBmcm9tIHRoZSByZW1haW5kZXIuICBJdCBpcyBjcml0aWNhbCB0aGF0XHJcbiAgICAvLyB0aGUgYXBwcm94aW1hdGUgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSByZWFsIHZhbHVlIHNvIHRoYXQgdGhlXHJcbiAgICAvLyByZW1haW5kZXIgbmV2ZXIgYmVjb21lcyBuZWdhdGl2ZS5cclxuICAgIHJlbSA9IHRoaXM7XHJcbiAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xyXG4gICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcclxuICAgICAgICAvLyBzbWFsbGVyIHRoYW4gdGhlIGFjdHVhbCB2YWx1ZS5cclxuICAgICAgICBhcHByb3ggPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKHJlbS50b051bWJlcigpIC8gZGl2aXNvci50b051bWJlcigpKSk7XHJcblxyXG4gICAgICAgIC8vIFdlIHdpbGwgdHdlYWsgdGhlIGFwcHJveGltYXRlIHJlc3VsdCBieSBjaGFuZ2luZyBpdCBpbiB0aGUgNDgtdGggZGlnaXQgb3JcclxuICAgICAgICAvLyB0aGUgc21hbGxlc3Qgbm9uLWZyYWN0aW9uYWwgZGlnaXQsIHdoaWNoZXZlciBpcyBsYXJnZXIuXHJcbiAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcclxuICAgICAgICAgICAgZGVsdGEgPSAobG9nMiA8PSA0OCkgPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxyXG5cclxuICAgICAgICAvLyBEZWNyZWFzZSB0aGUgYXBwcm94aW1hdGlvbiB1bnRpbCBpdCBpcyBzbWFsbGVyIHRoYW4gdGhlIHJlbWFpbmRlci4gIE5vdGVcclxuICAgICAgICAvLyB0aGF0IGlmIGl0IGlzIHRvbyBsYXJnZSwgdGhlIHByb2R1Y3Qgb3ZlcmZsb3dzIGFuZCBpcyBuZWdhdGl2ZS5cclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gpLFxyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XHJcbiAgICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gV2Uga25vdyB0aGUgYW5zd2VyIGNhbid0IGJlIHplcm8uLi4gYW5kIGFjdHVhbGx5LCB6ZXJvIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgLy8gaW5maW5pdGUgcmVjdXJzaW9uIHNpbmNlIHdlIHdvdWxkIG1ha2Ugbm8gcHJvZ3Jlc3MuXHJcbiAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSlcclxuICAgICAgICAgICAgYXBwcm94UmVzID0gT05FO1xyXG5cclxuICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XHJcbiAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyBkaXZpZGVkIGJ5IHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZGl2aWRlfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcclxuICovXHJcbkxvbmdQcm90b3R5cGUuZGl2ID0gTG9uZ1Byb3RvdHlwZS5kaXZpZGU7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZHVsbyA9IGZ1bmN0aW9uIG1vZHVsbyhkaXZpc29yKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhkaXZpc29yKSlcclxuICAgICAgICBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xyXG5cclxuICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxyXG4gICAgaWYgKHdhc20pIHtcclxuICAgICAgICB2YXIgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykoXHJcbiAgICAgICAgICAgIHRoaXMubG93LFxyXG4gICAgICAgICAgICB0aGlzLmhpZ2gsXHJcbiAgICAgICAgICAgIGRpdmlzb3IubG93LFxyXG4gICAgICAgICAgICBkaXZpc29yLmhpZ2hcclxuICAgICAgICApO1xyXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cclxuICogQGZ1bmN0aW9uXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gZGl2aXNvciBEaXZpc29yXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLm1vZCA9IExvbmdQcm90b3R5cGUubW9kdWxvO1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIG1vZHVsbyB0aGUgc3BlY2lmaWVkLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI21vZHVsb30uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE5PVCBvZiB0aGlzIExvbmcuXHJcbiAqIEByZXR1cm5zIHshTG9uZ31cclxuICovXHJcbkxvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQob3RoZXIpIHtcclxuICAgIGlmICghaXNMb25nKG90aGVyKSlcclxuICAgICAgICBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XHJcbiAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3cgJiBvdGhlci5sb3csIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGJpdHdpc2UgT1Igb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxyXG4gKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd9IG90aGVyIE90aGVyIExvbmdcclxuICogQHJldHVybnMgeyFMb25nfVxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKG90aGVyKSB7XHJcbiAgICBpZiAoIWlzTG9uZyhvdGhlcikpXHJcbiAgICAgICAgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xyXG4gICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IHwgb3RoZXIubG93LCB0aGlzLmhpZ2ggfCBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBiaXR3aXNlIFhPUiBvZiB0aGlzIExvbmcgYW5kIHRoZSBnaXZlbiBvbmUuXHJcbiAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9XHJcbiAqL1xyXG5Mb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xyXG4gICAgaWYgKCFpc0xvbmcob3RoZXIpKVxyXG4gICAgICAgIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdyBeIG90aGVyLmxvdywgdGhpcy5oaWdoIF4gb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMubG93IDw8IG51bUJpdHMsICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+ICgzMiAtIG51bUJpdHMpKSwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKDAsIHRoaXMubG93IDw8IChudW1CaXRzIC0gMzIpLCB0aGlzLnVuc2lnbmVkKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgc2hpZnRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0TGVmdH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHQobnVtQml0cykge1xyXG4gICAgaWYgKGlzTG9uZyhudW1CaXRzKSlcclxuICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xyXG4gICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcclxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCB0aGlzLmhpZ2ggPj4gbnVtQml0cywgdGhpcy51bnNpZ25lZCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSwgdGhpcy5oaWdoID49IDAgPyAwIDogLTEsIHRoaXMudW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHR9LlxyXG4gKiBAZnVuY3Rpb25cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hyID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBsb2dpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cclxuICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcclxuICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkID0gZnVuY3Rpb24gc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcclxuICAgIGlmIChpc0xvbmcobnVtQml0cykpXHJcbiAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcclxuICAgIG51bUJpdHMgJj0gNjM7XHJcbiAgICBpZiAobnVtQml0cyA9PT0gMClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhciBoaWdoID0gdGhpcy5oaWdoO1xyXG4gICAgICAgIGlmIChudW1CaXRzIDwgMzIpIHtcclxuICAgICAgICAgICAgdmFyIGxvdyA9IHRoaXMubG93O1xyXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJpdHMoKGxvdyA+Pj4gbnVtQml0cykgfCAoaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksIGhpZ2ggPj4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobnVtQml0cyA9PT0gMzIpXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBmcm9tQml0cyhoaWdoID4+PiAobnVtQml0cyAtIDMyKSwgMCwgdGhpcy51bnNpZ25lZCk7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJ1ID0gTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0VW5zaWduZWQ7XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXHJcbiAqIEBmdW5jdGlvblxyXG4gKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS5zaHJfdSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBzaWduZWQuXHJcbiAqIEByZXR1cm5zIHshTG9uZ30gU2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcclxuICAgIGlmICghdGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCBmYWxzZSk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIHVuc2lnbmVkLlxyXG4gKiBAcmV0dXJucyB7IUxvbmd9IFVuc2lnbmVkIGxvbmdcclxuICovXHJcbkxvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XHJcbiAgICBpZiAodGhpcy51bnNpZ25lZClcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmxvdywgdGhpcy5oaWdoLCB0cnVlKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGxlIFdoZXRoZXIgbGl0dGxlIG9yIGJpZyBlbmRpYW4sIGRlZmF1bHRzIHRvIGJpZyBlbmRpYW5cclxuICogQHJldHVybnMgeyFBcnJheS48bnVtYmVyPn0gQnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzID0gZnVuY3Rpb24gdG9CeXRlcyhsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzTEUgPSBmdW5jdGlvbiB0b0J5dGVzTEUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgbG8gICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gIDggJiAweGZmLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSAgICAgICAgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgPj4+IDE2ICYgMHhmZixcclxuICAgICAgICBoaSA+Pj4gMjRcclxuICAgIF07XHJcbn07XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKi9cclxuTG9uZ1Byb3RvdHlwZS50b0J5dGVzQkUgPSBmdW5jdGlvbiB0b0J5dGVzQkUoKSB7XHJcbiAgICB2YXIgaGkgPSB0aGlzLmhpZ2gsXHJcbiAgICAgICAgbG8gPSB0aGlzLmxvdztcclxuICAgIHJldHVybiBbXHJcbiAgICAgICAgaGkgPj4+IDI0ICAgICAgICxcclxuICAgICAgICBoaSA+Pj4gMTYgJiAweGZmLFxyXG4gICAgICAgIGhpID4+PiAgOCAmIDB4ZmYsXHJcbiAgICAgICAgaGkgICAgICAgICYgMHhmZixcclxuICAgICAgICBsbyA+Pj4gMjQgICAgICAgLFxyXG4gICAgICAgIGxvID4+PiAxNiAmIDB4ZmYsXHJcbiAgICAgICAgbG8gPj4+ICA4ICYgMHhmZixcclxuICAgICAgICBsbyAgICAgICAgJiAweGZmXHJcbiAgICBdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJ5dGUgcmVwcmVzZW50YXRpb24uXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBieXRlcyBCeXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHBhcmFtIHtib29sZWFuPX0gbGUgV2hldGhlciBsaXR0bGUgb3IgYmlnIGVuZGlhbiwgZGVmYXVsdHMgdG8gYmlnIGVuZGlhblxyXG4gKiBAcmV0dXJucyB7TG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxyXG4gKi9cclxuTG9uZy5mcm9tQnl0ZXMgPSBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xyXG4gICAgcmV0dXJuIGxlID8gTG9uZy5mcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIDogTG9uZy5mcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPG51bWJlcj59IGJ5dGVzIExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXHJcbiAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXHJcbiAqL1xyXG5Mb25nLmZyb21CeXRlc0xFID0gZnVuY3Rpb24gZnJvbUJ5dGVzTEUoYnl0ZXMsIHVuc2lnbmVkKSB7XHJcbiAgICByZXR1cm4gbmV3IExvbmcoXHJcbiAgICAgICAgYnl0ZXNbMF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzFdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1syXSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbM10gPDwgMjQsXHJcbiAgICAgICAgYnl0ZXNbNF0gICAgICAgfFxyXG4gICAgICAgIGJ5dGVzWzVdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s2XSA8PCAxNiB8XHJcbiAgICAgICAgYnl0ZXNbN10gPDwgMjQsXHJcbiAgICAgICAgdW5zaWduZWRcclxuICAgICk7XHJcbn07XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcclxuICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcclxuICovXHJcbkxvbmcuZnJvbUJ5dGVzQkUgPSBmdW5jdGlvbiBmcm9tQnl0ZXNCRShieXRlcywgdW5zaWduZWQpIHtcclxuICAgIHJldHVybiBuZXcgTG9uZyhcclxuICAgICAgICBieXRlc1s0XSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbNV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzZdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1s3XSxcclxuICAgICAgICBieXRlc1swXSA8PCAyNCB8XHJcbiAgICAgICAgYnl0ZXNbMV0gPDwgMTYgfFxyXG4gICAgICAgIGJ5dGVzWzJdIDw8ICA4IHxcclxuICAgICAgICBieXRlc1szXSxcclxuICAgICAgICB1bnNpZ25lZFxyXG4gICAgKTtcclxufTtcclxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJMb25nIiwid2FzbSIsIldlYkFzc2VtYmx5IiwiSW5zdGFuY2UiLCJNb2R1bGUiLCJVaW50OEFycmF5IiwiZSIsImxvdyIsImhpZ2giLCJ1bnNpZ25lZCIsInByb3RvdHlwZSIsIl9faXNMb25nX18iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsInZhbHVlIiwiaXNMb25nIiwib2JqIiwiSU5UX0NBQ0hFIiwiVUlOVF9DQUNIRSIsImZyb21JbnQiLCJjYWNoZWRPYmoiLCJjYWNoZSIsImZyb21CaXRzIiwiZnJvbU51bWJlciIsImlzTmFOIiwiVVpFUk8iLCJaRVJPIiwiVFdPX1BXUl82NF9EQkwiLCJNQVhfVU5TSUdORURfVkFMVUUiLCJUV09fUFdSXzYzX0RCTCIsIk1JTl9WQUxVRSIsIk1BWF9WQUxVRSIsIm5lZyIsIlRXT19QV1JfMzJfREJMIiwibG93Qml0cyIsImhpZ2hCaXRzIiwicG93X2RibCIsIk1hdGgiLCJwb3ciLCJmcm9tU3RyaW5nIiwic3RyIiwicmFkaXgiLCJsZW5ndGgiLCJFcnJvciIsIlJhbmdlRXJyb3IiLCJwIiwiaW5kZXhPZiIsInN1YnN0cmluZyIsInJhZGl4VG9Qb3dlciIsInJlc3VsdCIsImkiLCJzaXplIiwibWluIiwicGFyc2VJbnQiLCJwb3dlciIsIm11bCIsImFkZCIsImZyb21WYWx1ZSIsInZhbCIsIlRXT19QV1JfMTZfREJMIiwiVFdPX1BXUl8yNF9EQkwiLCJUV09fUFdSXzI0IiwiT05FIiwiVU9ORSIsIk5FR19PTkUiLCJMb25nUHJvdG90eXBlIiwidG9JbnQiLCJ0b051bWJlciIsInRvU3RyaW5nIiwiaXNaZXJvIiwiaXNOZWdhdGl2ZSIsImVxIiwicmFkaXhMb25nIiwiZGl2IiwicmVtMSIsInN1YiIsInJlbSIsInJlbURpdiIsImludHZhbCIsImRpZ2l0cyIsImdldEhpZ2hCaXRzIiwiZ2V0SGlnaEJpdHNVbnNpZ25lZCIsImdldExvd0JpdHMiLCJnZXRMb3dCaXRzVW5zaWduZWQiLCJnZXROdW1CaXRzQWJzIiwiYml0IiwiZXF6IiwiaXNQb3NpdGl2ZSIsImlzT2RkIiwiaXNFdmVuIiwiZXF1YWxzIiwib3RoZXIiLCJub3RFcXVhbHMiLCJuZXEiLCJuZSIsImxlc3NUaGFuIiwiY29tcCIsImx0IiwibGVzc1RoYW5PckVxdWFsIiwibHRlIiwibGUiLCJncmVhdGVyVGhhbiIsImd0IiwiZ3JlYXRlclRoYW5PckVxdWFsIiwiZ3RlIiwiZ2UiLCJjb21wYXJlIiwidGhpc05lZyIsIm90aGVyTmVnIiwibmVnYXRlIiwibm90IiwiYWRkZW5kIiwiYTQ4IiwiYTMyIiwiYTE2IiwiYTAwIiwiYjQ4IiwiYjMyIiwiYjE2IiwiYjAwIiwiYzQ4IiwiYzMyIiwiYzE2IiwiYzAwIiwic3VidHJhY3QiLCJzdWJ0cmFoZW5kIiwibXVsdGlwbHkiLCJtdWx0aXBsaWVyIiwiZ2V0X2hpZ2giLCJkaXZpZGUiLCJkaXZpc29yIiwiZGl2X3UiLCJkaXZfcyIsImFwcHJveCIsInJlcyIsImhhbGZUaGlzIiwic2hyIiwic2hsIiwidG9VbnNpZ25lZCIsInNocnUiLCJtYXgiLCJmbG9vciIsImxvZzIiLCJjZWlsIiwibG9nIiwiTE4yIiwiZGVsdGEiLCJhcHByb3hSZXMiLCJhcHByb3hSZW0iLCJtb2R1bG8iLCJyZW1fdSIsInJlbV9zIiwibW9kIiwiYW5kIiwib3IiLCJ4b3IiLCJzaGlmdExlZnQiLCJudW1CaXRzIiwic2hpZnRSaWdodCIsInNoaWZ0UmlnaHRVbnNpZ25lZCIsInNocl91IiwidG9TaWduZWQiLCJ0b0J5dGVzIiwidG9CeXRlc0xFIiwidG9CeXRlc0JFIiwiaGkiLCJsbyIsImZyb21CeXRlcyIsImJ5dGVzIiwiZnJvbUJ5dGVzTEUiLCJmcm9tQnl0ZXNCRSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/long/src/long.js\n");

/***/ })

};
;