"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@grpc";
exports.ids = ["vendor-chunks/@grpc"];
exports.modules = {

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/admin.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addAdminServicesToServer = exports.registerAdminService = void 0;\nconst registeredAdminServices = [];\nfunction registerAdminService(getServiceDefinition, getHandlers) {\n    registeredAdminServices.push({\n        getServiceDefinition,\n        getHandlers\n    });\n}\nexports.registerAdminService = registerAdminService;\nfunction addAdminServicesToServer(server) {\n    for (const { getServiceDefinition, getHandlers } of registeredAdminServices){\n        server.addService(getServiceDefinition(), getHandlers());\n    }\n}\nexports.addAdminServicesToServer = addAdminServicesToServer; //# sourceMappingURL=admin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYWRtaW4uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdDQUFnQyxHQUFHQSw0QkFBNEIsR0FBRyxLQUFLO0FBQ3ZFLE1BQU1JLDBCQUEwQixFQUFFO0FBQ2xDLFNBQVNELHFCQUFxQkUsb0JBQW9CLEVBQUVDLFdBQVc7SUFDM0RGLHdCQUF3QkcsSUFBSSxDQUFDO1FBQUVGO1FBQXNCQztJQUFZO0FBQ3JFO0FBQ0FOLDRCQUE0QixHQUFHRztBQUMvQixTQUFTRCx5QkFBeUJNLE1BQU07SUFDcEMsS0FBSyxNQUFNLEVBQUVILG9CQUFvQixFQUFFQyxXQUFXLEVBQUUsSUFBSUYsd0JBQXlCO1FBQ3pFSSxPQUFPQyxVQUFVLENBQUNKLHdCQUF3QkM7SUFDOUM7QUFDSjtBQUNBTixnQ0FBZ0MsR0FBR0UsMEJBQ25DLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9hZG1pbi5qcz85ODRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIxIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZEFkbWluU2VydmljZXNUb1NlcnZlciA9IGV4cG9ydHMucmVnaXN0ZXJBZG1pblNlcnZpY2UgPSB2b2lkIDA7XG5jb25zdCByZWdpc3RlcmVkQWRtaW5TZXJ2aWNlcyA9IFtdO1xuZnVuY3Rpb24gcmVnaXN0ZXJBZG1pblNlcnZpY2UoZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzKSB7XG4gICAgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMucHVzaCh7IGdldFNlcnZpY2VEZWZpbml0aW9uLCBnZXRIYW5kbGVycyB9KTtcbn1cbmV4cG9ydHMucmVnaXN0ZXJBZG1pblNlcnZpY2UgPSByZWdpc3RlckFkbWluU2VydmljZTtcbmZ1bmN0aW9uIGFkZEFkbWluU2VydmljZXNUb1NlcnZlcihzZXJ2ZXIpIHtcbiAgICBmb3IgKGNvbnN0IHsgZ2V0U2VydmljZURlZmluaXRpb24sIGdldEhhbmRsZXJzIH0gb2YgcmVnaXN0ZXJlZEFkbWluU2VydmljZXMpIHtcbiAgICAgICAgc2VydmVyLmFkZFNlcnZpY2UoZ2V0U2VydmljZURlZmluaXRpb24oKSwgZ2V0SGFuZGxlcnMoKSk7XG4gICAgfVxufVxuZXhwb3J0cy5hZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIgPSBhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZG1pbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJhZGRBZG1pblNlcnZpY2VzVG9TZXJ2ZXIiLCJyZWdpc3RlckFkbWluU2VydmljZSIsInJlZ2lzdGVyZWRBZG1pblNlcnZpY2VzIiwiZ2V0U2VydmljZURlZmluaXRpb24iLCJnZXRIYW5kbGVycyIsInB1c2giLCJzZXJ2ZXIiLCJhZGRTZXJ2aWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BackoffTimeout = void 0;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */ function uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nclass BackoffTimeout {\n    constructor(callback, options){\n        this.callback = callback;\n        /**\n         * The delay time at the start, and after each reset.\n         */ this.initialDelay = INITIAL_BACKOFF_MS;\n        /**\n         * The exponential backoff multiplier.\n         */ this.multiplier = BACKOFF_MULTIPLIER;\n        /**\n         * The maximum delay time\n         */ this.maxDelay = MAX_BACKOFF_MS;\n        /**\n         * The maximum fraction by which the delay time can randomly vary after\n         * applying the multiplier.\n         */ this.jitter = BACKOFF_JITTER;\n        /**\n         * Indicates whether the timer is currently running.\n         */ this.running = false;\n        /**\n         * Indicates whether the timer should keep the Node process running if no\n         * other async operation is doing so.\n         */ this.hasRef = true;\n        /**\n         * The time that the currently running timer was started. Only valid if\n         * running is true.\n         */ this.startTime = new Date();\n        if (options) {\n            if (options.initialDelay) {\n                this.initialDelay = options.initialDelay;\n            }\n            if (options.multiplier) {\n                this.multiplier = options.multiplier;\n            }\n            if (options.jitter) {\n                this.jitter = options.jitter;\n            }\n            if (options.maxDelay) {\n                this.maxDelay = options.maxDelay;\n            }\n        }\n        this.nextDelay = this.initialDelay;\n        this.timerId = setTimeout(()=>{}, 0);\n        clearTimeout(this.timerId);\n    }\n    runTimer(delay) {\n        var _a, _b;\n        clearTimeout(this.timerId);\n        this.timerId = setTimeout(()=>{\n            this.callback();\n            this.running = false;\n        }, delay);\n        if (!this.hasRef) {\n            (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Call the callback after the current amount of delay time\n     */ runOnce() {\n        this.running = true;\n        this.startTime = new Date();\n        this.runTimer(this.nextDelay);\n        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);\n        const jitterMagnitude = nextBackoff * this.jitter;\n        this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);\n    }\n    /**\n     * Stop the timer. The callback will not be called until `runOnce` is called\n     * again.\n     */ stop() {\n        clearTimeout(this.timerId);\n        this.running = false;\n    }\n    /**\n     * Reset the delay time to its initial value. If the timer is still running,\n     * retroactively apply that reset to the current timer.\n     */ reset() {\n        this.nextDelay = this.initialDelay;\n        if (this.running) {\n            const now = new Date();\n            const newEndTime = this.startTime;\n            newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);\n            clearTimeout(this.timerId);\n            if (now < newEndTime) {\n                this.runTimer(newEndTime.getTime() - now.getTime());\n            } else {\n                this.running = false;\n            }\n        }\n    }\n    /**\n     * Check whether the timer is currently running.\n     */ isRunning() {\n        return this.running;\n    }\n    /**\n     * Set that while the timer is running, it should keep the Node process\n     * running.\n     */ ref() {\n        var _a, _b;\n        this.hasRef = true;\n        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    /**\n     * Set that while the timer is running, it should not keep the Node process\n     * running.\n     */ unref() {\n        var _a, _b;\n        this.hasRef = false;\n        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n}\nexports.BackoffTimeout = BackoffTimeout; //# sourceMappingURL=backoff-timeout.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvYmFja29mZi10aW1lb3V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxzQkFBc0IsR0FBRyxLQUFLO0FBQzlCLE1BQU1HLHFCQUFxQjtBQUMzQixNQUFNQyxxQkFBcUI7QUFDM0IsTUFBTUMsaUJBQWlCO0FBQ3ZCLE1BQU1DLGlCQUFpQjtBQUN2Qjs7OztDQUlDLEdBQ0QsU0FBU0MsY0FBY0MsR0FBRyxFQUFFQyxHQUFHO0lBQzNCLE9BQU9DLEtBQUtDLE1BQU0sS0FBTUYsQ0FBQUEsTUFBTUQsR0FBRSxJQUFLQTtBQUN6QztBQUNBLE1BQU1OO0lBQ0ZVLFlBQVlDLFFBQVEsRUFBRUMsT0FBTyxDQUFFO1FBQzNCLElBQUksQ0FBQ0QsUUFBUSxHQUFHQTtRQUNoQjs7U0FFQyxHQUNELElBQUksQ0FBQ0UsWUFBWSxHQUFHWjtRQUNwQjs7U0FFQyxHQUNELElBQUksQ0FBQ2EsVUFBVSxHQUFHWjtRQUNsQjs7U0FFQyxHQUNELElBQUksQ0FBQ2EsUUFBUSxHQUFHWjtRQUNoQjs7O1NBR0MsR0FDRCxJQUFJLENBQUNhLE1BQU0sR0FBR1o7UUFDZDs7U0FFQyxHQUNELElBQUksQ0FBQ2EsT0FBTyxHQUFHO1FBQ2Y7OztTQUdDLEdBQ0QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZDs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLFNBQVMsR0FBRyxJQUFJQztRQUNyQixJQUFJUixTQUFTO1lBQ1QsSUFBSUEsUUFBUUMsWUFBWSxFQUFFO2dCQUN0QixJQUFJLENBQUNBLFlBQVksR0FBR0QsUUFBUUMsWUFBWTtZQUM1QztZQUNBLElBQUlELFFBQVFFLFVBQVUsRUFBRTtnQkFDcEIsSUFBSSxDQUFDQSxVQUFVLEdBQUdGLFFBQVFFLFVBQVU7WUFDeEM7WUFDQSxJQUFJRixRQUFRSSxN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MkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2JhY2tvZmYtdGltZW91dC5qcz9mZTQyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJhY2tvZmZUaW1lb3V0ID0gdm9pZCAwO1xuY29uc3QgSU5JVElBTF9CQUNLT0ZGX01TID0gMTAwMDtcbmNvbnN0IEJBQ0tPRkZfTVVMVElQTElFUiA9IDEuNjtcbmNvbnN0IE1BWF9CQUNLT0ZGX01TID0gMTIwMDAwO1xuY29uc3QgQkFDS09GRl9KSVRURVIgPSAwLjI7XG4vKipcbiAqIEdldCBhIG51bWJlciB1bmlmb3JtbHkgYXQgcmFuZG9tIGluIHRoZSByYW5nZSBbbWluLCBtYXgpXG4gKiBAcGFyYW0gbWluXG4gKiBAcGFyYW0gbWF4XG4gKi9cbmZ1bmN0aW9uIHVuaWZvcm1SYW5kb20obWluLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xufVxuY2xhc3MgQmFja29mZlRpbWVvdXQge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWxheSB0aW1lIGF0IHRoZSBzdGFydCwgYW5kIGFmdGVyIGVhY2ggcmVzZXQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRpYWxEZWxheSA9IElOSVRJQUxfQkFDS09GRl9NUztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBleHBvbmVudGlhbCBiYWNrb2ZmIG11bHRpcGxpZXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSBCQUNLT0ZGX01VTFRJUExJRVI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBkZWxheSB0aW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1heERlbGF5ID0gTUFYX0JBQ0tPRkZfTVM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbWF4aW11bSBmcmFjdGlvbiBieSB3aGljaCB0aGUgZGVsYXkgdGltZSBjYW4gcmFuZG9tbHkgdmFyeSBhZnRlclxuICAgICAgICAgKiBhcHBseWluZyB0aGUgbXVsdGlwbGllci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaml0dGVyID0gQkFDS09GRl9KSVRURVI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdGltZXIgaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSB0aW1lciBzaG91bGQga2VlcCB0aGUgTm9kZSBwcm9jZXNzIHJ1bm5pbmcgaWYgbm9cbiAgICAgICAgICogb3RoZXIgYXN5bmMgb3BlcmF0aW9uIGlzIGRvaW5nIHNvLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYXNSZWYgPSB0cnVlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgdGhhdCB0aGUgY3VycmVudGx5IHJ1bm5pbmcgdGltZXIgd2FzIHN0YXJ0ZWQuIE9ubHkgdmFsaWQgaWZcbiAgICAgICAgICogcnVubmluZyBpcyB0cnVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5pdGlhbERlbGF5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0aWFsRGVsYXkgPSBvcHRpb25zLmluaXRpYWxEZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGxpZXIgPSBvcHRpb25zLm11bHRpcGxpZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5qaXR0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmppdHRlciA9IG9wdGlvbnMuaml0dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubWF4RGVsYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1heERlbGF5ID0gb3B0aW9ucy5tYXhEZWxheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5leHREZWxheSA9IHRoaXMuaW5pdGlhbERlbGF5O1xuICAgICAgICB0aGlzLnRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVySWQpO1xuICAgIH1cbiAgICBydW5UaW1lcihkZWxheSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgdGhpcy50aW1lcklkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzUmVmKSB7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnRpbWVySWQpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgY2FsbGJhY2sgYWZ0ZXIgdGhlIGN1cnJlbnQgYW1vdW50IG9mIGRlbGF5IHRpbWVcbiAgICAgKi9cbiAgICBydW5PbmNlKCkge1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMucnVuVGltZXIodGhpcy5uZXh0RGVsYXkpO1xuICAgICAgICBjb25zdCBuZXh0QmFja29mZiA9IE1hdGgubWluKHRoaXMubmV4dERlbGF5ICogdGhpcy5tdWx0aXBsaWVyLCB0aGlzLm1heERlbGF5KTtcbiAgICAgICAgY29uc3Qgaml0dGVyTWFnbml0dWRlID0gbmV4dEJhY2tvZmYgKiB0aGlzLmppdHRlcjtcbiAgICAgICAgdGhpcy5uZXh0RGVsYXkgPVxuICAgICAgICAgICAgbmV4dEJhY2tvZmYgKyB1bmlmb3JtUmFuZG9tKC1qaXR0ZXJNYWduaXR1ZGUsIGppdHRlck1hZ25pdHVkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIHRpbWVyLiBUaGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIHVudGlsIGBydW5PbmNlYCBpcyBjYWxsZWRcbiAgICAgKiBhZ2Fpbi5cbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcklkKTtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBkZWxheSB0aW1lIHRvIGl0cyBpbml0aWFsIHZhbHVlLiBJZiB0aGUgdGltZXIgaXMgc3RpbGwgcnVubmluZyxcbiAgICAgKiByZXRyb2FjdGl2ZWx5IGFwcGx5IHRoYXQgcmVzZXQgdG8gdGhlIGN1cnJlbnQgdGltZXIuXG4gICAgICovXG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMubmV4dERlbGF5ID0gdGhpcy5pbml0aWFsRGVsYXk7XG4gICAgICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBuZXdFbmRUaW1lID0gdGhpcy5zdGFydFRpbWU7XG4gICAgICAgICAgICBuZXdFbmRUaW1lLnNldE1pbGxpc2Vjb25kcyhuZXdFbmRUaW1lLmdldE1pbGxpc2Vjb25kcygpICsgdGhpcy5uZXh0RGVsYXkpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXJJZCk7XG4gICAgICAgICAgICBpZiAobm93IDwgbmV3RW5kVGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZXIobmV3RW5kVGltZS5nZXRUaW1lKCkgLSBub3cuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgdGhlIHRpbWVyIGlzIGN1cnJlbnRseSBydW5uaW5nLlxuICAgICAqL1xuICAgIGlzUnVubmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnVubmluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoYXQgd2hpbGUgdGhlIHRpbWVyIGlzIHJ1bm5pbmcsIGl0IHNob3VsZCBrZWVwIHRoZSBOb2RlIHByb2Nlc3NcbiAgICAgKiBydW5uaW5nLlxuICAgICAqL1xuICAgIHJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5oYXNSZWYgPSB0cnVlO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnRpbWVySWQpLnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhhdCB3aGlsZSB0aGUgdGltZXIgaXMgcnVubmluZywgaXQgc2hvdWxkIG5vdCBrZWVwIHRoZSBOb2RlIHByb2Nlc3NcbiAgICAgKiBydW5uaW5nLlxuICAgICAqL1xuICAgIHVucmVmKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmhhc1JlZiA9IGZhbHNlO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnRpbWVySWQpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfVxufVxuZXhwb3J0cy5CYWNrb2ZmVGltZW91dCA9IEJhY2tvZmZUaW1lb3V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFja29mZi10aW1lb3V0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhY2tvZmZUaW1lb3V0IiwiSU5JVElBTF9CQUNLT0ZGX01TIiwiQkFDS09GRl9NVUxUSVBMSUVSIiwiTUFYX0JBQ0tPRkZfTVMiLCJCQUNLT0ZGX0pJVFRFUiIsInVuaWZvcm1SYW5kb20iLCJtaW4iLCJtYXgiLCJNYXRoIiwicmFuZG9tIiwiY29uc3RydWN0b3IiLCJjYWxsYmFjayIsIm9wdGlvbnMiLCJpbml0aWFsRGVsYXkiLCJtdWx0aXBsaWVyIiwibWF4RGVsYXkiLCJqaXR0ZXIiLCJydW5uaW5nIiwiaGFzUmVmIiwic3RhcnRUaW1lIiwiRGF0ZSIsIm5leHREZWxheSIsInRpbWVySWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZXIiLCJkZWxheSIsIl9hIiwiX2IiLCJ1bnJlZiIsImNhbGwiLCJydW5PbmNlIiwibmV4dEJhY2tvZmYiLCJqaXR0ZXJNYWduaXR1ZGUiLCJzdG9wIiwicmVzZXQiLCJub3ciLCJuZXdFbmRUaW1lIiwic2V0TWlsbGlzZWNvbmRzIiwiZ2V0TWlsbGlzZWNvbmRzIiwiZ2V0VGltZSIsImlzUnVubmluZyIsInJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CallCredentialsFilterFactory = exports.CallCredentialsFilter = void 0;\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nclass CallCredentialsFilter extends filter_1.BaseFilter {\n    constructor(channel, stream){\n        var _a, _b;\n        super();\n        this.channel = channel;\n        this.stream = stream;\n        this.channel = channel;\n        this.stream = stream;\n        const splitPath = stream.getMethod().split(\"/\");\n        let serviceName = \"\";\n        /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n         * by '/', the first item should be empty and the second should be the\n         * service name */ if (splitPath.length >= 2) {\n            serviceName = splitPath[1];\n        }\n        const hostname = (_b = (_a = uri_parser_1.splitHostPort(stream.getHost())) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : \"localhost\";\n        /* Currently, call credentials are only allowed on HTTPS connections, so we\n         * can assume that the scheme is \"https\" */ this.serviceUrl = `https://${hostname}/${serviceName}`;\n    }\n    async sendMetadata(metadata) {\n        const credentials = this.stream.getCredentials();\n        const credsMetadata = credentials.generateMetadata({\n            service_url: this.serviceUrl\n        });\n        const resultMetadata = await metadata;\n        try {\n            resultMetadata.merge(await credsMetadata);\n        } catch (error) {\n            this.stream.cancelWithStatus(constants_1.Status.UNAUTHENTICATED, `Failed to retrieve auth metadata with error: ${error.message}`);\n            return Promise.reject(\"Failed to retrieve auth metadata\");\n        }\n        if (resultMetadata.get(\"authorization\").length > 1) {\n            this.stream.cancelWithStatus(constants_1.Status.INTERNAL, '\"authorization\" metadata cannot have multiple values');\n            return Promise.reject('\"authorization\" metadata cannot have multiple values');\n        }\n        return resultMetadata;\n    }\n}\nexports.CallCredentialsFilter = CallCredentialsFilter;\nclass CallCredentialsFilterFactory {\n    constructor(channel){\n        this.channel = channel;\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new CallCredentialsFilter(this.channel, callStream);\n    }\n}\nexports.CallCredentialsFilterFactory = CallCredentialsFilterFactory; //# sourceMappingURL=call-credentials-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9DQUFvQyxHQUFHQSw2QkFBNkIsR0FBRyxLQUFLO0FBQzVFLE1BQU1JLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLGVBQWVGLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1GLDhCQUE4QkMsU0FBU0ksVUFBVTtJQUNuREMsWUFBWUMsT0FBTyxFQUFFQyxNQUFNLENBQUU7UUFDekIsSUFBSUMsSUFBSUM7UUFDUixLQUFLO1FBQ0wsSUFBSSxDQUFDSCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUdBO1FBQ2QsTUFBTUcsWUFBWUgsT0FBT0ksU0FBUyxHQUFHQyxLQUFLLENBQUM7UUFDM0MsSUFBSUMsY0FBYztRQUNsQjs7d0JBRWdCLEdBQ2hCLElBQUlILFVBQVVJLE1BQU0sSUFBSSxHQUFHO1lBQ3ZCRCxjQUFjSCxTQUFTLENBQUMsRUFBRTtRQUM5QjtRQUNBLE1BQU1LLFdBQVcsQ0FBQ04sS0FBSyxDQUFDRCxLQUFLTCxhQUFhYSxhQUFhLENBQUNULE9BQU9VLE9BQU8sR0FBRSxNQUFPLFFBQVFULE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR1UsSUFBSSxNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQzFKO2lEQUN5QyxHQUN6QyxJQUFJLENBQUNVLFVBQVUsR0FBRyxDQUFDLFFBQVEsRUFBRUosU0FBUyxDQUFDLEVBQUVGLFlBQVksQ0FBQztJQUMxRDtJQUNBLE1BQU1PLGFBQWFDLFFBQVEsRUFBRTtRQUN6QixNQUFNQyxjQUFjLElBQUksQ0FBQ2YsTUFBTSxDQUFDZ0IsY0FBYztRQUM5QyxNQUFNQyxnQkFBZ0JGLFlBQVlHLGdCQUFnQixDQUFDO1lBQy9DQyxhQUFhLElBQUksQ0FBQ1AsVUFBVTtRQUNoQztRQUNBLE1BQU1RLGlCQUFpQixNQUFNTjtRQUM3QixJQUFJO1lBQ0FNLGVBQWVDLEtBQUssQ0FBQyxNQUFNSjtRQUMvQixFQUNBLE9BQU9LLE9BQU87WUFDVixJQUFJLENBQUN0QixNQUFNLENBQUN1QixnQkFBZ0IsQ0FBQzVCLFlBQVk2QixNQUFNLENBQUNDLGVBQWUsRUFBRSxDQUFDLDZDQUE2QyxFQUFFSCxNQUFNSSxPQUFPLENBQUMsQ0FBQztZQUNoSSxPQUFPQyxRQUFRQyxNQUFNLENBQUM7UUFDMUI7UUFDQSxJQUFJUixlQUFlUyxHQUFHLENBQUMsaUJBQWlCdEIsTUFBTSxHQUFHLEdBQUc7WUFDaEQsSUFBSSxDQUFDUCxNQUFNLENBQUN1QixnQkFBZ0IsQ0FBQzVCLFlBQVk2QixNQUFNLENBQUNNLFFBQVEsRUFBRTtZQUMxRCxPQUFPSCxRQUFRQyxNQUFNLENBQUM7UUFDMUI7UUFDQSxPQUFPUjtJQUNYO0FBQ0o7QUFDQS9CLDZCQUE2QixHQUFHRztBQUNoQyxNQUFNRDtJQUNGTyxZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FnQyxhQUFhQyxVQUFVLEVBQUU7UUFDckIsT0FBTyxJQUFJeEMsc0JBQXNCLElBQUksQ0FBQ08sT0FBTyxFQUFFaUM7SUFDbkQ7QUFDSjtBQUNBM0Msb0NBQW9DLEdBQUdFLDhCQUN2QyxtREFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy1maWx0ZXIuanM/NzQxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHNGaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5DYWxsQ3JlZGVudGlhbHNGaWx0ZXIgPSB2b2lkIDA7XG5jb25zdCBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNsYXNzIENhbGxDcmVkZW50aWFsc0ZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwsIHN0cmVhbSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIGNvbnN0IHNwbGl0UGF0aCA9IHN0cmVhbS5nZXRNZXRob2QoKS5zcGxpdCgnLycpO1xuICAgICAgICBsZXQgc2VydmljZU5hbWUgPSAnJztcbiAgICAgICAgLyogVGhlIHN0YW5kYXJkIHBhdGggZm9ybWF0IGlzIFwiL3tzZXJ2aWNlTmFtZX0ve21ldGhvZE5hbWV9XCIsIHNvIGlmIHdlIHNwbGl0XG4gICAgICAgICAqIGJ5ICcvJywgdGhlIGZpcnN0IGl0ZW0gc2hvdWxkIGJlIGVtcHR5IGFuZCB0aGUgc2Vjb25kIHNob3VsZCBiZSB0aGVcbiAgICAgICAgICogc2VydmljZSBuYW1lICovXG4gICAgICAgIGlmIChzcGxpdFBhdGgubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHNlcnZpY2VOYW1lID0gc3BsaXRQYXRoWzFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvc3RuYW1lID0gKF9iID0gKF9hID0gdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQoc3RyZWFtLmdldEhvc3QoKSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ob3N0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnbG9jYWxob3N0JztcbiAgICAgICAgLyogQ3VycmVudGx5LCBjYWxsIGNyZWRlbnRpYWxzIGFyZSBvbmx5IGFsbG93ZWQgb24gSFRUUFMgY29ubmVjdGlvbnMsIHNvIHdlXG4gICAgICAgICAqIGNhbiBhc3N1bWUgdGhhdCB0aGUgc2NoZW1lIGlzIFwiaHR0cHNcIiAqL1xuICAgICAgICB0aGlzLnNlcnZpY2VVcmwgPSBgaHR0cHM6Ly8ke2hvc3RuYW1lfS8ke3NlcnZpY2VOYW1lfWA7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCBjcmVkZW50aWFscyA9IHRoaXMuc3RyZWFtLmdldENyZWRlbnRpYWxzKCk7XG4gICAgICAgIGNvbnN0IGNyZWRzTWV0YWRhdGEgPSBjcmVkZW50aWFscy5nZW5lcmF0ZU1ldGFkYXRhKHtcbiAgICAgICAgICAgIHNlcnZpY2VfdXJsOiB0aGlzLnNlcnZpY2VVcmwsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRNZXRhZGF0YSA9IGF3YWl0IG1ldGFkYXRhO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0TWV0YWRhdGEubWVyZ2UoYXdhaXQgY3JlZHNNZXRhZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5VTkFVVEhFTlRJQ0FURUQsIGBGYWlsZWQgdG8gcmV0cmlldmUgYXV0aCBtZXRhZGF0YSB3aXRoIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0ZhaWxlZCB0byByZXRyaWV2ZSBhdXRoIG1ldGFkYXRhJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdE1ldGFkYXRhLmdldCgnYXV0aG9yaXphdGlvbicpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCAnXCJhdXRob3JpemF0aW9uXCIgbWV0YWRhdGEgY2Fubm90IGhhdmUgbXVsdGlwbGUgdmFsdWVzJyk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ1wiYXV0aG9yaXphdGlvblwiIG1ldGFkYXRhIGNhbm5vdCBoYXZlIG11bHRpcGxlIHZhbHVlcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRNZXRhZGF0YTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxDcmVkZW50aWFsc0ZpbHRlciA9IENhbGxDcmVkZW50aWFsc0ZpbHRlcjtcbmNsYXNzIENhbGxDcmVkZW50aWFsc0ZpbHRlckZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICB9XG4gICAgY3JlYXRlRmlsdGVyKGNhbGxTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsQ3JlZGVudGlhbHNGaWx0ZXIodGhpcy5jaGFubmVsLCBjYWxsU3RyZWFtKTtcbiAgICB9XG59XG5leHBvcnRzLkNhbGxDcmVkZW50aWFsc0ZpbHRlckZhY3RvcnkgPSBDYWxsQ3JlZGVudGlhbHNGaWx0ZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC1jcmVkZW50aWFscy1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ2FsbENyZWRlbnRpYWxzRmlsdGVyRmFjdG9yeSIsIkNhbGxDcmVkZW50aWFsc0ZpbHRlciIsImZpbHRlcl8xIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwidXJpX3BhcnNlcl8xIiwiQmFzZUZpbHRlciIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbCIsInN0cmVhbSIsIl9hIiwiX2IiLCJzcGxpdFBhdGgiLCJnZXRNZXRob2QiLCJzcGxpdCIsInNlcnZpY2VOYW1lIiwibGVuZ3RoIiwiaG9zdG5hbWUiLCJzcGxpdEhvc3RQb3J0IiwiZ2V0SG9zdCIsImhvc3QiLCJzZXJ2aWNlVXJsIiwic2VuZE1ldGFkYXRhIiwibWV0YWRhdGEiLCJjcmVkZW50aWFscyIsImdldENyZWRlbnRpYWxzIiwiY3JlZHNNZXRhZGF0YSIsImdlbmVyYXRlTWV0YWRhdGEiLCJzZXJ2aWNlX3VybCIsInJlc3VsdE1ldGFkYXRhIiwibWVyZ2UiLCJlcnJvciIsImNhbmNlbFdpdGhTdGF0dXMiLCJTdGF0dXMiLCJVTkFVVEhFTlRJQ0FURUQiLCJtZXNzYWdlIiwiUHJvbWlzZSIsInJlamVjdCIsImdldCIsIklOVEVSTkFMIiwiY3JlYXRlRmlsdGVyIiwiY2FsbFN0cmVhbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js":
/*!******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-credentials.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CallCredentials = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nfunction isCurrentOauth2Client(client) {\n    return \"getRequestHeaders\" in client && typeof client.getRequestHeaders === \"function\";\n}\n/**\n * A class that represents a generic method of adding authentication-related\n * metadata on a per-request basis.\n */ class CallCredentials {\n    /**\n     * Creates a new CallCredentials object from a given function that generates\n     * Metadata objects.\n     * @param metadataGenerator A function that accepts a set of options, and\n     * generates a Metadata object based on these options, which is passed back\n     * to the caller via a supplied (err, metadata) callback.\n     */ static createFromMetadataGenerator(metadataGenerator) {\n        return new SingleCallCredentials(metadataGenerator);\n    }\n    /**\n     * Create a gRPC credential from a Google credential object.\n     * @param googleCredentials The authentication client to use.\n     * @return The resulting CallCredentials object.\n     */ static createFromGoogleCredential(googleCredentials) {\n        return CallCredentials.createFromMetadataGenerator((options, callback)=>{\n            let getHeaders;\n            if (isCurrentOauth2Client(googleCredentials)) {\n                getHeaders = googleCredentials.getRequestHeaders(options.service_url);\n            } else {\n                getHeaders = new Promise((resolve, reject)=>{\n                    googleCredentials.getRequestMetadata(options.service_url, (err, headers)=>{\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        resolve(headers);\n                    });\n                });\n            }\n            getHeaders.then((headers)=>{\n                const metadata = new metadata_1.Metadata();\n                for (const key of Object.keys(headers)){\n                    metadata.add(key, headers[key]);\n                }\n                callback(null, metadata);\n            }, (err)=>{\n                callback(err);\n            });\n        });\n    }\n    static createEmpty() {\n        return new EmptyCallCredentials();\n    }\n}\nexports.CallCredentials = CallCredentials;\nclass ComposedCallCredentials extends CallCredentials {\n    constructor(creds){\n        super();\n        this.creds = creds;\n    }\n    async generateMetadata(options) {\n        const base = new metadata_1.Metadata();\n        const generated = await Promise.all(this.creds.map((cred)=>cred.generateMetadata(options)));\n        for (const gen of generated){\n            base.merge(gen);\n        }\n        return base;\n    }\n    compose(other) {\n        return new ComposedCallCredentials(this.creds.concat([\n            other\n        ]));\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedCallCredentials) {\n            return this.creds.every((value, index)=>value._equals(other.creds[index]));\n        } else {\n            return false;\n        }\n    }\n}\nclass SingleCallCredentials extends CallCredentials {\n    constructor(metadataGenerator){\n        super();\n        this.metadataGenerator = metadataGenerator;\n    }\n    generateMetadata(options) {\n        return new Promise((resolve, reject)=>{\n            this.metadataGenerator(options, (err, metadata)=>{\n                if (metadata !== undefined) {\n                    resolve(metadata);\n                } else {\n                    reject(err);\n                }\n            });\n        });\n    }\n    compose(other) {\n        return new ComposedCallCredentials([\n            this,\n            other\n        ]);\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SingleCallCredentials) {\n            return this.metadataGenerator === other.metadataGenerator;\n        } else {\n            return false;\n        }\n    }\n}\nclass EmptyCallCredentials extends CallCredentials {\n    generateMetadata(options) {\n        return Promise.resolve(new metadata_1.Metadata());\n    }\n    compose(other) {\n        return other;\n    }\n    _equals(other) {\n        return other instanceof EmptyCallCredentials;\n    }\n} //# sourceMappingURL=call-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUcsS0FBSztBQUMvQixNQUFNRyxhQUFhQyxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxTQUFTQyxzQkFBc0JDLE1BQU07SUFDakMsT0FBUSx1QkFBdUJBLFVBQzNCLE9BQU9BLE9BQU9DLGlCQUFpQixLQUFLO0FBQzVDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUw7SUFDRjs7Ozs7O0tBTUMsR0FDRCxPQUFPTSw0QkFBNEJDLGlCQUFpQixFQUFFO1FBQ2xELE9BQU8sSUFBSUMsc0JBQXNCRDtJQUNyQztJQUNBOzs7O0tBSUMsR0FDRCxPQUFPRSwyQkFBMkJDLGlCQUFpQixFQUFFO1FBQ2pELE9BQU9WLGdCQUFnQk0sMkJBQTJCLENBQUMsQ0FBQ0ssU0FBU0M7WUFDekQsSUFBSUM7WUFDSixJQUFJVixzQkFBc0JPLG9CQUFvQjtnQkFDMUNHLGFBQWFILGtCQUFrQkwsaUJBQWlCLENBQUNNLFFBQVFHLFdBQVc7WUFDeEUsT0FDSztnQkFDREQsYUFBYSxJQUFJRSxRQUFRLENBQUNDLFNBQVNDO29CQUMvQlAsa0JBQWtCUSxrQkFBa0IsQ0FBQ1AsUUFBUUcsV0FBVyxFQUFFLENBQUNLLEtBQUtDO3dCQUM1RCxJQUFJRCxLQUFLOzRCQUNMRixPQUFPRTs0QkFDUDt3QkFDSjt3QkFDQUgsUUFBUUk7b0JBQ1o7Z0JBQ0o7WUFDSjtZQUNBUCxXQUFXUSxJQUFJLENBQUMsQ0FBQ0Q7Z0JBQ2IsTUFBTUUsV0FBVyxJQUFJckIsV0FBV3NCLFFBQVE7Z0JBQ3hDLEtBQUssTUFBTUMsT0FBTzVCLE9BQU82QixJQUFJLENBQUNMLFNBQVU7b0JBQ3BDRSxTQUFTSSxHQUFHLENBQUNGLEtBQUtKLE9BQU8sQ0FBQ0ksSUFBSTtnQkFDbEM7Z0JBQ0FaLFNBQVMsTUFBTVU7WUFDbkIsR0FBRyxDQUFDSDtnQkFDQVAsU0FBU087WUFDYjtRQUNKO0lBQ0o7SUFDQSxPQUFPUSxjQUFjO1FBQ2pCLE9BQU8sSUFBSUM7SUFDZjtBQUNKO0FBQ0E5Qix1QkFBdUIsR0FBR0U7QUFDMUIsTUFBTTZCLGdDQUFnQzdCO0lBQ2xDOEIsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsS0FBSztRQUNMLElBQUksQ0FBQ0EsS0FBSyxHQUFHQTtJQUNqQjtJQUNBLE1BQU1DLGlCQUFpQnJCLE9BQU8sRUFBRTtRQUM1QixNQUFNc0IsT0FBTyxJQUFJaEMsV0FBV3NCLFFBQVE7UUFDcEMsTUFBTVcsWUFBWSxNQUFNbkIsUUFBUW9CLEdBQUcsQ0FBQyxJQUFJLENBQUNKLEtBQUssQ0FBQ0ssR0FBRyxDQUFDLENBQUNDLE9BQVNBLEtBQUtMLGdCQUFnQixDQUFDckI7UUFDbkYsS0FBSyxNQUFNMkIsT0FBT0osVUFBVztZQUN6QkQsS0FBS00sS0FBSyxDQUFDRDtRQUNmO1FBQ0EsT0FBT0w7SUFDWDtJQUNBTyxRQUFRQyxLQUFLLEVBQUU7UUFDWCxPQUFPLElBQUlaLHdCQUF3QixJQUFJLENBQUNFLEtBQUssQ0FBQ1csTUFBTSxDQUFDO1lBQUNEO1NBQU07SUFDaEU7SUFDQUUsUUFBUUYsS0FBSyxFQUFFO1FBQ1gsSUFBSSxJQUFJLEtBQUtBLE9BQU87WUFDaEIsT0FBTztRQUNYO1FBQ0EsSUFBSUEsaUJBQWlCWix5QkFBeUI7WUFDMUMsT0FBTyxJQUFJLENBQUNFLEtBQUssQ0FBQ2EsS0FBSyxDQUFDLENBQUM3QyxPQUFPOEMsUUFBVTlDLE1BQU00QyxPQUFPLENBQUNGLE1BQU1WLEtBQUssQ0FBQ2MsTUFBTTtRQUM5RSxPQUNLO1lBQ0QsT0FBTztRQUNYO0lBQ0o7QUFDSjtBQUNBLE1BQU1yQyw4QkFBOEJSO0lBQ2hDOEIsWUFBWXZCLGlCQUFpQixDQUFFO1FBQzNCLEtBQUs7UUFDTCxJQUFJLENBQUNBLGlCQUFpQixHQUFHQTtJQUM3QjtJQUNBeUIsaUJBQWlCckIsT0FBTyxFQUFFO1FBQ3RCLE9BQU8sSUFBSUksUUFBUSxDQUFDQyxTQUFTQztZQUN6QixJQUFJLENBQUNWLGlCQUFpQixDQUFDSSxTQUFTLENBQUNRLEtBQUtHO2dCQUNsQyxJQUFJQSxhQUFhd0IsV0FBVztvQkFDeEI5QixRQUFRTTtnQkFDWixPQUNLO29CQUNETCxPQUFPRTtnQkFDWDtZQUNKO1FBQ0o7SUFDSjtJQUNBcUIsUUFBUUMsS0FBSyxFQUFFO1FBQ1gsT0FBTyxJQUFJWix3QkFBd0I7WUFBQyxJQUFJO1lBQUVZO1NBQU07SUFDcEQ7SUFDQUUsUUFBUUYsS0FBSyxFQUFFO1FBQ1gsSUFBSSxJQUFJLEtBQUtBLE9BQU87WUFDaEIsT0FBTztRQUNYO1FBQ0EsSUFBSUEsaUJBQWlCakMsdUJBQXVCO1lBQ3hDLE9BQU8sSUFBSSxDQUFDRCxpQkFBaUIsS0FBS2tDLE1BQU1sQyxpQkFBaUI7UUFDN0QsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKO0FBQ0o7QUFDQSxNQUFNcUIsNkJBQTZCNUI7SUFDL0JnQyxpQkFBaUJyQixPQUFPLEVBQUU7UUFDdEIsT0FBT0ksUUFBUUMsT0FBTyxDQUFDLElBQUlmLFdBQVdzQixRQUFRO0lBQ2xEO0lBQ0FpQixRQUFRQyxLQUFLLEVBQUU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FFLFFBQVFGLEtBQUssRUFBRTtRQUNYLE9BQU9BLGlCQUFpQmI7SUFDNUI7QUFDSixFQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLWNyZWRlbnRpYWxzLmpzPzI4YjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuZnVuY3Rpb24gaXNDdXJyZW50T2F1dGgyQ2xpZW50KGNsaWVudCkge1xuICAgIHJldHVybiAoJ2dldFJlcXVlc3RIZWFkZXJzJyBpbiBjbGllbnQgJiZcbiAgICAgICAgdHlwZW9mIGNsaWVudC5nZXRSZXF1ZXN0SGVhZGVycyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIEEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgZ2VuZXJpYyBtZXRob2Qgb2YgYWRkaW5nIGF1dGhlbnRpY2F0aW9uLXJlbGF0ZWRcbiAqIG1ldGFkYXRhIG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMuXG4gKi9cbmNsYXNzIENhbGxDcmVkZW50aWFscyB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDYWxsQ3JlZGVudGlhbHMgb2JqZWN0IGZyb20gYSBnaXZlbiBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlc1xuICAgICAqIE1ldGFkYXRhIG9iamVjdHMuXG4gICAgICogQHBhcmFtIG1ldGFkYXRhR2VuZXJhdG9yIEEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgc2V0IG9mIG9wdGlvbnMsIGFuZFxuICAgICAqIGdlbmVyYXRlcyBhIE1ldGFkYXRhIG9iamVjdCBiYXNlZCBvbiB0aGVzZSBvcHRpb25zLCB3aGljaCBpcyBwYXNzZWQgYmFja1xuICAgICAqIHRvIHRoZSBjYWxsZXIgdmlhIGEgc3VwcGxpZWQgKGVyciwgbWV0YWRhdGEpIGNhbGxiYWNrLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IobWV0YWRhdGFHZW5lcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaW5nbGVDYWxsQ3JlZGVudGlhbHMobWV0YWRhdGFHZW5lcmF0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBnUlBDIGNyZWRlbnRpYWwgZnJvbSBhIEdvb2dsZSBjcmVkZW50aWFsIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gZ29vZ2xlQ3JlZGVudGlhbHMgVGhlIGF1dGhlbnRpY2F0aW9uIGNsaWVudCB0byB1c2UuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENhbGxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsKGdvb2dsZUNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHJldHVybiBDYWxsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbU1ldGFkYXRhR2VuZXJhdG9yKChvcHRpb25zLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgbGV0IGdldEhlYWRlcnM7XG4gICAgICAgICAgICBpZiAoaXNDdXJyZW50T2F1dGgyQ2xpZW50KGdvb2dsZUNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgICAgIGdldEhlYWRlcnMgPSBnb29nbGVDcmVkZW50aWFscy5nZXRSZXF1ZXN0SGVhZGVycyhvcHRpb25zLnNlcnZpY2VfdXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGdldEhlYWRlcnMgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdvb2dsZUNyZWRlbnRpYWxzLmdldFJlcXVlc3RNZXRhZGF0YShvcHRpb25zLnNlcnZpY2VfdXJsLCAoZXJyLCBoZWFkZXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZXRIZWFkZXJzLnRoZW4oKGhlYWRlcnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEuYWRkKGtleSwgaGVhZGVyc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFbXB0eUNhbGxDcmVkZW50aWFscygpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2FsbENyZWRlbnRpYWxzID0gQ2FsbENyZWRlbnRpYWxzO1xuY2xhc3MgQ29tcG9zZWRDYWxsQ3JlZGVudGlhbHMgZXh0ZW5kcyBDYWxsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKGNyZWRzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY3JlZHMgPSBjcmVkcztcbiAgICB9XG4gICAgYXN5bmMgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWQgPSBhd2FpdCBQcm9taXNlLmFsbCh0aGlzLmNyZWRzLm1hcCgoY3JlZCkgPT4gY3JlZC5nZW5lcmF0ZU1ldGFkYXRhKG9wdGlvbnMpKSk7XG4gICAgICAgIGZvciAoY29uc3QgZ2VuIG9mIGdlbmVyYXRlZCkge1xuICAgICAgICAgICAgYmFzZS5tZXJnZShnZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICBjb21wb3NlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDYWxsQ3JlZGVudGlhbHModGhpcy5jcmVkcy5jb25jYXQoW290aGVyXSkpO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ29tcG9zZWRDYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWRzLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlLl9lcXVhbHMob3RoZXIuY3JlZHNbaW5kZXhdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTaW5nbGVDYWxsQ3JlZGVudGlhbHMgZXh0ZW5kcyBDYWxsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKG1ldGFkYXRhR2VuZXJhdG9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWV0YWRhdGFHZW5lcmF0b3IgPSBtZXRhZGF0YUdlbmVyYXRvcjtcbiAgICB9XG4gICAgZ2VuZXJhdGVNZXRhZGF0YShvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1ldGFkYXRhR2VuZXJhdG9yKG9wdGlvbnMsIChlcnIsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShtZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbXBvc2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb3NlZENhbGxDcmVkZW50aWFscyhbdGhpcywgb3RoZXJdKTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFNpbmdsZUNhbGxDcmVkZW50aWFscykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGFHZW5lcmF0b3IgPT09IG90aGVyLm1ldGFkYXRhR2VuZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgRW1wdHlDYWxsQ3JlZGVudGlhbHMgZXh0ZW5kcyBDYWxsQ3JlZGVudGlhbHMge1xuICAgIGdlbmVyYXRlTWV0YWRhdGEob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkpO1xuICAgIH1cbiAgICBjb21wb3NlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlcjtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBFbXB0eUNhbGxDcmVkZW50aWFscztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNhbGxDcmVkZW50aWFscyIsIm1ldGFkYXRhXzEiLCJyZXF1aXJlIiwiaXNDdXJyZW50T2F1dGgyQ2xpZW50IiwiY2xpZW50IiwiZ2V0UmVxdWVzdEhlYWRlcnMiLCJjcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IiLCJtZXRhZGF0YUdlbmVyYXRvciIsIlNpbmdsZUNhbGxDcmVkZW50aWFscyIsImNyZWF0ZUZyb21Hb29nbGVDcmVkZW50aWFsIiwiZ29vZ2xlQ3JlZGVudGlhbHMiLCJvcHRpb25zIiwiY2FsbGJhY2siLCJnZXRIZWFkZXJzIiwic2VydmljZV91cmwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImdldFJlcXVlc3RNZXRhZGF0YSIsImVyciIsImhlYWRlcnMiLCJ0aGVuIiwibWV0YWRhdGEiLCJNZXRhZGF0YSIsImtleSIsImtleXMiLCJhZGQiLCJjcmVhdGVFbXB0eSIsIkVtcHR5Q2FsbENyZWRlbnRpYWxzIiwiQ29tcG9zZWRDYWxsQ3JlZGVudGlhbHMiLCJjb25zdHJ1Y3RvciIsImNyZWRzIiwiZ2VuZXJhdGVNZXRhZGF0YSIsImJhc2UiLCJnZW5lcmF0ZWQiLCJhbGwiLCJtYXAiLCJjcmVkIiwiZ2VuIiwibWVyZ2UiLCJjb21wb3NlIiwib3RoZXIiLCJjb25jYXQiLCJfZXF1YWxzIiwiZXZlcnkiLCJpbmRleCIsInVuZGVmaW5lZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call-stream.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2CallStream = exports.InterceptingListenerImpl = exports.isInterceptingListener = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"call_stream\";\nconst { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL } = http2.constants;\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */ function getSystemErrorName(errno) {\n    for (const [name, num] of Object.entries(os.constants.errno)){\n        if (num === errno) {\n            return name;\n        }\n    }\n    return \"Unknown system error \" + errno;\n}\nfunction getMinDeadline(deadlineList) {\n    let minValue = Infinity;\n    for (const deadline of deadlineList){\n        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;\n        if (deadlineMsecs < minValue) {\n            minValue = deadlineMsecs;\n        }\n    }\n    return minValue;\n}\nfunction isInterceptingListener(listener) {\n    return listener.onReceiveMetadata !== undefined && listener.onReceiveMetadata.length === 1;\n}\nexports.isInterceptingListener = isInterceptingListener;\nclass InterceptingListenerImpl {\n    constructor(listener, nextListener){\n        this.listener = listener;\n        this.nextListener = nextListener;\n        this.processingMetadata = false;\n        this.hasPendingMessage = false;\n        this.processingMessage = false;\n        this.pendingStatus = null;\n    }\n    processPendingMessage() {\n        if (this.hasPendingMessage) {\n            this.nextListener.onReceiveMessage(this.pendingMessage);\n            this.pendingMessage = null;\n            this.hasPendingMessage = false;\n        }\n    }\n    processPendingStatus() {\n        if (this.pendingStatus) {\n            this.nextListener.onReceiveStatus(this.pendingStatus);\n        }\n    }\n    onReceiveMetadata(metadata) {\n        this.processingMetadata = true;\n        this.listener.onReceiveMetadata(metadata, (metadata)=>{\n            this.processingMetadata = false;\n            this.nextListener.onReceiveMetadata(metadata);\n            this.processPendingMessage();\n            this.processPendingStatus();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    onReceiveMessage(message) {\n        /* If this listener processes messages asynchronously, the last message may\n         * be reordered with respect to the status */ this.processingMessage = true;\n        this.listener.onReceiveMessage(message, (msg)=>{\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessage = msg;\n                this.hasPendingMessage = true;\n            } else {\n                this.nextListener.onReceiveMessage(msg);\n                this.processPendingStatus();\n            }\n        });\n    }\n    onReceiveStatus(status) {\n        this.listener.onReceiveStatus(status, (processedStatus)=>{\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingStatus = processedStatus;\n            } else {\n                this.nextListener.onReceiveStatus(processedStatus);\n            }\n        });\n    }\n}\nexports.InterceptingListenerImpl = InterceptingListenerImpl;\nclass Http2CallStream {\n    constructor(methodName, channel, options, filterStackFactory, channelCallCredentials, callNumber){\n        this.methodName = methodName;\n        this.channel = channel;\n        this.options = options;\n        this.channelCallCredentials = channelCallCredentials;\n        this.callNumber = callNumber;\n        this.http2Stream = null;\n        this.pendingRead = false;\n        this.isWriteFilterPending = false;\n        this.pendingWrite = null;\n        this.pendingWriteCallback = null;\n        this.writesClosed = false;\n        this.decoder = new stream_decoder_1.StreamDecoder();\n        this.isReadFilterPending = false;\n        this.canPush = false;\n        /**\n         * Indicates that an 'end' event has come from the http2 stream, so there\n         * will be no more data events.\n         */ this.readsClosed = false;\n        this.statusOutput = false;\n        this.unpushedReadMessages = [];\n        this.unfilteredReadMessages = [];\n        // Status code mapped from :status. To be used if grpc-status is not received\n        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n        // This is populated (non-null) if and only if the call has ended\n        this.finalStatus = null;\n        this.subchannel = null;\n        this.listener = null;\n        this.internalError = null;\n        this.configDeadline = Infinity;\n        this.statusWatchers = [];\n        this.streamEndWatchers = [];\n        this.callStatsTracker = null;\n        this.filterStack = filterStackFactory.createFilter(this);\n        this.credentials = channelCallCredentials;\n        this.disconnectListener = ()=>{\n            this.endCall({\n                code: constants_1.Status.UNAVAILABLE,\n                details: \"Connection dropped\",\n                metadata: new metadata_1.Metadata()\n            });\n        };\n        if (this.options.parentCall && this.options.flags & constants_1.Propagate.CANCELLATION) {\n            this.options.parentCall.on(\"cancelled\", ()=>{\n                this.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled by parent call\");\n            });\n        }\n    }\n    outputStatus() {\n        var _a;\n        /* Precondition: this.finalStatus !== null */ if (this.listener && !this.statusOutput) {\n            this.statusOutput = true;\n            const filteredStatus = this.filterStack.receiveTrailers(this.finalStatus);\n            this.trace(\"ended with status: code=\" + filteredStatus.code + ' details=\"' + filteredStatus.details + '\"');\n            this.statusWatchers.forEach((watcher)=>watcher(filteredStatus));\n            /* We delay the actual action of bubbling up the status to insulate the\n             * cleanup code in this class from any errors that may be thrown in the\n             * upper layers as a result of bubbling up the status. In particular,\n             * if the status is not OK, the \"error\" event may be emitted\n             * synchronously at the top level, which will result in a thrown error if\n             * the user does not handle that event. */ process.nextTick(()=>{\n                var _a;\n                (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);\n            });\n            /* Leave the http2 stream in flowing state to drain incoming messages, to\n             * ensure that the stream closure completes. The call stream already does\n             * not push more messages after the status is output, so the messages go\n             * nowhere either way. */ (_a = this.http2Stream) === null || _a === void 0 ? void 0 : _a.resume();\n            if (this.subchannel) {\n                this.subchannel.callUnref();\n                this.subchannel.removeDisconnectListener(this.disconnectListener);\n            }\n        }\n    }\n    trace(text) {\n        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, \"[\" + this.callNumber + \"] \" + text);\n    }\n    /**\n     * On first call, emits a 'status' event with the given StatusObject.\n     * Subsequent calls are no-ops.\n     * @param status The status of the call.\n     */ endCall(status) {\n        /* If the status is OK and a new status comes in (e.g. from a\n         * deserialization failure), that new status takes priority */ if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n            this.finalStatus = status;\n            this.maybeOutputStatus();\n        }\n        this.destroyHttp2Stream();\n    }\n    maybeOutputStatus() {\n        if (this.finalStatus !== null) {\n            /* The combination check of readsClosed and that the two message buffer\n             * arrays are empty checks that there all incoming data has been fully\n             * processed */ if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && this.unfilteredReadMessages.length === 0 && !this.isReadFilterPending) {\n                this.outputStatus();\n            }\n        }\n    }\n    push(message) {\n        this.trace(\"pushing to reader message of length \" + (message instanceof Buffer ? message.length : null));\n        this.canPush = false;\n        process.nextTick(()=>{\n            var _a;\n            /* If we have already output the status any later messages should be\n             * ignored, and can cause out-of-order operation errors higher up in the\n             * stack. Checking as late as possible here to avoid any race conditions.\n             */ if (this.statusOutput) {\n                return;\n            }\n            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMessage(message);\n            this.maybeOutputStatus();\n        });\n    }\n    handleFilterError(error) {\n        this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n    }\n    handleFilteredRead(message) {\n        /* If we the call has already ended with an error, we don't want to do\n         * anything with this message. Dropping it on the floor is correct\n         * behavior */ if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.maybeOutputStatus();\n            return;\n        }\n        this.isReadFilterPending = false;\n        if (this.canPush) {\n            this.http2Stream.pause();\n            this.push(message);\n        } else {\n            this.trace(\"unpushedReadMessages.push message of length \" + message.length);\n            this.unpushedReadMessages.push(message);\n        }\n        if (this.unfilteredReadMessages.length > 0) {\n            /* nextMessage is guaranteed not to be undefined because\n               unfilteredReadMessages is non-empty */ const nextMessage = this.unfilteredReadMessages.shift();\n            this.filterReceivedMessage(nextMessage);\n        }\n    }\n    filterReceivedMessage(framedMessage) {\n        /* If we the call has already ended with an error, we don't want to do\n         * anything with this message. Dropping it on the floor is correct\n         * behavior */ if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.maybeOutputStatus();\n            return;\n        }\n        this.trace(\"filterReceivedMessage of length \" + framedMessage.length);\n        this.isReadFilterPending = true;\n        this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n    }\n    tryPush(messageBytes) {\n        if (this.isReadFilterPending) {\n            this.trace(\"unfilteredReadMessages.push message of length \" + (messageBytes && messageBytes.length));\n            this.unfilteredReadMessages.push(messageBytes);\n        } else {\n            this.filterReceivedMessage(messageBytes);\n        }\n    }\n    handleTrailers(headers) {\n        this.streamEndWatchers.forEach((watcher)=>watcher(true));\n        let headersString = \"\";\n        for (const header of Object.keys(headers)){\n            headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n        }\n        this.trace(\"Received server trailers:\\n\" + headersString);\n        let metadata;\n        try {\n            metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        } catch (e) {\n            metadata = new metadata_1.Metadata();\n        }\n        const metadataMap = metadata.getMap();\n        let code = this.mappedStatusCode;\n        if (code === constants_1.Status.UNKNOWN && typeof metadataMap[\"grpc-status\"] === \"string\") {\n            const receivedStatus = Number(metadataMap[\"grpc-status\"]);\n            if (receivedStatus in constants_1.Status) {\n                code = receivedStatus;\n                this.trace(\"received status code \" + receivedStatus + \" from server\");\n            }\n            metadata.remove(\"grpc-status\");\n        }\n        let details = \"\";\n        if (typeof metadataMap[\"grpc-message\"] === \"string\") {\n            try {\n                details = decodeURI(metadataMap[\"grpc-message\"]);\n            } catch (e) {\n                details = metadataMap[\"grpc-message\"];\n            }\n            metadata.remove(\"grpc-message\");\n            this.trace('received status details string \"' + details + '\" from server');\n        }\n        const status = {\n            code,\n            details,\n            metadata\n        };\n        // This is a no-op if the call was already ended when handling headers.\n        this.endCall(status);\n    }\n    writeMessageToStream(message, callback) {\n        var _a;\n        (_a = this.callStatsTracker) === null || _a === void 0 ? void 0 : _a.addMessageSent();\n        this.http2Stream.write(message, callback);\n    }\n    attachHttp2Stream(stream, subchannel, extraFilters, callStatsTracker) {\n        this.filterStack.push(extraFilters);\n        if (this.finalStatus !== null) {\n            stream.close(NGHTTP2_CANCEL);\n        } else {\n            this.trace(\"attachHttp2Stream from subchannel \" + subchannel.getAddress());\n            this.http2Stream = stream;\n            this.subchannel = subchannel;\n            this.callStatsTracker = callStatsTracker;\n            subchannel.addDisconnectListener(this.disconnectListener);\n            subchannel.callRef();\n            stream.on(\"response\", (headers, flags)=>{\n                var _a;\n                let headersString = \"\";\n                for (const header of Object.keys(headers)){\n                    headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n                }\n                this.trace(\"Received server headers:\\n\" + headersString);\n                switch(headers[\":status\"]){\n                    // TODO(murgatroid99): handle 100 and 101\n                    case 400:\n                        this.mappedStatusCode = constants_1.Status.INTERNAL;\n                        break;\n                    case 401:\n                        this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n                        break;\n                    case 403:\n                        this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n                        break;\n                    case 404:\n                        this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n                        break;\n                    case 429:\n                    case 502:\n                    case 503:\n                    case 504:\n                        this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n                        break;\n                    default:\n                        this.mappedStatusCode = constants_1.Status.UNKNOWN;\n                }\n                if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n                    this.handleTrailers(headers);\n                } else {\n                    let metadata;\n                    try {\n                        metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n                    } catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata()\n                        });\n                        return;\n                    }\n                    try {\n                        const finalMetadata = this.filterStack.receiveMetadata(metadata);\n                        (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveMetadata(finalMetadata);\n                    } catch (error) {\n                        this.endCall({\n                            code: constants_1.Status.UNKNOWN,\n                            details: error.message,\n                            metadata: new metadata_1.Metadata()\n                        });\n                    }\n                }\n            });\n            stream.on(\"trailers\", (headers)=>{\n                this.handleTrailers(headers);\n            });\n            stream.on(\"data\", (data)=>{\n                /* If the status has already been output, allow the http2 stream to\n                 * drain without processing the data. */ if (this.statusOutput) {\n                    return;\n                }\n                this.trace(\"receive HTTP/2 data frame of length \" + data.length);\n                const messages = this.decoder.write(data);\n                for (const message of messages){\n                    this.trace(\"parsed message of length \" + message.length);\n                    this.callStatsTracker.addMessageReceived();\n                    this.tryPush(message);\n                }\n            });\n            stream.on(\"end\", ()=>{\n                this.readsClosed = true;\n                this.maybeOutputStatus();\n            });\n            stream.on(\"close\", ()=>{\n                /* Use process.next tick to ensure that this code happens after any\n                 * \"error\" event that may be emitted at about the same time, so that\n                 * we can bubble up the error message from that event. */ process.nextTick(()=>{\n                    var _a;\n                    this.trace(\"HTTP/2 stream closed with code \" + stream.rstCode);\n                    /* If we have a final status with an OK status code, that means that\n                     * we have received all of the messages and we have processed the\n                     * trailers and the call completed successfully, so it doesn't matter\n                     * how the stream ends after that */ if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                        return;\n                    }\n                    let code;\n                    let details = \"\";\n                    switch(stream.rstCode){\n                        case http2.constants.NGHTTP2_NO_ERROR:\n                            /* If we get a NO_ERROR code and we already have a status, the\n                             * stream completed properly and we just haven't fully processed\n                             * it yet */ if (this.finalStatus !== null) {\n                                return;\n                            }\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${stream.rstCode}`;\n                            break;\n                        case http2.constants.NGHTTP2_REFUSED_STREAM:\n                            code = constants_1.Status.UNAVAILABLE;\n                            details = \"Stream refused by server\";\n                            break;\n                        case http2.constants.NGHTTP2_CANCEL:\n                            code = constants_1.Status.CANCELLED;\n                            details = \"Call cancelled\";\n                            break;\n                        case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n                            code = constants_1.Status.RESOURCE_EXHAUSTED;\n                            details = \"Bandwidth exhausted or memory limit exceeded\";\n                            break;\n                        case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n                            code = constants_1.Status.PERMISSION_DENIED;\n                            details = \"Protocol not secure enough\";\n                            break;\n                        case http2.constants.NGHTTP2_INTERNAL_ERROR:\n                            code = constants_1.Status.INTERNAL;\n                            if (this.internalError === null) {\n                                /* This error code was previously handled in the default case, and\n                                 * there are several instances of it online, so I wanted to\n                                 * preserve the original error message so that people find existing\n                                 * information in searches, but also include the more recognizable\n                                 * \"Internal server error\" message. */ details = `Received RST_STREAM with code ${stream.rstCode} (Internal server error)`;\n                            } else {\n                                if (this.internalError.code === \"ECONNRESET\" || this.internalError.code === \"ETIMEDOUT\") {\n                                    code = constants_1.Status.UNAVAILABLE;\n                                    details = this.internalError.message;\n                                } else {\n                                    /* The \"Received RST_STREAM with code ...\" error is preserved\n                                     * here for continuity with errors reported online, but the\n                                     * error message at the end will probably be more relevant in\n                                     * most cases. */ details = `Received RST_STREAM with code ${stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n                                }\n                            }\n                            break;\n                        default:\n                            code = constants_1.Status.INTERNAL;\n                            details = `Received RST_STREAM with code ${stream.rstCode}`;\n                    }\n                    // This is a no-op if trailers were received at all.\n                    // This is OK, because status codes emitted here correspond to more\n                    // catastrophic issues that prevent us from receiving trailers in the\n                    // first place.\n                    this.endCall({\n                        code,\n                        details,\n                        metadata: new metadata_1.Metadata()\n                    });\n                });\n            });\n            stream.on(\"error\", (err)=>{\n                /* We need an error handler here to stop \"Uncaught Error\" exceptions\n                 * from bubbling up. However, errors here should all correspond to\n                 * \"close\" events, where we will handle the error more granularly */ /* Specifically looking for stream errors that were *not* constructed\n                 * from a RST_STREAM response here:\n                 * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n                 */ if (err.code !== \"ERR_HTTP2_STREAM_ERROR\") {\n                    this.trace(\"Node error event: message=\" + err.message + \" code=\" + err.code + \" errno=\" + getSystemErrorName(err.errno) + \" syscall=\" + err.syscall);\n                    this.internalError = err;\n                }\n                this.streamEndWatchers.forEach((watcher)=>watcher(false));\n            });\n            if (this.pendingWrite) {\n                if (!this.pendingWriteCallback) {\n                    throw new Error(\"Invalid state in write handling code\");\n                }\n                this.trace(\"sending data chunk of length \" + this.pendingWrite.length + \" (deferred)\");\n                try {\n                    this.writeMessageToStream(this.pendingWrite, this.pendingWriteCallback);\n                } catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: `Write failed with error ${error.message}`,\n                        metadata: new metadata_1.Metadata()\n                    });\n                }\n            }\n            this.maybeCloseWrites();\n        }\n    }\n    start(metadata, listener) {\n        this.trace(\"Sending metadata\");\n        this.listener = listener;\n        this.channel._startCallStream(this, metadata);\n        this.maybeOutputStatus();\n    }\n    destroyHttp2Stream() {\n        var _a;\n        // The http2 stream could already have been destroyed if cancelWithStatus\n        // is called in response to an internal http2 error.\n        if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n            /* If the call has ended with an OK status, communicate that when closing\n             * the stream, partly to avoid a situation in which we detect an error\n             * RST_STREAM as a result after we have the status */ let code;\n            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n                code = http2.constants.NGHTTP2_NO_ERROR;\n            } else {\n                code = http2.constants.NGHTTP2_CANCEL;\n            }\n            this.trace(\"close http2 stream with code \" + code);\n            this.http2Stream.close(code);\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.trace(\"cancelWithStatus code: \" + status + ' details: \"' + details + '\"');\n        this.endCall({\n            code: status,\n            details,\n            metadata: new metadata_1.Metadata()\n        });\n    }\n    getDeadline() {\n        const deadlineList = [\n            this.options.deadline\n        ];\n        if (this.options.parentCall && this.options.flags & constants_1.Propagate.DEADLINE) {\n            deadlineList.push(this.options.parentCall.getDeadline());\n        }\n        if (this.configDeadline) {\n            deadlineList.push(this.configDeadline);\n        }\n        return getMinDeadline(deadlineList);\n    }\n    getCredentials() {\n        return this.credentials;\n    }\n    setCredentials(credentials) {\n        this.credentials = this.channelCallCredentials.compose(credentials);\n    }\n    getStatus() {\n        return this.finalStatus;\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n    }\n    getMethod() {\n        return this.methodName;\n    }\n    getHost() {\n        return this.options.host;\n    }\n    setConfigDeadline(configDeadline) {\n        this.configDeadline = configDeadline;\n    }\n    addStatusWatcher(watcher) {\n        this.statusWatchers.push(watcher);\n    }\n    addStreamEndWatcher(watcher) {\n        this.streamEndWatchers.push(watcher);\n    }\n    addFilters(extraFilters) {\n        this.filterStack.push(extraFilters);\n    }\n    getCallNumber() {\n        return this.callNumber;\n    }\n    startRead() {\n        /* If the stream has ended with an error, we should not emit any more\n         * messages and we should communicate that the stream has ended */ if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n            this.readsClosed = true;\n            this.maybeOutputStatus();\n            return;\n        }\n        this.canPush = true;\n        if (this.http2Stream === null) {\n            this.pendingRead = true;\n        } else {\n            if (this.unpushedReadMessages.length > 0) {\n                const nextMessage = this.unpushedReadMessages.shift();\n                this.push(nextMessage);\n                return;\n            }\n            /* Only resume reading from the http2Stream if we don't have any pending\n             * messages to emit */ this.http2Stream.resume();\n        }\n    }\n    maybeCloseWrites() {\n        if (this.writesClosed && !this.isWriteFilterPending && this.http2Stream !== null) {\n            this.trace(\"calling end() on HTTP/2 stream\");\n            this.http2Stream.end();\n        }\n    }\n    sendMessageWithContext(context, message) {\n        this.trace(\"write() called with message of length \" + message.length);\n        const writeObj = {\n            message,\n            flags: context.flags\n        };\n        const cb = (error)=>{\n            var _a, _b;\n            let code = constants_1.Status.UNAVAILABLE;\n            if (((_a = error) === null || _a === void 0 ? void 0 : _a.code) === \"ERR_STREAM_WRITE_AFTER_END\") {\n                code = constants_1.Status.INTERNAL;\n            }\n            if (error) {\n                this.cancelWithStatus(code, `Write error: ${error.message}`);\n            }\n            (_b = context.callback) === null || _b === void 0 ? void 0 : _b.call(context);\n        };\n        this.isWriteFilterPending = true;\n        this.filterStack.sendMessage(Promise.resolve(writeObj)).then((message)=>{\n            this.isWriteFilterPending = false;\n            if (this.http2Stream === null) {\n                this.trace(\"deferring writing data chunk of length \" + message.message.length);\n                this.pendingWrite = message.message;\n                this.pendingWriteCallback = cb;\n            } else {\n                this.trace(\"sending data chunk of length \" + message.message.length);\n                try {\n                    this.writeMessageToStream(message.message, cb);\n                } catch (error) {\n                    this.endCall({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: `Write failed with error ${error.message}`,\n                        metadata: new metadata_1.Metadata()\n                    });\n                }\n                this.maybeCloseWrites();\n            }\n        }, this.handleFilterError.bind(this));\n    }\n    halfClose() {\n        this.trace(\"end() called\");\n        this.writesClosed = true;\n        this.maybeCloseWrites();\n    }\n}\nexports.Http2CallStream = Http2CallStream; //# sourceMappingURL=call-stream.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC1zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSxnQ0FBZ0MsR0FBR0EsOEJBQThCLEdBQUcsS0FBSztBQUNuRyxNQUFNSyxRQUFRQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNQyxLQUFLRCxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1HLGFBQWFILG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1JLG1CQUFtQkosbUJBQU9BLENBQUMsd0ZBQWtCO0FBQ25ELE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1NLGNBQWNOLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1PLGNBQWM7QUFDcEIsTUFBTSxFQUFFQyxtQkFBbUIsRUFBRUMseUJBQXlCLEVBQUVDLGNBQWMsRUFBRyxHQUFHWCxNQUFNWSxTQUFTO0FBQzNGOzs7OztDQUtDLEdBQ0QsU0FBU0MsbUJBQW1CQyxLQUFLO0lBQzdCLEtBQUssTUFBTSxDQUFDQyxNQUFNQyxJQUFJLElBQUl2QixPQUFPd0IsT0FBTyxDQUFDZixHQUFHVSxTQUFTLENBQUNFLEtBQUssRUFBRztRQUMxRCxJQUFJRSxRQUFRRixPQUFPO1lBQ2YsT0FBT0M7UUFDWDtJQUNKO0lBQ0EsT0FBTywwQkFBMEJEO0FBQ3JDO0FBQ0EsU0FBU0ksZUFBZUMsWUFBWTtJQUNoQyxJQUFJQyxXQUFXQztJQUNmLEtBQUssTUFBTUMsWUFBWUgsYUFBYztRQUNqQyxNQUFNSSxnQkFBZ0JELG9CQUFvQkUsT0FBT0YsU0FBU0csT0FBTyxLQUFLSDtRQUN0RSxJQUFJQyxnQkFBZ0JILFVBQVU7WUFDMUJBLFdBQVdH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b0JBQW9CLEdBQUc7WUFDNUIsSUFBSSxJQUFJLENBQUNGLFdBQVcsS0FBSyxNQUFNO2dCQUMzQixJQUFJLENBQUM0QyxLQUFLLENBQUMsNENBQTRDdEQsUUFBUUEsT0FBTyxDQUFDYixNQUFNO2dCQUM3RSxJQUFJLENBQUMwQixZQUFZLEdBQUdiLFFBQVFBLE9BQU87Z0JBQ25DLElBQUksQ0FBQ2Msb0JBQW9CLEdBQUc2STtZQUNoQyxPQUNLO2dCQUNELElBQUksQ0FBQ3JHLEtBQUssQ0FBQyxrQ0FBa0N0RCxRQUFRQSxPQUFPLENBQUNiLE1BQU07Z0JBQ25FLElBQUk7b0JBQ0EsSUFBSSxDQUFDZ0gsb0JBQW9CLENBQUNuRyxRQUFRQSxPQUFPLEVBQUUySjtnQkFDL0MsRUFDQSxPQUFPcEYsT0FBTztvQkFDVixJQUFJLENBQUNqQyxPQUFPLENBQUM7d0JBQ1RDLE1BQU05RSxZQUFZZ0UsTUFBTSxDQUFDZSxXQUFXO3dCQUNwQ0MsU0FBUyxDQUFDLHdCQUF3QixFQUFFOEIsTUFBTXZFLE9BQU8sQ0FBQyxDQUFDO3dCQUNuREQsVUFBVSxJQUFJckMsV0FBV2dGLFFBQVE7b0JBQ3JDO2dCQUNKO2dCQUNBLElBQUksQ0FBQ3VGLGdCQUFnQjtZQUN6QjtRQUNKLEdBQUcsSUFBSSxDQUFDM0QsaUJBQWlCLENBQUNhLElBQUksQ0FBQyxJQUFJO0lBQ3ZDO0lBQ0EyRSxZQUFZO1FBQ1IsSUFBSSxDQUFDeEcsS0FBSyxDQUFDO1FBQ1gsSUFBSSxDQUFDdkMsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ2tILGdCQUFnQjtJQUN6QjtBQUNKO0FBQ0FoTCx1QkFBdUIsR0FBR0UsaUJBQzFCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jYWxsLXN0cmVhbS5qcz85YjBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHAyQ2FsbFN0cmVhbSA9IGV4cG9ydHMuSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsID0gZXhwb3J0cy5pc0ludGVyY2VwdGluZ0xpc3RlbmVyID0gdm9pZCAwO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3Qgc3RyZWFtX2RlY29kZXJfMSA9IHJlcXVpcmUoXCIuL3N0cmVhbS1kZWNvZGVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ2NhbGxfc3RyZWFtJztcbmNvbnN0IHsgSFRUUDJfSEVBREVSX1NUQVRVUywgSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSwgTkdIVFRQMl9DQU5DRUwsIH0gPSBodHRwMi5jb25zdGFudHM7XG4vKipcbiAqIFNob3VsZCBkbyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIHRoaW5nIGFzIHV0aWwuZ2V0U3lzdGVtRXJyb3JOYW1lIGJ1dCB0aGVcbiAqIFR5cGVTY3JpcHQgdHlwZXMgZG9uJ3QgaGF2ZSB0aGF0IGZ1bmN0aW9uIGZvciBzb21lIHJlYXNvbiBzbyBJIGp1c3QgbWFkZSBteVxuICogb3duLlxuICogQHBhcmFtIGVycm5vXG4gKi9cbmZ1bmN0aW9uIGdldFN5c3RlbUVycm9yTmFtZShlcnJubykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIG51bV0gb2YgT2JqZWN0LmVudHJpZXMob3MuY29uc3RhbnRzLmVycm5vKSkge1xuICAgICAgICBpZiAobnVtID09PSBlcnJubykge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdVbmtub3duIHN5c3RlbSBlcnJvciAnICsgZXJybm87XG59XG5mdW5jdGlvbiBnZXRNaW5EZWFkbGluZShkZWFkbGluZUxpc3QpIHtcbiAgICBsZXQgbWluVmFsdWUgPSBJbmZpbml0eTtcbiAgICBmb3IgKGNvbnN0IGRlYWRsaW5lIG9mIGRlYWRsaW5lTGlzdCkge1xuICAgICAgICBjb25zdCBkZWFkbGluZU1zZWNzID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUuZ2V0VGltZSgpIDogZGVhZGxpbmU7XG4gICAgICAgIGlmIChkZWFkbGluZU1zZWNzIDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgIG1pblZhbHVlID0gZGVhZGxpbmVNc2VjcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluVmFsdWU7XG59XG5mdW5jdGlvbiBpc0ludGVyY2VwdGluZ0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIChsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhLmxlbmd0aCA9PT0gMSk7XG59XG5leHBvcnRzLmlzSW50ZXJjZXB0aW5nTGlzdGVuZXIgPSBpc0ludGVyY2VwdGluZ0xpc3RlbmVyO1xuY2xhc3MgSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihsaXN0ZW5lciwgbmV4dExpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIgPSBuZXh0TGlzdGVuZXI7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBlbmRpbmdTdGF0dXMgPSBudWxsO1xuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ01lc3NhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc1BlbmRpbmdNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRMaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKHRoaXMucGVuZGluZ01lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmhhc1BlbmRpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc1BlbmRpbmdTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdTdGF0dXMpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyh0aGlzLnBlbmRpbmdTdGF0dXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSwgKG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ01lc3NhZ2UoKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdTdGF0dXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIC8qIElmIHRoaXMgbGlzdGVuZXIgcHJvY2Vzc2VzIG1lc3NhZ2VzIGFzeW5jaHJvbm91c2x5LCB0aGUgbGFzdCBtZXNzYWdlIG1heVxuICAgICAgICAgKiBiZSByZW9yZGVyZWQgd2l0aCByZXNwZWN0IHRvIHRoZSBzdGF0dXMgKi9cbiAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSA9IHRydWU7XG4gICAgICAgIHRoaXMubGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtZXNzYWdlLCAobXNnKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlID0gbXNnO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzUGVuZGluZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9uUmVjZWl2ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5vblJlY2VpdmVTdGF0dXMoc3RhdHVzLCAocHJvY2Vzc2VkU3RhdHVzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgfHwgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1N0YXR1cyA9IHByb2Nlc3NlZFN0YXR1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cyhwcm9jZXNzZWRTdGF0dXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCA9IEludGVyY2VwdGluZ0xpc3RlbmVySW1wbDtcbmNsYXNzIEh0dHAyQ2FsbFN0cmVhbSB7XG4gICAgY29uc3RydWN0b3IobWV0aG9kTmFtZSwgY2hhbm5lbCwgb3B0aW9ucywgZmlsdGVyU3RhY2tGYWN0b3J5LCBjaGFubmVsQ2FsbENyZWRlbnRpYWxzLCBjYWxsTnVtYmVyKSB7XG4gICAgICAgIHRoaXMubWV0aG9kTmFtZSA9IG1ldGhvZE5hbWU7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2hhbm5lbENhbGxDcmVkZW50aWFscyA9IGNoYW5uZWxDYWxsQ3JlZGVudGlhbHM7XG4gICAgICAgIHRoaXMuY2FsbE51bWJlciA9IGNhbGxOdW1iZXI7XG4gICAgICAgIHRoaXMuaHR0cDJTdHJlYW0gPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZWFkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNXcml0ZUZpbHRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGUgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdXcml0ZUNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy53cml0ZXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IHN0cmVhbV9kZWNvZGVyXzEuU3RyZWFtRGVjb2RlcigpO1xuICAgICAgICB0aGlzLmlzUmVhZEZpbHRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhbiAnZW5kJyBldmVudCBoYXMgY29tZSBmcm9tIHRoZSBodHRwMiBzdHJlYW0sIHNvIHRoZXJlXG4gICAgICAgICAqIHdpbGwgYmUgbm8gbW9yZSBkYXRhIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVhZHNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0dXNPdXRwdXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLnVuZmlsdGVyZWRSZWFkTWVzc2FnZXMgPSBbXTtcbiAgICAgICAgLy8gU3RhdHVzIGNvZGUgbWFwcGVkIGZyb20gOnN0YXR1cy4gVG8gYmUgdXNlZCBpZiBncnBjLXN0YXR1cyBpcyBub3QgcmVjZWl2ZWRcbiAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV047XG4gICAgICAgIC8vIFRoaXMgaXMgcG9wdWxhdGVkIChub24tbnVsbCkgaWYgYW5kIG9ubHkgaWYgdGhlIGNhbGwgaGFzIGVuZGVkXG4gICAgICAgIHRoaXMuZmluYWxTdGF0dXMgPSBudWxsO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWwgPSBudWxsO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb25maWdEZWFkbGluZSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLnN0YXR1c1dhdGNoZXJzID0gW107XG4gICAgICAgIHRoaXMuc3RyZWFtRW5kV2F0Y2hlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jYWxsU3RhdHNUcmFja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjayA9IGZpbHRlclN0YWNrRmFjdG9yeS5jcmVhdGVGaWx0ZXIodGhpcyk7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSBjaGFubmVsQ2FsbENyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6ICdDb25uZWN0aW9uIGRyb3BwZWQnLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFyZW50Q2FsbCAmJlxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZsYWdzICYgY29uc3RhbnRzXzEuUHJvcGFnYXRlLkNBTkNFTExBVElPTikge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBhcmVudENhbGwub24oJ2NhbmNlbGxlZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBieSBwYXJlbnQgY2FsbCcpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3V0cHV0U3RhdHVzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8qIFByZWNvbmRpdGlvbjogdGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAqL1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lciAmJiAhdGhpcy5zdGF0dXNPdXRwdXQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzT3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkU3RhdHVzID0gdGhpcy5maWx0ZXJTdGFjay5yZWNlaXZlVHJhaWxlcnModGhpcy5maW5hbFN0YXR1cyk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdlbmRlZCB3aXRoIHN0YXR1czogY29kZT0nICtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFN0YXR1cy5jb2RlICtcbiAgICAgICAgICAgICAgICAnIGRldGFpbHM9XCInICtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZFN0YXR1cy5kZXRhaWxzICtcbiAgICAgICAgICAgICAgICAnXCInKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzV2F0Y2hlcnMuZm9yRWFjaCh3YXRjaGVyID0+IHdhdGNoZXIoZmlsdGVyZWRTdGF0dXMpKTtcbiAgICAgICAgICAgIC8qIFdlIGRlbGF5IHRoZSBhY3R1YWwgYWN0aW9uIG9mIGJ1YmJsaW5nIHVwIHRoZSBzdGF0dXMgdG8gaW5zdWxhdGUgdGhlXG4gICAgICAgICAgICAgKiBjbGVhbnVwIGNvZGUgaW4gdGhpcyBjbGFzcyBmcm9tIGFueSBlcnJvcnMgdGhhdCBtYXkgYmUgdGhyb3duIGluIHRoZVxuICAgICAgICAgICAgICogdXBwZXIgbGF5ZXJzIGFzIGEgcmVzdWx0IG9mIGJ1YmJsaW5nIHVwIHRoZSBzdGF0dXMuIEluIHBhcnRpY3VsYXIsXG4gICAgICAgICAgICAgKiBpZiB0aGUgc3RhdHVzIGlzIG5vdCBPSywgdGhlIFwiZXJyb3JcIiBldmVudCBtYXkgYmUgZW1pdHRlZFxuICAgICAgICAgICAgICogc3luY2hyb25vdXNseSBhdCB0aGUgdG9wIGxldmVsLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIHRocm93biBlcnJvciBpZlxuICAgICAgICAgICAgICogdGhlIHVzZXIgZG9lcyBub3QgaGFuZGxlIHRoYXQgZXZlbnQuICovXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZVN0YXR1cyhmaWx0ZXJlZFN0YXR1cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qIExlYXZlIHRoZSBodHRwMiBzdHJlYW0gaW4gZmxvd2luZyBzdGF0ZSB0byBkcmFpbiBpbmNvbWluZyBtZXNzYWdlcywgdG9cbiAgICAgICAgICAgICAqIGVuc3VyZSB0aGF0IHRoZSBzdHJlYW0gY2xvc3VyZSBjb21wbGV0ZXMuIFRoZSBjYWxsIHN0cmVhbSBhbHJlYWR5IGRvZXNcbiAgICAgICAgICAgICAqIG5vdCBwdXNoIG1vcmUgbWVzc2FnZXMgYWZ0ZXIgdGhlIHN0YXR1cyBpcyBvdXRwdXQsIHNvIHRoZSBtZXNzYWdlcyBnb1xuICAgICAgICAgICAgICogbm93aGVyZSBlaXRoZXIgd2F5LiAqL1xuICAgICAgICAgICAgKF9hID0gdGhpcy5odHRwMlN0cmVhbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VtZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ViY2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbC5jYWxsVW5yZWYoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWwucmVtb3ZlRGlzY29ubmVjdExpc3RlbmVyKHRoaXMuZGlzY29ubmVjdExpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJ1snICsgdGhpcy5jYWxsTnVtYmVyICsgJ10gJyArIHRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiBmaXJzdCBjYWxsLCBlbWl0cyBhICdzdGF0dXMnIGV2ZW50IHdpdGggdGhlIGdpdmVuIFN0YXR1c09iamVjdC5cbiAgICAgKiBTdWJzZXF1ZW50IGNhbGxzIGFyZSBuby1vcHMuXG4gICAgICogQHBhcmFtIHN0YXR1cyBUaGUgc3RhdHVzIG9mIHRoZSBjYWxsLlxuICAgICAqL1xuICAgIGVuZENhbGwoc3RhdHVzKSB7XG4gICAgICAgIC8qIElmIHRoZSBzdGF0dXMgaXMgT0sgYW5kIGEgbmV3IHN0YXR1cyBjb21lcyBpbiAoZS5nLiBmcm9tIGFcbiAgICAgICAgICogZGVzZXJpYWxpemF0aW9uIGZhaWx1cmUpLCB0aGF0IG5ldyBzdGF0dXMgdGFrZXMgcHJpb3JpdHkgKi9cbiAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgPT09IG51bGwgfHwgdGhpcy5maW5hbFN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMuZmluYWxTdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXN0cm95SHR0cDJTdHJlYW0oKTtcbiAgICB9XG4gICAgbWF5YmVPdXRwdXRTdGF0dXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvKiBUaGUgY29tYmluYXRpb24gY2hlY2sgb2YgcmVhZHNDbG9zZWQgYW5kIHRoYXQgdGhlIHR3byBtZXNzYWdlIGJ1ZmZlclxuICAgICAgICAgICAgICogYXJyYXlzIGFyZSBlbXB0eSBjaGVja3MgdGhhdCB0aGVyZSBhbGwgaW5jb21pbmcgZGF0YSBoYXMgYmVlbiBmdWxseVxuICAgICAgICAgICAgICogcHJvY2Vzc2VkICovXG4gICAgICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cy5jb2RlICE9PSBjb25zdGFudHNfMS5TdGF0dXMuT0sgfHxcbiAgICAgICAgICAgICAgICAodGhpcy5yZWFkc0Nsb3NlZCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVucHVzaGVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuZmlsdGVyZWRSZWFkTWVzc2FnZXMubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzUmVhZEZpbHRlclBlbmRpbmcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRTdGF0dXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXNoKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgncHVzaGluZyB0byByZWFkZXIgbWVzc2FnZSBvZiBsZW5ndGggJyArXG4gICAgICAgICAgICAobWVzc2FnZSBpbnN0YW5jZW9mIEJ1ZmZlciA/IG1lc3NhZ2UubGVuZ3RoIDogbnVsbCkpO1xuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvKiBJZiB3ZSBoYXZlIGFscmVhZHkgb3V0cHV0IHRoZSBzdGF0dXMgYW55IGxhdGVyIG1lc3NhZ2VzIHNob3VsZCBiZVxuICAgICAgICAgICAgICogaWdub3JlZCwgYW5kIGNhbiBjYXVzZSBvdXQtb2Ytb3JkZXIgb3BlcmF0aW9uIGVycm9ycyBoaWdoZXIgdXAgaW4gdGhlXG4gICAgICAgICAgICAgKiBzdGFjay4gQ2hlY2tpbmcgYXMgbGF0ZSBhcyBwb3NzaWJsZSBoZXJlIHRvIGF2b2lkIGFueSByYWNlIGNvbmRpdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c091dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYSA9IHRoaXMubGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlRmlsdGVyRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIGhhbmRsZUZpbHRlcmVkUmVhZChtZXNzYWdlKSB7XG4gICAgICAgIC8qIElmIHdlIHRoZSBjYWxsIGhhcyBhbHJlYWR5IGVuZGVkIHdpdGggYW4gZXJyb3IsIHdlIGRvbid0IHdhbnQgdG8gZG9cbiAgICAgICAgICogYW55dGhpbmcgd2l0aCB0aGlzIG1lc3NhZ2UuIERyb3BwaW5nIGl0IG9uIHRoZSBmbG9vciBpcyBjb3JyZWN0XG4gICAgICAgICAqIGJlaGF2aW9yICovXG4gICAgICAgIGlmICh0aGlzLmZpbmFsU3RhdHVzICE9PSBudWxsICYmIHRoaXMuZmluYWxTdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNhblB1c2gpIHtcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0ucGF1c2UoKTtcbiAgICAgICAgICAgIHRoaXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3VucHVzaGVkUmVhZE1lc3NhZ2VzLnB1c2ggbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgICAgIHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy51bmZpbHRlcmVkUmVhZE1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8qIG5leHRNZXNzYWdlIGlzIGd1YXJhbnRlZWQgbm90IHRvIGJlIHVuZGVmaW5lZCBiZWNhdXNlXG4gICAgICAgICAgICAgICB1bmZpbHRlcmVkUmVhZE1lc3NhZ2VzIGlzIG5vbi1lbXB0eSAqL1xuICAgICAgICAgICAgY29uc3QgbmV4dE1lc3NhZ2UgPSB0aGlzLnVuZmlsdGVyZWRSZWFkTWVzc2FnZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyUmVjZWl2ZWRNZXNzYWdlKG5leHRNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaWx0ZXJSZWNlaXZlZE1lc3NhZ2UoZnJhbWVkTWVzc2FnZSkge1xuICAgICAgICAvKiBJZiB3ZSB0aGUgY2FsbCBoYXMgYWxyZWFkeSBlbmRlZCB3aXRoIGFuIGVycm9yLCB3ZSBkb24ndCB3YW50IHRvIGRvXG4gICAgICAgICAqIGFueXRoaW5nIHdpdGggdGhpcyBtZXNzYWdlLiBEcm9wcGluZyBpdCBvbiB0aGUgZmxvb3IgaXMgY29ycmVjdFxuICAgICAgICAgKiBiZWhhdmlvciAqL1xuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAmJiB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ2ZpbHRlclJlY2VpdmVkTWVzc2FnZSBvZiBsZW5ndGggJyArIGZyYW1lZE1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5pc1JlYWRGaWx0ZXJQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFja1xuICAgICAgICAgICAgLnJlY2VpdmVNZXNzYWdlKFByb21pc2UucmVzb2x2ZShmcmFtZWRNZXNzYWdlKSlcbiAgICAgICAgICAgIC50aGVuKHRoaXMuaGFuZGxlRmlsdGVyZWRSZWFkLmJpbmQodGhpcyksIHRoaXMuaGFuZGxlRmlsdGVyRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIHRyeVB1c2gobWVzc2FnZUJ5dGVzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmVhZEZpbHRlclBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ3VuZmlsdGVyZWRSZWFkTWVzc2FnZXMucHVzaCBtZXNzYWdlIG9mIGxlbmd0aCAnICtcbiAgICAgICAgICAgICAgICAobWVzc2FnZUJ5dGVzICYmIG1lc3NhZ2VCeXRlcy5sZW5ndGgpKTtcbiAgICAgICAgICAgIHRoaXMudW5maWx0ZXJlZFJlYWRNZXNzYWdlcy5wdXNoKG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlclJlY2VpdmVkTWVzc2FnZShtZXNzYWdlQnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVRyYWlsZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5zdHJlYW1FbmRXYXRjaGVycy5mb3JFYWNoKHdhdGNoZXIgPT4gd2F0Y2hlcih0cnVlKSk7XG4gICAgICAgIGxldCBoZWFkZXJzU3RyaW5nID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgaGVhZGVyIG9mIE9iamVjdC5rZXlzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICBoZWFkZXJzU3RyaW5nICs9ICdcXHRcXHQnICsgaGVhZGVyICsgJzogJyArIGhlYWRlcnNbaGVhZGVyXSArICdcXG4nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2UoJ1JlY2VpdmVkIHNlcnZlciB0cmFpbGVyczpcXG4nICsgaGVhZGVyc1N0cmluZyk7XG4gICAgICAgIGxldCBtZXRhZGF0YTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbWV0YWRhdGFfMS5NZXRhZGF0YS5mcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YWRhdGFNYXAgPSBtZXRhZGF0YS5nZXRNYXAoKTtcbiAgICAgICAgbGV0IGNvZGUgPSB0aGlzLm1hcHBlZFN0YXR1c0NvZGU7XG4gICAgICAgIGlmIChjb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTiAmJlxuICAgICAgICAgICAgdHlwZW9mIG1ldGFkYXRhTWFwWydncnBjLXN0YXR1cyddID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgcmVjZWl2ZWRTdGF0dXMgPSBOdW1iZXIobWV0YWRhdGFNYXBbJ2dycGMtc3RhdHVzJ10pO1xuICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzIGluIGNvbnN0YW50c18xLlN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNvZGUgPSByZWNlaXZlZFN0YXR1cztcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdyZWNlaXZlZCBzdGF0dXMgY29kZSAnICsgcmVjZWl2ZWRTdGF0dXMgKyAnIGZyb20gc2VydmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtc3RhdHVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRldGFpbHMgPSAnJztcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRhZGF0YU1hcFsnZ3JwYy1tZXNzYWdlJ10gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRldGFpbHMgPSBkZWNvZGVVUkkobWV0YWRhdGFNYXBbJ2dycGMtbWVzc2FnZSddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZGV0YWlscyA9IG1ldGFkYXRhTWFwWydncnBjLW1lc3NhZ2UnXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1tZXNzYWdlJyk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdyZWNlaXZlZCBzdGF0dXMgZGV0YWlscyBzdHJpbmcgXCInICsgZGV0YWlscyArICdcIiBmcm9tIHNlcnZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IHsgY29kZSwgZGV0YWlscywgbWV0YWRhdGEgfTtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG5vLW9wIGlmIHRoZSBjYWxsIHdhcyBhbHJlYWR5IGVuZGVkIHdoZW4gaGFuZGxpbmcgaGVhZGVycy5cbiAgICAgICAgdGhpcy5lbmRDYWxsKHN0YXR1cyk7XG4gICAgfVxuICAgIHdyaXRlTWVzc2FnZVRvU3RyZWFtKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5jYWxsU3RhdHNUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWRkTWVzc2FnZVNlbnQoKTtcbiAgICAgICAgdGhpcy5odHRwMlN0cmVhbS53cml0ZShtZXNzYWdlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGF0dGFjaEh0dHAyU3RyZWFtKHN0cmVhbSwgc3ViY2hhbm5lbCwgZXh0cmFGaWx0ZXJzLCBjYWxsU3RhdHNUcmFja2VyKSB7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2sucHVzaChleHRyYUZpbHRlcnMpO1xuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyZWFtLmNsb3NlKE5HSFRUUDJfQ0FOQ0VMKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2F0dGFjaEh0dHAyU3RyZWFtIGZyb20gc3ViY2hhbm5lbCAnICsgc3ViY2hhbm5lbC5nZXRBZGRyZXNzKCkpO1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbCA9IHN1YmNoYW5uZWw7XG4gICAgICAgICAgICB0aGlzLmNhbGxTdGF0c1RyYWNrZXIgPSBjYWxsU3RhdHNUcmFja2VyO1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5hZGREaXNjb25uZWN0TGlzdGVuZXIodGhpcy5kaXNjb25uZWN0TGlzdGVuZXIpO1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5jYWxsUmVmKCk7XG4gICAgICAgICAgICBzdHJlYW0ub24oJ3Jlc3BvbnNlJywgKGhlYWRlcnMsIGZsYWdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCBoZWFkZXJzU3RyaW5nID0gJyc7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBoZWFkZXIgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1N0cmluZyArPSAnXFx0XFx0JyArIGhlYWRlciArICc6ICcgKyBoZWFkZXJzW2hlYWRlcl0gKyAnXFxuJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgc2VydmVyIGhlYWRlcnM6XFxuJyArIGhlYWRlcnNTdHJpbmcpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoaGVhZGVyc1snOnN0YXR1cyddKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8obXVyZ2F0cm9pZDk5KTogaGFuZGxlIDEwMCBhbmQgMTAxXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVVUSEVOVElDQVRFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5QRVJNSVNTSU9OX0RFTklFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQwNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWFwcGVkU3RhdHVzQ29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTklNUExFTUVOVEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDI5OlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDUwMjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MDM6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBwZWRTdGF0dXNDb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcHBlZFN0YXR1c0NvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZsYWdzICYgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfRkxBR19FTkRfU1RSRUFNKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhaWxlcnMoaGVhZGVycyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YSA9IG1ldGFkYXRhXzEuTWV0YWRhdGEuZnJvbUh0dHAySGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaW5hbE1ldGFkYXRhID0gdGhpcy5maWx0ZXJTdGFjay5yZWNlaXZlTWV0YWRhdGEobWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5saXN0ZW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9uUmVjZWl2ZU1ldGFkYXRhKGZpbmFsTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5LTk9XTixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBlcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0cmVhbS5vbigndHJhaWxlcnMnLCAoaGVhZGVycykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhaWxlcnMoaGVhZGVycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0cmVhbS5vbignZGF0YScsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlIHN0YXR1cyBoYXMgYWxyZWFkeSBiZWVuIG91dHB1dCwgYWxsb3cgdGhlIGh0dHAyIHN0cmVhbSB0b1xuICAgICAgICAgICAgICAgICAqIGRyYWluIHdpdGhvdXQgcHJvY2Vzc2luZyB0aGUgZGF0YS4gKi9cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXNPdXRwdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdyZWNlaXZlIEhUVFAvMiBkYXRhIGZyYW1lIG9mIGxlbmd0aCAnICsgZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gdGhpcy5kZWNvZGVyLndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdwYXJzZWQgbWVzc2FnZSBvZiBsZW5ndGggJyArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsU3RhdHNUcmFja2VyLmFkZE1lc3NhZ2VSZWNlaXZlZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeVB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdHJlYW0ub24oJ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlYWRzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0cmVhbS5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogVXNlIHByb2Nlc3MubmV4dCB0aWNrIHRvIGVuc3VyZSB0aGF0IHRoaXMgY29kZSBoYXBwZW5zIGFmdGVyIGFueVxuICAgICAgICAgICAgICAgICAqIFwiZXJyb3JcIiBldmVudCB0aGF0IG1heSBiZSBlbWl0dGVkIGF0IGFib3V0IHRoZSBzYW1lIHRpbWUsIHNvIHRoYXRcbiAgICAgICAgICAgICAgICAgKiB3ZSBjYW4gYnViYmxlIHVwIHRoZSBlcnJvciBtZXNzYWdlIGZyb20gdGhhdCBldmVudC4gKi9cbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdIVFRQLzIgc3RyZWFtIGNsb3NlZCB3aXRoIGNvZGUgJyArIHN0cmVhbS5yc3RDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgd2UgaGF2ZSBhIGZpbmFsIHN0YXR1cyB3aXRoIGFuIE9LIHN0YXR1cyBjb2RlLCB0aGF0IG1lYW5zIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICogd2UgaGF2ZSByZWNlaXZlZCBhbGwgb2YgdGhlIG1lc3NhZ2VzIGFuZCB3ZSBoYXZlIHByb2Nlc3NlZCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICogdHJhaWxlcnMgYW5kIHRoZSBjYWxsIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIHNvIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgICAgICAgICAgICAqIGhvdyB0aGUgc3RyZWFtIGVuZHMgYWZ0ZXIgdGhhdCAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoKChfYSA9IHRoaXMuZmluYWxTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkZXRhaWxzID0gJyc7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RyZWFtLnJzdENvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfTk9fRVJST1I6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogSWYgd2UgZ2V0IGEgTk9fRVJST1IgY29kZSBhbmQgd2UgYWxyZWFkeSBoYXZlIGEgc3RhdHVzLCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBzdHJlYW0gY29tcGxldGVkIHByb3Blcmx5IGFuZCB3ZSBqdXN0IGhhdmVuJ3QgZnVsbHkgcHJvY2Vzc2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaXQgeWV0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluYWxTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSBgUmVjZWl2ZWQgUlNUX1NUUkVBTSB3aXRoIGNvZGUgJHtzdHJlYW0ucnN0Q29kZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9SRUZVU0VEX1NUUkVBTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnU3RyZWFtIHJlZnVzZWQgYnkgc2VydmVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfQ0FOQ0VMOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuQ0FOQ0VMTEVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnQ2FsbCBjYW5jZWxsZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9FTkhBTkNFX1lPVVJfQ0FMTTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gJ0JhbmR3aWR0aCBleGhhdXN0ZWQgb3IgbWVtb3J5IGxpbWl0IGV4Y2VlZGVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgaHR0cDIuY29uc3RhbnRzLk5HSFRUUDJfSU5BREVRVUFURV9TRUNVUklUWTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLlBFUk1JU1NJT05fREVOSUVEO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHMgPSAnUHJvdG9jb2wgbm90IHNlY3VyZSBlbm91Z2gnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9JTlRFUk5BTF9FUlJPUjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmludGVybmFsRXJyb3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhpcyBlcnJvciBjb2RlIHdhcyBwcmV2aW91c2x5IGhhbmRsZWQgaW4gdGhlIGRlZmF1bHQgY2FzZSwgYW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZXJlIGFyZSBzZXZlcmFsIGluc3RhbmNlcyBvZiBpdCBvbmxpbmUsIHNvIEkgd2FudGVkIHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHByZXNlcnZlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIHNvIHRoYXQgcGVvcGxlIGZpbmQgZXhpc3RpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaW5mb3JtYXRpb24gaW4gc2VhcmNoZXMsIGJ1dCBhbHNvIGluY2x1ZGUgdGhlIG1vcmUgcmVjb2duaXphYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFwiSW50ZXJuYWwgc2VydmVyIGVycm9yXCIgbWVzc2FnZS4gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke3N0cmVhbS5yc3RDb2RlfSAoSW50ZXJuYWwgc2VydmVyIGVycm9yKWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnRlcm5hbEVycm9yLmNvZGUgPT09ICdFQ09OTlJFU0VUJyB8fCB0aGlzLmludGVybmFsRXJyb3IuY29kZSA9PT0gJ0VUSU1FRE9VVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzID0gdGhpcy5pbnRlcm5hbEVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBUaGUgXCJSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAuLi5cIiBlcnJvciBpcyBwcmVzZXJ2ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGhlcmUgZm9yIGNvbnRpbnVpdHkgd2l0aCBlcnJvcnMgcmVwb3J0ZWQgb25saW5lLCBidXQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBlcnJvciBtZXNzYWdlIGF0IHRoZSBlbmQgd2lsbCBwcm9iYWJseSBiZSBtb3JlIHJlbGV2YW50IGluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBtb3N0IGNhc2VzLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke3N0cmVhbS5yc3RDb2RlfSB0cmlnZ2VyZWQgYnkgaW50ZXJuYWwgY2xpZW50IGVycm9yOiAke3RoaXMuaW50ZXJuYWxFcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlscyA9IGBSZWNlaXZlZCBSU1RfU1RSRUFNIHdpdGggY29kZSAke3N0cmVhbS5yc3RDb2RlfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIG5vLW9wIGlmIHRyYWlsZXJzIHdlcmUgcmVjZWl2ZWQgYXQgYWxsLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIE9LLCBiZWNhdXNlIHN0YXR1cyBjb2RlcyBlbWl0dGVkIGhlcmUgY29ycmVzcG9uZCB0byBtb3JlXG4gICAgICAgICAgICAgICAgICAgIC8vIGNhdGFzdHJvcGhpYyBpc3N1ZXMgdGhhdCBwcmV2ZW50IHVzIGZyb20gcmVjZWl2aW5nIHRyYWlsZXJzIGluIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBmaXJzdCBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbmRDYWxsKHsgY29kZSwgZGV0YWlscywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0cmVhbS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgLyogV2UgbmVlZCBhbiBlcnJvciBoYW5kbGVyIGhlcmUgdG8gc3RvcCBcIlVuY2F1Z2h0IEVycm9yXCIgZXhjZXB0aW9uc1xuICAgICAgICAgICAgICAgICAqIGZyb20gYnViYmxpbmcgdXAuIEhvd2V2ZXIsIGVycm9ycyBoZXJlIHNob3VsZCBhbGwgY29ycmVzcG9uZCB0b1xuICAgICAgICAgICAgICAgICAqIFwiY2xvc2VcIiBldmVudHMsIHdoZXJlIHdlIHdpbGwgaGFuZGxlIHRoZSBlcnJvciBtb3JlIGdyYW51bGFybHkgKi9cbiAgICAgICAgICAgICAgICAvKiBTcGVjaWZpY2FsbHkgbG9va2luZyBmb3Igc3RyZWFtIGVycm9ycyB0aGF0IHdlcmUgKm5vdCogY29uc3RydWN0ZWRcbiAgICAgICAgICAgICAgICAgKiBmcm9tIGEgUlNUX1NUUkVBTSByZXNwb25zZSBoZXJlOlxuICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iLzhiODYyMGQ1ODAzMTQwNTAxNzU5ODM0MDJkZmRkZjI2NzRlOGUyMmEvbGliL2ludGVybmFsL2h0dHAyL2NvcmUuanMjTDIyNjdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUgIT09ICdFUlJfSFRUUDJfU1RSRUFNX0VSUk9SJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdOb2RlIGVycm9yIGV2ZW50OiBtZXNzYWdlPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBjb2RlPScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLmNvZGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyBlcnJubz0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFN5c3RlbUVycm9yTmFtZShlcnIuZXJybm8pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgc3lzY2FsbD0nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5zeXNjYWxsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcm5hbEVycm9yID0gZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbUVuZFdhdGNoZXJzLmZvckVhY2god2F0Y2hlciA9PiB3YXRjaGVyKGZhbHNlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdXcml0ZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wZW5kaW5nV3JpdGVDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RhdGUgaW4gd3JpdGUgaGFuZGxpbmcgY29kZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdzZW5kaW5nIGRhdGEgY2h1bmsgb2YgbGVuZ3RoICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdXcml0ZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICAgICAnIChkZWZlcnJlZCknKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndyaXRlTWVzc2FnZVRvU3RyZWFtKHRoaXMucGVuZGluZ1dyaXRlLCB0aGlzLnBlbmRpbmdXcml0ZUNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgV3JpdGUgZmFpbGVkIHdpdGggZXJyb3IgJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1heWJlQ2xvc2VXcml0ZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnU2VuZGluZyBtZXRhZGF0YScpO1xuICAgICAgICB0aGlzLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgIHRoaXMuY2hhbm5lbC5fc3RhcnRDYWxsU3RyZWFtKHRoaXMsIG1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5tYXliZU91dHB1dFN0YXR1cygpO1xuICAgIH1cbiAgICBkZXN0cm95SHR0cDJTdHJlYW0oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gVGhlIGh0dHAyIHN0cmVhbSBjb3VsZCBhbHJlYWR5IGhhdmUgYmVlbiBkZXN0cm95ZWQgaWYgY2FuY2VsV2l0aFN0YXR1c1xuICAgICAgICAvLyBpcyBjYWxsZWQgaW4gcmVzcG9uc2UgdG8gYW4gaW50ZXJuYWwgaHR0cDIgZXJyb3IuXG4gICAgICAgIGlmICh0aGlzLmh0dHAyU3RyZWFtICE9PSBudWxsICYmICF0aGlzLmh0dHAyU3RyZWFtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgLyogSWYgdGhlIGNhbGwgaGFzIGVuZGVkIHdpdGggYW4gT0sgc3RhdHVzLCBjb21tdW5pY2F0ZSB0aGF0IHdoZW4gY2xvc2luZ1xuICAgICAgICAgICAgICogdGhlIHN0cmVhbSwgcGFydGx5IHRvIGF2b2lkIGEgc2l0dWF0aW9uIGluIHdoaWNoIHdlIGRldGVjdCBhbiBlcnJvclxuICAgICAgICAgICAgICogUlNUX1NUUkVBTSBhcyBhIHJlc3VsdCBhZnRlciB3ZSBoYXZlIHRoZSBzdGF0dXMgKi9cbiAgICAgICAgICAgIGxldCBjb2RlO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmZpbmFsU3RhdHVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29kZSkgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9OT19FUlJPUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBodHRwMi5jb25zdGFudHMuTkdIVFRQMl9DQU5DRUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjbG9zZSBodHRwMiBzdHJlYW0gd2l0aCBjb2RlICcgKyBjb2RlKTtcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0uY2xvc2UoY29kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnY2FuY2VsV2l0aFN0YXR1cyBjb2RlOiAnICsgc3RhdHVzICsgJyBkZXRhaWxzOiBcIicgKyBkZXRhaWxzICsgJ1wiJyk7XG4gICAgICAgIHRoaXMuZW5kQ2FsbCh7IGNvZGU6IHN0YXR1cywgZGV0YWlscywgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCkgfSk7XG4gICAgfVxuICAgIGdldERlYWRsaW5lKCkge1xuICAgICAgICBjb25zdCBkZWFkbGluZUxpc3QgPSBbdGhpcy5vcHRpb25zLmRlYWRsaW5lXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJlbnRDYWxsICYmIHRoaXMub3B0aW9ucy5mbGFncyAmIGNvbnN0YW50c18xLlByb3BhZ2F0ZS5ERUFETElORSkge1xuICAgICAgICAgICAgZGVhZGxpbmVMaXN0LnB1c2godGhpcy5vcHRpb25zLnBhcmVudENhbGwuZ2V0RGVhZGxpbmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnRGVhZGxpbmUpIHtcbiAgICAgICAgICAgIGRlYWRsaW5lTGlzdC5wdXNoKHRoaXMuY29uZmlnRGVhZGxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRNaW5EZWFkbGluZShkZWFkbGluZUxpc3QpO1xuICAgIH1cbiAgICBnZXRDcmVkZW50aWFscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlZGVudGlhbHM7XG4gICAgfVxuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMuY3JlZGVudGlhbHMgPSB0aGlzLmNoYW5uZWxDYWxsQ3JlZGVudGlhbHMuY29tcG9zZShjcmVkZW50aWFscyk7XG4gICAgfVxuICAgIGdldFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluYWxTdGF0dXM7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnN1YmNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRBZGRyZXNzKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY2hhbm5lbC5nZXRUYXJnZXQoKTtcbiAgICB9XG4gICAgZ2V0TWV0aG9kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRob2ROYW1lO1xuICAgIH1cbiAgICBnZXRIb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmhvc3Q7XG4gICAgfVxuICAgIHNldENvbmZpZ0RlYWRsaW5lKGNvbmZpZ0RlYWRsaW5lKSB7XG4gICAgICAgIHRoaXMuY29uZmlnRGVhZGxpbmUgPSBjb25maWdEZWFkbGluZTtcbiAgICB9XG4gICAgYWRkU3RhdHVzV2F0Y2hlcih3YXRjaGVyKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzV2F0Y2hlcnMucHVzaCh3YXRjaGVyKTtcbiAgICB9XG4gICAgYWRkU3RyZWFtRW5kV2F0Y2hlcih3YXRjaGVyKSB7XG4gICAgICAgIHRoaXMuc3RyZWFtRW5kV2F0Y2hlcnMucHVzaCh3YXRjaGVyKTtcbiAgICB9XG4gICAgYWRkRmlsdGVycyhleHRyYUZpbHRlcnMpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJTdGFjay5wdXNoKGV4dHJhRmlsdGVycyk7XG4gICAgfVxuICAgIGdldENhbGxOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGxOdW1iZXI7XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgLyogSWYgdGhlIHN0cmVhbSBoYXMgZW5kZWQgd2l0aCBhbiBlcnJvciwgd2Ugc2hvdWxkIG5vdCBlbWl0IGFueSBtb3JlXG4gICAgICAgICAqIG1lc3NhZ2VzIGFuZCB3ZSBzaG91bGQgY29tbXVuaWNhdGUgdGhhdCB0aGUgc3RyZWFtIGhhcyBlbmRlZCAqL1xuICAgICAgICBpZiAodGhpcy5maW5hbFN0YXR1cyAhPT0gbnVsbCAmJiB0aGlzLmZpbmFsU3RhdHVzLmNvZGUgIT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgdGhpcy5yZWFkc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1heWJlT3V0cHV0U3RhdHVzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYW5QdXNoID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuaHR0cDJTdHJlYW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1JlYWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMudW5wdXNoZWRSZWFkTWVzc2FnZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRNZXNzYWdlID0gdGhpcy51bnB1c2hlZFJlYWRNZXNzYWdlcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHVzaChuZXh0TWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogT25seSByZXN1bWUgcmVhZGluZyBmcm9tIHRoZSBodHRwMlN0cmVhbSBpZiB3ZSBkb24ndCBoYXZlIGFueSBwZW5kaW5nXG4gICAgICAgICAgICAgKiBtZXNzYWdlcyB0byBlbWl0ICovXG4gICAgICAgICAgICB0aGlzLmh0dHAyU3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1heWJlQ2xvc2VXcml0ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLndyaXRlc0Nsb3NlZCAmJlxuICAgICAgICAgICAgIXRoaXMuaXNXcml0ZUZpbHRlclBlbmRpbmcgJiZcbiAgICAgICAgICAgIHRoaXMuaHR0cDJTdHJlYW0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NhbGxpbmcgZW5kKCkgb24gSFRUUC8yIHN0cmVhbScpO1xuICAgICAgICAgICAgdGhpcy5odHRwMlN0cmVhbS5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kTWVzc2FnZVdpdGhDb250ZXh0KGNvbnRleHQsIG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnd3JpdGUoKSBjYWxsZWQgd2l0aCBtZXNzYWdlIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgICBjb25zdCB3cml0ZU9iaiA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBmbGFnczogY29udGV4dC5mbGFncyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBsZXQgY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRTtcbiAgICAgICAgICAgIGlmICgoKF9hID0gZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gJ0VSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EJykge1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbFdpdGhTdGF0dXMoY29kZSwgYFdyaXRlIGVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2IgPSBjb250ZXh0LmNhbGxiYWNrKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChjb250ZXh0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pc1dyaXRlRmlsdGVyUGVuZGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2suc2VuZE1lc3NhZ2UoUHJvbWlzZS5yZXNvbHZlKHdyaXRlT2JqKSkudGhlbigobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc1dyaXRlRmlsdGVyUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMuaHR0cDJTdHJlYW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdkZWZlcnJpbmcgd3JpdGluZyBkYXRhIGNodW5rIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5tZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGUgPSBtZXNzYWdlLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nV3JpdGVDYWxsYmFjayA9IGNiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnc2VuZGluZyBkYXRhIGNodW5rIG9mIGxlbmd0aCAnICsgbWVzc2FnZS5tZXNzYWdlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53cml0ZU1lc3NhZ2VUb1N0cmVhbShtZXNzYWdlLm1lc3NhZ2UsIGNiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kQ2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgV3JpdGUgZmFpbGVkIHdpdGggZXJyb3IgJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tYXliZUNsb3NlV3JpdGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuaGFuZGxlRmlsdGVyRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIGhhbGZDbG9zZSgpIHtcbiAgICAgICAgdGhpcy50cmFjZSgnZW5kKCkgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMud3JpdGVzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXliZUNsb3NlV3JpdGVzKCk7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwMkNhbGxTdHJlYW0gPSBIdHRwMkNhbGxTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxsLXN0cmVhbS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJIdHRwMkNhbGxTdHJlYW0iLCJJbnRlcmNlcHRpbmdMaXN0ZW5lckltcGwiLCJpc0ludGVyY2VwdGluZ0xpc3RlbmVyIiwiaHR0cDIiLCJyZXF1aXJlIiwib3MiLCJjb25zdGFudHNfMSIsIm1ldGFkYXRhXzEiLCJzdHJlYW1fZGVjb2Rlcl8xIiwibG9nZ2luZyIsImNvbnN0YW50c18yIiwiVFJBQ0VSX05BTUUiLCJIVFRQMl9IRUFERVJfU1RBVFVTIiwiSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSIsIk5HSFRUUDJfQ0FOQ0VMIiwiY29uc3RhbnRzIiwiZ2V0U3lzdGVtRXJyb3JOYW1lIiwiZXJybm8iLCJuYW1lIiwibnVtIiwiZW50cmllcyIsImdldE1pbkRlYWRsaW5lIiwiZGVhZGxpbmVMaXN0IiwibWluVmFsdWUiLCJJbmZpbml0eSIsImRlYWRsaW5lIiwiZGVhZGxpbmVNc2VjcyIsIkRhdGUiLCJnZXRUaW1lIiwibGlzdGVuZXIiLCJvblJlY2VpdmVNZXRhZGF0YSIsInVuZGVmaW5lZCIsImxlbmd0aCIsImNvbnN0cnVjdG9yIiwibmV4dExpc3RlbmVyIiwicHJvY2Vzc2luZ01ldGFkYXRhIiwiaGFzUGVuZGluZ01lc3NhZ2UiLCJwcm9jZXNzaW5nTWVzc2FnZSIsInBlbmRpbmdTdGF0dXMiLCJwcm9jZXNzUGVuZGluZ01lc3NhZ2UiLCJvblJlY2VpdmVNZXNzYWdlIiwicGVuZGluZ01lc3NhZ2UiLCJwcm9jZXNzUGVuZGluZ1N0YXR1cyIsIm9uUmVjZWl2ZVN0YXR1cyIsIm1ldGFkYXRhIiwibWVzc2FnZSIsIm1zZyIsInN0YXR1cyIsInByb2Nlc3NlZFN0YXR1cyIsIm1ldGhvZE5hbWUiLCJjaGFubmVsIiwib3B0aW9ucyIsImZpbHRlclN0YWNrRmFjdG9yeSIsImNoYW5uZWxDYWxsQ3JlZGVudGlhbHMiLCJjYWxsTnVtYmVyIiwiaHR0cDJTdHJlYW0iLCJwZW5kaW5nUmVhZCIsImlzV3JpdGVGaWx0ZXJQZW5kaW5nIiwicGVuZGluZ1dyaXRlIiwicGVuZGluZ1dyaXRlQ2FsbGJhY2siLCJ3cml0ZXNDbG9zZWQiLCJkZWNvZGVyIiwiU3RyZWFtRGVjb2RlciIsImlzUmVhZEZpbHRlclBlbmRpbmciLCJjYW5QdXNoIiwicmVhZHNDbG9zZWQiLCJzdGF0dXNPdXRwdXQiLCJ1bnB1c2hlZFJlYWRNZXNzYWdlcyIsInVuZmlsdGVyZWRSZWFkTWVzc2FnZXMiLCJtYXBwZWRTdGF0dXNDb2RlIiwiU3RhdHVzIiwiVU5LTk9XTiIsImZpbmFsU3RhdHVzIiwic3ViY2hhbm5lbCIsImludGVybmFsRXJyb3IiLCJjb25maWdEZWFkbGluZSIsInN0YXR1c1dhdGNoZXJzIiwic3RyZWFtRW5kV2F0Y2hlcnMiLCJjYWxsU3RhdHNUcmFja2VyIiwiZmlsdGVyU3RhY2siLCJjcmVhdGVGaWx0ZXIiLCJjcmVkZW50aWFscyIsImRpc2Nvbm5lY3RMaXN0ZW5lciIsImVuZENhbGwiLCJjb2RlIiwiVU5BVkFJTEFCTEUiLCJkZXRhaWxzIiwiTWV0YWRhdGEiLCJwYXJlbnRDYWxsIiwiZmxhZ3MiLCJQcm9wYWdhdGUiLCJDQU5DRUxMQVRJT04iLCJvbiIsImNhbmNlbFdpdGhTdGF0dXMiLCJDQU5DRUxMRUQiLCJvdXRwdXRTdGF0dXMiLCJfYSIsImZpbHRlcmVkU3RhdHVzIiwicmVjZWl2ZVRyYWlsZXJzIiwidHJhY2UiLCJmb3JFYWNoIiwid2F0Y2hlciIsInByb2Nlc3MiLCJuZXh0VGljayIsInJlc3VtZSIsImNhbGxVbnJlZiIsInJlbW92ZURpc2Nvbm5lY3RMaXN0ZW5lciIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIk9LIiwibWF5YmVPdXRwdXRTdGF0dXMiLCJkZXN0cm95SHR0cDJTdHJlYW0iLCJwdXNoIiwiQnVmZmVyIiwiaGFuZGxlRmlsdGVyRXJyb3IiLCJlcnJvciIsIklOVEVSTkFMIiwiaGFuZGxlRmlsdGVyZWRSZWFkIiwicGF1c2UiLCJuZXh0TWVzc2FnZSIsInNoaWZ0IiwiZmlsdGVyUmVjZWl2ZWRNZXNzYWdlIiwiZnJhbWVkTWVzc2FnZSIsInJlY2VpdmVNZXNzYWdlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiYmluZCIsInRyeVB1c2giLCJtZXNzYWdlQnl0ZXMiLCJoYW5kbGVUcmFpbGVycyIsImhlYWRlcnMiLCJoZWFkZXJzU3RyaW5nIiwiaGVhZGVyIiwia2V5cyIsImZyb21IdHRwMkhlYWRlcnMiLCJlIiwibWV0YWRhdGFNYXAiLCJnZXRNYXAiLCJyZWNlaXZlZFN0YXR1cyIsIk51bWJlciIsInJlbW92ZSIsImRlY29kZVVSSSIsIndyaXRlTWVzc2FnZVRvU3RyZWFtIiwiY2FsbGJhY2siLCJhZGRNZXNzYWdlU2VudCIsIndyaXRlIiwiYXR0YWNoSHR0cDJTdHJlYW0iLCJzdHJlYW0iLCJleHRyYUZpbHRlcnMiLCJjbG9zZSIsImdldEFkZHJlc3MiLCJhZGREaXNjb25uZWN0TGlzdGVuZXIiLCJjYWxsUmVmIiwiVU5BVVRIRU5USUNBVEVEIiwiUEVSTUlTU0lPTl9ERU5JRUQiLCJVTklNUExFTUVOVEVEIiwiTkdIVFRQMl9GTEFHX0VORF9TVFJFQU0iLCJmaW5hbE1ldGFkYXRhIiwicmVjZWl2ZU1ldGFkYXRhIiwiZGF0YSIsIm1lc3NhZ2VzIiwiYWRkTWVzc2FnZVJlY2VpdmVkIiwicnN0Q29kZSIsIk5HSFRUUDJfTk9fRVJST1IiLCJOR0hUVFAyX1JFRlVTRURfU1RSRUFNIiwiTkdIVFRQMl9FTkhBTkNFX1lPVVJfQ0FMTSIsIlJFU09VUkNFX0VYSEFVU1RFRCIsIk5HSFRUUDJfSU5BREVRVUFURV9TRUNVUklUWSIsIk5HSFRUUDJfSU5URVJOQUxfRVJST1IiLCJlcnIiLCJzeXNjYWxsIiwiRXJyb3IiLCJtYXliZUNsb3NlV3JpdGVzIiwic3RhcnQiLCJfc3RhcnRDYWxsU3RyZWFtIiwiZGVzdHJveWVkIiwiZ2V0RGVhZGxpbmUiLCJERUFETElORSIsImdldENyZWRlbnRpYWxzIiwic2V0Q3JlZGVudGlhbHMiLCJjb21wb3NlIiwiZ2V0U3RhdHVzIiwiZ2V0UGVlciIsIl9iIiwiZ2V0VGFyZ2V0IiwiZ2V0TWV0aG9kIiwiZ2V0SG9zdCIsImhvc3QiLCJzZXRDb25maWdEZWFkbGluZSIsImFkZFN0YXR1c1dhdGNoZXIiLCJhZGRTdHJlYW1FbmRXYXRjaGVyIiwiYWRkRmlsdGVycyIsImdldENhbGxOdW1iZXIiLCJzdGFydFJlYWQiLCJlbmQiLCJzZW5kTWVzc2FnZVdpdGhDb250ZXh0IiwiY29udGV4dCIsIndyaXRlT2JqIiwiY2IiLCJjYWxsIiwic2VuZE1lc3NhZ2UiLCJoYWxmQ2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js":
/*!******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/call.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ClientDuplexStreamImpl = exports.ClientWritableStreamImpl = exports.ClientReadableStreamImpl = exports.ClientUnaryCallImpl = exports.callErrorFromStatus = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Construct a ServiceError from a StatusObject. This function exists primarily\n * as an attempt to make the error stack trace clearly communicate that the\n * error is not necessarily a problem in gRPC itself.\n * @param status\n */ function callErrorFromStatus(status, callerStack) {\n    const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;\n    const error = new Error(message);\n    const stack = `${error.stack}\\nfor call at\\n${callerStack}`;\n    return Object.assign(new Error(message), status, {\n        stack\n    });\n}\nexports.callErrorFromStatus = callErrorFromStatus;\nclass ClientUnaryCallImpl extends events_1.EventEmitter {\n    constructor(){\n        super();\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n}\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\nclass ClientReadableStreamImpl extends stream_1.Readable {\n    constructor(deserialize){\n        super({\n            objectMode: true\n        });\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n}\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\nclass ClientWritableStreamImpl extends stream_1.Writable {\n    constructor(serialize){\n        super({\n            objectMode: true\n        });\n        this.serialize = serialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\nclass ClientDuplexStreamImpl extends stream_1.Duplex {\n    constructor(serialize, deserialize){\n        super({\n            objectMode: true\n        });\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n    }\n    cancel() {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, \"Cancelled on client\");\n    }\n    getPeer() {\n        var _a, _b;\n        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    _read(_size) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();\n    }\n    _write(chunk, encoding, cb) {\n        var _a;\n        const context = {\n            callback: cb\n        };\n        const flags = Number(encoding);\n        if (!Number.isNaN(flags)) {\n            context.flags = flags;\n        }\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);\n    }\n    _final(cb) {\n        var _a;\n        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();\n        cb();\n    }\n}\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl; //# sourceMappingURL=call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsOEJBQThCLEdBQUdBLGdDQUFnQyxHQUFHQSxnQ0FBZ0MsR0FBR0EsMkJBQTJCLEdBQUdBLDJCQUEyQixHQUFHLEtBQUs7QUFDeEssTUFBTU8sV0FBV0MsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUMsV0FBV0QsbUJBQU9BLENBQUMsc0JBQVE7QUFDakMsTUFBTUUsY0FBY0YsbUJBQU9BLENBQUMsOEVBQWE7QUFDekM7Ozs7O0NBS0MsR0FDRCxTQUFTRixvQkFBb0JLLE1BQU0sRUFBRUMsV0FBVztJQUM1QyxNQUFNQyxVQUFVLENBQUMsRUFBRUYsT0FBT0csSUFBSSxDQUFDLENBQUMsRUFBRUosWUFBWUssTUFBTSxDQUFDSixPQUFPRyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUVILE9BQU9LLE9BQU8sQ0FBQyxDQUFDO0lBQ3RGLE1BQU1DLFFBQVEsSUFBSUMsTUFBTUw7SUFDeEIsTUFBTU0sUUFBUSxDQUFDLEVBQUVGLE1BQU1FLEtBQUssQ0FBQyxlQUFlLEVBQUVQLFlBQVksQ0FBQztJQUMzRCxPQUFPZCxPQUFPc0IsTUFBTSxDQUFDLElBQUlGLE1BQU1MLFVBQVVGLFFBQVE7UUFBRVE7SUFBTTtBQUM3RDtBQUNBbkIsMkJBQTJCLEdBQUdNO0FBQzlCLE1BQU1ELDRCQUE0QkUsU0FBU2MsWUFBWTtJQUNuREMsYUFBYztRQUNWLEtBQUs7SUFDVDtJQUNBQyxTQUFTO1FBQ0wsSUFBSUM7UUFDSEEsQ0FBQUEsS0FBSyxJQUFJLENBQUNDLElBQUksTUFBTSxRQUFRRCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdFLGdCQUFnQixDQUFDaEIsWUFBWUssTUFBTSxDQUFDWSxTQUFTLEVBQUU7SUFDNUc7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IndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2FsbC5qcz9mZTM3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudER1cGxleFN0cmVhbUltcGwgPSBleHBvcnRzLkNsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsID0gZXhwb3J0cy5DbGllbnRVbmFyeUNhbGxJbXBsID0gZXhwb3J0cy5jYWxsRXJyb3JGcm9tU3RhdHVzID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG4vKipcbiAqIENvbnN0cnVjdCBhIFNlcnZpY2VFcnJvciBmcm9tIGEgU3RhdHVzT2JqZWN0LiBUaGlzIGZ1bmN0aW9uIGV4aXN0cyBwcmltYXJpbHlcbiAqIGFzIGFuIGF0dGVtcHQgdG8gbWFrZSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UgY2xlYXJseSBjb21tdW5pY2F0ZSB0aGF0IHRoZVxuICogZXJyb3IgaXMgbm90IG5lY2Vzc2FyaWx5IGEgcHJvYmxlbSBpbiBnUlBDIGl0c2VsZi5cbiAqIEBwYXJhbSBzdGF0dXNcbiAqL1xuZnVuY3Rpb24gY2FsbEVycm9yRnJvbVN0YXR1cyhzdGF0dXMsIGNhbGxlclN0YWNrKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IGAke3N0YXR1cy5jb2RlfSAke2NvbnN0YW50c18xLlN0YXR1c1tzdGF0dXMuY29kZV19OiAke3N0YXR1cy5kZXRhaWxzfWA7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgY29uc3Qgc3RhY2sgPSBgJHtlcnJvci5zdGFja31cXG5mb3IgY2FsbCBhdFxcbiR7Y2FsbGVyU3RhY2t9YDtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IobWVzc2FnZSksIHN0YXR1cywgeyBzdGFjayB9KTtcbn1cbmV4cG9ydHMuY2FsbEVycm9yRnJvbVN0YXR1cyA9IGNhbGxFcnJvckZyb21TdGF0dXM7XG5jbGFzcyBDbGllbnRVbmFyeUNhbGxJbXBsIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50VW5hcnlDYWxsSW1wbCA9IENsaWVudFVuYXJ5Q2FsbEltcGw7XG5jbGFzcyBDbGllbnRSZWFkYWJsZVN0cmVhbUltcGwgZXh0ZW5kcyBzdHJlYW1fMS5SZWFkYWJsZSB7XG4gICAgY29uc3RydWN0b3IoZGVzZXJpYWxpemUpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgX3JlYWQoX3NpemUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFydFJlYWQoKTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbCA9IENsaWVudFJlYWRhYmxlU3RyZWFtSW1wbDtcbmNsYXNzIENsaWVudFdyaXRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLldyaXRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJpYWxpemUpIHtcbiAgICAgICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLkNBTkNFTExFRCwgJ0NhbmNlbGxlZCBvbiBjbGllbnQnKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBlZXIoKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBfd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBjYWxsYmFjazogY2IsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZsYWdzID0gTnVtYmVyKGVuY29kaW5nKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oZmxhZ3MpKSB7XG4gICAgICAgICAgICBjb250ZXh0LmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5jYWxsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBjaHVuayk7XG4gICAgfVxuICAgIF9maW5hbChjYikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbGZDbG9zZSgpO1xuICAgICAgICBjYigpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsID0gQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgQ2xpZW50RHVwbGV4U3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3Ioc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSkge1xuICAgICAgICBzdXBlcih7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIHRoaXMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsICdDYW5jZWxsZWQgb24gY2xpZW50Jyk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQZWVyKCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgX3JlYWQoX3NpemUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFydFJlYWQoKTtcbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBmbGFncyA9IE51bWJlcihlbmNvZGluZyk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGZsYWdzKSkge1xuICAgICAgICAgICAgY29udGV4dC5mbGFncyA9IGZsYWdzO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuY2FsbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgY2h1bmspO1xuICAgIH1cbiAgICBfZmluYWwoY2IpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmNhbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYWxmQ2xvc2UoKTtcbiAgICAgICAgY2IoKTtcbiAgICB9XG59XG5leHBvcnRzLkNsaWVudER1cGxleFN0cmVhbUltcGwgPSBDbGllbnREdXBsZXhTdHJlYW1JbXBsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FsbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDbGllbnREdXBsZXhTdHJlYW1JbXBsIiwiQ2xpZW50V3JpdGFibGVTdHJlYW1JbXBsIiwiQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsIiwiQ2xpZW50VW5hcnlDYWxsSW1wbCIsImNhbGxFcnJvckZyb21TdGF0dXMiLCJldmVudHNfMSIsInJlcXVpcmUiLCJzdHJlYW1fMSIsImNvbnN0YW50c18xIiwic3RhdHVzIiwiY2FsbGVyU3RhY2siLCJtZXNzYWdlIiwiY29kZSIsIlN0YXR1cyIsImRldGFpbHMiLCJlcnJvciIsIkVycm9yIiwic3RhY2siLCJhc3NpZ24iLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsImNhbmNlbCIsIl9hIiwiY2FsbCIsImNhbmNlbFdpdGhTdGF0dXMiLCJDQU5DRUxMRUQiLCJnZXRQZWVyIiwiX2IiLCJSZWFkYWJsZSIsImRlc2VyaWFsaXplIiwib2JqZWN0TW9kZSIsIl9yZWFkIiwiX3NpemUiLCJzdGFydFJlYWQiLCJXcml0YWJsZSIsInNlcmlhbGl6ZSIsIl93cml0ZSIsImNodW5rIiwiZW5jb2RpbmciLCJjYiIsImNvbnRleHQiLCJjYWxsYmFjayIsImZsYWdzIiwiTnVtYmVyIiwiaXNOYU4iLCJzZW5kTWVzc2FnZVdpdGhDb250ZXh0IiwiX2ZpbmFsIiwiaGFsZkNsb3NlIiwiRHVwbGV4Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-credentials.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChannelCredentials = void 0;\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction verifyIsBufferOrNull(obj, friendlyName) {\n    if (obj && !(obj instanceof Buffer)) {\n        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);\n    }\n}\nfunction bufferOrNullEqual(buf1, buf2) {\n    if (buf1 === null && buf2 === null) {\n        return true;\n    } else {\n        return buf1 !== null && buf2 !== null && buf1.equals(buf2);\n    }\n}\n/**\n * A class that contains credentials for communicating over a channel, as well\n * as a set of per-call credentials, which are applied to every method call made\n * over a channel initialized with an instance of this class.\n */ class ChannelCredentials {\n    constructor(callCredentials){\n        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();\n    }\n    /**\n     * Gets the set of per-call credentials associated with this instance.\n     */ _getCallCredentials() {\n        return this.callCredentials;\n    }\n    /**\n     * Return a new ChannelCredentials instance with a given set of credentials.\n     * The resulting instance can be used to construct a Channel that communicates\n     * over TLS.\n     * @param rootCerts The root certificate data.\n     * @param privateKey The client certificate private key, if available.\n     * @param certChain The client certificate key chain, if available.\n     * @param verifyOptions Additional options to modify certificate verification\n     */ static createSsl(rootCerts, privateKey, certChain, verifyOptions) {\n        var _a;\n        verifyIsBufferOrNull(rootCerts, \"Root certificate\");\n        verifyIsBufferOrNull(privateKey, \"Private key\");\n        verifyIsBufferOrNull(certChain, \"Certificate chain\");\n        if (privateKey && !certChain) {\n            throw new Error(\"Private key must be given with accompanying certificate chain\");\n        }\n        if (!privateKey && certChain) {\n            throw new Error(\"Certificate chain must be given with accompanying private key\");\n        }\n        const secureContext = tls_1.createSecureContext({\n            ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : tls_helpers_1.getDefaultRootsData()) !== null && _a !== void 0 ? _a : undefined,\n            key: privateKey !== null && privateKey !== void 0 ? privateKey : undefined,\n            cert: certChain !== null && certChain !== void 0 ? certChain : undefined,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        });\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with credentials created using\n     * the provided secureContext. The resulting instances can be used to\n     * construct a Channel that communicates over TLS. gRPC will not override\n     * anything in the provided secureContext, so the environment variables\n     * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will\n     * not be applied.\n     * @param secureContext The return value of tls.createSecureContext()\n     * @param verifyOptions Additional options to modify certificate verification\n     */ static createFromSecureContext(secureContext, verifyOptions) {\n        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});\n    }\n    /**\n     * Return a new ChannelCredentials instance with no credentials.\n     */ static createInsecure() {\n        return new InsecureChannelCredentialsImpl();\n    }\n}\nexports.ChannelCredentials = ChannelCredentials;\nclass InsecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(callCredentials){\n        super(callCredentials);\n    }\n    compose(callCredentials) {\n        throw new Error(\"Cannot compose insecure credentials\");\n    }\n    _getConnectionOptions() {\n        return null;\n    }\n    _isSecure() {\n        return false;\n    }\n    _equals(other) {\n        return other instanceof InsecureChannelCredentialsImpl;\n    }\n}\nclass SecureChannelCredentialsImpl extends ChannelCredentials {\n    constructor(secureContext, verifyOptions){\n        super();\n        this.secureContext = secureContext;\n        this.verifyOptions = verifyOptions;\n        this.connectionOptions = {\n            secureContext\n        };\n        // Node asserts that this option is a function, so we cannot pass undefined\n        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {\n            this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;\n        }\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        // Copy to prevent callers from mutating this.connectionOptions\n        return Object.assign({}, this.connectionOptions);\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof SecureChannelCredentialsImpl) {\n            return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;\n        } else {\n            return false;\n        }\n    }\n}\nclass ComposedChannelCredentialsImpl extends ChannelCredentials {\n    constructor(channelCredentials, callCreds){\n        super(callCreds);\n        this.channelCredentials = channelCredentials;\n    }\n    compose(callCredentials) {\n        const combinedCallCredentials = this.callCredentials.compose(callCredentials);\n        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);\n    }\n    _getConnectionOptions() {\n        return this.channelCredentials._getConnectionOptions();\n    }\n    _isSecure() {\n        return true;\n    }\n    _equals(other) {\n        if (this === other) {\n            return true;\n        }\n        if (other instanceof ComposedChannelCredentialsImpl) {\n            return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);\n        } else {\n            return false;\n        }\n    }\n} //# sourceMappingURL=channel-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1jcmVkZW50aWFscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMEJBQTBCLEdBQUcsS0FBSztBQUNsQyxNQUFNRyxRQUFRQyxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNQyxxQkFBcUJELG1CQUFPQSxDQUFDLDRGQUFvQjtBQUN2RCxNQUFNRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLDhEQUE4RDtBQUM5RCxTQUFTRyxxQkFBcUJDLEdBQUcsRUFBRUMsWUFBWTtJQUMzQyxJQUFJRCxPQUFPLENBQUVBLENBQUFBLGVBQWVFLE1BQUssR0FBSTtRQUNqQyxNQUFNLElBQUlDLFVBQVUsQ0FBQyxFQUFFRixhQUFhLGdDQUFnQyxDQUFDO0lBQ3pFO0FBQ0o7QUFDQSxTQUFTRyxrQkFBa0JDLElBQUksRUFBRUMsSUFBSTtJQUNqQyxJQUFJRCxTQUFTLFFBQVFDLFNBQVMsTUFBTTtRQUNoQyxPQUFPO0lBQ1gsT0FDSztRQUNELE9BQU9ELFNBQVMsUUFBUUMsU0FBUyxRQUFRRCxLQUFLRSxNQUFNLENBQUNEO0lBQ3pEO0FBQ0o7QUFDQTs7OztDQUlDLEdBQ0QsTUFBTVo7SUFDRmMsWUFBWUMsZUFBZSxDQUFFO1FBQ3pCLElBQUksQ0FBQ0EsZUFBZSxHQUFHQSxtQkFBbUJaLG1CQUFtQmEsZUFBZSxDQUFDQyxXQUFXO0lBQzVGO0lBQ0E7O0tBRUMsR0FDREMsc0JBQXNCO1FBQ2xCLE9BQU8sSUFBSSxDQUFDSCxlQUFlO0lBQy9CO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRCxPQUFPSSxVQUFVQyxTQUFTLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxFQUFFQyxhQUFhLEVBQUU7UUFDOUQsSUFBSUM7UUFDSm5CLHFCQUFxQmUsV0FBVztRQUNoQ2YscUJB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Q0E7UUFDTixJQUFJLENBQUNELGtCQUFrQixHQUFHQTtJQUM5QjtJQUNBVixRQUFReEIsZUFBZSxFQUFFO1FBQ3JCLE1BQU0rQiwwQkFBMEIsSUFBSSxDQUFDL0IsZUFBZSxDQUFDd0IsT0FBTyxDQUFDeEI7UUFDN0QsT0FBTyxJQUFJZ0MsK0JBQStCLElBQUksQ0FBQ0Usa0JBQWtCLEVBQUVIO0lBQ3ZFO0lBQ0FOLHdCQUF3QjtRQUNwQixPQUFPLElBQUksQ0FBQ1Msa0JBQWtCLENBQUNULHFCQUFxQjtJQUN4RDtJQUNBQyxZQUFZO1FBQ1IsT0FBTztJQUNYO0lBQ0FDLFFBQVFDLEtBQUssRUFBRTtRQUNYLElBQUksSUFBSSxLQUFLQSxPQUFPO1lBQ2hCLE9BQU87UUFDWDtRQUNBLElBQUlBLGlCQUFpQkksZ0NBQWdDO1lBQ2pELE9BQVEsSUFBSSxDQUFDRSxrQkFBa0IsQ0FBQ1AsT0FBTyxDQUFDQyxNQUFNTSxrQkFBa0IsS0FDNUQsSUFBSSxDQUFDbEMsZUFBZSxDQUFDMkIsT0FBTyxDQUFDQyxNQUFNNUIsZUFBZTtRQUMxRCxPQUNLO1lBQ0QsT0FBTztRQUNYO0lBQ0o7QUFDSixFQUNBLCtDQUErQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLWNyZWRlbnRpYWxzLmpzPzhlNzAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xuY29uc3QgY2FsbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2FsbC1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IHRsc19oZWxwZXJzXzEgPSByZXF1aXJlKFwiLi90bHMtaGVscGVyc1wiKTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB2ZXJpZnlJc0J1ZmZlck9yTnVsbChvYmosIGZyaWVuZGx5TmFtZSkge1xuICAgIGlmIChvYmogJiYgIShvYmogaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7ZnJpZW5kbHlOYW1lfSwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYSBCdWZmZXIuYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVmZmVyT3JOdWxsRXF1YWwoYnVmMSwgYnVmMikge1xuICAgIGlmIChidWYxID09PSBudWxsICYmIGJ1ZjIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYnVmMSAhPT0gbnVsbCAmJiBidWYyICE9PSBudWxsICYmIGJ1ZjEuZXF1YWxzKGJ1ZjIpO1xuICAgIH1cbn1cbi8qKlxuICogQSBjbGFzcyB0aGF0IGNvbnRhaW5zIGNyZWRlbnRpYWxzIGZvciBjb21tdW5pY2F0aW5nIG92ZXIgYSBjaGFubmVsLCBhcyB3ZWxsXG4gKiBhcyBhIHNldCBvZiBwZXItY2FsbCBjcmVkZW50aWFscywgd2hpY2ggYXJlIGFwcGxpZWQgdG8gZXZlcnkgbWV0aG9kIGNhbGwgbWFkZVxuICogb3ZlciBhIGNoYW5uZWwgaW5pdGlhbGl6ZWQgd2l0aCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuICovXG5jbGFzcyBDaGFubmVsQ3JlZGVudGlhbHMge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxDcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmNhbGxDcmVkZW50aWFscyA9IGNhbGxDcmVkZW50aWFscyB8fCBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzLmNyZWF0ZUVtcHR5KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNldCBvZiBwZXItY2FsbCBjcmVkZW50aWFscyBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBfZ2V0Q2FsbENyZWRlbnRpYWxzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsQ3JlZGVudGlhbHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIG5ldyBDaGFubmVsQ3JlZGVudGlhbHMgaW5zdGFuY2Ugd2l0aCBhIGdpdmVuIHNldCBvZiBjcmVkZW50aWFscy5cbiAgICAgKiBUaGUgcmVzdWx0aW5nIGluc3RhbmNlIGNhbiBiZSB1c2VkIHRvIGNvbnN0cnVjdCBhIENoYW5uZWwgdGhhdCBjb21tdW5pY2F0ZXNcbiAgICAgKiBvdmVyIFRMUy5cbiAgICAgKiBAcGFyYW0gcm9vdENlcnRzIFRoZSByb290IGNlcnRpZmljYXRlIGRhdGEuXG4gICAgICogQHBhcmFtIHByaXZhdGVLZXkgVGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBwcml2YXRlIGtleSwgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBwYXJhbSBjZXJ0Q2hhaW4gVGhlIGNsaWVudCBjZXJ0aWZpY2F0ZSBrZXkgY2hhaW4sIGlmIGF2YWlsYWJsZS5cbiAgICAgKiBAcGFyYW0gdmVyaWZ5T3B0aW9ucyBBZGRpdGlvbmFsIG9wdGlvbnMgdG8gbW9kaWZ5IGNlcnRpZmljYXRlIHZlcmlmaWNhdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTc2wocm9vdENlcnRzLCBwcml2YXRlS2V5LCBjZXJ0Q2hhaW4sIHZlcmlmeU9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChyb290Q2VydHMsICdSb290IGNlcnRpZmljYXRlJyk7XG4gICAgICAgIHZlcmlmeUlzQnVmZmVyT3JOdWxsKHByaXZhdGVLZXksICdQcml2YXRlIGtleScpO1xuICAgICAgICB2ZXJpZnlJc0J1ZmZlck9yTnVsbChjZXJ0Q2hhaW4sICdDZXJ0aWZpY2F0ZSBjaGFpbicpO1xuICAgICAgICBpZiAocHJpdmF0ZUtleSAmJiAhY2VydENoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaXZhdGUga2V5IG11c3QgYmUgZ2l2ZW4gd2l0aCBhY2NvbXBhbnlpbmcgY2VydGlmaWNhdGUgY2hhaW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByaXZhdGVLZXkgJiYgY2VydENoYWluKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlcnRpZmljYXRlIGNoYWluIG11c3QgYmUgZ2l2ZW4gd2l0aCBhY2NvbXBhbnlpbmcgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWN1cmVDb250ZXh0ID0gdGxzXzEuY3JlYXRlU2VjdXJlQ29udGV4dCh7XG4gICAgICAgICAgICBjYTogKF9hID0gcm9vdENlcnRzICE9PSBudWxsICYmIHJvb3RDZXJ0cyAhPT0gdm9pZCAwID8gcm9vdENlcnRzIDogdGxzX2hlbHBlcnNfMS5nZXREZWZhdWx0Um9vdHNEYXRhKCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGtleTogcHJpdmF0ZUtleSAhPT0gbnVsbCAmJiBwcml2YXRlS2V5ICE9PSB2b2lkIDAgPyBwcml2YXRlS2V5IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2VydDogY2VydENoYWluICE9PSBudWxsICYmIGNlcnRDaGFpbiAhPT0gdm9pZCAwID8gY2VydENoYWluIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2lwaGVyczogdGxzX2hlbHBlcnNfMS5DSVBIRVJfU1VJVEVTLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHNlY3VyZUNvbnRleHQsIHZlcmlmeU9wdGlvbnMgIT09IG51bGwgJiYgdmVyaWZ5T3B0aW9ucyAhPT0gdm9pZCAwID8gdmVyaWZ5T3B0aW9ucyA6IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbmV3IENoYW5uZWxDcmVkZW50aWFscyBpbnN0YW5jZSB3aXRoIGNyZWRlbnRpYWxzIGNyZWF0ZWQgdXNpbmdcbiAgICAgKiB0aGUgcHJvdmlkZWQgc2VjdXJlQ29udGV4dC4gVGhlIHJlc3VsdGluZyBpbnN0YW5jZXMgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiBjb25zdHJ1Y3QgYSBDaGFubmVsIHRoYXQgY29tbXVuaWNhdGVzIG92ZXIgVExTLiBnUlBDIHdpbGwgbm90IG92ZXJyaWRlXG4gICAgICogYW55dGhpbmcgaW4gdGhlIHByb3ZpZGVkIHNlY3VyZUNvbnRleHQsIHNvIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgKiBHUlBDX1NTTF9DSVBIRVJfU1VJVEVTIGFuZCBHUlBDX0RFRkFVTFRfU1NMX1JPT1RTX0ZJTEVfUEFUSCB3aWxsXG4gICAgICogbm90IGJlIGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHNlY3VyZUNvbnRleHQgVGhlIHJldHVybiB2YWx1ZSBvZiB0bHMuY3JlYXRlU2VjdXJlQ29udGV4dCgpXG4gICAgICogQHBhcmFtIHZlcmlmeU9wdGlvbnMgQWRkaXRpb25hbCBvcHRpb25zIHRvIG1vZGlmeSBjZXJ0aWZpY2F0ZSB2ZXJpZmljYXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IFNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwoc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucyAhPT0gbnVsbCAmJiB2ZXJpZnlPcHRpb25zICE9PSB2b2lkIDAgPyB2ZXJpZnlPcHRpb25zIDoge30pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBuZXcgQ2hhbm5lbENyZWRlbnRpYWxzIGluc3RhbmNlIHdpdGggbm8gY3JlZGVudGlhbHMuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUluc2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gbmV3IEluc2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gQ2hhbm5lbENyZWRlbnRpYWxzO1xuY2xhc3MgSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIGV4dGVuZHMgQ2hhbm5lbENyZWRlbnRpYWxzIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgc3VwZXIoY2FsbENyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcG9zZSBpbnNlY3VyZSBjcmVkZW50aWFscycpO1xuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBJbnNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGw7XG4gICAgfVxufVxuY2xhc3MgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3Ioc2VjdXJlQ29udGV4dCwgdmVyaWZ5T3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNlY3VyZUNvbnRleHQgPSBzZWN1cmVDb250ZXh0O1xuICAgICAgICB0aGlzLnZlcmlmeU9wdGlvbnMgPSB2ZXJpZnlPcHRpb25zO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcHRpb25zID0ge1xuICAgICAgICAgICAgc2VjdXJlQ29udGV4dFxuICAgICAgICB9O1xuICAgICAgICAvLyBOb2RlIGFzc2VydHMgdGhhdCB0aGlzIG9wdGlvbiBpcyBhIGZ1bmN0aW9uLCBzbyB3ZSBjYW5ub3QgcGFzcyB1bmRlZmluZWRcbiAgICAgICAgaWYgKHZlcmlmeU9wdGlvbnMgPT09IG51bGwgfHwgdmVyaWZ5T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPSB2ZXJpZnlPcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMgPSB0aGlzLmNhbGxDcmVkZW50aWFscy5jb21wb3NlKGNhbGxDcmVkZW50aWFscyk7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsKHRoaXMsIGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgX2dldENvbm5lY3Rpb25PcHRpb25zKCkge1xuICAgICAgICAvLyBDb3B5IHRvIHByZXZlbnQgY2FsbGVycyBmcm9tIG11dGF0aW5nIHRoaXMuY29ubmVjdGlvbk9wdGlvbnNcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY29ubmVjdGlvbk9wdGlvbnMpO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09PSBvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgU2VjdXJlQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnNlY3VyZUNvbnRleHQgPT09IG90aGVyLnNlY3VyZUNvbnRleHQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnZlcmlmeU9wdGlvbnMuY2hlY2tTZXJ2ZXJJZGVudGl0eSA9PT0gb3RoZXIudmVyaWZ5T3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCBleHRlbmRzIENoYW5uZWxDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbENyZWRlbnRpYWxzLCBjYWxsQ3JlZHMpIHtcbiAgICAgICAgc3VwZXIoY2FsbENyZWRzKTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ3JlZGVudGlhbHMgPSBjaGFubmVsQ3JlZGVudGlhbHM7XG4gICAgfVxuICAgIGNvbXBvc2UoY2FsbENyZWRlbnRpYWxzKSB7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzID0gdGhpcy5jYWxsQ3JlZGVudGlhbHMuY29tcG9zZShjYWxsQ3JlZGVudGlhbHMpO1xuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCh0aGlzLmNoYW5uZWxDcmVkZW50aWFscywgY29tYmluZWRDYWxsQ3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICBfZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWxDcmVkZW50aWFscy5fZ2V0Q29ubmVjdGlvbk9wdGlvbnMoKTtcbiAgICB9XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX2VxdWFscyhvdGhlcikge1xuICAgICAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvbXBvc2VkQ2hhbm5lbENyZWRlbnRpYWxzSW1wbCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmNoYW5uZWxDcmVkZW50aWFscy5fZXF1YWxzKG90aGVyLmNoYW5uZWxDcmVkZW50aWFscykgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxDcmVkZW50aWFscy5fZXF1YWxzKG90aGVyLmNhbGxDcmVkZW50aWFscykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC1jcmVkZW50aWFscy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDaGFubmVsQ3JlZGVudGlhbHMiLCJ0bHNfMSIsInJlcXVpcmUiLCJjYWxsX2NyZWRlbnRpYWxzXzEiLCJ0bHNfaGVscGVyc18xIiwidmVyaWZ5SXNCdWZmZXJPck51bGwiLCJvYmoiLCJmcmllbmRseU5hbWUiLCJCdWZmZXIiLCJUeXBlRXJyb3IiLCJidWZmZXJPck51bGxFcXVhbCIsImJ1ZjEiLCJidWYyIiwiZXF1YWxzIiwiY29uc3RydWN0b3IiLCJjYWxsQ3JlZGVudGlhbHMiLCJDYWxsQ3JlZGVudGlhbHMiLCJjcmVhdGVFbXB0eSIsIl9nZXRDYWxsQ3JlZGVudGlhbHMiLCJjcmVhdGVTc2wiLCJyb290Q2VydHMiLCJwcml2YXRlS2V5IiwiY2VydENoYWluIiwidmVyaWZ5T3B0aW9ucyIsIl9hIiwiRXJyb3IiLCJzZWN1cmVDb250ZXh0IiwiY3JlYXRlU2VjdXJlQ29udGV4dCIsImNhIiwiZ2V0RGVmYXVsdFJvb3RzRGF0YSIsInVuZGVmaW5lZCIsImtleSIsImNlcnQiLCJjaXBoZXJzIiwiQ0lQSEVSX1NVSVRFUyIsIlNlY3VyZUNoYW5uZWxDcmVkZW50aWFsc0ltcGwiLCJjcmVhdGVGcm9tU2VjdXJlQ29udGV4dCIsImNyZWF0ZUluc2VjdXJlIiwiSW5zZWN1cmVDaGFubmVsQ3JlZGVudGlhbHNJbXBsIiwiY29tcG9zZSIsIl9nZXRDb25uZWN0aW9uT3B0aW9ucyIsIl9pc1NlY3VyZSIsIl9lcXVhbHMiLCJvdGhlciIsImNvbm5lY3Rpb25PcHRpb25zIiwiY2hlY2tTZXJ2ZXJJZGVudGl0eSIsImNvbWJpbmVkQ2FsbENyZWRlbnRpYWxzIiwiQ29tcG9zZWRDaGFubmVsQ3JlZGVudGlhbHNJbXBsIiwiYXNzaWduIiwiY2hhbm5lbENyZWRlbnRpYWxzIiwiY2FsbENyZWRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel-options.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.channelOptionsEqual = exports.recognizedOptions = void 0;\n/**\n * This is for checking provided options at runtime. This is an object for\n * easier membership checking.\n */ exports.recognizedOptions = {\n    \"grpc.ssl_target_name_override\": true,\n    \"grpc.primary_user_agent\": true,\n    \"grpc.secondary_user_agent\": true,\n    \"grpc.default_authority\": true,\n    \"grpc.keepalive_time_ms\": true,\n    \"grpc.keepalive_timeout_ms\": true,\n    \"grpc.keepalive_permit_without_calls\": true,\n    \"grpc.service_config\": true,\n    \"grpc.max_concurrent_streams\": true,\n    \"grpc.initial_reconnect_backoff_ms\": true,\n    \"grpc.max_reconnect_backoff_ms\": true,\n    \"grpc.use_local_subchannel_pool\": true,\n    \"grpc.max_send_message_length\": true,\n    \"grpc.max_receive_message_length\": true,\n    \"grpc.enable_http_proxy\": true,\n    \"grpc.enable_channelz\": true,\n    \"grpc.dns_min_time_between_resolutions_ms\": true,\n    \"grpc-node.max_session_memory\": true\n};\nfunction channelOptionsEqual(options1, options2) {\n    const keys1 = Object.keys(options1).sort();\n    const keys2 = Object.keys(options2).sort();\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for(let i = 0; i < keys1.length; i += 1){\n        if (keys1[i] !== keys2[i]) {\n            return false;\n        }\n        if (options1[keys1[i]] !== options2[keys2[i]]) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.channelOptionsEqual = channelOptionsEqual; //# sourceMappingURL=channel-options.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwyQkFBMkIsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUMvRDs7O0NBR0MsR0FDREEseUJBQXlCLEdBQUc7SUFDeEIsaUNBQWlDO0lBQ2pDLDJCQUEyQjtJQUMzQiw2QkFBNkI7SUFDN0IsMEJBQTBCO0lBQzFCLDBCQUEwQjtJQUMxQiw2QkFBNkI7SUFDN0IsdUNBQXVDO0lBQ3ZDLHVCQUF1QjtJQUN2QiwrQkFBK0I7SUFDL0IscUNBQXFDO0lBQ3JDLGlDQUFpQztJQUNqQyxrQ0FBa0M7SUFDbEMsZ0NBQWdDO0lBQ2hDLG1DQUFtQztJQUNuQywwQkFBMEI7SUFDMUIsd0JBQXdCO0lBQ3hCLDRDQUE0QztJQUM1QyxnQ0FBZ0M7QUFDcEM7QUFDQSxTQUFTRSxvQkFBb0JFLFFBQVEsRUFBRUMsUUFBUTtJQUMzQyxNQUFNQyxRQUFRUixPQUFPUyxJQUFJLENBQUNILFVBQVVJLElBQUk7SUFDeEMsTUFBTUMsUUFBUVgsT0FBT1MsSUFBSSxDQUFDRixVQUFVRyxJQUFJO0lBQ3hDLElBQUlGLE1BQU1JLE1BQU0sS0FBS0QsTUFBTUMsTUFBTSxFQUFFO1FBQy9CLE9BQU87SUFDWDtJQUNBLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJTCxNQUFNSSxNQUFNLEVBQUVDLEtBQUssRUFBRztRQUN0QyxJQUFJTCxLQUFLLENBQUNLLEVBQUUsS0FBS0YsS0FBSyxDQUFDRSxFQUFFLEVBQUU7WUFDdkIsT0FBTztRQUNYO1FBQ0EsSUFBSVAsUUFBUSxDQUFDRSxLQUFLLENBQUNLLEVBQUUsQ0FBQyxLQUFLTixRQUFRLENBQUNJLEtBQUssQ0FBQ0UsRUFBRSxDQUFDLEVBQUU7WUFDM0MsT0FBTztRQUNYO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQVgsMkJBQTJCLEdBQUdFLHFCQUM5QiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC1vcHRpb25zLmpzPzc3NmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hhbm5lbE9wdGlvbnNFcXVhbCA9IGV4cG9ydHMucmVjb2duaXplZE9wdGlvbnMgPSB2b2lkIDA7XG4vKipcbiAqIFRoaXMgaXMgZm9yIGNoZWNraW5nIHByb3ZpZGVkIG9wdGlvbnMgYXQgcnVudGltZS4gVGhpcyBpcyBhbiBvYmplY3QgZm9yXG4gKiBlYXNpZXIgbWVtYmVyc2hpcCBjaGVja2luZy5cbiAqL1xuZXhwb3J0cy5yZWNvZ25pemVkT3B0aW9ucyA9IHtcbiAgICAnZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnOiB0cnVlLFxuICAgICdncnBjLnByaW1hcnlfdXNlcl9hZ2VudCc6IHRydWUsXG4gICAgJ2dycGMuc2Vjb25kYXJ5X3VzZXJfYWdlbnQnOiB0cnVlLFxuICAgICdncnBjLmRlZmF1bHRfYXV0aG9yaXR5JzogdHJ1ZSxcbiAgICAnZ3JwYy5rZWVwYWxpdmVfdGltZV9tcyc6IHRydWUsXG4gICAgJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnOiB0cnVlLFxuICAgICdncnBjLmtlZXBhbGl2ZV9wZXJtaXRfd2l0aG91dF9jYWxscyc6IHRydWUsXG4gICAgJ2dycGMuc2VydmljZV9jb25maWcnOiB0cnVlLFxuICAgICdncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnOiB0cnVlLFxuICAgICdncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnOiB0cnVlLFxuICAgICdncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyc6IHRydWUsXG4gICAgJ2dycGMudXNlX2xvY2FsX3N1YmNoYW5uZWxfcG9vbCc6IHRydWUsXG4gICAgJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnOiB0cnVlLFxuICAgICdncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJzogdHJ1ZSxcbiAgICAnZ3JwYy5lbmFibGVfaHR0cF9wcm94eSc6IHRydWUsXG4gICAgJ2dycGMuZW5hYmxlX2NoYW5uZWx6JzogdHJ1ZSxcbiAgICAnZ3JwYy5kbnNfbWluX3RpbWVfYmV0d2Vlbl9yZXNvbHV0aW9uc19tcyc6IHRydWUsXG4gICAgJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGNoYW5uZWxPcHRpb25zRXF1YWwob3B0aW9uczEsIG9wdGlvbnMyKSB7XG4gICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvcHRpb25zMSkuc29ydCgpO1xuICAgIGNvbnN0IGtleXMyID0gT2JqZWN0LmtleXMob3B0aW9uczIpLnNvcnQoKTtcbiAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMxLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGlmIChrZXlzMVtpXSAhPT0ga2V5czJbaV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9uczFba2V5czFbaV1dICE9PSBvcHRpb25zMltrZXlzMltpXV0pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydHMuY2hhbm5lbE9wdGlvbnNFcXVhbCA9IGNoYW5uZWxPcHRpb25zRXF1YWw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGFubmVsLW9wdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiY2hhbm5lbE9wdGlvbnNFcXVhbCIsInJlY29nbml6ZWRPcHRpb25zIiwib3B0aW9uczEiLCJvcHRpb25zMiIsImtleXMxIiwia2V5cyIsInNvcnQiLCJrZXlzMiIsImxlbmd0aCIsImkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channel.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChannelImplementation = void 0;\nconst call_stream_1 = __webpack_require__(/*! ./call-stream */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js\");\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nconst resolving_load_balancer_1 = __webpack_require__(/*! ./resolving-load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\");\nconst subchannel_pool_1 = __webpack_require__(/*! ./subchannel-pool */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nconst call_credentials_filter_1 = __webpack_require__(/*! ./call-credentials-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials-filter.js\");\nconst deadline_filter_1 = __webpack_require__(/*! ./deadline-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline-filter.js\");\nconst compression_filter_1 = __webpack_require__(/*! ./compression-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst max_message_size_filter_1 = __webpack_require__(/*! ./max-message-size-filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */ const MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\nfunction getNewCallNumber() {\n    const callNumber = nextCallNumber;\n    nextCallNumber += 1;\n    if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n        nextCallNumber = 0;\n    }\n    return callNumber;\n}\nconst INAPPROPRIATE_CONTROL_PLANE_CODES = [\n    constants_1.Status.OK,\n    constants_1.Status.INVALID_ARGUMENT,\n    constants_1.Status.NOT_FOUND,\n    constants_1.Status.ALREADY_EXISTS,\n    constants_1.Status.FAILED_PRECONDITION,\n    constants_1.Status.ABORTED,\n    constants_1.Status.OUT_OF_RANGE,\n    constants_1.Status.DATA_LOSS\n];\nfunction restrictControlPlaneStatusCode(code, details) {\n    if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {\n        return {\n            code: constants_1.Status.INTERNAL,\n            details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`\n        };\n    } else {\n        return {\n            code,\n            details\n        };\n    }\n}\nclass ChannelImplementation {\n    constructor(target, credentials, options){\n        var _a, _b, _c, _d;\n        this.credentials = credentials;\n        this.options = options;\n        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentPicker = new picker_1.UnavailablePicker();\n        /**\n         * Calls queued up to get a call config. Should only be populated before the\n         * first time the resolver returns a result, which includes the ConfigSelector.\n         */ this.configSelectionQueue = [];\n        this.pickQueue = [];\n        this.connectivityStateWatchers = [];\n        this.configSelector = null;\n        /**\n         * This is the error from the name resolver if it failed most recently. It\n         * is only used to end calls that start while there is no config selector\n         * and the name resolver is in backoff, so it should be nulled if\n         * configSelector becomes set or the channel state becomes anything other\n         * than TRANSIENT_FAILURE.\n         */ this.currentResolutionError = null;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        if (typeof target !== \"string\") {\n            throw new TypeError(\"Channel target must be a string\");\n        }\n        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n            throw new TypeError(\"Channel credentials must be a ChannelCredentials object\");\n        }\n        if (options) {\n            if (typeof options !== \"object\") {\n                throw new TypeError(\"Channel options must be an object\");\n            }\n        }\n        this.originalTarget = target;\n        const originalTargetUri = uri_parser_1.parseUri(target);\n        if (originalTargetUri === null) {\n            throw new Error(`Could not parse target name \"${target}\"`);\n        }\n        /* This ensures that the target has a scheme that is registered with the\n         * resolver */ const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n        if (defaultSchemeMapResult === null) {\n            throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n        }\n        this.callRefTimer = setInterval(()=>{}, MAX_TIMEOUT_TIME);\n        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        if (this.options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = channelz_1.registerChannelzChannel(target, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Channel created\");\n        }\n        if (this.options[\"grpc.default_authority\"]) {\n            this.defaultAuthority = this.options[\"grpc.default_authority\"];\n        } else {\n            this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n        }\n        const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n        this.target = proxyMapResult.target;\n        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n        /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n         * the grpc.use_local_subchannel_pool channel option means. */ this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options[\"grpc.use_local_subchannel_pool\"]) !== null && _c !== void 0 ? _c : 0) === 0);\n        const channelControlHelper = {\n            createSubchannel: (subchannelAddress, subchannelArgs)=>{\n                const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace(\"CT_INFO\", \"Created subchannel or used existing subchannel\", subchannel.getChannelzRef());\n                }\n                return subchannel;\n            },\n            updateState: (connectivityState, picker)=>{\n                this.currentPicker = picker;\n                const queueCopy = this.pickQueue.slice();\n                this.pickQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata, callConfig, dynamicFilters } of queueCopy){\n                    this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                }\n                this.updateState(connectivityState);\n            },\n            requestReresolution: ()=>{\n                // This should never be called.\n                throw new Error(\"Resolving load balancer should never call requestReresolution\");\n            },\n            addChannelzChild: (child)=>{\n                if (this.channelzEnabled) {\n                    this.childrenTracker.refChild(child);\n                }\n            },\n            removeChannelzChild: (child)=>{\n                if (this.channelzEnabled) {\n                    this.childrenTracker.unrefChild(child);\n                }\n            }\n        };\n        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (configSelector)=>{\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Address resolution succeeded\");\n            }\n            this.configSelector = configSelector;\n            this.currentResolutionError = null;\n            /* We process the queue asynchronously to ensure that the corresponding\n             * load balancer update has completed. */ process.nextTick(()=>{\n                const localQueue = this.configSelectionQueue;\n                this.configSelectionQueue = [];\n                this.callRefTimerUnref();\n                for (const { callStream, callMetadata } of localQueue){\n                    this.tryGetConfig(callStream, callMetadata);\n                }\n                this.configSelectionQueue = [];\n            });\n        }, (status)=>{\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_WARNING\", \"Address resolution failed with code \" + status.code + ' and details \"' + status.details + '\"');\n            }\n            if (this.configSelectionQueue.length > 0) {\n                this.trace(\"Name resolution failed with calls queued for config selection\");\n            }\n            if (this.configSelector === null) {\n                this.currentResolutionError = Object.assign(Object.assign({}, restrictControlPlaneStatusCode(status.code, status.details)), {\n                    metadata: status.metadata\n                });\n            }\n            const localQueue = this.configSelectionQueue;\n            this.configSelectionQueue = [];\n            this.callRefTimerUnref();\n            for (const { callStream, callMetadata } of localQueue){\n                if (callMetadata.getOptions().waitForReady) {\n                    this.callRefTimerRef();\n                    this.configSelectionQueue.push({\n                        callStream,\n                        callMetadata\n                    });\n                } else {\n                    callStream.cancelWithStatus(status.code, status.details);\n                }\n            }\n        });\n        this.filterStackFactory = new filter_stack_1.FilterStackFactory([\n            new call_credentials_filter_1.CallCredentialsFilterFactory(this),\n            new deadline_filter_1.DeadlineFilterFactory(this),\n            new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),\n            new compression_filter_1.CompressionFilterFactory(this, this.options)\n        ]);\n        this.trace(\"Channel constructed with options \" + JSON.stringify(options, undefined, 2));\n        const error = new Error();\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, \"channel_stacktrace\", \"(\" + this.channelzRef.id + \") \" + \"Channel constructed \\n\" + ((_d = error.stack) === null || _d === void 0 ? void 0 : _d.substring(error.stack.indexOf(\"\\n\") + 1)));\n    }\n    getChannelzInfo() {\n        return {\n            target: this.originalTarget,\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists()\n        };\n    }\n    trace(text, verbosityOverride) {\n        logging_1.trace(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, \"channel\", \"(\" + this.channelzRef.id + \") \" + uri_parser_1.uriToString(this.target) + \" \" + text);\n    }\n    callRefTimerRef() {\n        var _a, _b, _c, _d;\n        // If the hasRef function does not exist, always run the code\n        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            this.trace(\"callRefTimer.ref | configSelectionQueue.length=\" + this.configSelectionQueue.length + \" pickQueue.length=\" + this.pickQueue.length);\n            (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n        }\n    }\n    callRefTimerUnref() {\n        var _a, _b;\n        // If the hasRef function does not exist, always run the code\n        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n            this.trace(\"callRefTimer.unref | configSelectionQueue.length=\" + this.configSelectionQueue.length + \" pickQueue.length=\" + this.pickQueue.length);\n            (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    pushPick(callStream, callMetadata, callConfig, dynamicFilters) {\n        this.pickQueue.push({\n            callStream,\n            callMetadata,\n            callConfig,\n            dynamicFilters\n        });\n        this.callRefTimerRef();\n    }\n    /**\n     * Check the picker output for the given call and corresponding metadata,\n     * and take any relevant actions. Should not be called while iterating\n     * over pickQueue.\n     * @param callStream\n     * @param callMetadata\n     */ tryPick(callStream, callMetadata, callConfig, dynamicFilters) {\n        var _a, _b;\n        const pickResult = this.currentPicker.pick({\n            metadata: callMetadata,\n            extraPickInfo: callConfig.pickInformation\n        });\n        const subchannelString = pickResult.subchannel ? \"(\" + pickResult.subchannel.getChannelzRef().id + \") \" + pickResult.subchannel.getAddress() : \"\" + pickResult.subchannel;\n        this.trace(\"Pick result for call [\" + callStream.getCallNumber() + \"]: \" + picker_1.PickResultType[pickResult.pickResultType] + \" subchannel: \" + subchannelString + \" status: \" + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + \" \" + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n        switch(pickResult.pickResultType){\n            case picker_1.PickResultType.COMPLETE:\n                if (pickResult.subchannel === null) {\n                    callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, \"Request dropped by load balancing policy\");\n                // End the call with an error\n                } else {\n                    /* If the subchannel is not in the READY state, that indicates a bug\n                     * somewhere in the load balancer or picker. So, we log an error and\n                     * queue the pick to be tried again later. */ if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n                        logging_1.log(constants_1.LogVerbosity.ERROR, \"Error: COMPLETE pick result subchannel \" + subchannelString + \" has state \" + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n                        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                        break;\n                    }\n                    /* We need to clone the callMetadata here because the transparent\n                     * retry code in the promise resolution handler use the same\n                     * callMetadata object, so it needs to stay unmodified */ callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then((finalMetadata)=>{\n                        var _a, _b, _c;\n                        const subchannelState = pickResult.subchannel.getConnectivityState();\n                        if (subchannelState === connectivity_state_1.ConnectivityState.READY) {\n                            try {\n                                const pickExtraFilters = pickResult.extraFilterFactories.map((factory)=>factory.createFilter(callStream));\n                                (_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getRealSubchannel().startCallStream(finalMetadata, callStream, [\n                                    ...dynamicFilters,\n                                    ...pickExtraFilters\n                                ]);\n                                /* If we reach this point, the call stream has started\n                                 * successfully */ (_b = callConfig.onCommitted) === null || _b === void 0 ? void 0 : _b.call(callConfig);\n                                (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n                            } catch (error) {\n                                const errorCode = error.code;\n                                if (errorCode === \"ERR_HTTP2_GOAWAY_SESSION\" || errorCode === \"ERR_HTTP2_INVALID_SESSION\") {\n                                    /* An error here indicates that something went wrong with\n                                     * the picked subchannel's http2 stream right before we\n                                     * tried to start the stream. We are handling a promise\n                                     * result here, so this is asynchronous with respect to the\n                                     * original tryPick call, so calling it again is not\n                                     * recursive. We call tryPick immediately instead of\n                                     * queueing this pick again because handling the queue is\n                                     * triggered by state changes, and we want to immediately\n                                     * check if the state has already changed since the\n                                     * previous tryPick call. We do this instead of cancelling\n                                     * the stream because the correct behavior may be\n                                     * re-queueing instead, based on the logic in the rest of\n                                     * tryPick */ this.trace(\"Failed to start call on picked subchannel \" + subchannelString + \" with error \" + error.message + \". Retrying pick\", constants_1.LogVerbosity.INFO);\n                                    this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                                } else {\n                                    this.trace(\"Failed to start call on picked subchanel \" + subchannelString + \" with error \" + error.message + \". Ending call\", constants_1.LogVerbosity.INFO);\n                                    callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                                }\n                            }\n                        } else {\n                            /* The logic for doing this here is the same as in the catch\n                             * block above */ this.trace(\"Picked subchannel \" + subchannelString + \" has state \" + connectivity_state_1.ConnectivityState[subchannelState] + \" after metadata filters. Retrying pick\", constants_1.LogVerbosity.INFO);\n                            this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                        }\n                    }, (error)=>{\n                        // We assume the error code isn't 0 (Status.OK)\n                        const { code, details } = restrictControlPlaneStatusCode(typeof error.code === \"number\" ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n                        callStream.cancelWithStatus(code, details);\n                    });\n                }\n                break;\n            case picker_1.PickResultType.QUEUE:\n                this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                break;\n            case picker_1.PickResultType.TRANSIENT_FAILURE:\n                if (callMetadata.getOptions().waitForReady) {\n                    this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n                } else {\n                    const { code, details } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n                    callStream.cancelWithStatus(code, details);\n                }\n                break;\n            case picker_1.PickResultType.DROP:\n                const { code, details } = restrictControlPlaneStatusCode(pickResult.status.code, pickResult.status.details);\n                callStream.cancelWithStatus(code, details);\n                break;\n            default:\n                throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n        }\n    }\n    removeConnectivityStateWatcher(watcherObject) {\n        const watcherIndex = this.connectivityStateWatchers.findIndex((value)=>value === watcherObject);\n        if (watcherIndex >= 0) {\n            this.connectivityStateWatchers.splice(watcherIndex, 1);\n        }\n    }\n    updateState(newState) {\n        logging_1.trace(constants_1.LogVerbosity.DEBUG, \"connectivity_state\", \"(\" + this.channelzRef.id + \") \" + uri_parser_1.uriToString(this.target) + \" \" + connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        }\n        this.connectivityState = newState;\n        const watchersCopy = this.connectivityStateWatchers.slice();\n        for (const watcherObject of watchersCopy){\n            if (newState !== watcherObject.currentState) {\n                if (watcherObject.timer) {\n                    clearTimeout(watcherObject.timer);\n                }\n                this.removeConnectivityStateWatcher(watcherObject);\n                watcherObject.callback();\n            }\n        }\n        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            this.currentResolutionError = null;\n        }\n    }\n    tryGetConfig(stream, metadata) {\n        if (stream.getStatus() !== null) {\n            /* If the stream has a status, it has already finished and we don't need\n             * to take any more actions on it. */ return;\n        }\n        if (this.configSelector === null) {\n            /* This branch will only be taken at the beginning of the channel's life,\n             * before the resolver ever returns a result. So, the\n             * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n             * because it now has a pending request. */ this.resolvingLoadBalancer.exitIdle();\n            if (this.currentResolutionError && !metadata.getOptions().waitForReady) {\n                stream.cancelWithStatus(this.currentResolutionError.code, this.currentResolutionError.details);\n            } else {\n                this.configSelectionQueue.push({\n                    callStream: stream,\n                    callMetadata: metadata\n                });\n                this.callRefTimerRef();\n            }\n        } else {\n            const callConfig = this.configSelector(stream.getMethod(), metadata);\n            if (callConfig.status === constants_1.Status.OK) {\n                if (callConfig.methodConfig.timeout) {\n                    const deadline = new Date();\n                    deadline.setSeconds(deadline.getSeconds() + callConfig.methodConfig.timeout.seconds);\n                    deadline.setMilliseconds(deadline.getMilliseconds() + callConfig.methodConfig.timeout.nanos / 1000000);\n                    stream.setConfigDeadline(deadline);\n                    // Refreshing the filters makes the deadline filter pick up the new deadline\n                    stream.filterStack.refresh();\n                }\n                if (callConfig.dynamicFilterFactories.length > 0) {\n                    /* These dynamicFilters are the mechanism for implementing gRFC A39:\n                     * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n                     * We run them here instead of with the rest of the filters because\n                     * that spec says \"the xDS HTTP filters will run in between name\n                     * resolution and load balancing\".\n                     *\n                     * We use the filter stack here to simplify the multi-filter async\n                     * waterfall logic, but we pass along the underlying list of filters\n                     * to avoid having nested filter stacks when combining it with the\n                     * original filter stack. We do not pass along the original filter\n                     * factory list because these filters may need to persist data\n                     * between sending headers and other operations. */ const dynamicFilterStackFactory = new filter_stack_1.FilterStackFactory(callConfig.dynamicFilterFactories);\n                    const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n                    dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then((filteredMetadata)=>{\n                        this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n                    });\n                } else {\n                    this.tryPick(stream, metadata, callConfig, []);\n                }\n            } else {\n                const { code, details } = restrictControlPlaneStatusCode(callConfig.status, \"Failed to route call to method \" + stream.getMethod());\n                stream.cancelWithStatus(code, details);\n            }\n        }\n    }\n    _startCallStream(stream, metadata) {\n        this.tryGetConfig(stream, metadata.clone());\n    }\n    close() {\n        this.resolvingLoadBalancer.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n        clearInterval(this.callRefTimer);\n        if (this.channelzEnabled) {\n            channelz_1.unregisterChannelzRef(this.channelzRef);\n        }\n        this.subchannelPool.unrefUnusedSubchannels();\n    }\n    getTarget() {\n        return uri_parser_1.uriToString(this.target);\n    }\n    getConnectivityState(tryToConnect) {\n        const connectivityState = this.connectivityState;\n        if (tryToConnect) {\n            this.resolvingLoadBalancer.exitIdle();\n        }\n        return connectivityState;\n    }\n    watchConnectivityState(currentState, deadline, callback) {\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error(\"Channel has been shut down\");\n        }\n        let timer = null;\n        if (deadline !== Infinity) {\n            const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n            const now = new Date();\n            if (deadline === -Infinity || deadlineDate <= now) {\n                process.nextTick(callback, new Error(\"Deadline passed without connectivity state change\"));\n                return;\n            }\n            timer = setTimeout(()=>{\n                this.removeConnectivityStateWatcher(watcherObject);\n                callback(new Error(\"Deadline passed without connectivity state change\"));\n            }, deadlineDate.getTime() - now.getTime());\n        }\n        const watcherObject = {\n            currentState,\n            callback,\n            timer\n        };\n        this.connectivityStateWatchers.push(watcherObject);\n    }\n    /**\n     * Get the channelz reference object for this channel. The returned value is\n     * garbage if channelz is disabled for this channel.\n     * @returns\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    createCall(method, deadline, host, parentCall, propagateFlags) {\n        if (typeof method !== \"string\") {\n            throw new TypeError(\"Channel#createCall: method must be a string\");\n        }\n        if (!(typeof deadline === \"number\" || deadline instanceof Date)) {\n            throw new TypeError(\"Channel#createCall: deadline must be a number or Date\");\n        }\n        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n            throw new Error(\"Channel has been shut down\");\n        }\n        const callNumber = getNewCallNumber();\n        this.trace(\"createCall [\" + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n        const finalOptions = {\n            deadline: deadline,\n            flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n            host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n            parentCall: parentCall\n        };\n        const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            stream.addStatusWatcher((status)=>{\n                if (status.code === constants_1.Status.OK) {\n                    this.callTracker.addCallSucceeded();\n                } else {\n                    this.callTracker.addCallFailed();\n                }\n            });\n        }\n        return stream;\n    }\n}\nexports.ChannelImplementation = ChannelImplementation; //# sourceMappingURL=channel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxNQUFNRyxnQkFBZ0JDLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLE1BQU1DLHdCQUF3QkQsbUJBQU9BLENBQUMsa0dBQXVCO0FBQzdELE1BQU1FLDRCQUE0QkYsbUJBQU9BLENBQUMsMEdBQTJCO0FBQ3JFLE1BQU1HLG9CQUFvQkgsbUJBQU9BLENBQUMsMEZBQW1CO0FBQ3JELE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1NLGlCQUFpQk4sbUJBQU9BLENBQUMsb0ZBQWdCO0FBQy9DLE1BQU1PLDRCQUE0QlAsbUJBQU9BLENBQUMsMEdBQTJCO0FBQ3JFLE1BQU1RLG9CQUFvQlIsbUJBQU9BLENBQUMsMEZBQW1CO0FBQ3JELE1BQU1TLHVCQUF1QlQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1VLGFBQWFWLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1XLFlBQVlYLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ3JDLE1BQU1ZLDRCQUE0QlosbUJBQU9BLENBQUMsMEdBQTJCO0FBQ3JFLE1BQU1hLGVBQWViLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1jLGVBQWVkLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1lLHVCQUF1QmYsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1nQixhQUFhaEIsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkM7O0NBRUMsR0FDRCxNQUFNaUIsbUJBQW1CO0FBQ3pCLElBQUlDLGlCQUFpQjtBQUNyQixTQUFTQztJQUNMLE1BQU1DLGFB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LGNBQWNzUCxlQUFlLENBQUNSLFFBQVEsSUFBSSxFQUFFSSxjQUFjLElBQUksQ0FBQ3BILGtCQUFrQixFQUFFLElBQUksQ0FBQ3JGLFdBQVcsQ0FBQzhNLG1CQUFtQixJQUFJbE87UUFDOUksSUFBSSxJQUFJLENBQUNvQyxlQUFlLEVBQUU7WUFDdEIsSUFBSSxDQUFDQyxXQUFXLENBQUM4TCxjQUFjO1lBQy9CL0MsT0FBT2dELGdCQUFnQixDQUFDcEksQ0FBQUE7Z0JBQ3BCLElBQUlBLE9BQU9sRixJQUFJLEtBQUs3QixZQUFZbUIsTUFBTSxDQUFDQyxFQUFFLEVBQUU7b0JBQ3ZDLElBQUksQ0FBQ2dDLFdBQVcsQ0FBQ2dNLGdCQUFnQjtnQkFDckMsT0FDSztvQkFDRCxJQUFJLENBQUNoTSxXQUFXLENBQUNpTSxhQUFhO2dCQUNsQztZQUNKO1FBQ0o7UUFDQSxPQUFPbEQ7SUFDWDtBQUNKO0FBQ0E1TSw2QkFBNkIsR0FBR0UsdUJBQ2hDLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jaGFubmVsLmpzP2NkOGEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hhbm5lbEltcGxlbWVudGF0aW9uID0gdm9pZCAwO1xuY29uc3QgY2FsbF9zdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2NhbGwtc3RyZWFtXCIpO1xuY29uc3QgY2hhbm5lbF9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vY2hhbm5lbC1jcmVkZW50aWFsc1wiKTtcbmNvbnN0IHJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZpbmctbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfcG9vbF8xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1wb29sXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xuY29uc3QgY2FsbF9jcmVkZW50aWFsc19maWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2NhbGwtY3JlZGVudGlhbHMtZmlsdGVyXCIpO1xuY29uc3QgZGVhZGxpbmVfZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9kZWFkbGluZS1maWx0ZXJcIik7XG5jb25zdCBjb21wcmVzc2lvbl9maWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2NvbXByZXNzaW9uLWZpbHRlclwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBtYXhfbWVzc2FnZV9zaXplX2ZpbHRlcl8xID0gcmVxdWlyZShcIi4vbWF4LW1lc3NhZ2Utc2l6ZS1maWx0ZXJcIik7XG5jb25zdCBodHRwX3Byb3h5XzEgPSByZXF1aXJlKFwiLi9odHRwX3Byb3h5XCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgY2hhbm5lbHpfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuLyoqXG4gKiBTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lcnNfc2V0aW50ZXJ2YWxfY2FsbGJhY2tfZGVsYXlfYXJnc1xuICovXG5jb25zdCBNQVhfVElNRU9VVF9USU1FID0gMjE0NzQ4MzY0NztcbmxldCBuZXh0Q2FsbE51bWJlciA9IDA7XG5mdW5jdGlvbiBnZXROZXdDYWxsTnVtYmVyKCkge1xuICAgIGNvbnN0IGNhbGxOdW1iZXIgPSBuZXh0Q2FsbE51bWJlcjtcbiAgICBuZXh0Q2FsbE51bWJlciArPSAxO1xuICAgIGlmIChuZXh0Q2FsbE51bWJlciA+PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICBuZXh0Q2FsbE51bWJlciA9IDA7XG4gICAgfVxuICAgIHJldHVybiBjYWxsTnVtYmVyO1xufVxuY29uc3QgSU5BUFBST1BSSUFURV9DT05UUk9MX1BMQU5FX0NPREVTID0gW1xuICAgIGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuSU5WQUxJRF9BUkdVTUVOVCxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5BTFJFQURZX0VYSVNUUyxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuRkFJTEVEX1BSRUNPTkRJVElPTixcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuQUJPUlRFRCxcbiAgICBjb25zdGFudHNfMS5TdGF0dXMuT1VUX09GX1JBTkdFLFxuICAgIGNvbnN0YW50c18xLlN0YXR1cy5EQVRBX0xPU1Ncbl07XG5mdW5jdGlvbiByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUoY29kZSwgZGV0YWlscykge1xuICAgIGlmIChJTkFQUFJPUFJJQVRFX0NPTlRST0xfUExBTkVfQ09ERVMuaW5jbHVkZXMoY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgIGRldGFpbHM6IGBJbnZhbGlkIHN0YXR1cyBmcm9tIGNvbnRyb2wgcGxhbmU6ICR7Y29kZX0gJHtjb25zdGFudHNfMS5TdGF0dXNbY29kZV19ICR7ZGV0YWlsc31gXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBjb2RlLCBkZXRhaWxzIH07XG4gICAgfVxufVxuY2xhc3MgQ2hhbm5lbEltcGxlbWVudGF0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNyZWRlbnRpYWxzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5jdXJyZW50UGlja2VyID0gbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxscyBxdWV1ZWQgdXAgdG8gZ2V0IGEgY2FsbCBjb25maWcuIFNob3VsZCBvbmx5IGJlIHBvcHVsYXRlZCBiZWZvcmUgdGhlXG4gICAgICAgICAqIGZpcnN0IHRpbWUgdGhlIHJlc29sdmVyIHJldHVybnMgYSByZXN1bHQsIHdoaWNoIGluY2x1ZGVzIHRoZSBDb25maWdTZWxlY3Rvci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5waWNrUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzID0gW107XG4gICAgICAgIHRoaXMuY29uZmlnU2VsZWN0b3IgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBpcyB0aGUgZXJyb3IgZnJvbSB0aGUgbmFtZSByZXNvbHZlciBpZiBpdCBmYWlsZWQgbW9zdCByZWNlbnRseS4gSXRcbiAgICAgICAgICogaXMgb25seSB1c2VkIHRvIGVuZCBjYWxscyB0aGF0IHN0YXJ0IHdoaWxlIHRoZXJlIGlzIG5vIGNvbmZpZyBzZWxlY3RvclxuICAgICAgICAgKiBhbmQgdGhlIG5hbWUgcmVzb2x2ZXIgaXMgaW4gYmFja29mZiwgc28gaXQgc2hvdWxkIGJlIG51bGxlZCBpZlxuICAgICAgICAgKiBjb25maWdTZWxlY3RvciBiZWNvbWVzIHNldCBvciB0aGUgY2hhbm5lbCBzdGF0ZSBiZWNvbWVzIGFueXRoaW5nIG90aGVyXG4gICAgICAgICAqIHRoYW4gVFJBTlNJRU5UX0ZBSUxVUkUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgPSBudWxsO1xuICAgICAgICAvLyBDaGFubmVseiBpbmZvXG4gICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jYWxsVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVsekNoaWxkcmVuVHJhY2tlcigpO1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NoYW5uZWwgdGFyZ2V0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShjcmVkZW50aWFscyBpbnN0YW5jZW9mIGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIGNyZWRlbnRpYWxzIG11c3QgYmUgYSBDaGFubmVsQ3JlZGVudGlhbHMgb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsIG9wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9yaWdpbmFsVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICBjb25zdCBvcmlnaW5hbFRhcmdldFVyaSA9IHVyaV9wYXJzZXJfMS5wYXJzZVVyaSh0YXJnZXQpO1xuICAgICAgICBpZiAob3JpZ2luYWxUYXJnZXRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBUaGlzIGVuc3VyZXMgdGhhdCB0aGUgdGFyZ2V0IGhhcyBhIHNjaGVtZSB0aGF0IGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGVcbiAgICAgICAgICogcmVzb2x2ZXIgKi9cbiAgICAgICAgY29uc3QgZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCA9IHJlc29sdmVyXzEubWFwVXJpRGVmYXVsdFNjaGVtZShvcmlnaW5hbFRhcmdldFVyaSk7XG4gICAgICAgIGlmIChkZWZhdWx0U2NoZW1lTWFwUmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGEgZGVmYXVsdCBzY2hlbWUgZm9yIHRhcmdldCBuYW1lIFwiJHt0YXJnZXR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxSZWZUaW1lciA9IHNldEludGVydmFsKCgpID0+IHsgfSwgTUFYX1RJTUVPVVRfVElNRSk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLmVuYWJsZV9jaGFubmVseiddID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6RW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZSA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6VHJhY2UoKTtcbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9IGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwodGFyZ2V0LCAoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ0NoYW5uZWwgY3JlYXRlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZGVmYXVsdF9hdXRob3JpdHknXSkge1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0QXV0aG9yaXR5ID0gdGhpcy5vcHRpb25zWydncnBjLmRlZmF1bHRfYXV0aG9yaXR5J107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRBdXRob3JpdHkgPSByZXNvbHZlcl8xLmdldERlZmF1bHRBdXRob3JpdHkoZGVmYXVsdFNjaGVtZU1hcFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJveHlNYXBSZXN1bHQgPSBodHRwX3Byb3h5XzEubWFwUHJveHlOYW1lKGRlZmF1bHRTY2hlbWVNYXBSZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHByb3h5TWFwUmVzdWx0LnRhcmdldDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zLCBwcm94eU1hcFJlc3VsdC5leHRyYU9wdGlvbnMpO1xuICAgICAgICAvKiBUaGUgZ2xvYmFsIGJvb2xlYW4gcGFyYW1ldGVyIHRvIGdldFN1YmNoYW5uZWxQb29sIGhhcyB0aGUgaW52ZXJzZSBtZWFuaW5nIHRvIHdoYXRcbiAgICAgICAgICogdGhlIGdycGMudXNlX2xvY2FsX3N1YmNoYW5uZWxfcG9vbCBjaGFubmVsIG9wdGlvbiBtZWFucy4gKi9cbiAgICAgICAgdGhpcy5zdWJjaGFubmVsUG9vbCA9IHN1YmNoYW5uZWxfcG9vbF8xLmdldFN1YmNoYW5uZWxQb29sKCgoX2MgPSBvcHRpb25zWydncnBjLnVzZV9sb2NhbF9zdWJjaGFubmVsX3Bvb2wnXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCkgPT09IDApO1xuICAgICAgICBjb25zdCBjaGFubmVsQ29udHJvbEhlbHBlciA9IHtcbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJjaGFubmVsID0gdGhpcy5zdWJjaGFubmVsUG9vbC5nZXRPckNyZWF0ZVN1YmNoYW5uZWwodGhpcy50YXJnZXQsIHN1YmNoYW5uZWxBZGRyZXNzLCBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIHN1YmNoYW5uZWxBcmdzKSwgdGhpcy5jcmVkZW50aWFscyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDcmVhdGVkIHN1YmNoYW5uZWwgb3IgdXNlZCBleGlzdGluZyBzdWJjaGFubmVsJywgc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50UGlja2VyID0gcGlja2VyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXVlQ29weSA9IHRoaXMucGlja1F1ZXVlLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5waWNrUXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxSZWZUaW1lclVucmVmKCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMgfSBvZiBxdWV1ZUNvcHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlQaWNrKGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1ZXN0UmVyZXNvbHV0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBzaG91bGQgbmV2ZXIgYmUgY2FsbGVkLlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzb2x2aW5nIGxvYWQgYmFsYW5jZXIgc2hvdWxkIG5ldmVyIGNhbGwgcmVxdWVzdFJlcmVzb2x1dGlvbicpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQ6IChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci5yZWZDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQ6IChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVzb2x2aW5nTG9hZEJhbGFuY2VyID0gbmV3IHJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEuUmVzb2x2aW5nTG9hZEJhbGFuY2VyKHRoaXMudGFyZ2V0LCBjaGFubmVsQ29udHJvbEhlbHBlciwgb3B0aW9ucywgKGNvbmZpZ1NlbGVjdG9yKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQWRkcmVzcyByZXNvbHV0aW9uIHN1Y2NlZWRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3RvciA9IGNvbmZpZ1NlbGVjdG9yO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIC8qIFdlIHByb2Nlc3MgdGhlIHF1ZXVlIGFzeW5jaHJvbm91c2x5IHRvIGVuc3VyZSB0aGF0IHRoZSBjb3JyZXNwb25kaW5nXG4gICAgICAgICAgICAgKiBsb2FkIGJhbGFuY2VyIHVwZGF0ZSBoYXMgY29tcGxldGVkLiAqL1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxRdWV1ZSA9IHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyVW5yZWYoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHsgY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhIH0gb2YgbG9jYWxRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyeUdldENvbmZpZyhjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlID0gW107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9XQVJOSU5HJywgJ0FkZHJlc3MgcmVzb2x1dGlvbiBmYWlsZWQgd2l0aCBjb2RlICcgKyBzdGF0dXMuY29kZSArICcgYW5kIGRldGFpbHMgXCInICsgc3RhdHVzLmRldGFpbHMgKyAnXCInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZ1NlbGVjdGlvblF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdOYW1lIHJlc29sdXRpb24gZmFpbGVkIHdpdGggY2FsbHMgcXVldWVkIGZvciBjb25maWcgc2VsZWN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWdTZWxlY3RvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlKHN0YXR1cy5jb2RlLCBzdGF0dXMuZGV0YWlscykpLCB7IG1ldGFkYXRhOiBzdGF0dXMubWV0YWRhdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb2NhbFF1ZXVlID0gdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZTtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyVW5yZWYoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEgfSBvZiBsb2NhbFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxNZXRhZGF0YS5nZXRPcHRpb25zKCkud2FpdEZvclJlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyUmVmKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnU2VsZWN0aW9uUXVldWUucHVzaCh7IGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMuY29kZSwgc3RhdHVzLmRldGFpbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmlsdGVyU3RhY2tGYWN0b3J5ID0gbmV3IGZpbHRlcl9zdGFja18xLkZpbHRlclN0YWNrRmFjdG9yeShbXG4gICAgICAgICAgICBuZXcgY2FsbF9jcmVkZW50aWFsc19maWx0ZXJfMS5DYWxsQ3JlZGVudGlhbHNGaWx0ZXJGYWN0b3J5KHRoaXMpLFxuICAgICAgICAgICAgbmV3IGRlYWRsaW5lX2ZpbHRlcl8xLkRlYWRsaW5lRmlsdGVyRmFjdG9yeSh0aGlzKSxcbiAgICAgICAgICAgIG5ldyBtYXhfbWVzc2FnZV9zaXplX2ZpbHRlcl8xLk1heE1lc3NhZ2VTaXplRmlsdGVyRmFjdG9yeSh0aGlzLm9wdGlvbnMpLFxuICAgICAgICAgICAgbmV3IGNvbXByZXNzaW9uX2ZpbHRlcl8xLkNvbXByZXNzaW9uRmlsdGVyRmFjdG9yeSh0aGlzLCB0aGlzLm9wdGlvbnMpLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy50cmFjZSgnQ2hhbm5lbCBjb25zdHJ1Y3RlZCB3aXRoIG9wdGlvbnMgJyArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIHVuZGVmaW5lZCwgMikpO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBsb2dnaW5nXzEudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnY2hhbm5lbF9zdGFja3RyYWNlJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyAnQ2hhbm5lbCBjb25zdHJ1Y3RlZCBcXG4nICsgKChfZCA9IGVycm9yLnN0YWNrKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc3Vic3RyaW5nKGVycm9yLnN0YWNrLmluZGV4T2YoJ1xcbicpICsgMSkpKTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpJbmZvKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLm9yaWdpbmFsVGFyZ2V0LFxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY29ubmVjdGl2aXR5U3RhdGUsXG4gICAgICAgICAgICB0cmFjZTogdGhpcy5jaGFubmVselRyYWNlLFxuICAgICAgICAgICAgY2FsbFRyYWNrZXI6IHRoaXMuY2FsbFRyYWNrZXIsXG4gICAgICAgICAgICBjaGlsZHJlbjogdGhpcy5jaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRyYWNlKHRleHQsIHZlcmJvc2l0eU92ZXJyaWRlKSB7XG4gICAgICAgIGxvZ2dpbmdfMS50cmFjZSh2ZXJib3NpdHlPdmVycmlkZSAhPT0gbnVsbCAmJiB2ZXJib3NpdHlPdmVycmlkZSAhPT0gdm9pZCAwID8gdmVyYm9zaXR5T3ZlcnJpZGUgOiBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjaGFubmVsJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGNhbGxSZWZUaW1lclJlZigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAvLyBJZiB0aGUgaGFzUmVmIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LCBhbHdheXMgcnVuIHRoZSBjb2RlXG4gICAgICAgIGlmICghKChfYiA9IChfYSA9IHRoaXMuY2FsbFJlZlRpbWVyKS5oYXNSZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NhbGxSZWZUaW1lci5yZWYgfCBjb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICcgcGlja1F1ZXVlLmxlbmd0aD0nICtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgKF9kID0gKF9jID0gdGhpcy5jYWxsUmVmVGltZXIpLnJlZikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxSZWZUaW1lclVucmVmKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBJZiB0aGUgaGFzUmVmIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0LCBhbHdheXMgcnVuIHRoZSBjb2RlXG4gICAgICAgIGlmICghdGhpcy5jYWxsUmVmVGltZXIuaGFzUmVmIHx8IHRoaXMuY2FsbFJlZlRpbWVyLmhhc1JlZigpKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjYWxsUmVmVGltZXIudW5yZWYgfCBjb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGg9JyArXG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5sZW5ndGggK1xuICAgICAgICAgICAgICAgICcgcGlja1F1ZXVlLmxlbmd0aD0nICtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tRdWV1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jYWxsUmVmVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHVzaFBpY2soY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhLCBjYWxsQ29uZmlnLCBkeW5hbWljRmlsdGVycykge1xuICAgICAgICB0aGlzLnBpY2tRdWV1ZS5wdXNoKHsgY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhLCBjYWxsQ29uZmlnLCBkeW5hbWljRmlsdGVycyB9KTtcbiAgICAgICAgdGhpcy5jYWxsUmVmVGltZXJSZWYoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgdGhlIHBpY2tlciBvdXRwdXQgZm9yIHRoZSBnaXZlbiBjYWxsIGFuZCBjb3JyZXNwb25kaW5nIG1ldGFkYXRhLFxuICAgICAqIGFuZCB0YWtlIGFueSByZWxldmFudCBhY3Rpb25zLiBTaG91bGQgbm90IGJlIGNhbGxlZCB3aGlsZSBpdGVyYXRpbmdcbiAgICAgKiBvdmVyIHBpY2tRdWV1ZS5cbiAgICAgKiBAcGFyYW0gY2FsbFN0cmVhbVxuICAgICAqIEBwYXJhbSBjYWxsTWV0YWRhdGFcbiAgICAgKi9cbiAgICB0cnlQaWNrKGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgcGlja1Jlc3VsdCA9IHRoaXMuY3VycmVudFBpY2tlci5waWNrKHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjYWxsTWV0YWRhdGEsXG4gICAgICAgICAgICBleHRyYVBpY2tJbmZvOiBjYWxsQ29uZmlnLnBpY2tJbmZvcm1hdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdHJpbmcgPSBwaWNrUmVzdWx0LnN1YmNoYW5uZWwgP1xuICAgICAgICAgICAgJygnICsgcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkuaWQgKyAnKSAnICsgcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldEFkZHJlc3MoKSA6XG4gICAgICAgICAgICAnJyArIHBpY2tSZXN1bHQuc3ViY2hhbm5lbDtcbiAgICAgICAgdGhpcy50cmFjZSgnUGljayByZXN1bHQgZm9yIGNhbGwgWycgK1xuICAgICAgICAgICAgY2FsbFN0cmVhbS5nZXRDYWxsTnVtYmVyKCkgK1xuICAgICAgICAgICAgJ106ICcgK1xuICAgICAgICAgICAgcGlja2VyXzEuUGlja1Jlc3VsdFR5cGVbcGlja1Jlc3VsdC5waWNrUmVzdWx0VHlwZV0gK1xuICAgICAgICAgICAgJyBzdWJjaGFubmVsOiAnICtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgJyBzdGF0dXM6ICcgKyAoKF9hID0gcGlja1Jlc3VsdC5zdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSArXG4gICAgICAgICAgICAnICcgKyAoKF9iID0gcGlja1Jlc3VsdC5zdGF0dXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXRhaWxzKSk7XG4gICAgICAgIHN3aXRjaCAocGlja1Jlc3VsdC5waWNrUmVzdWx0VHlwZSkge1xuICAgICAgICAgICAgY2FzZSBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURTpcbiAgICAgICAgICAgICAgICBpZiAocGlja1Jlc3VsdC5zdWJjaGFubmVsID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsICdSZXF1ZXN0IGRyb3BwZWQgYnkgbG9hZCBiYWxhbmNpbmcgcG9saWN5Jyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuZCB0aGUgY2FsbCB3aXRoIGFuIGVycm9yXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBJZiB0aGUgc3ViY2hhbm5lbCBpcyBub3QgaW4gdGhlIFJFQURZIHN0YXRlLCB0aGF0IGluZGljYXRlcyBhIGJ1Z1xuICAgICAgICAgICAgICAgICAgICAgKiBzb21ld2hlcmUgaW4gdGhlIGxvYWQgYmFsYW5jZXIgb3IgcGlja2VyLiBTbywgd2UgbG9nIGFuIGVycm9yIGFuZFxuICAgICAgICAgICAgICAgICAgICAgKiBxdWV1ZSB0aGUgcGljayB0byBiZSB0cmllZCBhZ2FpbiBsYXRlci4gKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpICE9PVxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRXJyb3I6IENPTVBMRVRFIHBpY2sgcmVzdWx0IHN1YmNoYW5uZWwgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBoYXMgc3RhdGUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbcGlja1Jlc3VsdC5zdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaFBpY2soY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhLCBjYWxsQ29uZmlnLCBkeW5hbWljRmlsdGVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKiBXZSBuZWVkIHRvIGNsb25lIHRoZSBjYWxsTWV0YWRhdGEgaGVyZSBiZWNhdXNlIHRoZSB0cmFuc3BhcmVudFxuICAgICAgICAgICAgICAgICAgICAgKiByZXRyeSBjb2RlIGluIHRoZSBwcm9taXNlIHJlc29sdXRpb24gaGFuZGxlciB1c2UgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAgICAgICogY2FsbE1ldGFkYXRhIG9iamVjdCwgc28gaXQgbmVlZHMgdG8gc3RheSB1bm1vZGlmaWVkICovXG4gICAgICAgICAgICAgICAgICAgIGNhbGxTdHJlYW0uZmlsdGVyU3RhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zZW5kTWV0YWRhdGEoUHJvbWlzZS5yZXNvbHZlKGNhbGxNZXRhZGF0YS5jbG9uZSgpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChmaW5hbE1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IHBpY2tSZXN1bHQuc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWxTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwaWNrRXh0cmFGaWx0ZXJzID0gcGlja1Jlc3VsdC5leHRyYUZpbHRlckZhY3Rvcmllcy5tYXAoZmFjdG9yeSA9PiBmYWN0b3J5LmNyZWF0ZUZpbHRlcihjYWxsU3RyZWFtKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IHBpY2tSZXN1bHQuc3ViY2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFJlYWxTdWJjaGFubmVsKCkuc3RhcnRDYWxsU3RyZWFtKGZpbmFsTWV0YWRhdGEsIGNhbGxTdHJlYW0sIFsuLi5keW5hbWljRmlsdGVycywgLi4ucGlja0V4dHJhRmlsdGVyc10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBJZiB3ZSByZWFjaCB0aGlzIHBvaW50LCB0aGUgY2FsbCBzdHJlYW0gaGFzIHN0YXJ0ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogc3VjY2Vzc2Z1bGx5ICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGNhbGxDb25maWcub25Db21taXR0ZWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKGNhbGxDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2MgPSBwaWNrUmVzdWx0Lm9uQ2FsbFN0YXJ0ZWQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHBpY2tSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JDb2RlID0gZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gJ0VSUl9IVFRQMl9HT0FXQVlfU0VTU0lPTicgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQ29kZSA9PT0gJ0VSUl9IVFRQMl9JTlZBTElEX1NFU1NJT04nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBBbiBlcnJvciBoZXJlIGluZGljYXRlcyB0aGF0IHNvbWV0aGluZyB3ZW50IHdyb25nIHdpdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRoZSBwaWNrZWQgc3ViY2hhbm5lbCdzIGh0dHAyIHN0cmVhbSByaWdodCBiZWZvcmUgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRyaWVkIHRvIHN0YXJ0IHRoZSBzdHJlYW0uIFdlIGFyZSBoYW5kbGluZyBhIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHJlc3VsdCBoZXJlLCBzbyB0aGlzIGlzIGFzeW5jaHJvbm91cyB3aXRoIHJlc3BlY3QgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBvcmlnaW5hbCB0cnlQaWNrIGNhbGwsIHNvIGNhbGxpbmcgaXQgYWdhaW4gaXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiByZWN1cnNpdmUuIFdlIGNhbGwgdHJ5UGljayBpbW1lZGlhdGVseSBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBxdWV1ZWluZyB0aGlzIHBpY2sgYWdhaW4gYmVjYXVzZSBoYW5kbGluZyB0aGUgcXVldWUgaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRyaWdnZXJlZCBieSBzdGF0ZSBjaGFuZ2VzLCBhbmQgd2Ugd2FudCB0byBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogY2hlY2sgaWYgdGhlIHN0YXRlIGhhcyBhbHJlYWR5IGNoYW5nZWQgc2luY2UgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBwcmV2aW91cyB0cnlQaWNrIGNhbGwuIFdlIGRvIHRoaXMgaW5zdGVhZCBvZiBjYW5jZWxsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgc3RyZWFtIGJlY2F1c2UgdGhlIGNvcnJlY3QgYmVoYXZpb3IgbWF5IGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiByZS1xdWV1ZWluZyBpbnN0ZWFkLCBiYXNlZCBvbiB0aGUgbG9naWMgaW4gdGhlIHJlc3Qgb2ZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIHRyeVBpY2sgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZhaWxlZCB0byBzdGFydCBjYWxsIG9uIHBpY2tlZCBzdWJjaGFubmVsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdHJpbmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgd2l0aCBlcnJvciAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLiBSZXRyeWluZyBwaWNrJywgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cnlQaWNrKGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIHN0YXJ0IGNhbGwgb24gcGlja2VkIHN1YmNoYW5lbCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJy4gRW5kaW5nIGNhbGwnLCBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsU3RyZWFtLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCBgRmFpbGVkIHRvIHN0YXJ0IEhUVFAvMiBzdHJlYW0gd2l0aCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogVGhlIGxvZ2ljIGZvciBkb2luZyB0aGlzIGhlcmUgaXMgdGhlIHNhbWUgYXMgaW4gdGhlIGNhdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYmxvY2sgYWJvdmUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdQaWNrZWQgc3ViY2hhbm5lbCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFN0cmluZyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaGFzIHN0YXRlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtzdWJjaGFubmVsU3RhdGVdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJyBhZnRlciBtZXRhZGF0YSBmaWx0ZXJzLiBSZXRyeWluZyBwaWNrJywgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5UGljayhjYWxsU3RyZWFtLCBjYWxsTWV0YWRhdGEsIGNhbGxDb25maWcsIGR5bmFtaWNGaWx0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhlIGVycm9yIGNvZGUgaXNuJ3QgMCAoU3RhdHVzLk9LKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUodHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInID8gZXJyb3IuY29kZSA6IGNvbnN0YW50c18xLlN0YXR1cy5VTktOT1dOLCBgR2V0dGluZyBtZXRhZGF0YSBmcm9tIHBsdWdpbiBmYWlsZWQgd2l0aCBlcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvZGUsIGRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLlFVRVVFOlxuICAgICAgICAgICAgICAgIHRoaXMucHVzaFBpY2soY2FsbFN0cmVhbSwgY2FsbE1ldGFkYXRhLCBjYWxsQ29uZmlnLCBkeW5hbWljRmlsdGVycyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLlRSQU5TSUVOVF9GQUlMVVJFOlxuICAgICAgICAgICAgICAgIGlmIChjYWxsTWV0YWRhdGEuZ2V0T3B0aW9ucygpLndhaXRGb3JSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hQaWNrKGNhbGxTdHJlYW0sIGNhbGxNZXRhZGF0YSwgY2FsbENvbmZpZywgZHluYW1pY0ZpbHRlcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUocGlja1Jlc3VsdC5zdGF0dXMuY29kZSwgcGlja1Jlc3VsdC5zdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxTdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyhjb2RlLCBkZXRhaWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHBpY2tlcl8xLlBpY2tSZXN1bHRUeXBlLkRST1A6XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUocGlja1Jlc3VsdC5zdGF0dXMuY29kZSwgcGlja1Jlc3VsdC5zdGF0dXMuZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvZGUsIGRldGFpbHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGU6IHVua25vd24gcGlja1Jlc3VsdFR5cGUgJHtwaWNrUmVzdWx0LnBpY2tSZXN1bHRUeXBlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcih3YXRjaGVyT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IHdhdGNoZXJJbmRleCA9IHRoaXMuY29ubmVjdGl2aXR5U3RhdGVXYXRjaGVycy5maW5kSW5kZXgoKHZhbHVlKSA9PiB2YWx1ZSA9PT0gd2F0Y2hlck9iamVjdCk7XG4gICAgICAgIGlmICh3YXRjaGVySW5kZXggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLnNwbGljZSh3YXRjaGVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIGxvZ2dpbmdfMS50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdjb25uZWN0aXZpdHlfc3RhdGUnLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArXG4gICAgICAgICAgICB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmNvbm5lY3Rpdml0eVN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmNvbm5lY3Rpdml0eVN0YXRlXSArICcgLT4gJyArIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBjb25zdCB3YXRjaGVyc0NvcHkgPSB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlV2F0Y2hlcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yIChjb25zdCB3YXRjaGVyT2JqZWN0IG9mIHdhdGNoZXJzQ29weSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB3YXRjaGVyT2JqZWN0LmN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmICh3YXRjaGVyT2JqZWN0LnRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh3YXRjaGVyT2JqZWN0LnRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXIod2F0Y2hlck9iamVjdCk7XG4gICAgICAgICAgICAgICAgd2F0Y2hlck9iamVjdC5jYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb25FcnJvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5R2V0Q29uZmlnKHN0cmVhbSwgbWV0YWRhdGEpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5nZXRTdGF0dXMoKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLyogSWYgdGhlIHN0cmVhbSBoYXMgYSBzdGF0dXMsIGl0IGhhcyBhbHJlYWR5IGZpbmlzaGVkIGFuZCB3ZSBkb24ndCBuZWVkXG4gICAgICAgICAgICAgKiB0byB0YWtlIGFueSBtb3JlIGFjdGlvbnMgb24gaXQuICovXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnU2VsZWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qIFRoaXMgYnJhbmNoIHdpbGwgb25seSBiZSB0YWtlbiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjaGFubmVsJ3MgbGlmZSxcbiAgICAgICAgICAgICAqIGJlZm9yZSB0aGUgcmVzb2x2ZXIgZXZlciByZXR1cm5zIGEgcmVzdWx0LiBTbywgdGhlXG4gICAgICAgICAgICAgKiBSZXNvbHZpbmdMb2FkQmFsYW5jZXIgbWF5IGJlIGlkbGUgYW5kIGlmIHNvIGl0IG5lZWRzIHRvIGJlIGtpY2tlZFxuICAgICAgICAgICAgICogYmVjYXVzZSBpdCBub3cgaGFzIGEgcGVuZGluZyByZXF1ZXN0LiAqL1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IgJiYgIW1ldGFkYXRhLmdldE9wdGlvbnMoKS53YWl0Rm9yUmVhZHkpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0uY2FuY2VsV2l0aFN0YXR1cyh0aGlzLmN1cnJlbnRSZXNvbHV0aW9uRXJyb3IuY29kZSwgdGhpcy5jdXJyZW50UmVzb2x1dGlvbkVycm9yLmRldGFpbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWdTZWxlY3Rpb25RdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbFN0cmVhbTogc3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBjYWxsTWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFJlZlRpbWVyUmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsQ29uZmlnID0gdGhpcy5jb25maWdTZWxlY3RvcihzdHJlYW0uZ2V0TWV0aG9kKCksIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIGlmIChjYWxsQ29uZmlnLnN0YXR1cyA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxDb25maWcubWV0aG9kQ29uZmlnLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVhZGxpbmUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBkZWFkbGluZS5zZXRTZWNvbmRzKGRlYWRsaW5lLmdldFNlY29uZHMoKSArIGNhbGxDb25maWcubWV0aG9kQ29uZmlnLnRpbWVvdXQuc2Vjb25kcyk7XG4gICAgICAgICAgICAgICAgICAgIGRlYWRsaW5lLnNldE1pbGxpc2Vjb25kcyhkZWFkbGluZS5nZXRNaWxsaXNlY29uZHMoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29uZmlnLm1ldGhvZENvbmZpZy50aW1lb3V0Lm5hbm9zIC8gMTAwMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5zZXRDb25maWdEZWFkbGluZShkZWFkbGluZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZnJlc2hpbmcgdGhlIGZpbHRlcnMgbWFrZXMgdGhlIGRlYWRsaW5lIGZpbHRlciBwaWNrIHVwIHRoZSBuZXcgZGVhZGxpbmVcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmZpbHRlclN0YWNrLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxDb25maWcuZHluYW1pY0ZpbHRlckZhY3Rvcmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFRoZXNlIGR5bmFtaWNGaWx0ZXJzIGFyZSB0aGUgbWVjaGFuaXNtIGZvciBpbXBsZW1lbnRpbmcgZ1JGQyBBMzk6XG4gICAgICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0EzOS14ZHMtaHR0cC1maWx0ZXJzLm1kXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIHJ1biB0aGVtIGhlcmUgaW5zdGVhZCBvZiB3aXRoIHRoZSByZXN0IG9mIHRoZSBmaWx0ZXJzIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgICAgICogdGhhdCBzcGVjIHNheXMgXCJ0aGUgeERTIEhUVFAgZmlsdGVycyB3aWxsIHJ1biBpbiBiZXR3ZWVuIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICogcmVzb2x1dGlvbiBhbmQgbG9hZCBiYWxhbmNpbmdcIi5cbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogV2UgdXNlIHRoZSBmaWx0ZXIgc3RhY2sgaGVyZSB0byBzaW1wbGlmeSB0aGUgbXVsdGktZmlsdGVyIGFzeW5jXG4gICAgICAgICAgICAgICAgICAgICAqIHdhdGVyZmFsbCBsb2dpYywgYnV0IHdlIHBhc3MgYWxvbmcgdGhlIHVuZGVybHlpbmcgbGlzdCBvZiBmaWx0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAqIHRvIGF2b2lkIGhhdmluZyBuZXN0ZWQgZmlsdGVyIHN0YWNrcyB3aGVuIGNvbWJpbmluZyBpdCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBvcmlnaW5hbCBmaWx0ZXIgc3RhY2suIFdlIGRvIG5vdCBwYXNzIGFsb25nIHRoZSBvcmlnaW5hbCBmaWx0ZXJcbiAgICAgICAgICAgICAgICAgICAgICogZmFjdG9yeSBsaXN0IGJlY2F1c2UgdGhlc2UgZmlsdGVycyBtYXkgbmVlZCB0byBwZXJzaXN0IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICogYmV0d2VlbiBzZW5kaW5nIGhlYWRlcnMgYW5kIG90aGVyIG9wZXJhdGlvbnMuICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNGaWx0ZXJTdGFja0ZhY3RvcnkgPSBuZXcgZmlsdGVyX3N0YWNrXzEuRmlsdGVyU3RhY2tGYWN0b3J5KGNhbGxDb25maWcuZHluYW1pY0ZpbHRlckZhY3Rvcmllcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNGaWx0ZXJTdGFjayA9IGR5bmFtaWNGaWx0ZXJTdGFja0ZhY3RvcnkuY3JlYXRlRmlsdGVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNGaWx0ZXJTdGFjay5zZW5kTWV0YWRhdGEoUHJvbWlzZS5yZXNvbHZlKG1ldGFkYXRhKSkudGhlbihmaWx0ZXJlZE1ldGFkYXRhID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5UGljayhzdHJlYW0sIGZpbHRlcmVkTWV0YWRhdGEsIGNhbGxDb25maWcsIGR5bmFtaWNGaWx0ZXJTdGFjay5nZXRGaWx0ZXJzKCkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5UGljayhzdHJlYW0sIG1ldGFkYXRhLCBjYWxsQ29uZmlnLCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBjb2RlLCBkZXRhaWxzIH0gPSByZXN0cmljdENvbnRyb2xQbGFuZVN0YXR1c0NvZGUoY2FsbENvbmZpZy5zdGF0dXMsICdGYWlsZWQgdG8gcm91dGUgY2FsbCB0byBtZXRob2QgJyArIHN0cmVhbS5nZXRNZXRob2QoKSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmNhbmNlbFdpdGhTdGF0dXMoY29kZSwgZGV0YWlscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3N0YXJ0Q2FsbFN0cmVhbShzdHJlYW0sIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMudHJ5R2V0Q29uZmlnKHN0cmVhbSwgbWV0YWRhdGEuY2xvbmUoKSk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLnJlc29sdmluZ0xvYWRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV04pO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2FsbFJlZlRpbWVyKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZih0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxQb29sLnVucmVmVW51c2VkU3ViY2hhbm5lbHMoKTtcbiAgICB9XG4gICAgZ2V0VGFyZ2V0KCkge1xuICAgICAgICByZXR1cm4gdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMudGFyZ2V0KTtcbiAgICB9XG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ5VG9Db25uZWN0KSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpdml0eVN0YXRlID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgaWYgKHRyeVRvQ29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZpbmdMb2FkQmFsYW5jZXIuZXhpdElkbGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGl2aXR5U3RhdGU7XG4gICAgfVxuICAgIHdhdGNoQ29ubmVjdGl2aXR5U3RhdGUoY3VycmVudFN0YXRlLCBkZWFkbGluZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NoYW5uZWwgaGFzIGJlZW4gc2h1dCBkb3duJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgaWYgKGRlYWRsaW5lICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgY29uc3QgZGVhZGxpbmVEYXRlID0gZGVhZGxpbmUgaW5zdGFuY2VvZiBEYXRlID8gZGVhZGxpbmUgOiBuZXcgRGF0ZShkZWFkbGluZSk7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgaWYgKGRlYWRsaW5lID09PSAtSW5maW5pdHkgfHwgZGVhZGxpbmVEYXRlIDw9IG5vdykge1xuICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2ssIG5ldyBFcnJvcignRGVhZGxpbmUgcGFzc2VkIHdpdGhvdXQgY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVXYXRjaGVyKHdhdGNoZXJPYmplY3QpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRGVhZGxpbmUgcGFzc2VkIHdpdGhvdXQgY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZScpKTtcbiAgICAgICAgICAgIH0sIGRlYWRsaW5lRGF0ZS5nZXRUaW1lKCkgLSBub3cuZ2V0VGltZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YXRjaGVyT2JqZWN0ID0ge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlLFxuICAgICAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICAgICB0aW1lcixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzLnB1c2god2F0Y2hlck9iamVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2hhbm5lbHogcmVmZXJlbmNlIG9iamVjdCBmb3IgdGhpcyBjaGFubmVsLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXNcbiAgICAgKiBnYXJiYWdlIGlmIGNoYW5uZWx6IGlzIGRpc2FibGVkIGZvciB0aGlzIGNoYW5uZWwuXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbm5lbHpSZWY7XG4gICAgfVxuICAgIGNyZWF0ZUNhbGwobWV0aG9kLCBkZWFkbGluZSwgaG9zdCwgcGFyZW50Q2FsbCwgcHJvcGFnYXRlRmxhZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IG1ldGhvZCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEodHlwZW9mIGRlYWRsaW5lID09PSAnbnVtYmVyJyB8fCBkZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDaGFubmVsI2NyZWF0ZUNhbGw6IGRlYWRsaW5lIG11c3QgYmUgYSBudW1iZXIgb3IgRGF0ZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGFubmVsIGhhcyBiZWVuIHNodXQgZG93bicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxOdW1iZXIgPSBnZXROZXdDYWxsTnVtYmVyKCk7XG4gICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0ZUNhbGwgWycgK1xuICAgICAgICAgICAgY2FsbE51bWJlciArXG4gICAgICAgICAgICAnXSBtZXRob2Q9XCInICtcbiAgICAgICAgICAgIG1ldGhvZCArXG4gICAgICAgICAgICAnXCIsIGRlYWRsaW5lPScgK1xuICAgICAgICAgICAgZGVhZGxpbmUpO1xuICAgICAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSB7XG4gICAgICAgICAgICBkZWFkbGluZTogZGVhZGxpbmUsXG4gICAgICAgICAgICBmbGFnczogcHJvcGFnYXRlRmxhZ3MgIT09IG51bGwgJiYgcHJvcGFnYXRlRmxhZ3MgIT09IHZvaWQgMCA/IHByb3BhZ2F0ZUZsYWdzIDogY29uc3RhbnRzXzEuUHJvcGFnYXRlLkRFRkFVTFRTLFxuICAgICAgICAgICAgaG9zdDogaG9zdCAhPT0gbnVsbCAmJiBob3N0ICE9PSB2b2lkIDAgPyBob3N0IDogdGhpcy5kZWZhdWx0QXV0aG9yaXR5LFxuICAgICAgICAgICAgcGFyZW50Q2FsbDogcGFyZW50Q2FsbCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGNhbGxfc3RyZWFtXzEuSHR0cDJDYWxsU3RyZWFtKG1ldGhvZCwgdGhpcywgZmluYWxPcHRpb25zLCB0aGlzLmZpbHRlclN0YWNrRmFjdG9yeSwgdGhpcy5jcmVkZW50aWFscy5fZ2V0Q2FsbENyZWRlbnRpYWxzKCksIGNhbGxOdW1iZXIpO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN0YXJ0ZWQoKTtcbiAgICAgICAgICAgIHN0cmVhbS5hZGRTdGF0dXNXYXRjaGVyKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbEltcGxlbWVudGF0aW9uID0gQ2hhbm5lbEltcGxlbWVudGF0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjYWxsX3N0cmVhbV8xIiwicmVxdWlyZSIsImNoYW5uZWxfY3JlZGVudGlhbHNfMSIsInJlc29sdmluZ19sb2FkX2JhbGFuY2VyXzEiLCJzdWJjaGFubmVsX3Bvb2xfMSIsInBpY2tlcl8xIiwiY29uc3RhbnRzXzEiLCJmaWx0ZXJfc3RhY2tfMSIsImNhbGxfY3JlZGVudGlhbHNfZmlsdGVyXzEiLCJkZWFkbGluZV9maWx0ZXJfMSIsImNvbXByZXNzaW9uX2ZpbHRlcl8xIiwicmVzb2x2ZXJfMSIsImxvZ2dpbmdfMSIsIm1heF9tZXNzYWdlX3NpemVfZmlsdGVyXzEiLCJodHRwX3Byb3h5XzEiLCJ1cmlfcGFyc2VyXzEiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsImNoYW5uZWx6XzEiLCJNQVhfVElNRU9VVF9USU1FIiwibmV4dENhbGxOdW1iZXIiLCJnZXROZXdDYWxsTnVtYmVyIiwiY2FsbE51bWJlciIsIk51bWJlciIsIk1BWF9TQUZFX0lOVEVHRVIiLCJJTkFQUFJPUFJJQVRFX0NPTlRST0xfUExBTkVfQ09ERVMiLCJTdGF0dXMiLCJPSyIsIklOVkFMSURfQVJHVU1FTlQiLCJOT1RfRk9VTkQiLCJBTFJFQURZX0VYSVNUUyIsIkZBSUxFRF9QUkVDT05ESVRJT04iLCJBQk9SVEVEIiwiT1VUX09GX1JBTkdFIiwiREFUQV9MT1NTIiwicmVzdHJpY3RDb250cm9sUGxhbmVTdGF0dXNDb2RlIiwiY29kZSIsImRldGFpbHMiLCJpbmNsdWRlcyIsIklOVEVSTkFMIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJjcmVkZW50aWFscyIsIm9wdGlvbnMiLCJfYSIsIl9iIiwiX2MiLCJfZCIsImNvbm5lY3Rpdml0eVN0YXRlIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJJRExFIiwiY3VycmVudFBpY2tlciIsIlVuYXZhaWxhYmxlUGlja2VyIiwiY29uZmlnU2VsZWN0aW9uUXVldWUiLCJwaWNrUXVldWUiLCJjb25uZWN0aXZpdHlTdGF0ZVdhdGNoZXJzIiwiY29uZmlnU2VsZWN0b3IiLCJjdXJyZW50UmVzb2x1dGlvbkVycm9yIiwiY2hhbm5lbHpFbmFibGVkIiwiY2FsbFRyYWNrZXIiLCJDaGFubmVsekNhbGxUcmFja2VyIiwiY2hpbGRyZW5UcmFja2VyIiwiQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIiLCJUeXBlRXJyb3IiLCJDaGFubmVsQ3JlZGVudGlhbHMiLCJvcmlnaW5hbFRhcmdldCIsIm9yaWdpbmFsVGFyZ2V0VXJpIiwicGFyc2VVcmkiLCJFcnJvciIsImRlZmF1bHRTY2hlbWVNYXBSZXN1bHQiLCJtYXBVcmlEZWZhdWx0U2NoZW1lIiwiY2FsbFJlZlRpbWVyIiwic2V0SW50ZXJ2YWwiLCJ1bnJlZiIsImNhbGwiLCJjaGFubmVselRyYWNlIiwiQ2hhbm5lbHpUcmFjZSIsImNoYW5uZWx6UmVmIiwicmVnaXN0ZXJDaGFubmVsekNoYW5uZWwiLCJnZXRDaGFubmVsekluZm8iLCJhZGRUcmFjZSIsImRlZmF1bHRBdXRob3JpdHkiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicHJveHlNYXBSZXN1bHQiLCJtYXBQcm94eU5hbWUiLCJhc3NpZ24iLCJleHRyYU9wdGlvbnMiLCJzdWJjaGFubmVsUG9vbCIsImdldFN1YmNoYW5uZWxQb29sIiwiY2hhbm5lbENvbnRyb2xIZWxwZXIiLCJjcmVhdGVTdWJjaGFubmVsIiwic3ViY2hhbm5lbEFkZHJlc3MiLCJzdWJjaGFubmVsQXJncyIsInN1YmNoYW5uZWwiLCJnZXRPckNyZWF0ZVN1YmNoYW5uZWwiLCJnZXRDaGFubmVselJlZiIsInVwZGF0ZVN0YXRlIiwicGlja2VyIiwicXVldWVDb3B5Iiwic2xpY2UiLCJjYWxsUmVmVGltZXJVbnJlZiIsImNhbGxTdHJlYW0iLCJjYWxsTWV0YWRhdGEiLCJjYWxsQ29uZmlnIiwiZHluYW1pY0ZpbHRlcnMiLCJ0cnlQaWNrIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImFkZENoYW5uZWx6Q2hpbGQiLCJjaGlsZCIsInJlZkNoaWxkIiwicmVtb3ZlQ2hhbm5lbHpDaGlsZCIsInVucmVmQ2hpbGQiLCJyZXNvbHZpbmdMb2FkQmFsYW5jZXIiLCJSZXNvbHZpbmdMb2FkQmFsYW5jZXIiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJsb2NhbFF1ZXVlIiwidHJ5R2V0Q29uZmlnIiwic3RhdHVzIiwibGVuZ3RoIiwidHJhY2UiLCJtZXRhZGF0YSIsImdldE9wdGlvbnMiLCJ3YWl0Rm9yUmVhZHkiLCJjYWxsUmVmVGltZXJSZWYiLCJwdXNoIiwiY2FuY2VsV2l0aFN0YXR1cyIsImZpbHRlclN0YWNrRmFjdG9yeSIsIkZpbHRlclN0YWNrRmFjdG9yeSIsIkNhbGxDcmVkZW50aWFsc0ZpbHRlckZhY3RvcnkiLCJEZWFkbGluZUZpbHRlckZhY3RvcnkiLCJNYXhNZXNzYWdlU2l6ZUZpbHRlckZhY3RvcnkiLCJDb21wcmVzc2lvbkZpbHRlckZhY3RvcnkiLCJKU09OIiwic3RyaW5naWZ5IiwidW5kZWZpbmVkIiwiZXJyb3IiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsImlkIiwic3RhY2siLCJzdWJzdHJpbmciLCJpbmRleE9mIiwic3RhdGUiLCJjaGlsZHJlbiIsImdldENoaWxkTGlzdHMiLCJ0ZXh0IiwidmVyYm9zaXR5T3ZlcnJpZGUiLCJ1cmlUb1N0cmluZyIsImhhc1JlZiIsInJlZiIsInB1c2hQaWNrIiwicGlja1Jlc3VsdCIsInBpY2siLCJleHRyYVBpY2tJbmZvIiwicGlja0luZm9ybWF0aW9uIiwic3ViY2hhbm5lbFN0cmluZyIsImdldEFkZHJlc3MiLCJnZXRDYWxsTnVtYmVyIiwiUGlja1Jlc3VsdFR5cGUiLCJwaWNrUmVzdWx0VHlwZSIsIkNPTVBMRVRFIiwiVU5BVkFJTEFCTEUiLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsIlJFQURZIiwibG9nIiwiRVJST1IiLCJmaWx0ZXJTdGFjayIsInNlbmRNZXRhZGF0YSIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2xvbmUiLCJ0aGVuIiwiZmluYWxNZXRhZGF0YSIsInN1YmNoYW5uZWxTdGF0ZSIsInBpY2tFeHRyYUZpbHRlcnMiLCJleHRyYUZpbHRlckZhY3RvcmllcyIsIm1hcCIsImZhY3RvcnkiLCJjcmVhdGVGaWx0ZXIiLCJnZXRSZWFsU3ViY2hhbm5lbCIsInN0YXJ0Q2FsbFN0cmVhbSIsIm9uQ29tbWl0dGVkIiwib25DYWxsU3RhcnRlZCIsImVycm9yQ29kZSIsIm1lc3NhZ2UiLCJJTkZPIiwiVU5LTk9XTiIsIlFVRVVFIiwiVFJBTlNJRU5UX0ZBSUxVUkUiLCJEUk9QIiwicmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVXYXRjaGVyIiwid2F0Y2hlck9iamVjdCIsIndhdGNoZXJJbmRleCIsImZpbmRJbmRleCIsInNwbGljZSIsIm5ld1N0YXRlIiwid2F0Y2hlcnNDb3B5IiwiY3VycmVudFN0YXRlIiwidGltZXIiLCJjbGVhclRpbWVvdXQiLCJjYWxsYmFjayIsInN0cmVhbSIsImdldFN0YXR1cyIsImV4aXRJZGxlIiwiZ2V0TWV0aG9kIiwibWV0aG9kQ29uZmlnIiwidGltZW91dCIsImRlYWRsaW5lIiwiRGF0ZSIsInNldFNlY29uZHMiLCJnZXRTZWNvbmRzIiwic2Vjb25kcyIsInNldE1pbGxpc2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsIm5hbm9zIiwic2V0Q29uZmlnRGVhZGxpbmUiLCJyZWZyZXNoIiwiZHluYW1pY0ZpbHRlckZhY3RvcmllcyIsImR5bmFtaWNGaWx0ZXJTdGFja0ZhY3RvcnkiLCJkeW5hbWljRmlsdGVyU3RhY2siLCJmaWx0ZXJlZE1ldGFkYXRhIiwiZ2V0RmlsdGVycyIsIl9zdGFydENhbGxTdHJlYW0iLCJjbG9zZSIsImRlc3Ryb3kiLCJTSFVURE9XTiIsImNsZWFySW50ZXJ2YWwiLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJ1bnJlZlVudXNlZFN1YmNoYW5uZWxzIiwiZ2V0VGFyZ2V0IiwidHJ5VG9Db25uZWN0Iiwid2F0Y2hDb25uZWN0aXZpdHlTdGF0ZSIsIkluZmluaXR5IiwiZGVhZGxpbmVEYXRlIiwibm93Iiwic2V0VGltZW91dCIsImdldFRpbWUiLCJjcmVhdGVDYWxsIiwibWV0aG9kIiwiaG9zdCIsInBhcmVudENhbGwiLCJwcm9wYWdhdGVGbGFncyIsImZpbmFsT3B0aW9ucyIsImZsYWdzIiwiUHJvcGFnYXRlIiwiREVGQVVMVFMiLCJIdHRwMkNhbGxTdHJlYW0iLCJfZ2V0Q2FsbENyZWRlbnRpYWxzIiwiYWRkQ2FsbFN0YXJ0ZWQiLCJhZGRTdGF0dXNXYXRjaGVyIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsImFkZENhbGxGYWlsZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/channelz.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nfunction channelRefToMessage(ref) {\n    return {\n        channel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction subchannelRefToMessage(ref) {\n    return {\n        subchannel_id: ref.id,\n        name: ref.name\n    };\n}\nfunction serverRefToMessage(ref) {\n    return {\n        server_id: ref.id\n    };\n}\nfunction socketRefToMessage(ref) {\n    return {\n        socket_id: ref.id,\n        name: ref.name\n    };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */ const TARGET_RETAINED_TRACES = 32;\nclass ChannelzTrace {\n    constructor(){\n        this.events = [];\n        this.eventsLogged = 0;\n        this.creationTimestamp = new Date();\n    }\n    addTrace(severity, description, child) {\n        const timestamp = new Date();\n        this.events.push({\n            description: description,\n            severity: severity,\n            timestamp: timestamp,\n            childChannel: (child === null || child === void 0 ? void 0 : child.kind) === \"channel\" ? child : undefined,\n            childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === \"subchannel\" ? child : undefined\n        });\n        // Whenever the trace array gets too large, discard the first half\n        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n            this.events = this.events.slice(TARGET_RETAINED_TRACES);\n        }\n        this.eventsLogged += 1;\n    }\n    getTraceMessage() {\n        return {\n            creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n            num_events_logged: this.eventsLogged,\n            events: this.events.map((event)=>{\n                return {\n                    description: event.description,\n                    severity: event.severity,\n                    timestamp: dateToProtoTimestamp(event.timestamp),\n                    channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n                    subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n                };\n            })\n        };\n    }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n    constructor(){\n        this.channelChildren = new Map();\n        this.subchannelChildren = new Map();\n        this.socketChildren = new Map();\n    }\n    refChild(child) {\n        var _a, _b, _c;\n        switch(child.kind){\n            case \"channel\":\n                {\n                    let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.channelChildren.set(child.id, trackedChild);\n                    break;\n                }\n            case \"subchannel\":\n                {\n                    let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.subchannelChildren.set(child.id, trackedChild);\n                    break;\n                }\n            case \"socket\":\n                {\n                    let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\n                        ref: child,\n                        count: 0\n                    };\n                    trackedChild.count += 1;\n                    this.socketChildren.set(child.id, trackedChild);\n                    break;\n                }\n        }\n    }\n    unrefChild(child) {\n        switch(child.kind){\n            case \"channel\":\n                {\n                    let trackedChild = this.channelChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.channelChildren.delete(child.id);\n                        } else {\n                            this.channelChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n            case \"subchannel\":\n                {\n                    let trackedChild = this.subchannelChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.subchannelChildren.delete(child.id);\n                        } else {\n                            this.subchannelChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n            case \"socket\":\n                {\n                    let trackedChild = this.socketChildren.get(child.id);\n                    if (trackedChild !== undefined) {\n                        trackedChild.count -= 1;\n                        if (trackedChild.count === 0) {\n                            this.socketChildren.delete(child.id);\n                        } else {\n                            this.socketChildren.set(child.id, trackedChild);\n                        }\n                    }\n                    break;\n                }\n        }\n    }\n    getChildLists() {\n        const channels = [];\n        for (const { ref } of this.channelChildren.values()){\n            channels.push(ref);\n        }\n        const subchannels = [];\n        for (const { ref } of this.subchannelChildren.values()){\n            subchannels.push(ref);\n        }\n        const sockets = [];\n        for (const { ref } of this.socketChildren.values()){\n            sockets.push(ref);\n        }\n        return {\n            channels,\n            subchannels,\n            sockets\n        };\n    }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzCallTracker {\n    constructor(){\n        this.callsStarted = 0;\n        this.callsSucceeded = 0;\n        this.callsFailed = 0;\n        this.lastCallStartedTimestamp = null;\n    }\n    addCallStarted() {\n        this.callsStarted += 1;\n        this.lastCallStartedTimestamp = new Date();\n    }\n    addCallSucceeded() {\n        this.callsSucceeded += 1;\n    }\n    addCallFailed() {\n        this.callsFailed += 1;\n    }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\nfunction getNextId() {\n    return nextId++;\n}\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"channel\"\n    };\n    if (channelzEnabled) {\n        channels[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzChannel = registerChannelzChannel;\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"subchannel\"\n    };\n    if (channelzEnabled) {\n        subchannels[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        kind: \"server\"\n    };\n    if (channelzEnabled) {\n        servers[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzServer = registerChannelzServer;\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n    const id = getNextId();\n    const ref = {\n        id,\n        name,\n        kind: \"socket\"\n    };\n    if (channelzEnabled) {\n        sockets[id] = {\n            ref,\n            getInfo\n        };\n    }\n    return ref;\n}\nexports.registerChannelzSocket = registerChannelzSocket;\nfunction unregisterChannelzRef(ref) {\n    switch(ref.kind){\n        case \"channel\":\n            delete channels[ref.id];\n            return;\n        case \"subchannel\":\n            delete subchannels[ref.id];\n            return;\n        case \"server\":\n            delete servers[ref.id];\n            return;\n        case \"socket\":\n            delete sockets[ref.id];\n            return;\n    }\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */ function parseIPv6Section(addressSection) {\n    const numberValue = Number.parseInt(addressSection, 16);\n    return [\n        numberValue / 256 | 0,\n        numberValue % 256\n    ];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */ function parseIPv6Chunk(addressChunk) {\n    if (addressChunk === \"\") {\n        return [];\n    }\n    const bytePairs = addressChunk.split(\":\").map((section)=>parseIPv6Section(section));\n    const result = [];\n    return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */ function ipAddressStringToBuffer(ipAddress) {\n    if (net_1.isIPv4(ipAddress)) {\n        return Buffer.from(Uint8Array.from(ipAddress.split(\".\").map((segment)=>Number.parseInt(segment))));\n    } else if (net_1.isIPv6(ipAddress)) {\n        let leftSection;\n        let rightSection;\n        const doubleColonIndex = ipAddress.indexOf(\"::\");\n        if (doubleColonIndex === -1) {\n            leftSection = ipAddress;\n            rightSection = \"\";\n        } else {\n            leftSection = ipAddress.substring(0, doubleColonIndex);\n            rightSection = ipAddress.substring(doubleColonIndex + 2);\n        }\n        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n        return Buffer.concat([\n            leftBuffer,\n            middleBuffer,\n            rightBuffer\n        ]);\n    } else {\n        return null;\n    }\n}\nfunction connectivityStateToMessage(state) {\n    switch(state){\n        case connectivity_state_1.ConnectivityState.CONNECTING:\n            return {\n                state: \"CONNECTING\"\n            };\n        case connectivity_state_1.ConnectivityState.IDLE:\n            return {\n                state: \"IDLE\"\n            };\n        case connectivity_state_1.ConnectivityState.READY:\n            return {\n                state: \"READY\"\n            };\n        case connectivity_state_1.ConnectivityState.SHUTDOWN:\n            return {\n                state: \"SHUTDOWN\"\n            };\n        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n            return {\n                state: \"TRANSIENT_FAILURE\"\n            };\n        default:\n            return {\n                state: \"UNKNOWN\"\n            };\n    }\n}\nfunction dateToProtoTimestamp(date) {\n    if (!date) {\n        return null;\n    }\n    const millisSinceEpoch = date.getTime();\n    return {\n        seconds: millisSinceEpoch / 1000 | 0,\n        nanos: millisSinceEpoch % 1000 * 1000000\n    };\n}\nfunction getChannelMessage(channelEntry) {\n    const resolvedInfo = channelEntry.getInfo();\n    return {\n        ref: channelRefToMessage(channelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        channel_ref: resolvedInfo.children.channels.map((ref)=>channelRefToMessage(ref)),\n        subchannel_ref: resolvedInfo.children.subchannels.map((ref)=>subchannelRefToMessage(ref))\n    };\n}\nfunction GetChannel(call, callback) {\n    const channelId = Number.parseInt(call.request.channel_id);\n    const channelEntry = channels[channelId];\n    if (channelEntry === undefined) {\n        callback({\n            \"code\": constants_1.Status.NOT_FOUND,\n            \"details\": \"No channel data found for id \" + channelId\n        });\n        return;\n    }\n    callback(null, {\n        channel: getChannelMessage(channelEntry)\n    });\n}\nfunction GetTopChannels(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_channel_id);\n    for(; i < channels.length; i++){\n        const channelEntry = channels[i];\n        if (channelEntry === undefined) {\n            continue;\n        }\n        resultList.push(getChannelMessage(channelEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        channel: resultList,\n        end: i >= servers.length\n    });\n}\nfunction getServerMessage(serverEntry) {\n    const resolvedInfo = serverEntry.getInfo();\n    return {\n        ref: serverRefToMessage(serverEntry.ref),\n        data: {\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        listen_socket: resolvedInfo.listenerChildren.sockets.map((ref)=>socketRefToMessage(ref))\n    };\n}\nfunction GetServer(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            \"code\": constants_1.Status.NOT_FOUND,\n            \"details\": \"No server data found for id \" + serverId\n        });\n        return;\n    }\n    callback(null, {\n        server: getServerMessage(serverEntry)\n    });\n}\nfunction GetServers(call, callback) {\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resultList = [];\n    let i = Number.parseInt(call.request.start_server_id);\n    for(; i < servers.length; i++){\n        const serverEntry = servers[i];\n        if (serverEntry === undefined) {\n            continue;\n        }\n        resultList.push(getServerMessage(serverEntry));\n        if (resultList.length >= maxResults) {\n            break;\n        }\n    }\n    callback(null, {\n        server: resultList,\n        end: i >= servers.length\n    });\n}\nfunction GetSubchannel(call, callback) {\n    const subchannelId = Number.parseInt(call.request.subchannel_id);\n    const subchannelEntry = subchannels[subchannelId];\n    if (subchannelEntry === undefined) {\n        callback({\n            \"code\": constants_1.Status.NOT_FOUND,\n            \"details\": \"No subchannel data found for id \" + subchannelId\n        });\n        return;\n    }\n    const resolvedInfo = subchannelEntry.getInfo();\n    const subchannelMessage = {\n        ref: subchannelRefToMessage(subchannelEntry.ref),\n        data: {\n            target: resolvedInfo.target,\n            state: connectivityStateToMessage(resolvedInfo.state),\n            calls_started: resolvedInfo.callTracker.callsStarted,\n            calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n            calls_failed: resolvedInfo.callTracker.callsFailed,\n            last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n            trace: resolvedInfo.trace.getTraceMessage()\n        },\n        socket_ref: resolvedInfo.children.sockets.map((ref)=>socketRefToMessage(ref))\n    };\n    callback(null, {\n        subchannel: subchannelMessage\n    });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n    var _a;\n    if (subchannel_address_1.isTcpSubchannelAddress(subchannelAddress)) {\n        return {\n            address: \"tcpip_address\",\n            tcpip_address: {\n                ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n                port: subchannelAddress.port\n            }\n        };\n    } else {\n        return {\n            address: \"uds_address\",\n            uds_address: {\n                filename: subchannelAddress.path\n            }\n        };\n    }\n}\nfunction GetSocket(call, callback) {\n    var _a, _b, _c, _d, _e;\n    const socketId = Number.parseInt(call.request.socket_id);\n    const socketEntry = sockets[socketId];\n    if (socketEntry === undefined) {\n        callback({\n            \"code\": constants_1.Status.NOT_FOUND,\n            \"details\": \"No socket data found for id \" + socketId\n        });\n        return;\n    }\n    const resolvedInfo = socketEntry.getInfo();\n    const securityMessage = resolvedInfo.security ? {\n        model: \"tls\",\n        tls: {\n            cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? \"standard_name\" : \"other_name\",\n            standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n            other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n            local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n            remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n        }\n    } : null;\n    const socketMessage = {\n        ref: socketRefToMessage(socketEntry.ref),\n        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n        security: securityMessage,\n        data: {\n            keep_alives_sent: resolvedInfo.keepAlivesSent,\n            streams_started: resolvedInfo.streamsStarted,\n            streams_succeeded: resolvedInfo.streamsSucceeded,\n            streams_failed: resolvedInfo.streamsFailed,\n            last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n            last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n            messages_received: resolvedInfo.messagesReceived,\n            messages_sent: resolvedInfo.messagesSent,\n            last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n            last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n            local_flow_control_window: resolvedInfo.localFlowControlWindow ? {\n                value: resolvedInfo.localFlowControlWindow\n            } : null,\n            remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {\n                value: resolvedInfo.remoteFlowControlWindow\n            } : null\n        }\n    };\n    callback(null, {\n        socket: socketMessage\n    });\n}\nfunction GetServerSockets(call, callback) {\n    const serverId = Number.parseInt(call.request.server_id);\n    const serverEntry = servers[serverId];\n    if (serverEntry === undefined) {\n        callback({\n            \"code\": constants_1.Status.NOT_FOUND,\n            \"details\": \"No server data found for id \" + serverId\n        });\n        return;\n    }\n    const startId = Number.parseInt(call.request.start_socket_id);\n    const maxResults = Number.parseInt(call.request.max_results);\n    const resolvedInfo = serverEntry.getInfo();\n    // If we wanted to include listener sockets in the result, this line would\n    // instead say\n    // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n    const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2)=>ref1.id - ref2.id);\n    const resultList = [];\n    let i = 0;\n    for(; i < allSockets.length; i++){\n        if (allSockets[i].id >= startId) {\n            resultList.push(socketRefToMessage(allSockets[i]));\n            if (resultList.length >= maxResults) {\n                break;\n            }\n        }\n    }\n    callback(null, {\n        socket_ref: resultList,\n        end: i >= allSockets.length\n    });\n}\nfunction getChannelzHandlers() {\n    return {\n        GetChannel,\n        GetTopChannels,\n        GetServer,\n        GetServers,\n        GetSubchannel,\n        GetSocket,\n        GetServerSockets\n    };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n    if (loadedChannelzDefinition) {\n        return loadedChannelzDefinition;\n    }\n    /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n     * runtime for users who will not use/enable channelz. */ const loaderLoadSync = (__webpack_require__(/*! @grpc/proto-loader */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js\").loadSync);\n    const loadedProto = loaderLoadSync(\"channelz.proto\", {\n        keepCase: true,\n        longs: String,\n        enums: String,\n        defaults: true,\n        oneofs: true,\n        includeDirs: [\n            `${__dirname}/../../proto`\n        ]\n    });\n    const channelzGrpcObject = make_client_1.loadPackageDefinition(loadedProto);\n    loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n    return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n    admin_1.registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup; //# sourceMappingURL=channelz.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBR0Esb0NBQW9DLEdBQUdBLDJCQUEyQixHQUFHQSw2QkFBNkIsR0FBR0EsOEJBQThCLEdBQUdBLDhCQUE4QixHQUFHQSxrQ0FBa0MsR0FBR0EsK0JBQStCLEdBQUdBLDJCQUEyQixHQUFHQSwrQkFBK0IsR0FBR0EscUJBQXFCLEdBQUcsS0FBSztBQUMzVixNQUFNYSxRQUFRQyxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNQyx1QkFBdUJELG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRyx1QkFBdUJILG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQyxzRUFBUztBQUNqQyxNQUFNSyxnQkFBZ0JMLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLFNBQVNNLG9CQUFvQkMsR0FBRztJQUM1QixPQUFPO1FBQ0hDLFlBQVlELElBQUlFLEVBQUU7UUFDbEJDLE1BQU1ILElBQUlHLElBQUk7SUFDbEI7QUFDSjtBQUNBLFNBQVNDLHVCQUF1QkosR0FBRztJQUMvQixPQUFPO1FBQ0hLLGVBQWVMLElBQUlFLEVBQUU7UUFDckJDLE1BQU1ILElBQUlHLElBQUk7SUFDbEI7QUFDSjtBQUNBLFNBQVNHLG1CQUFtQk4sR0FBRztJQUMzQixPQUFPO1FBQ0hPLFdBQVdQLElBQUlFLEVBQUU7SUFDckI7QUFDSjtBQUNBLFNBQVNNLG1CQUFtQlIsR0FBRztJQUMzQixPQUFPO1FBQ0hTLFdBQVdULElBQUlFLEVBQUU7UUFDakJDLE1BQU1ILElBQUlHLElBQUk7SUFDbEI7QUFDSjtBQUNBOzs7OztDQUtDLEdB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UUFDWkcsS0FBS0YsS0FBS2tGLFdBQVc3TCxNQUFNO0lBQy9CO0FBQ0o7QUFDQSxTQUFTM0M7SUFDTCxPQUFPO1FBQ0gwSTtRQUNBUTtRQUNBVztRQUNBRztRQUNBRTtRQUNBaUI7UUFDQWtEO0lBQ0o7QUFDSjtBQUNBek8sMkJBQTJCLEdBQUdJO0FBQzlCLElBQUk2TywyQkFBMkI7QUFDL0IsU0FBUzlPO0lBQ0wsSUFBSThPLDBCQUEwQjtRQUMxQixPQUFPQTtJQUNYO0lBQ0E7MkRBQ3VELEdBQ3ZELE1BQU1DLGlCQUFpQnBPLGlKQUFzQztJQUM3RCxNQUFNc08sY0FBY0YsZUFBZSxrQkFBa0I7UUFDakRHLFVBQVU7UUFDVkMsT0FBT0M7UUFDUEMsT0FBT0Q7UUFDUEUsVUFBVTtRQUNWQyxRQUFRO1FBQ1JDLGFBQWE7WUFDVCxDQUFDLEVBQUVDLFVBQVUsWUFBWSxDQUFDO1NBQzdCO0lBQ0w7SUFDQSxNQUFNQyxxQkFBcUIxTyxjQUFjMk8scUJBQXFCLENBQUNWO0lBQy9ESCwyQkFBMkJZLG1CQUFtQkUsSUFBSSxDQUFDQyxRQUFRLENBQUNDLEVBQUUsQ0FBQ0MsUUFBUSxDQUFDQyxPQUFPO0lBQy9FLE9BQU9sQjtBQUNYO0FBQ0FqUCxvQ0FBb0MsR0FBR0c7QUFDdkMsU0FBU0Q7SUFDTGdCLFFBQVFrUCxvQkFBb0IsQ0FBQ2pRLDhCQUE4QkM7QUFDL0Q7QUFDQUosYUFBYSxHQUFHRSxPQUNoQixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2hhbm5lbHouanM/NjI3NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXR1cCA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGV4cG9ydHMuZ2V0Q2hhbm5lbHpIYW5kbGVycyA9IGV4cG9ydHMudW5yZWdpc3RlckNoYW5uZWx6UmVmID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U29ja2V0ID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U2VydmVyID0gZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6U3ViY2hhbm5lbCA9IGV4cG9ydHMucmVnaXN0ZXJDaGFubmVsekNoYW5uZWwgPSBleHBvcnRzLkNoYW5uZWx6Q2FsbFRyYWNrZXIgPSBleHBvcnRzLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyID0gZXhwb3J0cy5DaGFubmVselRyYWNlID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuY29uc3QgbWFrZV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL21ha2UtY2xpZW50XCIpO1xuZnVuY3Rpb24gY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGFubmVsX2lkOiByZWYuaWQsXG4gICAgICAgIG5hbWU6IHJlZi5uYW1lXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YmNoYW5uZWxSZWZUb01lc3NhZ2UocmVmKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3ViY2hhbm5lbF9pZDogcmVmLmlkLFxuICAgICAgICBuYW1lOiByZWYubmFtZVxuICAgIH07XG59XG5mdW5jdGlvbiBzZXJ2ZXJSZWZUb01lc3NhZ2UocmVmKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VydmVyX2lkOiByZWYuaWRcbiAgICB9O1xufVxuZnVuY3Rpb24gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNvY2tldF9pZDogcmVmLmlkLFxuICAgICAgICBuYW1lOiByZWYubmFtZVxuICAgIH07XG59XG4vKipcbiAqIFRoZSBsb29zZSB1cHBlciBib3VuZCBvbiB0aGUgbnVtYmVyIG9mIGV2ZW50cyB0aGF0IHNob3VsZCBiZSByZXRhaW5lZCBpbiBhXG4gKiB0cmFjZS4gVGhpcyBtYXkgYmUgZXhjZWVkZWQgYnkgdXAgdG8gYSBmYWN0b3Igb2YgMi4gQXJiaXRyYXJpbHkgY2hvc2VuIGFzIGFcbiAqIG51bWJlciB0aGF0IHNob3VsZCBiZSBsYXJnZSBlbm91Z2ggdG8gY29udGFpbiB0aGUgcmVjZW50IHJlbGV2YW50XG4gKiBpbmZvcm1hdGlvbiwgYnV0IHNtYWxsIGVub3VnaCB0byBub3QgdXNlIGV4Y2Vzc2l2ZSBtZW1vcnkuXG4gKi9cbmNvbnN0IFRBUkdFVF9SRVRBSU5FRF9UUkFDRVMgPSAzMjtcbmNsYXNzIENoYW5uZWx6VHJhY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50c0xvZ2dlZCA9IDA7XG4gICAgICAgIHRoaXMuY3JlYXRpb25UaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICBhZGRUcmFjZShzZXZlcml0eSwgZGVzY3JpcHRpb24sIGNoaWxkKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIHRoaXMuZXZlbnRzLnB1c2goe1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgc2V2ZXJpdHk6IHNldmVyaXR5LFxuICAgICAgICAgICAgdGltZXN0YW1wOiB0aW1lc3RhbXAsXG4gICAgICAgICAgICBjaGlsZENoYW5uZWw6IChjaGlsZCA9PT0gbnVsbCB8fCBjaGlsZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGQua2luZCkgPT09ICdjaGFubmVsJyA/IGNoaWxkIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hpbGRTdWJjaGFubmVsOiAoY2hpbGQgPT09IG51bGwgfHwgY2hpbGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkLmtpbmQpID09PSAnc3ViY2hhbm5lbCcgPyBjaGlsZCA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2hlbmV2ZXIgdGhlIHRyYWNlIGFycmF5IGdldHMgdG9vIGxhcmdlLCBkaXNjYXJkIHRoZSBmaXJzdCBoYWxmXG4gICAgICAgIGlmICh0aGlzLmV2ZW50cy5sZW5ndGggPj0gVEFSR0VUX1JFVEFJTkVEX1RSQUNFUyAqIDIpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzID0gdGhpcy5ldmVudHMuc2xpY2UoVEFSR0VUX1JFVEFJTkVEX1RSQUNFUyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudHNMb2dnZWQgKz0gMTtcbiAgICB9XG4gICAgZ2V0VHJhY2VNZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRpb25fdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcCh0aGlzLmNyZWF0aW9uVGltZXN0YW1wKSxcbiAgICAgICAgICAgIG51bV9ldmVudHNfbG9nZ2VkOiB0aGlzLmV2ZW50c0xvZ2dlZCxcbiAgICAgICAgICAgIGV2ZW50czogdGhpcy5ldmVudHMubWFwKGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogZXZlbnQuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNldmVyaXR5OiBldmVudC5zZXZlcml0eSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChldmVudC50aW1lc3RhbXApLFxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsX3JlZjogZXZlbnQuY2hpbGRDaGFubmVsID8gY2hhbm5lbFJlZlRvTWVzc2FnZShldmVudC5jaGlsZENoYW5uZWwpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbF9yZWY6IGV2ZW50LmNoaWxkU3ViY2hhbm5lbCA/IHN1YmNoYW5uZWxSZWZUb01lc3NhZ2UoZXZlbnQuY2hpbGRTdWJjaGFubmVsKSA6IG51bGxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWx6VHJhY2UgPSBDaGFubmVselRyYWNlO1xuY2xhc3MgQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYW5uZWxDaGlsZHJlbiA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc29ja2V0Q2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHJlZkNoaWxkKGNoaWxkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBzd2l0Y2ggKGNoaWxkLmtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NoYW5uZWwnOiB7XG4gICAgICAgICAgICAgICAgbGV0IHRyYWNrZWRDaGlsZCA9IChfYSA9IHRoaXMuY2hhbm5lbENoaWxkcmVuLmdldChjaGlsZC5pZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHsgcmVmOiBjaGlsZCwgY291bnQ6IDAgfTtcbiAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzdWJjaGFubmVsJzoge1xuICAgICAgICAgICAgICAgIGxldCB0cmFja2VkQ2hpbGQgPSAoX2IgPSB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7IHJlZjogY2hpbGQsIGNvdW50OiAwIH07XG4gICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50ICs9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uc2V0KGNoaWxkLmlkLCB0cmFja2VkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnc29ja2V0Jzoge1xuICAgICAgICAgICAgICAgIGxldCB0cmFja2VkQ2hpbGQgPSAoX2MgPSB0aGlzLnNvY2tldENoaWxkcmVuLmdldChjaGlsZC5pZCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHsgcmVmOiBjaGlsZCwgY291bnQ6IDAgfTtcbiAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1bnJlZkNoaWxkKGNoaWxkKSB7XG4gICAgICAgIHN3aXRjaCAoY2hpbGQua2luZCkge1xuICAgICAgICAgICAgY2FzZSAnY2hhbm5lbCc6IHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhY2tlZENoaWxkID0gdGhpcy5jaGFubmVsQ2hpbGRyZW4uZ2V0KGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tlZENoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tlZENoaWxkLmNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQuY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENoaWxkcmVuLmRlbGV0ZShjaGlsZC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWxDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdzdWJjaGFubmVsJzoge1xuICAgICAgICAgICAgICAgIGxldCB0cmFja2VkQ2hpbGQgPSB0aGlzLnN1YmNoYW5uZWxDaGlsZHJlbi5nZXQoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsQ2hpbGRyZW4uZGVsZXRlKGNoaWxkLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLnNldChjaGlsZC5pZCwgdHJhY2tlZENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3NvY2tldCc6IHtcbiAgICAgICAgICAgICAgICBsZXQgdHJhY2tlZENoaWxkID0gdGhpcy5zb2NrZXRDaGlsZHJlbi5nZXQoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2VkQ2hpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFja2VkQ2hpbGQuY291bnQgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrZWRDaGlsZC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbi5kZWxldGUoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRDaGlsZHJlbi5zZXQoY2hpbGQuaWQsIHRyYWNrZWRDaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q2hpbGRMaXN0cygpIHtcbiAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IHJlZiB9IG9mIHRoaXMuY2hhbm5lbENoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjaGFubmVscy5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IHJlZiB9IG9mIHRoaXMuc3ViY2hhbm5lbENoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVscy5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHsgcmVmIH0gb2YgdGhpcy5zb2NrZXRDaGlsZHJlbi52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0cy5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgY2hhbm5lbHMsIHN1YmNoYW5uZWxzLCBzb2NrZXRzIH07XG4gICAgfVxufVxuZXhwb3J0cy5DaGFubmVsekNoaWxkcmVuVHJhY2tlciA9IENoYW5uZWx6Q2hpbGRyZW5UcmFja2VyO1xuY2xhc3MgQ2hhbm5lbHpDYWxsVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdGFydGVkID0gMDtcbiAgICAgICAgdGhpcy5jYWxsc1N1Y2NlZWRlZCA9IDA7XG4gICAgICAgIHRoaXMuY2FsbHNGYWlsZWQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCA9IG51bGw7XG4gICAgfVxuICAgIGFkZENhbGxTdGFydGVkKCkge1xuICAgICAgICB0aGlzLmNhbGxzU3RhcnRlZCArPSAxO1xuICAgICAgICB0aGlzLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgfVxuICAgIGFkZENhbGxTdWNjZWVkZWQoKSB7XG4gICAgICAgIHRoaXMuY2FsbHNTdWNjZWVkZWQgKz0gMTtcbiAgICB9XG4gICAgYWRkQ2FsbEZhaWxlZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsc0ZhaWxlZCArPSAxO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbm5lbHpDYWxsVHJhY2tlciA9IENoYW5uZWx6Q2FsbFRyYWNrZXI7XG5sZXQgbmV4dElkID0gMTtcbmZ1bmN0aW9uIGdldE5leHRJZCgpIHtcbiAgICByZXR1cm4gbmV4dElkKys7XG59XG5jb25zdCBjaGFubmVscyA9IFtdO1xuY29uc3Qgc3ViY2hhbm5lbHMgPSBbXTtcbmNvbnN0IHNlcnZlcnMgPSBbXTtcbmNvbnN0IHNvY2tldHMgPSBbXTtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsKG5hbWUsIGdldEluZm8sIGNoYW5uZWx6RW5hYmxlZCkge1xuICAgIGNvbnN0IGlkID0gZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgcmVmID0geyBpZCwgbmFtZSwga2luZDogJ2NoYW5uZWwnIH07XG4gICAgaWYgKGNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICBjaGFubmVsc1tpZF0gPSB7IHJlZiwgZ2V0SW5mbyB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufVxuZXhwb3J0cy5yZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCA9IHJlZ2lzdGVyQ2hhbm5lbHpDaGFubmVsO1xuZnVuY3Rpb24gcmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwobmFtZSwgZ2V0SW5mbywgY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgY29uc3QgaWQgPSBnZXROZXh0SWQoKTtcbiAgICBjb25zdCByZWYgPSB7IGlkLCBuYW1lLCBraW5kOiAnc3ViY2hhbm5lbCcgfTtcbiAgICBpZiAoY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgIHN1YmNoYW5uZWxzW2lkXSA9IHsgcmVmLCBnZXRJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiByZWY7XG59XG5leHBvcnRzLnJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsID0gcmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWw7XG5mdW5jdGlvbiByZWdpc3RlckNoYW5uZWx6U2VydmVyKGdldEluZm8sIGNoYW5uZWx6RW5hYmxlZCkge1xuICAgIGNvbnN0IGlkID0gZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgcmVmID0geyBpZCwga2luZDogJ3NlcnZlcicgfTtcbiAgICBpZiAoY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgIHNlcnZlcnNbaWRdID0geyByZWYsIGdldEluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNlcnZlciA9IHJlZ2lzdGVyQ2hhbm5lbHpTZXJ2ZXI7XG5mdW5jdGlvbiByZWdpc3RlckNoYW5uZWx6U29ja2V0KG5hbWUsIGdldEluZm8sIGNoYW5uZWx6RW5hYmxlZCkge1xuICAgIGNvbnN0IGlkID0gZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgcmVmID0geyBpZCwgbmFtZSwga2luZDogJ3NvY2tldCcgfTtcbiAgICBpZiAoY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgIHNvY2tldHNbaWRdID0geyByZWYsIGdldEluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn1cbmV4cG9ydHMucmVnaXN0ZXJDaGFubmVselNvY2tldCA9IHJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQ7XG5mdW5jdGlvbiB1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYocmVmKSB7XG4gICAgc3dpdGNoIChyZWYua2luZCkge1xuICAgICAgICBjYXNlICdjaGFubmVsJzpcbiAgICAgICAgICAgIGRlbGV0ZSBjaGFubmVsc1tyZWYuaWRdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdzdWJjaGFubmVsJzpcbiAgICAgICAgICAgIGRlbGV0ZSBzdWJjaGFubmVsc1tyZWYuaWRdO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlICdzZXJ2ZXInOlxuICAgICAgICAgICAgZGVsZXRlIHNlcnZlcnNbcmVmLmlkXTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSAnc29ja2V0JzpcbiAgICAgICAgICAgIGRlbGV0ZSBzb2NrZXRzW3JlZi5pZF07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxufVxuZXhwb3J0cy51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYgPSB1bnJlZ2lzdGVyQ2hhbm5lbHpSZWY7XG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHNlY3Rpb24gb2YgYW4gSVB2NiBhZGRyZXNzIGFzIHR3byBieXRlc1xuICogQHBhcmFtIGFkZHJlc3NTZWN0aW9uIEEgaGV4YWRlY2ltYWwgc3RyaW5nIG9mIGxlbmd0aCB1cCB0byA0XG4gKiBAcmV0dXJucyBUaGUgcGFpciBvZiBieXRlcyByZXByZXNlbnRpbmcgdGhpcyBhZGRyZXNzIHNlY3Rpb25cbiAqL1xuZnVuY3Rpb24gcGFyc2VJUHY2U2VjdGlvbihhZGRyZXNzU2VjdGlvbikge1xuICAgIGNvbnN0IG51bWJlclZhbHVlID0gTnVtYmVyLnBhcnNlSW50KGFkZHJlc3NTZWN0aW9uLCAxNik7XG4gICAgcmV0dXJuIFtudW1iZXJWYWx1ZSAvIDI1NiB8IDAsIG51bWJlclZhbHVlICUgMjU2XTtcbn1cbi8qKlxuICogUGFyc2UgYSBjaHVuayBvZiBhbiBJUHY2IGFkZHJlc3Mgc3RyaW5nIHRvIHNvbWUgbnVtYmVyIG9mIGJ5dGVzXG4gKiBAcGFyYW0gYWRkcmVzc0NodW5rIFNvbWUgbnVtYmVyIG9mIHNlZ21lbnRzIG9mIHVwIHRvIDQgaGV4YWRlY2ltYWxcbiAqICAgY2hhcmFjdGVycyBlYWNoLCBqb2luZWQgYnkgY29sb25zLlxuICogQHJldHVybnMgVGhlIGxpc3Qgb2YgYnl0ZXMgcmVwcmVzZW50aW5nIHRoaXMgYWRkcmVzcyBjaHVua1xuICovXG5mdW5jdGlvbiBwYXJzZUlQdjZDaHVuayhhZGRyZXNzQ2h1bmspIHtcbiAgICBpZiAoYWRkcmVzc0NodW5rID09PSAnJykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVQYWlycyA9IGFkZHJlc3NDaHVuay5zcGxpdCgnOicpLm1hcChzZWN0aW9uID0+IHBhcnNlSVB2NlNlY3Rpb24oc2VjdGlvbikpO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHJldHVybiByZXN1bHQuY29uY2F0KC4uLmJ5dGVQYWlycyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIElQdjQgb3IgSVB2NiBhZGRyZXNzIGZyb20gc3RyaW5nIHJlcHJlc2VudGF0aW9uIHRvIGJpbmFyeVxuICogcmVwcmVzZW50YXRpb25cbiAqIEBwYXJhbSBpcEFkZHJlc3MgYW4gSVAgYWRkcmVzcyBpbiBzdGFuZGFyZCBJUHY0IG9yIElQdjYgdGV4dCBmb3JtYXRcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKGlwQWRkcmVzcykge1xuICAgIGlmIChuZXRfMS5pc0lQdjQoaXBBZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oVWludDhBcnJheS5mcm9tKGlwQWRkcmVzcy5zcGxpdCgnLicpLm1hcChzZWdtZW50ID0+IE51bWJlci5wYXJzZUludChzZWdtZW50KSkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobmV0XzEuaXNJUHY2KGlwQWRkcmVzcykpIHtcbiAgICAgICAgbGV0IGxlZnRTZWN0aW9uO1xuICAgICAgICBsZXQgcmlnaHRTZWN0aW9uO1xuICAgICAgICBjb25zdCBkb3VibGVDb2xvbkluZGV4ID0gaXBBZGRyZXNzLmluZGV4T2YoJzo6Jyk7XG4gICAgICAgIGlmIChkb3VibGVDb2xvbkluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgbGVmdFNlY3Rpb24gPSBpcEFkZHJlc3M7XG4gICAgICAgICAgICByaWdodFNlY3Rpb24gPSAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZnRTZWN0aW9uID0gaXBBZGRyZXNzLnN1YnN0cmluZygwLCBkb3VibGVDb2xvbkluZGV4KTtcbiAgICAgICAgICAgIHJpZ2h0U2VjdGlvbiA9IGlwQWRkcmVzcy5zdWJzdHJpbmcoZG91YmxlQ29sb25JbmRleCArIDIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlZnRCdWZmZXIgPSBCdWZmZXIuZnJvbShwYXJzZUlQdjZDaHVuayhsZWZ0U2VjdGlvbikpO1xuICAgICAgICBjb25zdCByaWdodEJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHBhcnNlSVB2NkNodW5rKHJpZ2h0U2VjdGlvbikpO1xuICAgICAgICBjb25zdCBtaWRkbGVCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMTYgLSBsZWZ0QnVmZmVyLmxlbmd0aCAtIHJpZ2h0QnVmZmVyLmxlbmd0aCwgMCk7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtsZWZ0QnVmZmVyLCBtaWRkbGVCdWZmZXIsIHJpZ2h0QnVmZmVyXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBjb25uZWN0aXZpdHlTdGF0ZVRvTWVzc2FnZShzdGF0ZSkge1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ0NPTk5FQ1RJTkcnXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnSURMRSdcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFk6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnUkVBRFknXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOOlxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ1NIVVRET1dOJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRTpcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdUUkFOU0lFTlRfRkFJTFVSRSdcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnVU5LTk9XTidcbiAgICAgICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gZGF0ZVRvUHJvdG9UaW1lc3RhbXAoZGF0ZSkge1xuICAgIGlmICghZGF0ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgbWlsbGlzU2luY2VFcG9jaCA9IGRhdGUuZ2V0VGltZSgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlY29uZHM6IChtaWxsaXNTaW5jZUVwb2NoIC8gMTAwMCkgfCAwLFxuICAgICAgICBuYW5vczogKG1pbGxpc1NpbmNlRXBvY2ggJSAxMDAwKSAqIDEwMDAwMDBcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2hhbm5lbE1lc3NhZ2UoY2hhbm5lbEVudHJ5KSB7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gY2hhbm5lbEVudHJ5LmdldEluZm8oKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWY6IGNoYW5uZWxSZWZUb01lc3NhZ2UoY2hhbm5lbEVudHJ5LnJlZiksXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHRhcmdldDogcmVzb2x2ZWRJbmZvLnRhcmdldCxcbiAgICAgICAgICAgIHN0YXRlOiBjb25uZWN0aXZpdHlTdGF0ZVRvTWVzc2FnZShyZXNvbHZlZEluZm8uc3RhdGUpLFxuICAgICAgICAgICAgY2FsbHNfc3RhcnRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgIGNhbGxzX3N1Y2NlZWRlZDogcmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgY2FsbHNfZmFpbGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICBsYXN0X2NhbGxfc3RhcnRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5sYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgdHJhY2U6IHJlc29sdmVkSW5mby50cmFjZS5nZXRUcmFjZU1lc3NhZ2UoKVxuICAgICAgICB9LFxuICAgICAgICBjaGFubmVsX3JlZjogcmVzb2x2ZWRJbmZvLmNoaWxkcmVuLmNoYW5uZWxzLm1hcChyZWYgPT4gY2hhbm5lbFJlZlRvTWVzc2FnZShyZWYpKSxcbiAgICAgICAgc3ViY2hhbm5lbF9yZWY6IHJlc29sdmVkSW5mby5jaGlsZHJlbi5zdWJjaGFubmVscy5tYXAocmVmID0+IHN1YmNoYW5uZWxSZWZUb01lc3NhZ2UocmVmKSlcbiAgICB9O1xufVxuZnVuY3Rpb24gR2V0Q2hhbm5lbChjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGNoYW5uZWxJZCA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QuY2hhbm5lbF9pZCk7XG4gICAgY29uc3QgY2hhbm5lbEVudHJ5ID0gY2hhbm5lbHNbY2hhbm5lbElkXTtcbiAgICBpZiAoY2hhbm5lbEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgJ2NvZGUnOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgJ2RldGFpbHMnOiAnTm8gY2hhbm5lbCBkYXRhIGZvdW5kIGZvciBpZCAnICsgY2hhbm5lbElkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHsgY2hhbm5lbDogZ2V0Q2hhbm5lbE1lc3NhZ2UoY2hhbm5lbEVudHJ5KSB9KTtcbn1cbmZ1bmN0aW9uIEdldFRvcENoYW5uZWxzKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbWF4UmVzdWx0cyA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3QubWF4X3Jlc3VsdHMpO1xuICAgIGNvbnN0IHJlc3VsdExpc3QgPSBbXTtcbiAgICBsZXQgaSA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc3RhcnRfY2hhbm5lbF9pZCk7XG4gICAgZm9yICg7IGkgPCBjaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFubmVsRW50cnkgPSBjaGFubmVsc1tpXTtcbiAgICAgICAgaWYgKGNoYW5uZWxFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRMaXN0LnB1c2goZ2V0Q2hhbm5lbE1lc3NhZ2UoY2hhbm5lbEVudHJ5KSk7XG4gICAgICAgIGlmIChyZXN1bHRMaXN0Lmxlbmd0aCA+PSBtYXhSZXN1bHRzKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFjayhudWxsLCB7XG4gICAgICAgIGNoYW5uZWw6IHJlc3VsdExpc3QsXG4gICAgICAgIGVuZDogaSA+PSBzZXJ2ZXJzLmxlbmd0aFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkge1xuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHNlcnZlckVudHJ5LmdldEluZm8oKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWY6IHNlcnZlclJlZlRvTWVzc2FnZShzZXJ2ZXJFbnRyeS5yZWYpLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBjYWxsc19zdGFydGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBjYWxsc19mYWlsZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIGxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpXG4gICAgICAgIH0sXG4gICAgICAgIGxpc3Rlbl9zb2NrZXQ6IHJlc29sdmVkSW5mby5saXN0ZW5lckNoaWxkcmVuLnNvY2tldHMubWFwKHJlZiA9PiBzb2NrZXRSZWZUb01lc3NhZ2UocmVmKSlcbiAgICB9O1xufVxuZnVuY3Rpb24gR2V0U2VydmVyKGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgY29uc3Qgc2VydmVySWQgPSBOdW1iZXIucGFyc2VJbnQoY2FsbC5yZXF1ZXN0LnNlcnZlcl9pZCk7XG4gICAgY29uc3Qgc2VydmVyRW50cnkgPSBzZXJ2ZXJzW3NlcnZlcklkXTtcbiAgICBpZiAoc2VydmVyRW50cnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICAnY29kZSc6IGNvbnN0YW50c18xLlN0YXR1cy5OT1RfRk9VTkQsXG4gICAgICAgICAgICAnZGV0YWlscyc6ICdObyBzZXJ2ZXIgZGF0YSBmb3VuZCBmb3IgaWQgJyArIHNlcnZlcklkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHsgc2VydmVyOiBnZXRTZXJ2ZXJNZXNzYWdlKHNlcnZlckVudHJ5KSB9KTtcbn1cbmZ1bmN0aW9uIEdldFNlcnZlcnMoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBtYXhSZXN1bHRzID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5tYXhfcmVzdWx0cyk7XG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdO1xuICAgIGxldCBpID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5zdGFydF9zZXJ2ZXJfaWQpO1xuICAgIGZvciAoOyBpIDwgc2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzZXJ2ZXJFbnRyeSA9IHNlcnZlcnNbaV07XG4gICAgICAgIGlmIChzZXJ2ZXJFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRMaXN0LnB1c2goZ2V0U2VydmVyTWVzc2FnZShzZXJ2ZXJFbnRyeSkpO1xuICAgICAgICBpZiAocmVzdWx0TGlzdC5sZW5ndGggPj0gbWF4UmVzdWx0cykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICBzZXJ2ZXI6IHJlc3VsdExpc3QsXG4gICAgICAgIGVuZDogaSA+PSBzZXJ2ZXJzLmxlbmd0aFxuICAgIH0pO1xufVxuZnVuY3Rpb24gR2V0U3ViY2hhbm5lbChjYWxsLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHN1YmNoYW5uZWxJZCA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc3ViY2hhbm5lbF9pZCk7XG4gICAgY29uc3Qgc3ViY2hhbm5lbEVudHJ5ID0gc3ViY2hhbm5lbHNbc3ViY2hhbm5lbElkXTtcbiAgICBpZiAoc3ViY2hhbm5lbEVudHJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FsbGJhY2soe1xuICAgICAgICAgICAgJ2NvZGUnOiBjb25zdGFudHNfMS5TdGF0dXMuTk9UX0ZPVU5ELFxuICAgICAgICAgICAgJ2RldGFpbHMnOiAnTm8gc3ViY2hhbm5lbCBkYXRhIGZvdW5kIGZvciBpZCAnICsgc3ViY2hhbm5lbElkXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc29sdmVkSW5mbyA9IHN1YmNoYW5uZWxFbnRyeS5nZXRJbmZvKCk7XG4gICAgY29uc3Qgc3ViY2hhbm5lbE1lc3NhZ2UgPSB7XG4gICAgICAgIHJlZjogc3ViY2hhbm5lbFJlZlRvTWVzc2FnZShzdWJjaGFubmVsRW50cnkucmVmKSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGFyZ2V0OiByZXNvbHZlZEluZm8udGFyZ2V0LFxuICAgICAgICAgICAgc3RhdGU6IGNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlKHJlc29sdmVkSW5mby5zdGF0ZSksXG4gICAgICAgICAgICBjYWxsc19zdGFydGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgY2FsbHNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uY2FsbFRyYWNrZXIuY2FsbHNTdWNjZWVkZWQsXG4gICAgICAgICAgICBjYWxsc19mYWlsZWQ6IHJlc29sdmVkSW5mby5jYWxsVHJhY2tlci5jYWxsc0ZhaWxlZCxcbiAgICAgICAgICAgIGxhc3RfY2FsbF9zdGFydGVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmNhbGxUcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICB0cmFjZTogcmVzb2x2ZWRJbmZvLnRyYWNlLmdldFRyYWNlTWVzc2FnZSgpXG4gICAgICAgIH0sXG4gICAgICAgIHNvY2tldF9yZWY6IHJlc29sdmVkSW5mby5jaGlsZHJlbi5zb2NrZXRzLm1hcChyZWYgPT4gc29ja2V0UmVmVG9NZXNzYWdlKHJlZikpXG4gICAgfTtcbiAgICBjYWxsYmFjayhudWxsLCB7IHN1YmNoYW5uZWw6IHN1YmNoYW5uZWxNZXNzYWdlIH0pO1xufVxuZnVuY3Rpb24gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHN1YmNoYW5uZWxBZGRyZXNzKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChzdWJjaGFubmVsX2FkZHJlc3NfMS5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKHN1YmNoYW5uZWxBZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkcmVzczogJ3RjcGlwX2FkZHJlc3MnLFxuICAgICAgICAgICAgdGNwaXBfYWRkcmVzczoge1xuICAgICAgICAgICAgICAgIGlwX2FkZHJlc3M6IChfYSA9IGlwQWRkcmVzc1N0cmluZ1RvQnVmZmVyKHN1YmNoYW5uZWxBZGRyZXNzLmhvc3QpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcG9ydDogc3ViY2hhbm5lbEFkZHJlc3MucG9ydFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZHJlc3M6ICd1ZHNfYWRkcmVzcycsXG4gICAgICAgICAgICB1ZHNfYWRkcmVzczoge1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBzdWJjaGFubmVsQWRkcmVzcy5wYXRoXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gR2V0U29ja2V0KGNhbGwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICBjb25zdCBzb2NrZXRJZCA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc29ja2V0X2lkKTtcbiAgICBjb25zdCBzb2NrZXRFbnRyeSA9IHNvY2tldHNbc29ja2V0SWRdO1xuICAgIGlmIChzb2NrZXRFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICdjb2RlJzogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgICdkZXRhaWxzJzogJ05vIHNvY2tldCBkYXRhIGZvdW5kIGZvciBpZCAnICsgc29ja2V0SWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc29ja2V0RW50cnkuZ2V0SW5mbygpO1xuICAgIGNvbnN0IHNlY3VyaXR5TWVzc2FnZSA9IHJlc29sdmVkSW5mby5zZWN1cml0eSA/IHtcbiAgICAgICAgbW9kZWw6ICd0bHMnLFxuICAgICAgICB0bHM6IHtcbiAgICAgICAgICAgIGNpcGhlcl9zdWl0ZTogcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmNpcGhlclN1aXRlU3RhbmRhcmROYW1lID8gJ3N0YW5kYXJkX25hbWUnIDogJ290aGVyX25hbWUnLFxuICAgICAgICAgICAgc3RhbmRhcmRfbmFtZTogKF9hID0gcmVzb2x2ZWRJbmZvLnNlY3VyaXR5LmNpcGhlclN1aXRlU3RhbmRhcmROYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhlcl9uYW1lOiAoX2IgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkuY2lwaGVyU3VpdGVPdGhlck5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvY2FsX2NlcnRpZmljYXRlOiAoX2MgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkubG9jYWxDZXJ0aWZpY2F0ZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVtb3RlX2NlcnRpZmljYXRlOiAoX2QgPSByZXNvbHZlZEluZm8uc2VjdXJpdHkucmVtb3RlQ2VydGlmaWNhdGUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfSA6IG51bGw7XG4gICAgY29uc3Qgc29ja2V0TWVzc2FnZSA9IHtcbiAgICAgICAgcmVmOiBzb2NrZXRSZWZUb01lc3NhZ2Uoc29ja2V0RW50cnkucmVmKSxcbiAgICAgICAgbG9jYWw6IHJlc29sdmVkSW5mby5sb2NhbEFkZHJlc3MgPyBzdWJjaGFubmVsQWRkcmVzc1RvQWRkcmVzc01lc3NhZ2UocmVzb2x2ZWRJbmZvLmxvY2FsQWRkcmVzcykgOiBudWxsLFxuICAgICAgICByZW1vdGU6IHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzID8gc3ViY2hhbm5lbEFkZHJlc3NUb0FkZHJlc3NNZXNzYWdlKHJlc29sdmVkSW5mby5yZW1vdGVBZGRyZXNzKSA6IG51bGwsXG4gICAgICAgIHJlbW90ZV9uYW1lOiAoX2UgPSByZXNvbHZlZEluZm8ucmVtb3RlTmFtZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdW5kZWZpbmVkLFxuICAgICAgICBzZWN1cml0eTogc2VjdXJpdHlNZXNzYWdlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICBrZWVwX2FsaXZlc19zZW50OiByZXNvbHZlZEluZm8ua2VlcEFsaXZlc1NlbnQsXG4gICAgICAgICAgICBzdHJlYW1zX3N0YXJ0ZWQ6IHJlc29sdmVkSW5mby5zdHJlYW1zU3RhcnRlZCxcbiAgICAgICAgICAgIHN0cmVhbXNfc3VjY2VlZGVkOiByZXNvbHZlZEluZm8uc3RyZWFtc1N1Y2NlZWRlZCxcbiAgICAgICAgICAgIHN0cmVhbXNfZmFpbGVkOiByZXNvbHZlZEluZm8uc3RyZWFtc0ZhaWxlZCxcbiAgICAgICAgICAgIGxhc3RfbG9jYWxfc3RyZWFtX2NyZWF0ZWRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8ubGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICBsYXN0X3JlbW90ZV9zdHJlYW1fY3JlYXRlZF90aW1lc3RhbXA6IGRhdGVUb1Byb3RvVGltZXN0YW1wKHJlc29sdmVkSW5mby5sYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCksXG4gICAgICAgICAgICBtZXNzYWdlc19yZWNlaXZlZDogcmVzb2x2ZWRJbmZvLm1lc3NhZ2VzUmVjZWl2ZWQsXG4gICAgICAgICAgICBtZXNzYWdlc19zZW50OiByZXNvbHZlZEluZm8ubWVzc2FnZXNTZW50LFxuICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3JlY2VpdmVkX3RpbWVzdGFtcDogZGF0ZVRvUHJvdG9UaW1lc3RhbXAocmVzb2x2ZWRJbmZvLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXApLFxuICAgICAgICAgICAgbGFzdF9tZXNzYWdlX3NlbnRfdGltZXN0YW1wOiBkYXRlVG9Qcm90b1RpbWVzdGFtcChyZXNvbHZlZEluZm8ubGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wKSxcbiAgICAgICAgICAgIGxvY2FsX2Zsb3dfY29udHJvbF93aW5kb3c6IHJlc29sdmVkSW5mby5sb2NhbEZsb3dDb250cm9sV2luZG93ID8geyB2YWx1ZTogcmVzb2x2ZWRJbmZvLmxvY2FsRmxvd0NvbnRyb2xXaW5kb3cgfSA6IG51bGwsXG4gICAgICAgICAgICByZW1vdGVfZmxvd19jb250cm9sX3dpbmRvdzogcmVzb2x2ZWRJbmZvLnJlbW90ZUZsb3dDb250cm9sV2luZG93ID8geyB2YWx1ZTogcmVzb2x2ZWRJbmZvLnJlbW90ZUZsb3dDb250cm9sV2luZG93IH0gOiBudWxsLFxuICAgICAgICB9XG4gICAgfTtcbiAgICBjYWxsYmFjayhudWxsLCB7IHNvY2tldDogc29ja2V0TWVzc2FnZSB9KTtcbn1cbmZ1bmN0aW9uIEdldFNlcnZlclNvY2tldHMoY2FsbCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBzZXJ2ZXJJZCA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc2VydmVyX2lkKTtcbiAgICBjb25zdCBzZXJ2ZXJFbnRyeSA9IHNlcnZlcnNbc2VydmVySWRdO1xuICAgIGlmIChzZXJ2ZXJFbnRyeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgICAgICdjb2RlJzogY29uc3RhbnRzXzEuU3RhdHVzLk5PVF9GT1VORCxcbiAgICAgICAgICAgICdkZXRhaWxzJzogJ05vIHNlcnZlciBkYXRhIGZvdW5kIGZvciBpZCAnICsgc2VydmVySWRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRJZCA9IE51bWJlci5wYXJzZUludChjYWxsLnJlcXVlc3Quc3RhcnRfc29ja2V0X2lkKTtcbiAgICBjb25zdCBtYXhSZXN1bHRzID0gTnVtYmVyLnBhcnNlSW50KGNhbGwucmVxdWVzdC5tYXhfcmVzdWx0cyk7XG4gICAgY29uc3QgcmVzb2x2ZWRJbmZvID0gc2VydmVyRW50cnkuZ2V0SW5mbygpO1xuICAgIC8vIElmIHdlIHdhbnRlZCB0byBpbmNsdWRlIGxpc3RlbmVyIHNvY2tldHMgaW4gdGhlIHJlc3VsdCwgdGhpcyBsaW5lIHdvdWxkXG4gICAgLy8gaW5zdGVhZCBzYXlcbiAgICAvLyBjb25zdCBhbGxTb2NrZXRzID0gcmVzb2x2ZWRJbmZvLmxpc3RlbmVyQ2hpbGRyZW4uc29ja2V0cy5jb25jYXQocmVzb2x2ZWRJbmZvLnNlc3Npb25DaGlsZHJlbi5zb2NrZXRzKS5zb3J0KChyZWYxLCByZWYyKSA9PiByZWYxLmlkIC0gcmVmMi5pZCk7XG4gICAgY29uc3QgYWxsU29ja2V0cyA9IHJlc29sdmVkSW5mby5zZXNzaW9uQ2hpbGRyZW4uc29ja2V0cy5zb3J0KChyZWYxLCByZWYyKSA9PiByZWYxLmlkIC0gcmVmMi5pZCk7XG4gICAgY29uc3QgcmVzdWx0TGlzdCA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGFsbFNvY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFsbFNvY2tldHNbaV0uaWQgPj0gc3RhcnRJZCkge1xuICAgICAgICAgICAgcmVzdWx0TGlzdC5wdXNoKHNvY2tldFJlZlRvTWVzc2FnZShhbGxTb2NrZXRzW2ldKSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0TGlzdC5sZW5ndGggPj0gbWF4UmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKG51bGwsIHtcbiAgICAgICAgc29ja2V0X3JlZjogcmVzdWx0TGlzdCxcbiAgICAgICAgZW5kOiBpID49IGFsbFNvY2tldHMubGVuZ3RoXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRDaGFubmVsekhhbmRsZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIEdldENoYW5uZWwsXG4gICAgICAgIEdldFRvcENoYW5uZWxzLFxuICAgICAgICBHZXRTZXJ2ZXIsXG4gICAgICAgIEdldFNlcnZlcnMsXG4gICAgICAgIEdldFN1YmNoYW5uZWwsXG4gICAgICAgIEdldFNvY2tldCxcbiAgICAgICAgR2V0U2VydmVyU29ja2V0c1xuICAgIH07XG59XG5leHBvcnRzLmdldENoYW5uZWx6SGFuZGxlcnMgPSBnZXRDaGFubmVsekhhbmRsZXJzO1xubGV0IGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbiA9IG51bGw7XG5mdW5jdGlvbiBnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uKCkge1xuICAgIGlmIChsb2FkZWRDaGFubmVsekRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbjtcbiAgICB9XG4gICAgLyogVGhlIHB1cnBvc2Ugb2YgdGhpcyBjb21wbGV4aXR5IGlzIHRvIGF2b2lkIGxvYWRpbmcgQGdycGMvcHJvdG8tbG9hZGVyIGF0XG4gICAgICogcnVudGltZSBmb3IgdXNlcnMgd2hvIHdpbGwgbm90IHVzZS9lbmFibGUgY2hhbm5lbHouICovXG4gICAgY29uc3QgbG9hZGVyTG9hZFN5bmMgPSByZXF1aXJlKCdAZ3JwYy9wcm90by1sb2FkZXInKS5sb2FkU3luYztcbiAgICBjb25zdCBsb2FkZWRQcm90byA9IGxvYWRlckxvYWRTeW5jKCdjaGFubmVsei5wcm90bycsIHtcbiAgICAgICAga2VlcENhc2U6IHRydWUsXG4gICAgICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgICAgIGVudW1zOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgICAgICBvbmVvZnM6IHRydWUsXG4gICAgICAgIGluY2x1ZGVEaXJzOiBbXG4gICAgICAgICAgICBgJHtfX2Rpcm5hbWV9Ly4uLy4uL3Byb3RvYFxuICAgICAgICBdXG4gICAgfSk7XG4gICAgY29uc3QgY2hhbm5lbHpHcnBjT2JqZWN0ID0gbWFrZV9jbGllbnRfMS5sb2FkUGFja2FnZURlZmluaXRpb24obG9hZGVkUHJvdG8pO1xuICAgIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbiA9IGNoYW5uZWx6R3JwY09iamVjdC5ncnBjLmNoYW5uZWx6LnYxLkNoYW5uZWx6LnNlcnZpY2U7XG4gICAgcmV0dXJuIGxvYWRlZENoYW5uZWx6RGVmaW5pdGlvbjtcbn1cbmV4cG9ydHMuZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiA9IGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb247XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBhZG1pbl8xLnJlZ2lzdGVyQWRtaW5TZXJ2aWNlKGdldENoYW5uZWx6U2VydmljZURlZmluaXRpb24sIGdldENoYW5uZWx6SGFuZGxlcnMpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhbm5lbHouanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2V0dXAiLCJnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uIiwiZ2V0Q2hhbm5lbHpIYW5kbGVycyIsInVucmVnaXN0ZXJDaGFubmVselJlZiIsInJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQiLCJyZWdpc3RlckNoYW5uZWx6U2VydmVyIiwicmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwiLCJyZWdpc3RlckNoYW5uZWx6Q2hhbm5lbCIsIkNoYW5uZWx6Q2FsbFRyYWNrZXIiLCJDaGFubmVsekNoaWxkcmVuVHJhY2tlciIsIkNoYW5uZWx6VHJhY2UiLCJuZXRfMSIsInJlcXVpcmUiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsImNvbnN0YW50c18xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJhZG1pbl8xIiwibWFrZV9jbGllbnRfMSIsImNoYW5uZWxSZWZUb01lc3NhZ2UiLCJyZWYiLCJjaGFubmVsX2lkIiwiaWQiLCJuYW1lIiwic3ViY2hhbm5lbFJlZlRvTWVzc2FnZSIsInN1YmNoYW5uZWxfaWQiLCJzZXJ2ZXJSZWZUb01lc3NhZ2UiLCJzZXJ2ZXJfaWQiLCJzb2NrZXRSZWZUb01lc3NhZ2UiLCJzb2NrZXRfaWQiLCJUQVJHRVRfUkVUQUlORURfVFJBQ0VTIiwiY29uc3RydWN0b3IiLCJldmVudHMiLCJldmVudHNMb2dnZWQiLCJjcmVhdGlvblRpbWVzdGFtcCIsIkRhdGUiLCJhZGRUcmFjZSIsInNldmVyaXR5IiwiZGVzY3JpcHRpb24iLCJjaGlsZCIsInRpbWVzdGFtcCIsInB1c2giLCJjaGlsZENoYW5uZWwiLCJraW5kIiwidW5kZWZpbmVkIiwiY2hpbGRTdWJjaGFubmVsIiwibGVuZ3RoIiwic2xpY2UiLCJnZXRUcmFjZU1lc3NhZ2UiLCJjcmVhdGlvbl90aW1lc3RhbXAiLCJkYXRlVG9Qcm90b1RpbWVzdGFtcCIsIm51bV9ldmVudHNfbG9nZ2VkIiwibWFwIiwiZXZlbnQiLCJjaGFubmVsX3JlZiIsInN1YmNoYW5uZWxfcmVmIiwiY2hhbm5lbENoaWxkcmVuIiwiTWFwIiwic3ViY2hhbm5lbENoaWxkcmVuIiwic29ja2V0Q2hpbGRyZW4iLCJyZWZDaGlsZCIsIl9hIiwiX2IiLCJfYyIsInRyYWNrZWRDaGlsZCIsImdldCIsImNvdW50Iiwic2V0IiwidW5yZWZDaGlsZCIsImRlbGV0ZSIsImdldENoaWxkTGlzdHMiLCJjaGFubmVscyIsInZhbHVlcyIsInN1YmNoYW5uZWxzIiwic29ja2V0cyIsImNhbGxzU3RhcnRlZCIsImNhbGxzU3VjY2VlZGVkIiwiY2FsbHNGYWlsZWQiLCJsYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAiLCJhZGRDYWxsU3RhcnRlZCIsImFkZENhbGxTdWNjZWVkZWQiLCJhZGRDYWxsRmFpbGVkIiwibmV4dElkIiwiZ2V0TmV4dElkIiwic2VydmVycyIsImdldEluZm8iLCJjaGFubmVsekVuYWJsZWQiLCJwYXJzZUlQdjZTZWN0aW9uIiwiYWRkcmVzc1NlY3Rpb24iLCJudW1iZXJWYWx1ZSIsIk51bWJlciIsInBhcnNlSW50IiwicGFyc2VJUHY2Q2h1bmsiLCJhZGRyZXNzQ2h1bmsiLCJieXRlUGFpcnMiLCJzcGxpdCIsInNlY3Rpb24iLCJyZXN1bHQiLCJjb25jYXQiLCJpcEFkZHJlc3NTdHJpbmdUb0J1ZmZlciIsImlwQWRkcmVzcyIsImlzSVB2NCIsIkJ1ZmZlciIsImZyb20iLCJVaW50OEFycmF5Iiwic2VnbWVudCIsImlzSVB2NiIsImxlZnRTZWN0aW9uIiwicmlnaHRTZWN0aW9uIiwiZG91YmxlQ29sb25JbmRleCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJsZWZ0QnVmZmVyIiwicmlnaHRCdWZmZXIiLCJtaWRkbGVCdWZmZXIiLCJhbGxvYyIsImNvbm5lY3Rpdml0eVN0YXRlVG9NZXNzYWdlIiwic3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIkNPTk5FQ1RJTkciLCJJRExFIiwiUkVBRFkiLCJTSFVURE9XTiIsIlRSQU5TSUVOVF9GQUlMVVJFIiwiZGF0ZSIsIm1pbGxpc1NpbmNlRXBvY2giLCJnZXRUaW1lIiwic2Vjb25kcyIsIm5hbm9zIiwiZ2V0Q2hhbm5lbE1lc3NhZ2UiLCJjaGFubmVsRW50cnkiLCJyZXNvbHZlZEluZm8iLCJkYXRhIiwidGFyZ2V0IiwiY2FsbHNfc3RhcnRlZCIsImNhbGxUcmFja2VyIiwiY2FsbHNfc3VjY2VlZGVkIiwiY2FsbHNfZmFpbGVkIiwibGFzdF9jYWxsX3N0YXJ0ZWRfdGltZXN0YW1wIiwidHJhY2UiLCJjaGlsZHJlbiIsIkdldENoYW5uZWwiLCJjYWxsIiwiY2FsbGJhY2siLCJjaGFubmVsSWQiLCJyZXF1ZXN0IiwiU3RhdHVzIiwiTk9UX0ZPVU5EIiwiY2hhbm5lbCIsIkdldFRvcENoYW5uZWxzIiwibWF4UmVzdWx0cyIsIm1heF9yZXN1bHRzIiwicmVzdWx0TGlzdCIsImkiLCJzdGFydF9jaGFubmVsX2lkIiwiZW5kIiwiZ2V0U2VydmVyTWVzc2FnZSIsInNlcnZlckVudHJ5IiwibGlzdGVuX3NvY2tldCIsImxpc3RlbmVyQ2hpbGRyZW4iLCJHZXRTZXJ2ZXIiLCJzZXJ2ZXJJZCIsInNlcnZlciIsIkdldFNlcnZlcnMiLCJzdGFydF9zZXJ2ZXJfaWQiLCJHZXRTdWJjaGFubmVsIiwic3ViY2hhbm5lbElkIiwic3ViY2hhbm5lbEVudHJ5Iiwic3ViY2hhbm5lbE1lc3NhZ2UiLCJzb2NrZXRfcmVmIiwic3ViY2hhbm5lbCIsInN1YmNoYW5uZWxBZGRyZXNzVG9BZGRyZXNzTWVzc2FnZSIsInN1YmNoYW5uZWxBZGRyZXNzIiwiaXNUY3BTdWJjaGFubmVsQWRkcmVzcyIsImFkZHJlc3MiLCJ0Y3BpcF9hZGRyZXNzIiwiaXBfYWRkcmVzcyIsImhvc3QiLCJwb3J0IiwidWRzX2FkZHJlc3MiLCJmaWxlbmFtZSIsInBhdGgiLCJHZXRTb2NrZXQiLCJfZCIsIl9lIiwic29ja2V0SWQiLCJzb2NrZXRFbnRyeSIsInNlY3VyaXR5TWVzc2FnZSIsInNlY3VyaXR5IiwibW9kZWwiLCJ0bHMiLCJjaXBoZXJfc3VpdGUiLCJjaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZSIsInN0YW5kYXJkX25hbWUiLCJvdGhlcl9uYW1lIiwiY2lwaGVyU3VpdGVPdGhlck5hbWUiLCJsb2NhbF9jZXJ0aWZpY2F0ZSIsImxvY2FsQ2VydGlmaWNhdGUiLCJyZW1vdGVfY2VydGlmaWNhdGUiLCJyZW1vdGVDZXJ0aWZpY2F0ZSIsInNvY2tldE1lc3NhZ2UiLCJsb2NhbCIsImxvY2FsQWRkcmVzcyIsInJlbW90ZSIsInJlbW90ZUFkZHJlc3MiLCJyZW1vdGVfbmFtZSIsInJlbW90ZU5hbWUiLCJrZWVwX2FsaXZlc19zZW50Iiwia2VlcEFsaXZlc1NlbnQiLCJzdHJlYW1zX3N0YXJ0ZWQiLCJzdHJlYW1zU3RhcnRlZCIsInN0cmVhbXNfc3VjY2VlZGVkIiwic3RyZWFtc1N1Y2NlZWRlZCIsInN0cmVhbXNfZmFpbGVkIiwic3RyZWFtc0ZhaWxlZCIsImxhc3RfbG9jYWxfc3RyZWFtX2NyZWF0ZWRfdGltZXN0YW1wIiwibGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCIsImxhc3RfcmVtb3RlX3N0cmVhbV9jcmVhdGVkX3RpbWVzdGFtcCIsImxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibWVzc2FnZXNfcmVjZWl2ZWQiLCJtZXNzYWdlc1JlY2VpdmVkIiwibWVzc2FnZXNfc2VudCIsIm1lc3NhZ2VzU2VudCIsImxhc3RfbWVzc2FnZV9yZWNlaXZlZF90aW1lc3RhbXAiLCJsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wIiwibGFzdF9tZXNzYWdlX3NlbnRfdGltZXN0YW1wIiwibGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wIiwibG9jYWxfZmxvd19jb250cm9sX3dpbmRvdyIsImxvY2FsRmxvd0NvbnRyb2xXaW5kb3ciLCJyZW1vdGVfZmxvd19jb250cm9sX3dpbmRvdyIsInJlbW90ZUZsb3dDb250cm9sV2luZG93Iiwic29ja2V0IiwiR2V0U2VydmVyU29ja2V0cyIsInN0YXJ0SWQiLCJzdGFydF9zb2NrZXRfaWQiLCJhbGxTb2NrZXRzIiwic2Vzc2lvbkNoaWxkcmVuIiwic29ydCIsInJlZjEiLCJyZWYyIiwibG9hZGVkQ2hhbm5lbHpEZWZpbml0aW9uIiwibG9hZGVyTG9hZFN5bmMiLCJsb2FkU3luYyIsImxvYWRlZFByb3RvIiwia2VlcENhc2UiLCJsb25ncyIsIlN0cmluZyIsImVudW1zIiwiZGVmYXVsdHMiLCJvbmVvZnMiLCJpbmNsdWRlRGlycyIsIl9fZGlybmFtZSIsImNoYW5uZWx6R3JwY09iamVjdCIsImxvYWRQYWNrYWdlRGVmaW5pdGlvbiIsImdycGMiLCJjaGFubmVseiIsInYxIiwiQ2hhbm5lbHoiLCJzZXJ2aWNlIiwicmVnaXN0ZXJBZG1pblNlcnZpY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client-interceptors.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst call_stream_1 = __webpack_require__(/*! ./call-stream */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-stream.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */ class InterceptorConfigurationError extends Error {\n    constructor(message){\n        super(message);\n        this.name = \"InterceptorConfigurationError\";\n        Error.captureStackTrace(this, InterceptorConfigurationError);\n    }\n}\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nclass ListenerBuilder {\n    constructor(){\n        this.metadata = undefined;\n        this.message = undefined;\n        this.status = undefined;\n    }\n    withOnReceiveMetadata(onReceiveMetadata) {\n        this.metadata = onReceiveMetadata;\n        return this;\n    }\n    withOnReceiveMessage(onReceiveMessage) {\n        this.message = onReceiveMessage;\n        return this;\n    }\n    withOnReceiveStatus(onReceiveStatus) {\n        this.status = onReceiveStatus;\n        return this;\n    }\n    build() {\n        return {\n            onReceiveMetadata: this.metadata,\n            onReceiveMessage: this.message,\n            onReceiveStatus: this.status\n        };\n    }\n}\nexports.ListenerBuilder = ListenerBuilder;\nclass RequesterBuilder {\n    constructor(){\n        this.start = undefined;\n        this.message = undefined;\n        this.halfClose = undefined;\n        this.cancel = undefined;\n    }\n    withStart(start) {\n        this.start = start;\n        return this;\n    }\n    withSendMessage(sendMessage) {\n        this.message = sendMessage;\n        return this;\n    }\n    withHalfClose(halfClose) {\n        this.halfClose = halfClose;\n        return this;\n    }\n    withCancel(cancel) {\n        this.cancel = cancel;\n        return this;\n    }\n    build() {\n        return {\n            start: this.start,\n            sendMessage: this.message,\n            halfClose: this.halfClose,\n            cancel: this.cancel\n        };\n    }\n}\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */ const defaultListener = {\n    onReceiveMetadata: (metadata, next)=>{\n        next(metadata);\n    },\n    onReceiveMessage: (message, next)=>{\n        next(message);\n    },\n    onReceiveStatus: (status, next)=>{\n        next(status);\n    }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */ const defaultRequester = {\n    start: (metadata, listener, next)=>{\n        next(metadata, listener);\n    },\n    sendMessage: (message, next)=>{\n        next(message);\n    },\n    halfClose: (next)=>{\n        next();\n    },\n    cancel: (next)=>{\n        next();\n    }\n};\nclass InterceptingCall {\n    constructor(nextCall, requester){\n        var _a, _b, _c, _d;\n        this.nextCall = nextCall;\n        /**\n         * Indicates that metadata has been passed to the requester's start\n         * method but it has not been passed to the corresponding next callback\n         */ this.processingMetadata = false;\n        /**\n         * Message context for a pending message that is waiting for\n         */ this.pendingMessageContext = null;\n        /**\n         * Indicates that a message has been passed to the requester's sendMessage\n         * method but it has not been passed to the corresponding next callback\n         */ this.processingMessage = false;\n        /**\n         * Indicates that a status was received but could not be propagated because\n         * a message was still being processed.\n         */ this.pendingHalfClose = false;\n        if (requester) {\n            this.requester = {\n                start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n                sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n                halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n                cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n            };\n        } else {\n            this.requester = defaultRequester;\n        }\n    }\n    cancelWithStatus(status, details) {\n        this.requester.cancel(()=>{\n            this.nextCall.cancelWithStatus(status, details);\n        });\n    }\n    getPeer() {\n        return this.nextCall.getPeer();\n    }\n    processPendingMessage() {\n        if (this.pendingMessageContext) {\n            this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n            this.pendingMessageContext = null;\n            this.pendingMessage = null;\n        }\n    }\n    processPendingHalfClose() {\n        if (this.pendingHalfClose) {\n            this.nextCall.halfClose();\n        }\n    }\n    start(metadata, interceptingListener) {\n        var _a, _b, _c, _d, _e, _f;\n        const fullInterceptingListener = {\n            onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata)=>{},\n            onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message)=>{},\n            onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status)=>{}\n        };\n        this.processingMetadata = true;\n        this.requester.start(metadata, fullInterceptingListener, (md, listener)=>{\n            var _a, _b, _c;\n            this.processingMetadata = false;\n            let finalInterceptingListener;\n            if (call_stream_1.isInterceptingListener(listener)) {\n                finalInterceptingListener = listener;\n            } else {\n                const fullListener = {\n                    onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n                    onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n                    onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n                };\n                finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n            }\n            this.nextCall.start(md, finalInterceptingListener);\n            this.processPendingMessage();\n            this.processPendingHalfClose();\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        this.processingMessage = true;\n        this.requester.sendMessage(message, (finalMessage)=>{\n            this.processingMessage = false;\n            if (this.processingMetadata) {\n                this.pendingMessageContext = context;\n                this.pendingMessage = message;\n            } else {\n                this.nextCall.sendMessageWithContext(context, finalMessage);\n                this.processPendingHalfClose();\n            }\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    startRead() {\n        this.nextCall.startRead();\n    }\n    halfClose() {\n        this.requester.halfClose(()=>{\n            if (this.processingMetadata || this.processingMessage) {\n                this.pendingHalfClose = true;\n            } else {\n                this.nextCall.halfClose();\n            }\n        });\n    }\n    setCredentials(credentials) {\n        this.nextCall.setCredentials(credentials);\n    }\n}\nexports.InterceptingCall = InterceptingCall;\nfunction getCall(channel, path, options) {\n    var _a, _b;\n    const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n    const host = options.host;\n    const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n    const propagateFlags = options.propagate_flags;\n    const credentials = options.credentials;\n    const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n    if (credentials) {\n        call.setCredentials(credentials);\n    }\n    return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */ class BaseInterceptingCall {\n    constructor(call, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    methodDefinition){\n        this.call = call;\n        this.methodDefinition = methodDefinition;\n    }\n    cancelWithStatus(status, details) {\n        this.call.cancelWithStatus(status, details);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    setCredentials(credentials) {\n        this.call.setCredentials(credentials);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessageWithContext(context, message) {\n        let serialized;\n        try {\n            serialized = this.methodDefinition.requestSerialize(message);\n        } catch (e) {\n            this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);\n            return;\n        }\n        this.call.sendMessageWithContext(context, serialized);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sendMessage(message) {\n        this.sendMessageWithContext({}, message);\n    }\n    start(metadata, interceptingListener) {\n        let readError = null;\n        this.call.start(metadata, {\n            onReceiveMetadata: (metadata)=>{\n                var _a;\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n            },\n            onReceiveMessage: (message)=>{\n                var _a;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                let deserialized;\n                try {\n                    deserialized = this.methodDefinition.responseDeserialize(message);\n                } catch (e) {\n                    readError = {\n                        code: constants_1.Status.INTERNAL,\n                        details: `Response message parsing error: ${e.message}`,\n                        metadata: new metadata_1.Metadata()\n                    };\n                    this.call.cancelWithStatus(readError.code, readError.details);\n                    return;\n                }\n                (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n            },\n            onReceiveStatus: (status)=>{\n                var _a, _b;\n                if (readError) {\n                    (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n                } else {\n                    (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n                }\n            }\n        });\n    }\n    startRead() {\n        this.call.startRead();\n    }\n    halfClose() {\n        this.call.halfClose();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */ class BaseUnaryInterceptingCall extends BaseInterceptingCall {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(call, methodDefinition){\n        super(call, methodDefinition);\n    }\n    start(metadata, listener) {\n        var _a, _b;\n        let receivedMessage = false;\n        const wrapperListener = {\n            onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata)=>{},\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage: (message)=>{\n                var _a;\n                receivedMessage = true;\n                (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n            },\n            onReceiveStatus: (status)=>{\n                var _a, _b;\n                if (!receivedMessage) {\n                    (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n                }\n                (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n            }\n        };\n        super.start(metadata, wrapperListener);\n        this.call.startRead();\n    }\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */ class BaseStreamingInterceptingCall extends BaseInterceptingCall {\n}\nfunction getBottomInterceptingCall(channel, options, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n    const call = getCall(channel, methodDefinition.path, options);\n    if (methodDefinition.responseStream) {\n        return new BaseStreamingInterceptingCall(call, methodDefinition);\n    } else {\n        return new BaseUnaryInterceptingCall(call, methodDefinition);\n    }\n}\nfunction getInterceptingCall(interceptorArgs, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n    if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError(\"Both interceptors and interceptor_providers were passed as options \" + \"to the client constructor. Only one of these is allowed.\");\n    }\n    if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n        throw new InterceptorConfigurationError(\"Both interceptors and interceptor_providers were passed as call \" + \"options. Only one of these is allowed.\");\n    }\n    let interceptors = [];\n    // Interceptors passed to the call override interceptors passed to the client constructor\n    if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider)=>provider(methodDefinition))).filter((interceptor)=>interceptor);\n    // Filter out falsy values when providers return nothing\n    } else {\n        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider)=>provider(methodDefinition))).filter((interceptor)=>interceptor);\n    // Filter out falsy values when providers return nothing\n    }\n    const interceptorOptions = Object.assign({}, options, {\n        method_definition: methodDefinition\n    });\n    /* For each interceptor in the list, the nextCall function passed to it is\n     * based on the next interceptor in the list, using a nextCall function\n     * constructed with the following interceptor in the list, and so on. The\n     * initialValue, which is effectively at the end of the list, is a nextCall\n     * function that invokes getBottomInterceptingCall, the result of which\n     * handles (de)serialization and also gets the underlying call from the\n     * channel. */ const getCall = interceptors.reduceRight((nextCall, nextInterceptor)=>{\n        return (currentOptions)=>nextInterceptor(currentOptions, nextCall);\n    }, (finalOptions)=>getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n    return getCall(interceptorOptions);\n}\nexports.getInterceptingCall = getInterceptingCall; //# sourceMappingURL=client-interceptors.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsMkJBQTJCLEdBQUdBLHdCQUF3QixHQUFHQSx3QkFBd0IsR0FBR0EsdUJBQXVCLEdBQUdBLHFDQUFxQyxHQUFHLEtBQUs7QUFDM0osTUFBTU8sYUFBYUMsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxrRkFBZTtBQUM3QyxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6Qzs7O0NBR0MsR0FDRCxNQUFNRixzQ0FBc0NLO0lBQ3hDQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSyxDQUFDQTtRQUNOLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1pILE1BQU1JLGlCQUFpQixDQUFDLElBQUksRUFBRVQ7SUFDbEM7QUFDSjtBQUNBTixxQ0FBcUMsR0FBR007QUFDeEMsTUFBTUQ7SUFDRk8sYUFBYztRQUNWLElBQUksQ0FBQ0ksUUFBUSxHQUFHQztRQUNoQixJQUFJLENBQUNKLE9BQU8sR0FBR0k7UUFDZixJQUFJLENBQUNDLE1BQU0sR0FBR0Q7SUFDbEI7SUFDQUUsc0JBQXNCQyxpQkFBaUIsRUFBRTtRQUNyQyxJQUFJLENBQUNKLFFBQVEsR0FBR0k7UUFDaEIsT0FBTyxJQUFJO0lBQ2Y7SUFDQUMscUJBQXFCQyxnQkFBZ0IsRUFBRTtRQUNuQyxJQUFJLENBQUNULE9BQU8sR0FBR1M7UUFDZixPQUFPLElBQUk7SUFDZjtJQUNBQyxvQkFBb0JDLGVBQWUsRUFBRTtRQUNqQyxJQUFJLENBQUNOLE1BQU0sR0FBR007UUFDZCxPQUFPLElBQUk7SUFDZjtJQUNBQyxRQUFRO1FBQ0osT0FBTztZQUNITCxtQkFBbUIsSUFBSSxDQUFDSixRQUFR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WixNQUFNYixVQUFVb0MsYUFBYVMsV0FBVyxDQUFDLENBQUM3RSxVQUFVOEU7UUFDaEQsT0FBTyxDQUFDQyxpQkFBbUJELGdCQUFnQkMsZ0JBQWdCL0U7SUFDL0QsR0FBRyxDQUFDZ0YsZUFBaUJwQiwwQkFBMEIzQixTQUFTK0MsY0FBY25DO0lBQ3RFLE9BQU9iLFFBQVEwQztBQUNuQjtBQUNBaEgsMkJBQTJCLEdBQUdFLHFCQUM5QiwrQ0FBK0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LWludGVyY2VwdG9ycy5qcz8xMzBmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldEludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLkludGVyY2VwdGluZ0NhbGwgPSBleHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBleHBvcnRzLkxpc3RlbmVyQnVpbGRlciA9IGV4cG9ydHMuSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IgPSB2b2lkIDA7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBjYWxsX3N0cmVhbV8xID0gcmVxdWlyZShcIi4vY2FsbC1zdHJlYW1cIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbi8qKlxuICogRXJyb3IgY2xhc3MgYXNzb2NpYXRlZCB3aXRoIHBhc3NpbmcgYm90aCBpbnRlcmNlcHRvcnMgYW5kIGludGVyY2VwdG9yXG4gKiBwcm92aWRlcnMgdG8gYSBjbGllbnQgY29uc3RydWN0b3Igb3IgYXMgY2FsbCBvcHRpb25zLlxuICovXG5jbGFzcyBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3InO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBJbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcik7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvciA9IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yO1xuY2xhc3MgTGlzdGVuZXJCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgd2l0aE9uUmVjZWl2ZU1ldGFkYXRhKG9uUmVjZWl2ZU1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBvblJlY2VpdmVNZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVNZXNzYWdlKG9uUmVjZWl2ZU1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gb25SZWNlaXZlTWVzc2FnZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhPblJlY2VpdmVTdGF0dXMob25SZWNlaXZlU3RhdHVzKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gb25SZWNlaXZlU3RhdHVzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5MaXN0ZW5lckJ1aWxkZXIgPSBMaXN0ZW5lckJ1aWxkZXI7XG5jbGFzcyBSZXF1ZXN0ZXJCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jYW5jZWwgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHdpdGhTdGFydChzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoU2VuZE1lc3NhZ2Uoc2VuZE1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gc2VuZE1lc3NhZ2U7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB3aXRoSGFsZkNsb3NlKGhhbGZDbG9zZSkge1xuICAgICAgICB0aGlzLmhhbGZDbG9zZSA9IGhhbGZDbG9zZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdpdGhDYW5jZWwoY2FuY2VsKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYnVpbGQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGFydDogdGhpcy5zdGFydCxcbiAgICAgICAgICAgIHNlbmRNZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICAgICAgICBoYWxmQ2xvc2U6IHRoaXMuaGFsZkNsb3NlLFxuICAgICAgICAgICAgY2FuY2VsOiB0aGlzLmNhbmNlbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlJlcXVlc3RlckJ1aWxkZXIgPSBSZXF1ZXN0ZXJCdWlsZGVyO1xuLyoqXG4gKiBBIExpc3RlbmVyIHdpdGggYSBkZWZhdWx0IHBhc3MtdGhyb3VnaCBpbXBsZW1lbnRhdGlvbiBvZiBlYWNoIG1ldGhvZC4gVXNlZFxuICogZm9yIGZpbGxpbmcgb3V0IExpc3RlbmVycyB3aXRoIHNvbWUgbWV0aG9kcyBvbWl0dGVkLlxuICovXG5jb25zdCBkZWZhdWx0TGlzdGVuZXIgPSB7XG4gICAgb25SZWNlaXZlTWV0YWRhdGE6IChtZXRhZGF0YSwgbmV4dCkgPT4ge1xuICAgICAgICBuZXh0KG1ldGFkYXRhKTtcbiAgICB9LFxuICAgIG9uUmVjZWl2ZU1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWVzc2FnZSk7XG4gICAgfSxcbiAgICBvblJlY2VpdmVTdGF0dXM6IChzdGF0dXMsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChzdGF0dXMpO1xuICAgIH0sXG59O1xuLyoqXG4gKiBBIFJlcXVlc3RlciB3aXRoIGEgZGVmYXVsdCBwYXNzLXRocm91Z2ggaW1wbGVtZW50YXRpb24gb2YgZWFjaCBtZXRob2QuIFVzZWRcbiAqIGZvciBmaWxsaW5nIG91dCBSZXF1ZXN0ZXJzIHdpdGggc29tZSBtZXRob2RzIG9taXR0ZWQuXG4gKi9cbmNvbnN0IGRlZmF1bHRSZXF1ZXN0ZXIgPSB7XG4gICAgc3RhcnQ6IChtZXRhZGF0YSwgbGlzdGVuZXIsIG5leHQpID0+IHtcbiAgICAgICAgbmV4dChtZXRhZGF0YSwgbGlzdGVuZXIpO1xuICAgIH0sXG4gICAgc2VuZE1lc3NhZ2U6IChtZXNzYWdlLCBuZXh0KSA9PiB7XG4gICAgICAgIG5leHQobWVzc2FnZSk7XG4gICAgfSxcbiAgICBoYWxmQ2xvc2U6IChuZXh0KSA9PiB7XG4gICAgICAgIG5leHQoKTtcbiAgICB9LFxuICAgIGNhbmNlbDogKG5leHQpID0+IHtcbiAgICAgICAgbmV4dCgpO1xuICAgIH0sXG59O1xuY2xhc3MgSW50ZXJjZXB0aW5nQ2FsbCB7XG4gICAgY29uc3RydWN0b3IobmV4dENhbGwsIHJlcXVlc3Rlcikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHRoaXMubmV4dENhbGwgPSBuZXh0Q2FsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IG1ldGFkYXRhIGhhcyBiZWVuIHBhc3NlZCB0byB0aGUgcmVxdWVzdGVyJ3Mgc3RhcnRcbiAgICAgICAgICogbWV0aG9kIGJ1dCBpdCBoYXMgbm90IGJlZW4gcGFzc2VkIHRvIHRoZSBjb3JyZXNwb25kaW5nIG5leHQgY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01ldGFkYXRhID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXNzYWdlIGNvbnRleHQgZm9yIGEgcGVuZGluZyBtZXNzYWdlIHRoYXQgaXMgd2FpdGluZyBmb3JcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IGEgbWVzc2FnZSBoYXMgYmVlbiBwYXNzZWQgdG8gdGhlIHJlcXVlc3RlcidzIHNlbmRNZXNzYWdlXG4gICAgICAgICAqIG1ldGhvZCBidXQgaXQgaGFzIG5vdCBiZWVuIHBhc3NlZCB0byB0aGUgY29ycmVzcG9uZGluZyBuZXh0IGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIHN0YXR1cyB3YXMgcmVjZWl2ZWQgYnV0IGNvdWxkIG5vdCBiZSBwcm9wYWdhdGVkIGJlY2F1c2VcbiAgICAgICAgICogYSBtZXNzYWdlIHdhcyBzdGlsbCBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlbmRpbmdIYWxmQ2xvc2UgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJlcXVlc3Rlcikge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0ZXIgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IChfYSA9IHJlcXVlc3Rlci5zdGFydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdFJlcXVlc3Rlci5zdGFydCxcbiAgICAgICAgICAgICAgICBzZW5kTWVzc2FnZTogKF9iID0gcmVxdWVzdGVyLnNlbmRNZXNzYWdlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0UmVxdWVzdGVyLnNlbmRNZXNzYWdlLFxuICAgICAgICAgICAgICAgIGhhbGZDbG9zZTogKF9jID0gcmVxdWVzdGVyLmhhbGZDbG9zZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZGVmYXVsdFJlcXVlc3Rlci5oYWxmQ2xvc2UsXG4gICAgICAgICAgICAgICAgY2FuY2VsOiAoX2QgPSByZXF1ZXN0ZXIuY2FuY2VsKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBkZWZhdWx0UmVxdWVzdGVyLmNhbmNlbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RlciA9IGRlZmF1bHRSZXF1ZXN0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ZXIuY2FuY2VsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dENhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBwcm9jZXNzUGVuZGluZ01lc3NhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0LCB0aGlzLnBlbmRpbmdNZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2VDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ01lc3NhZ2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nSGFsZkNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRDYWxsLmhhbGZDbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBpbnRlcmNlcHRpbmdMaXN0ZW5lcikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgY29uc3QgZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyID0ge1xuICAgICAgICAgICAgb25SZWNlaXZlTWV0YWRhdGE6IChfYiA9IChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJpbmQoaW50ZXJjZXB0aW5nTGlzdGVuZXIpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoKG1ldGFkYXRhKSA9PiB7IH0pLFxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKF9kID0gKF9jID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iaW5kKGludGVyY2VwdGluZ0xpc3RlbmVyKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogKChtZXNzYWdlKSA9PiB7IH0pLFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoX2YgPSAoX2UgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlU3RhdHVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYmluZChpbnRlcmNlcHRpbmdMaXN0ZW5lcikpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6ICgoc3RhdHVzKSA9PiB7IH0pLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXRhZGF0YSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVxdWVzdGVyLnN0YXJ0KG1ldGFkYXRhLCBmdWxsSW50ZXJjZXB0aW5nTGlzdGVuZXIsIChtZCwgbGlzdGVuZXIpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyO1xuICAgICAgICAgICAgaWYgKGNhbGxfc3RyZWFtXzEuaXNJbnRlcmNlcHRpbmdMaXN0ZW5lcihsaXN0ZW5lcikpIHtcbiAgICAgICAgICAgICAgICBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyID0gbGlzdGVuZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsTGlzdGVuZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhOiAoX2EgPSBsaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdExpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiAoX2IgPSBsaXN0ZW5lci5vblJlY2VpdmVNZXNzYWdlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBkZWZhdWx0TGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoX2MgPSBsaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyID0gbmV3IGNhbGxfc3RyZWFtXzEuSW50ZXJjZXB0aW5nTGlzdGVuZXJJbXBsKGZ1bGxMaXN0ZW5lciwgZnVsbEludGVyY2VwdGluZ0xpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmV4dENhbGwuc3RhcnQobWQsIGZpbmFsSW50ZXJjZXB0aW5nTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUGVuZGluZ01lc3NhZ2UoKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlcXVlc3Rlci5zZW5kTWVzc2FnZShtZXNzYWdlLCAoZmluYWxNZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NpbmdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdNZXNzYWdlQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsLnNlbmRNZXNzYWdlV2l0aENvbnRleHQoY29udGV4dCwgZmluYWxNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NQZW5kaW5nSGFsZkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHNlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5zZW5kTWVzc2FnZVdpdGhDb250ZXh0KHt9LCBtZXNzYWdlKTtcbiAgICB9XG4gICAgc3RhcnRSZWFkKCkge1xuICAgICAgICB0aGlzLm5leHRDYWxsLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdGVyLmhhbGZDbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9jZXNzaW5nTWV0YWRhdGEgfHwgdGhpcy5wcm9jZXNzaW5nTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0hhbGZDbG9zZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRDYWxsLmhhbGZDbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0Q3JlZGVudGlhbHMoY3JlZGVudGlhbHMpIHtcbiAgICAgICAgdGhpcy5uZXh0Q2FsbC5zZXRDcmVkZW50aWFscyhjcmVkZW50aWFscyk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnRlcmNlcHRpbmdDYWxsID0gSW50ZXJjZXB0aW5nQ2FsbDtcbmZ1bmN0aW9uIGdldENhbGwoY2hhbm5lbCwgcGF0aCwgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZGVhZGxpbmUgPSAoX2EgPSBvcHRpb25zLmRlYWRsaW5lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBJbmZpbml0eTtcbiAgICBjb25zdCBob3N0ID0gb3B0aW9ucy5ob3N0O1xuICAgIGNvbnN0IHBhcmVudCA9IChfYiA9IG9wdGlvbnMucGFyZW50KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsO1xuICAgIGNvbnN0IHByb3BhZ2F0ZUZsYWdzID0gb3B0aW9ucy5wcm9wYWdhdGVfZmxhZ3M7XG4gICAgY29uc3QgY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzO1xuICAgIGNvbnN0IGNhbGwgPSBjaGFubmVsLmNyZWF0ZUNhbGwocGF0aCwgZGVhZGxpbmUsIGhvc3QsIHBhcmVudCwgcHJvcGFnYXRlRmxhZ3MpO1xuICAgIGlmIChjcmVkZW50aWFscykge1xuICAgICAgICBjYWxsLnNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGw7XG59XG4vKipcbiAqIEludGVyY2VwdGluZ0NhbGwgaW1wbGVtZW50YXRpb24gdGhhdCBkaXJlY3RseSBvd25zIHRoZSB1bmRlcmx5aW5nIENhbGxcbiAqIG9iamVjdCBhbmQgaGFuZGxlcyBzZXJpYWxpemF0aW9uIGFuZCBkZXNlcmFpemxpYXRpb24uXG4gKi9cbmNsYXNzIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIG1ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRob2REZWZpbml0aW9uID0gbWV0aG9kRGVmaW5pdGlvbjtcbiAgICB9XG4gICAgY2FuY2VsV2l0aFN0YXR1cyhzdGF0dXMsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMoc3RhdHVzLCBkZXRhaWxzKTtcbiAgICB9XG4gICAgZ2V0UGVlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQZWVyKCk7XG4gICAgfVxuICAgIHNldENyZWRlbnRpYWxzKGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZXRDcmVkZW50aWFscyhjcmVkZW50aWFscyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBtZXNzYWdlKSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VyaWFsaXplZCA9IHRoaXMubWV0aG9kRGVmaW5pdGlvbi5yZXF1ZXN0U2VyaWFsaXplKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGwuY2FuY2VsV2l0aFN0YXR1cyhjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsIGBSZXF1ZXN0IG1lc3NhZ2Ugc2VyaWFsaXphdGlvbiBmYWlsdXJlOiAke2UubWVzc2FnZX1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGwuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dChjb250ZXh0LCBzZXJpYWxpemVkKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2VXaXRoQ29udGV4dCh7fSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXJ0KG1ldGFkYXRhLCBpbnRlcmNlcHRpbmdMaXN0ZW5lcikge1xuICAgICAgICBsZXQgcmVhZEVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0KG1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIGxldCBkZXNlcmlhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVzZXJpYWxpemVkID0gdGhpcy5tZXRob2REZWZpbml0aW9uLnJlc3BvbnNlRGVzZXJpYWxpemUobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRFcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBSZXNwb25zZSBtZXNzYWdlIHBhcnNpbmcgZXJyb3I6ICR7ZS5tZXNzYWdlfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsLmNhbmNlbFdpdGhTdGF0dXMocmVhZEVycm9yLmNvZGUsIHJlYWRFcnJvci5kZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoX2EgPSBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gbnVsbCB8fCBpbnRlcmNlcHRpbmdMaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW50ZXJjZXB0aW5nTGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIGRlc2VyaWFsaXplZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzOiAoc3RhdHVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAocmVhZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSBudWxsIHx8IGludGVyY2VwdGluZ0xpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnRlcmNlcHRpbmdMaXN0ZW5lci5vblJlY2VpdmVTdGF0dXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGludGVyY2VwdGluZ0xpc3RlbmVyLCByZWFkRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgKF9iID0gaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IG51bGwgfHwgaW50ZXJjZXB0aW5nTGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGludGVyY2VwdGluZ0xpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoaW50ZXJjZXB0aW5nTGlzdGVuZXIsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0UmVhZCgpIHtcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0UmVhZCgpO1xuICAgIH1cbiAgICBoYWxmQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMuY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICB9XG59XG4vKipcbiAqIEJhc2VJbnRlcmNlcHRpbmdDYWxsIHdpdGggc3BlY2lhbC1jYXNlZCBiZWhhdmlvciBmb3IgbWV0aG9kcyB3aXRoIHVuYXJ5XG4gKiByZXNwb25zZXMuXG4gKi9cbmNsYXNzIEJhc2VVbmFyeUludGVyY2VwdGluZ0NhbGwgZXh0ZW5kcyBCYXNlSW50ZXJjZXB0aW5nQ2FsbCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBtZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHN1cGVyKGNhbGwsIG1ldGhvZERlZmluaXRpb24pO1xuICAgIH1cbiAgICBzdGFydChtZXRhZGF0YSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlY2VpdmVkTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCB3cmFwcGVyTGlzdGVuZXIgPSB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKF9iID0gKF9hID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZU1ldGFkYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChsaXN0ZW5lcikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICgobWV0YWRhdGEpID0+IHsgfSksXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAoX2EgPSBsaXN0ZW5lciA9PT0gbnVsbCB8fCBsaXN0ZW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGlzdGVuZXIub25SZWNlaXZlTWVzc2FnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobGlzdGVuZXIsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVjZWl2ZVN0YXR1czogKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWNlaXZlZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZU1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGxpc3RlbmVyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKF9iID0gbGlzdGVuZXIgPT09IG51bGwgfHwgbGlzdGVuZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxpc3RlbmVyLm9uUmVjZWl2ZVN0YXR1cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwobGlzdGVuZXIsIHN0YXR1cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBzdXBlci5zdGFydChtZXRhZGF0YSwgd3JhcHBlckxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5jYWxsLnN0YXJ0UmVhZCgpO1xuICAgIH1cbn1cbi8qKlxuICogQmFzZUludGVyY2VwdGluZ0NhbGwgd2l0aCBzcGVjaWFsLWNhc2VkIGJlaGF2aW9yIGZvciBtZXRob2RzIHdpdGggc3RyZWFtaW5nXG4gKiByZXNwb25zZXMuXG4gKi9cbmNsYXNzIEJhc2VTdHJlYW1pbmdJbnRlcmNlcHRpbmdDYWxsIGV4dGVuZHMgQmFzZUludGVyY2VwdGluZ0NhbGwge1xufVxuZnVuY3Rpb24gZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbChjaGFubmVsLCBvcHRpb25zLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5tZXRob2REZWZpbml0aW9uKSB7XG4gICAgY29uc3QgY2FsbCA9IGdldENhbGwoY2hhbm5lbCwgbWV0aG9kRGVmaW5pdGlvbi5wYXRoLCBvcHRpb25zKTtcbiAgICBpZiAobWV0aG9kRGVmaW5pdGlvbi5yZXNwb25zZVN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IEJhc2VTdHJlYW1pbmdJbnRlcmNlcHRpbmdDYWxsKGNhbGwsIG1ldGhvZERlZmluaXRpb24pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCYXNlVW5hcnlJbnRlcmNlcHRpbmdDYWxsKGNhbGwsIG1ldGhvZERlZmluaXRpb24pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEludGVyY2VwdGluZ0NhbGwoaW50ZXJjZXB0b3JBcmdzLCBcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5tZXRob2REZWZpbml0aW9uLCBvcHRpb25zLCBjaGFubmVsKSB7XG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jbGllbnRJbnRlcmNlcHRvcnMubGVuZ3RoID4gMCAmJlxuICAgICAgICBpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IoJ0JvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvcl9wcm92aWRlcnMgd2VyZSBwYXNzZWQgYXMgb3B0aW9ucyAnICtcbiAgICAgICAgICAgICd0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yLiBPbmx5IG9uZSBvZiB0aGVzZSBpcyBhbGxvd2VkLicpO1xuICAgIH1cbiAgICBpZiAoaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvcnMubGVuZ3RoID4gMCAmJlxuICAgICAgICBpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludGVyY2VwdG9yQ29uZmlndXJhdGlvbkVycm9yKCdCb3RoIGludGVyY2VwdG9ycyBhbmQgaW50ZXJjZXB0b3JfcHJvdmlkZXJzIHdlcmUgcGFzc2VkIGFzIGNhbGwgJyArXG4gICAgICAgICAgICAnb3B0aW9ucy4gT25seSBvbmUgb2YgdGhlc2UgaXMgYWxsb3dlZC4nKTtcbiAgICB9XG4gICAgbGV0IGludGVyY2VwdG9ycyA9IFtdO1xuICAgIC8vIEludGVyY2VwdG9ycyBwYXNzZWQgdG8gdGhlIGNhbGwgb3ZlcnJpZGUgaW50ZXJjZXB0b3JzIHBhc3NlZCB0byB0aGUgY2xpZW50IGNvbnN0cnVjdG9yXG4gICAgaWYgKGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLmxlbmd0aCA+IDAgfHxcbiAgICAgICAgaW50ZXJjZXB0b3JBcmdzLmNhbGxJbnRlcmNlcHRvclByb3ZpZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGludGVyY2VwdG9ycyA9IFtdXG4gICAgICAgICAgICAuY29uY2F0KGludGVyY2VwdG9yQXJncy5jYWxsSW50ZXJjZXB0b3JzLCBpbnRlcmNlcHRvckFyZ3MuY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzLm1hcCgocHJvdmlkZXIpID0+IHByb3ZpZGVyKG1ldGhvZERlZmluaXRpb24pKSlcbiAgICAgICAgICAgIC5maWx0ZXIoKGludGVyY2VwdG9yKSA9PiBpbnRlcmNlcHRvcik7XG4gICAgICAgIC8vIEZpbHRlciBvdXQgZmFsc3kgdmFsdWVzIHdoZW4gcHJvdmlkZXJzIHJldHVybiBub3RoaW5nXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbnRlcmNlcHRvcnMgPSBbXVxuICAgICAgICAgICAgLmNvbmNhdChpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JzLCBpbnRlcmNlcHRvckFyZ3MuY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnMubWFwKChwcm92aWRlcikgPT4gcHJvdmlkZXIobWV0aG9kRGVmaW5pdGlvbikpKVxuICAgICAgICAgICAgLmZpbHRlcigoaW50ZXJjZXB0b3IpID0+IGludGVyY2VwdG9yKTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBmYWxzeSB2YWx1ZXMgd2hlbiBwcm92aWRlcnMgcmV0dXJuIG5vdGhpbmdcbiAgICB9XG4gICAgY29uc3QgaW50ZXJjZXB0b3JPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBtZXRob2RfZGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICB9KTtcbiAgICAvKiBGb3IgZWFjaCBpbnRlcmNlcHRvciBpbiB0aGUgbGlzdCwgdGhlIG5leHRDYWxsIGZ1bmN0aW9uIHBhc3NlZCB0byBpdCBpc1xuICAgICAqIGJhc2VkIG9uIHRoZSBuZXh0IGludGVyY2VwdG9yIGluIHRoZSBsaXN0LCB1c2luZyBhIG5leHRDYWxsIGZ1bmN0aW9uXG4gICAgICogY29uc3RydWN0ZWQgd2l0aCB0aGUgZm9sbG93aW5nIGludGVyY2VwdG9yIGluIHRoZSBsaXN0LCBhbmQgc28gb24uIFRoZVxuICAgICAqIGluaXRpYWxWYWx1ZSwgd2hpY2ggaXMgZWZmZWN0aXZlbHkgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCwgaXMgYSBuZXh0Q2FsbFxuICAgICAqIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBnZXRCb3R0b21JbnRlcmNlcHRpbmdDYWxsLCB0aGUgcmVzdWx0IG9mIHdoaWNoXG4gICAgICogaGFuZGxlcyAoZGUpc2VyaWFsaXphdGlvbiBhbmQgYWxzbyBnZXRzIHRoZSB1bmRlcmx5aW5nIGNhbGwgZnJvbSB0aGVcbiAgICAgKiBjaGFubmVsLiAqL1xuICAgIGNvbnN0IGdldENhbGwgPSBpbnRlcmNlcHRvcnMucmVkdWNlUmlnaHQoKG5leHRDYWxsLCBuZXh0SW50ZXJjZXB0b3IpID0+IHtcbiAgICAgICAgcmV0dXJuIChjdXJyZW50T3B0aW9ucykgPT4gbmV4dEludGVyY2VwdG9yKGN1cnJlbnRPcHRpb25zLCBuZXh0Q2FsbCk7XG4gICAgfSwgKGZpbmFsT3B0aW9ucykgPT4gZ2V0Qm90dG9tSW50ZXJjZXB0aW5nQ2FsbChjaGFubmVsLCBmaW5hbE9wdGlvbnMsIG1ldGhvZERlZmluaXRpb24pKTtcbiAgICByZXR1cm4gZ2V0Q2FsbChpbnRlcmNlcHRvck9wdGlvbnMpO1xufVxuZXhwb3J0cy5nZXRJbnRlcmNlcHRpbmdDYWxsID0gZ2V0SW50ZXJjZXB0aW5nQ2FsbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsaWVudC1pbnRlcmNlcHRvcnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0SW50ZXJjZXB0aW5nQ2FsbCIsIkludGVyY2VwdGluZ0NhbGwiLCJSZXF1ZXN0ZXJCdWlsZGVyIiwiTGlzdGVuZXJCdWlsZGVyIiwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IiLCJtZXRhZGF0YV8xIiwicmVxdWlyZSIsImNhbGxfc3RyZWFtXzEiLCJjb25zdGFudHNfMSIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwibmFtZSIsImNhcHR1cmVTdGFja1RyYWNlIiwibWV0YWRhdGEiLCJ1bmRlZmluZWQiLCJzdGF0dXMiLCJ3aXRoT25SZWNlaXZlTWV0YWRhdGEiLCJvblJlY2VpdmVNZXRhZGF0YSIsIndpdGhPblJlY2VpdmVNZXNzYWdlIiwib25SZWNlaXZlTWVzc2FnZSIsIndpdGhPblJlY2VpdmVTdGF0dXMiLCJvblJlY2VpdmVTdGF0dXMiLCJidWlsZCIsInN0YXJ0IiwiaGFsZkNsb3NlIiwiY2FuY2VsIiwid2l0aFN0YXJ0Iiwid2l0aFNlbmRNZXNzYWdlIiwic2VuZE1lc3NhZ2UiLCJ3aXRoSGFsZkNsb3NlIiwid2l0aENhbmNlbCIsImRlZmF1bHRMaXN0ZW5lciIsIm5leHQiLCJkZWZhdWx0UmVxdWVzdGVyIiwibGlzdGVuZXIiLCJuZXh0Q2FsbCIsInJlcXVlc3RlciIsIl9hIiwiX2IiLCJfYyIsIl9kIiwicHJvY2Vzc2luZ01ldGFkYXRhIiwicGVuZGluZ01lc3NhZ2VDb250ZXh0IiwicHJvY2Vzc2luZ01lc3NhZ2UiLCJwZW5kaW5nSGFsZkNsb3NlIiwiY2FuY2VsV2l0aFN0YXR1cyIsImRldGFpbHMiLCJnZXRQZWVyIiwicHJvY2Vzc1BlbmRpbmdNZXNzYWdlIiwic2VuZE1lc3NhZ2VXaXRoQ29udGV4dCIsInBlbmRpbmdNZXNzYWdlIiwicHJvY2Vzc1BlbmRpbmdIYWxmQ2xvc2UiLCJpbnRlcmNlcHRpbmdMaXN0ZW5lciIsIl9lIiwiX2YiLCJmdWxsSW50ZXJjZXB0aW5nTGlzdGVuZXIiLCJiaW5kIiwibWQiLCJmaW5hbEludGVyY2VwdGluZ0xpc3RlbmVyIiwiaXNJbnRlcmNlcHRpbmdMaXN0ZW5lciIsImZ1bGxMaXN0ZW5lciIsIkludGVyY2VwdGluZ0xpc3RlbmVySW1wbCIsImNvbnRleHQiLCJmaW5hbE1lc3NhZ2UiLCJzdGFydFJlYWQiLCJzZXRDcmVkZW50aWFscyIsImNyZWRlbnRpYWxzIiwiZ2V0Q2FsbCIsImNoYW5uZWwiLCJwYXRoIiwib3B0aW9ucyIsImRlYWRsaW5lIiwiSW5maW5pdHkiLCJob3N0IiwicGFyZW50IiwicHJvcGFnYXRlRmxhZ3MiLCJwcm9wYWdhdGVfZmxhZ3MiLCJjYWxsIiwiY3JlYXRlQ2FsbCIsIkJhc2VJbnRlcmNlcHRpbmdDYWxsIiwibWV0aG9kRGVmaW5pdGlvbiIsInNlcmlhbGl6ZWQiLCJyZXF1ZXN0U2VyaWFsaXplIiwiZSIsIlN0YXR1cyIsIklOVEVSTkFMIiwicmVhZEVycm9yIiwiZGVzZXJpYWxpemVkIiwicmVzcG9uc2VEZXNlcmlhbGl6ZSIsImNvZGUiLCJNZXRhZGF0YSIsIkJhc2VVbmFyeUludGVyY2VwdGluZ0NhbGwiLCJyZWNlaXZlZE1lc3NhZ2UiLCJ3cmFwcGVyTGlzdGVuZXIiLCJCYXNlU3RyZWFtaW5nSW50ZXJjZXB0aW5nQ2FsbCIsImdldEJvdHRvbUludGVyY2VwdGluZ0NhbGwiLCJyZXNwb25zZVN0cmVhbSIsImludGVyY2VwdG9yQXJncyIsImNsaWVudEludGVyY2VwdG9ycyIsImxlbmd0aCIsImNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzIiwiY2FsbEludGVyY2VwdG9ycyIsImNhbGxJbnRlcmNlcHRvclByb3ZpZGVycyIsImludGVyY2VwdG9ycyIsImNvbmNhdCIsIm1hcCIsInByb3ZpZGVyIiwiZmlsdGVyIiwiaW50ZXJjZXB0b3IiLCJpbnRlcmNlcHRvck9wdGlvbnMiLCJhc3NpZ24iLCJtZXRob2RfZGVmaW5pdGlvbiIsInJlZHVjZVJpZ2h0IiwibmV4dEludGVyY2VwdG9yIiwiY3VycmVudE9wdGlvbnMiLCJmaW5hbE9wdGlvbnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/client.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Client = void 0;\nconst call_1 = __webpack_require__(/*! ./call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call.js\");\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nconst CHANNEL_SYMBOL = Symbol();\nconst INTERCEPTOR_SYMBOL = Symbol();\nconst INTERCEPTOR_PROVIDER_SYMBOL = Symbol();\nconst CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();\nfunction isFunction(arg) {\n    return typeof arg === \"function\";\n}\nfunction getErrorStackString(error) {\n    return error.stack.split(\"\\n\").slice(1).join(\"\\n\");\n}\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */ class Client {\n    constructor(address, credentials, options = {}){\n        var _a, _b;\n        options = Object.assign({}, options);\n        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];\n        delete options.interceptors;\n        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];\n        delete options.interceptor_providers;\n        if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {\n            throw new Error(\"Both interceptors and interceptor_providers were passed as options \" + \"to the client constructor. Only one of these is allowed.\");\n        }\n        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;\n        delete options.callInvocationTransformer;\n        if (options.channelOverride) {\n            this[CHANNEL_SYMBOL] = options.channelOverride;\n        } else if (options.channelFactoryOverride) {\n            const channelFactoryOverride = options.channelFactoryOverride;\n            delete options.channelFactoryOverride;\n            this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);\n        } else {\n            this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);\n        }\n    }\n    close() {\n        this[CHANNEL_SYMBOL].close();\n    }\n    getChannel() {\n        return this[CHANNEL_SYMBOL];\n    }\n    waitForReady(deadline, callback) {\n        const checkState = (err)=>{\n            if (err) {\n                callback(new Error(\"Failed to connect before the deadline\"));\n                return;\n            }\n            let newState;\n            try {\n                newState = this[CHANNEL_SYMBOL].getConnectivityState(true);\n            } catch (e) {\n                callback(new Error(\"The channel has been closed\"));\n                return;\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                callback();\n            } else {\n                try {\n                    this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);\n                } catch (e) {\n                    callback(new Error(\"The channel has been closed\"));\n                }\n            }\n        };\n        setImmediate(checkState);\n    }\n    checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n        if (isFunction(arg1)) {\n            return {\n                metadata: new metadata_1.Metadata(),\n                options: {},\n                callback: arg1\n            };\n        } else if (isFunction(arg2)) {\n            if (arg1 instanceof metadata_1.Metadata) {\n                return {\n                    metadata: arg1,\n                    options: {},\n                    callback: arg2\n                };\n            } else {\n                return {\n                    metadata: new metadata_1.Metadata(),\n                    options: arg1,\n                    callback: arg2\n                };\n            }\n        } else {\n            if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {\n                throw new Error(\"Incorrect arguments passed\");\n            }\n            return {\n                metadata: arg1,\n                options: arg2,\n                callback: arg3\n            };\n        }\n    }\n    makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientUnaryCallImpl(),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ emitter.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let responseMessage = null;\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata)=>{\n                emitter.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, \"Too many responses received\");\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback(call_1.callErrorFromStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: \"No message received\",\n                            metadata: status.metadata\n                        }, callerStack));\n                    } else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                } else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback(call_1.callErrorFromStatus(status, callerStack));\n                }\n                emitter.emit(\"status\", status);\n            }\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return emitter;\n    }\n    makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n        var _a, _b;\n        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: false,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientWritableStreamImpl(serialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options,\n            callback: checkedArguments.callback\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const emitter = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ emitter.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let responseMessage = null;\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata: (metadata)=>{\n                emitter.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                if (responseMessage !== null) {\n                    call.cancelWithStatus(constants_1.Status.INTERNAL, \"Too many responses received\");\n                }\n                responseMessage = message;\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                if (status.code === constants_1.Status.OK) {\n                    if (responseMessage === null) {\n                        const callerStack = getErrorStackString(callerStackError);\n                        callProperties.callback(call_1.callErrorFromStatus({\n                            code: constants_1.Status.INTERNAL,\n                            details: \"No message received\",\n                            metadata: status.metadata\n                        }, callerStack));\n                    } else {\n                        callProperties.callback(null, responseMessage);\n                    }\n                } else {\n                    const callerStack = getErrorStackString(callerStackError);\n                    callProperties.callback(call_1.callErrorFromStatus(status, callerStack));\n                }\n                emitter.emit(\"status\", status);\n            }\n        });\n        return emitter;\n    }\n    checkMetadataAndOptions(arg1, arg2) {\n        let metadata;\n        let options;\n        if (arg1 instanceof metadata_1.Metadata) {\n            metadata = arg1;\n            if (arg2) {\n                options = arg2;\n            } else {\n                options = {};\n            }\n        } else {\n            if (arg1) {\n                options = arg1;\n            } else {\n                options = {};\n            }\n            metadata = new metadata_1.Metadata();\n        }\n        return {\n            metadata,\n            options\n        };\n    }\n    makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: false,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            argument: argument,\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientReadableStreamImpl(deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ stream.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata (metadata) {\n                stream.emit(\"metadata\", metadata);\n            },\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            onReceiveMessage (message) {\n                stream.push(message);\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit(\"error\", call_1.callErrorFromStatus(status, callerStack));\n                }\n                stream.emit(\"status\", status);\n            }\n        });\n        call.sendMessage(argument);\n        call.halfClose();\n        return stream;\n    }\n    makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n        var _a, _b;\n        const checkedArguments = this.checkMetadataAndOptions(metadata, options);\n        const methodDefinition = {\n            path: method,\n            requestStream: true,\n            responseStream: true,\n            requestSerialize: serialize,\n            responseDeserialize: deserialize\n        };\n        let callProperties = {\n            metadata: checkedArguments.metadata,\n            call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),\n            channel: this[CHANNEL_SYMBOL],\n            methodDefinition: methodDefinition,\n            callOptions: checkedArguments.options\n        };\n        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {\n            callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);\n        }\n        const stream = callProperties.call;\n        const interceptorArgs = {\n            clientInterceptors: this[INTERCEPTOR_SYMBOL],\n            clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],\n            callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],\n            callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []\n        };\n        const call = client_interceptors_1.getInterceptingCall(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);\n        /* This needs to happen before the emitter is used. Unfortunately we can't\n         * enforce this with the type system. We need to construct this emitter\n         * before calling the CallInvocationTransformer, and we need to create the\n         * call after that. */ stream.call = call;\n        if (callProperties.callOptions.credentials) {\n            call.setCredentials(callProperties.callOptions.credentials);\n        }\n        let receivedStatus = false;\n        const callerStackError = new Error();\n        call.start(callProperties.metadata, {\n            onReceiveMetadata (metadata) {\n                stream.emit(\"metadata\", metadata);\n            },\n            onReceiveMessage (message) {\n                stream.push(message);\n            },\n            onReceiveStatus (status) {\n                if (receivedStatus) {\n                    return;\n                }\n                receivedStatus = true;\n                stream.push(null);\n                if (status.code !== constants_1.Status.OK) {\n                    const callerStack = getErrorStackString(callerStackError);\n                    stream.emit(\"error\", call_1.callErrorFromStatus(status, callerStack));\n                }\n                stream.emit(\"status\", status);\n            }\n        });\n        return stream;\n    }\n}\nexports.Client = Client; //# sourceMappingURL=client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxTQUFTQyxtQkFBT0EsQ0FBQyxvRUFBUTtBQUMvQixNQUFNQyxZQUFZRCxtQkFBT0EsQ0FBQywwRUFBVztBQUNyQyxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRyxjQUFjSCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNSSxhQUFhSixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSyx3QkFBd0JMLG1CQUFPQSxDQUFDLGtHQUF1QjtBQUM3RCxNQUFNTSxpQkFBaUJDO0FBQ3ZCLE1BQU1DLHFCQUFxQkQ7QUFDM0IsTUFBTUUsOEJBQThCRjtBQUNwQyxNQUFNRyxxQ0FBcUNIO0FBQzNDLFNBQVNJLFdBQVdDLEdBQUc7SUFDbkIsT0FBTyxPQUFPQSxRQUFRO0FBQzFCO0FBQ0EsU0FBU0Msb0JBQW9CQyxLQUFLO0lBQzlCLE9BQU9BLE1BQU1DLEtBQUssQ0FBQ0MsS0FBSyxDQUFDLE1BQU1DLEtBQUssQ0FBQyxHQUFHQyxJQUFJLENBQUM7QUFDakQ7QUFDQTs7O0NBR0MsR0FDRCxNQUFNcEI7SUFDRnFCLFlBQVlDLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQzVDLElBQUlDLElBQUlDO1FBQ1JGLFVBQVU1QixPQUFPK0IsTUFBTSxDQUFDLENBQUMsR0FBR0g7UUFDNUIsSUFBSSxDQUFDZCxtQkFBbUIsR0FBRyxDQUFDZSxLQUFLRCxRQUFRSSxZQUFZLE1BQU0sUUFBUUgsT0FBTyxLQUFLLElBQUlBLEtBQUssRUFBRTtRQUMxRixPQUFPRCxRQUFRSSxZQUFZO1FBQzNCLElBQUksQ0FBQ2pC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c291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2NsaWVudC5qcz84MjY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGNhbGxfMSA9IHJlcXVpcmUoXCIuL2NhbGxcIik7XG5jb25zdCBjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGNsaWVudF9pbnRlcmNlcHRvcnNfMSA9IHJlcXVpcmUoXCIuL2NsaWVudC1pbnRlcmNlcHRvcnNcIik7XG5jb25zdCBDSEFOTkVMX1NZTUJPTCA9IFN5bWJvbCgpO1xuY29uc3QgSU5URVJDRVBUT1JfU1lNQk9MID0gU3ltYm9sKCk7XG5jb25zdCBJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0wgPSBTeW1ib2woKTtcbmNvbnN0IENBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0wgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5mdW5jdGlvbiBnZXRFcnJvclN0YWNrU3RyaW5nKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLnN0YWNrLnNwbGl0KCdcXG4nKS5zbGljZSgxKS5qb2luKCdcXG4nKTtcbn1cbi8qKlxuICogQSBnZW5lcmljIGdSUEMgY2xpZW50LiBQcmltYXJpbHkgdXNlZnVsIGFzIGEgYmFzZSBjbGFzcyBmb3IgYWxsIGdlbmVyYXRlZFxuICogY2xpZW50cy5cbiAqL1xuY2xhc3MgQ2xpZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgICAgICAgdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdID0gKF9hID0gb3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5pbnRlcmNlcHRvcnM7XG4gICAgICAgIHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSA9IChfYiA9IG9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzO1xuICAgICAgICBpZiAodGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JvdGggaW50ZXJjZXB0b3JzIGFuZCBpbnRlcmNlcHRvcl9wcm92aWRlcnMgd2VyZSBwYXNzZWQgYXMgb3B0aW9ucyAnICtcbiAgICAgICAgICAgICAgICAndG8gdGhlIGNsaWVudCBjb25zdHJ1Y3Rvci4gT25seSBvbmUgb2YgdGhlc2UgaXMgYWxsb3dlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdID1cbiAgICAgICAgICAgIG9wdGlvbnMuY2FsbEludm9jYXRpb25UcmFuc2Zvcm1lcjtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuY2FsbEludm9jYXRpb25UcmFuc2Zvcm1lcjtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhbm5lbE92ZXJyaWRlKSB7XG4gICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXSA9IG9wdGlvbnMuY2hhbm5lbE92ZXJyaWRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY2hhbm5lbEZhY3RvcnlPdmVycmlkZSkge1xuICAgICAgICAgICAgY29uc3QgY2hhbm5lbEZhY3RvcnlPdmVycmlkZSA9IG9wdGlvbnMuY2hhbm5lbEZhY3RvcnlPdmVycmlkZTtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmNoYW5uZWxGYWN0b3J5T3ZlcnJpZGU7XG4gICAgICAgICAgICB0aGlzW0NIQU5ORUxfU1lNQk9MXSA9IGNoYW5uZWxGYWN0b3J5T3ZlcnJpZGUoYWRkcmVzcywgY3JlZGVudGlhbHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0gPSBuZXcgY2hhbm5lbF8xLkNoYW5uZWxJbXBsZW1lbnRhdGlvbihhZGRyZXNzLCBjcmVkZW50aWFscywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXNbQ0hBTk5FTF9TWU1CT0xdLmNsb3NlKCk7XG4gICAgfVxuICAgIGdldENoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0NIQU5ORUxfU1lNQk9MXTtcbiAgICB9XG4gICAgd2FpdEZvclJlYWR5KGRlYWRsaW5lLCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBjaGVja1N0YXRlID0gKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbm5lY3QgYmVmb3JlIHRoZSBkZWFkbGluZScpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbmV3U3RhdGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gdGhpc1tDSEFOTkVMX1NZTUJPTF0uZ2V0Q29ubmVjdGl2aXR5U3RhdGUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignVGhlIGNoYW5uZWwgaGFzIGJlZW4gY2xvc2VkJykpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tDSEFOTkVMX1NZTUJPTF0ud2F0Y2hDb25uZWN0aXZpdHlTdGF0ZShuZXdTdGF0ZSwgZGVhZGxpbmUsIGNoZWNrU3RhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ1RoZSBjaGFubmVsIGhhcyBiZWVuIGNsb3NlZCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldEltbWVkaWF0ZShjaGVja1N0YXRlKTtcbiAgICB9XG4gICAgY2hlY2tPcHRpb25hbFVuYXJ5UmVzcG9uc2VBcmd1bWVudHMoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihhcmcxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksIG9wdGlvbnM6IHt9LCBjYWxsYmFjazogYXJnMSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oYXJnMikpIHtcbiAgICAgICAgICAgIGlmIChhcmcxIGluc3RhbmNlb2YgbWV0YWRhdGFfMS5NZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBhcmcxLCBvcHRpb25zOiB7fSwgY2FsbGJhY2s6IGFyZzIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLCBvcHRpb25zOiBhcmcxLCBjYWxsYmFjazogYXJnMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCEoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEgJiZcbiAgICAgICAgICAgICAgICBhcmcyIGluc3RhbmNlb2YgT2JqZWN0ICYmXG4gICAgICAgICAgICAgICAgaXNGdW5jdGlvbihhcmczKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBhcmd1bWVudHMgcGFzc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBtZXRhZGF0YTogYXJnMSwgb3B0aW9uczogYXJnMiwgY2FsbGJhY2s6IGFyZzMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYWtlVW5hcnlSZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgYXJndW1lbnQsIG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjaGVja2VkQXJndW1lbnRzID0gdGhpcy5jaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyhtZXRhZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogZmFsc2UsXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbTogZmFsc2UsXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudFVuYXJ5Q2FsbEltcGwoKSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICAgICAgICBjYWxsYmFjazogY2hlY2tlZEFyZ3VtZW50cy5jYWxsYmFjayxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1pdHRlciA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbChpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xuICAgICAgICBpZiAoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIGNhbGwuc2V0Q3JlZGVudGlhbHMoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCAnVG9vIG1hbnkgcmVzcG9uc2VzIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjayhjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBtZXNzYWdlIHJlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjayhjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cyhzdGF0dXMsIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsLnNlbmRNZXNzYWdlKGFyZ3VtZW50KTtcbiAgICAgICAgY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXI7XG4gICAgfVxuICAgIG1ha2VDbGllbnRTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgbWV0YWRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrT3B0aW9uYWxVbmFyeVJlc3BvbnNlQXJndW1lbnRzKG1ldGFkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIGNvbnN0IG1ldGhvZERlZmluaXRpb24gPSB7XG4gICAgICAgICAgICBwYXRoOiBtZXRob2QsXG4gICAgICAgICAgICByZXF1ZXN0U3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnRXcml0YWJsZVN0cmVhbUltcGwoc2VyaWFsaXplKSxcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXNbQ0hBTk5FTF9TWU1CT0xdLFxuICAgICAgICAgICAgbWV0aG9kRGVmaW5pdGlvbjogbWV0aG9kRGVmaW5pdGlvbixcbiAgICAgICAgICAgIGNhbGxPcHRpb25zOiBjaGVja2VkQXJndW1lbnRzLm9wdGlvbnMsXG4gICAgICAgICAgICBjYWxsYmFjazogY2hlY2tlZEFyZ3VtZW50cy5jYWxsYmFjayxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW1pdHRlciA9IGNhbGxQcm9wZXJ0aWVzLmNhbGw7XG4gICAgICAgIGNvbnN0IGludGVyY2VwdG9yQXJncyA9IHtcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yczogdGhpc1tJTlRFUkNFUFRPUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JQcm92aWRlcnM6IHRoaXNbSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvcnM6IChfYSA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9ycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnM6IChfYiA9IGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmludGVyY2VwdG9yX3Byb3ZpZGVycykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhbGwgPSBjbGllbnRfaW50ZXJjZXB0b3JzXzEuZ2V0SW50ZXJjZXB0aW5nQ2FsbChpbnRlcmNlcHRvckFyZ3MsIGNhbGxQcm9wZXJ0aWVzLm1ldGhvZERlZmluaXRpb24sIGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLCBjYWxsUHJvcGVydGllcy5jaGFubmVsKTtcbiAgICAgICAgLyogVGhpcyBuZWVkcyB0byBoYXBwZW4gYmVmb3JlIHRoZSBlbWl0dGVyIGlzIHVzZWQuIFVuZm9ydHVuYXRlbHkgd2UgY2FuJ3RcbiAgICAgICAgICogZW5mb3JjZSB0aGlzIHdpdGggdGhlIHR5cGUgc3lzdGVtLiBXZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGlzIGVtaXR0ZXJcbiAgICAgICAgICogYmVmb3JlIGNhbGxpbmcgdGhlIENhbGxJbnZvY2F0aW9uVHJhbnNmb3JtZXIsIGFuZCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgICogY2FsbCBhZnRlciB0aGF0LiAqL1xuICAgICAgICBlbWl0dGVyLmNhbGwgPSBjYWxsO1xuICAgICAgICBpZiAoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIGNhbGwuc2V0Q3JlZGVudGlhbHMoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwb25zZU1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YTogKG1ldGFkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgb25SZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTWVzc2FnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLCAnVG9vIG1hbnkgcmVzcG9uc2VzIHJlY2VpdmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZWNlaXZlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZFN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY2VpdmVkU3RhdHVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLmNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2VNZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZXJTdGFjayA9IGdldEVycm9yU3RhY2tTdHJpbmcoY2FsbGVyU3RhY2tFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjayhjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdObyBtZXNzYWdlIHJlY2VpdmVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogc3RhdHVzLm1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMuY2FsbGJhY2sobnVsbCwgcmVzcG9uc2VNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGVyU3RhY2sgPSBnZXRFcnJvclN0YWNrU3RyaW5nKGNhbGxlclN0YWNrRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsUHJvcGVydGllcy5jYWxsYmFjayhjYWxsXzEuY2FsbEVycm9yRnJvbVN0YXR1cyhzdGF0dXMsIGNhbGxlclN0YWNrKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICB9XG4gICAgY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMoYXJnMSwgYXJnMikge1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIGxldCBvcHRpb25zO1xuICAgICAgICBpZiAoYXJnMSBpbnN0YW5jZW9mIG1ldGFkYXRhXzEuTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIG1ldGFkYXRhID0gYXJnMTtcbiAgICAgICAgICAgIGlmIChhcmcyKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IGFyZzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXJnMSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBhcmcxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG1ldGFkYXRhLCBvcHRpb25zIH07XG4gICAgfVxuICAgIG1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgYXJndW1lbnQsIG1ldGFkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNoZWNrZWRBcmd1bWVudHMgPSB0aGlzLmNoZWNrTWV0YWRhdGFBbmRPcHRpb25zKG1ldGFkYXRhLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWV0aG9kRGVmaW5pdGlvbiA9IHtcbiAgICAgICAgICAgIHBhdGg6IG1ldGhvZCxcbiAgICAgICAgICAgIHJlcXVlc3RTdHJlYW06IGZhbHNlLFxuICAgICAgICAgICAgcmVzcG9uc2VTdHJlYW06IHRydWUsXG4gICAgICAgICAgICByZXF1ZXN0U2VyaWFsaXplOiBzZXJpYWxpemUsXG4gICAgICAgICAgICByZXNwb25zZURlc2VyaWFsaXplOiBkZXNlcmlhbGl6ZSxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGNhbGxQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYXJndW1lbnQ6IGFyZ3VtZW50LFxuICAgICAgICAgICAgbWV0YWRhdGE6IGNoZWNrZWRBcmd1bWVudHMubWV0YWRhdGEsXG4gICAgICAgICAgICBjYWxsOiBuZXcgY2FsbF8xLkNsaWVudFJlYWRhYmxlU3RyZWFtSW1wbChkZXNlcmlhbGl6ZSksXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzW0NIQU5ORUxfU1lNQk9MXSxcbiAgICAgICAgICAgIG1ldGhvZERlZmluaXRpb246IG1ldGhvZERlZmluaXRpb24sXG4gICAgICAgICAgICBjYWxsT3B0aW9uczogY2hlY2tlZEFyZ3VtZW50cy5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXSkge1xuICAgICAgICAgICAgY2FsbFByb3BlcnRpZXMgPSB0aGlzW0NBTExfSU5WT0NBVElPTl9UUkFOU0ZPUk1FUl9TWU1CT0xdKGNhbGxQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBjYWxsUHJvcGVydGllcy5jYWxsO1xuICAgICAgICBjb25zdCBpbnRlcmNlcHRvckFyZ3MgPSB7XG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvcnM6IHRoaXNbSU5URVJDRVBUT1JfU1lNQk9MXSxcbiAgICAgICAgICAgIGNsaWVudEludGVyY2VwdG9yUHJvdmlkZXJzOiB0aGlzW0lOVEVSQ0VQVE9SX1BST1ZJREVSX1NZTUJPTF0sXG4gICAgICAgICAgICBjYWxsSW50ZXJjZXB0b3JzOiAoX2EgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yUHJvdmlkZXJzOiAoX2IgPSBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucy5pbnRlcmNlcHRvcl9wcm92aWRlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjYWxsID0gY2xpZW50X2ludGVyY2VwdG9yc18xLmdldEludGVyY2VwdGluZ0NhbGwoaW50ZXJjZXB0b3JBcmdzLCBjYWxsUHJvcGVydGllcy5tZXRob2REZWZpbml0aW9uLCBjYWxsUHJvcGVydGllcy5jYWxsT3B0aW9ucywgY2FsbFByb3BlcnRpZXMuY2hhbm5lbCk7XG4gICAgICAgIC8qIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGJlZm9yZSB0aGUgZW1pdHRlciBpcyB1c2VkLiBVbmZvcnR1bmF0ZWx5IHdlIGNhbid0XG4gICAgICAgICAqIGVuZm9yY2UgdGhpcyB3aXRoIHRoZSB0eXBlIHN5c3RlbS4gV2UgbmVlZCB0byBjb25zdHJ1Y3QgdGhpcyBlbWl0dGVyXG4gICAgICAgICAqIGJlZm9yZSBjYWxsaW5nIHRoZSBDYWxsSW52b2NhdGlvblRyYW5zZm9ybWVyLCBhbmQgd2UgbmVlZCB0byBjcmVhdGUgdGhlXG4gICAgICAgICAqIGNhbGwgYWZ0ZXIgdGhhdC4gKi9cbiAgICAgICAgc3RyZWFtLmNhbGwgPSBjYWxsO1xuICAgICAgICBpZiAoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpIHtcbiAgICAgICAgICAgIGNhbGwuc2V0Q3JlZGVudGlhbHMoY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuY3JlZGVudGlhbHMpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWNlaXZlZFN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYWxsZXJTdGFja0Vycm9yID0gbmV3IEVycm9yKCk7XG4gICAgICAgIGNhbGwuc3RhcnQoY2FsbFByb3BlcnRpZXMubWV0YWRhdGEsIHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ21ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjYWxsLnNlbmRNZXNzYWdlKGFyZ3VtZW50KTtcbiAgICAgICAgY2FsbC5oYWxmQ2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9XG4gICAgbWFrZUJpZGlTdHJlYW1SZXF1ZXN0KG1ldGhvZCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgbWV0YWRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2hlY2tlZEFyZ3VtZW50cyA9IHRoaXMuY2hlY2tNZXRhZGF0YUFuZE9wdGlvbnMobWV0YWRhdGEsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtZXRob2REZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgcGF0aDogbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIHJlc3BvbnNlU3RyZWFtOiB0cnVlLFxuICAgICAgICAgICAgcmVxdWVzdFNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgICAgICAgICAgcmVzcG9uc2VEZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjYWxsUHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgIG1ldGFkYXRhOiBjaGVja2VkQXJndW1lbnRzLm1ldGFkYXRhLFxuICAgICAgICAgICAgY2FsbDogbmV3IGNhbGxfMS5DbGllbnREdXBsZXhTdHJlYW1JbXBsKHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpc1tDSEFOTkVMX1NZTUJPTF0sXG4gICAgICAgICAgICBtZXRob2REZWZpbml0aW9uOiBtZXRob2REZWZpbml0aW9uLFxuICAgICAgICAgICAgY2FsbE9wdGlvbnM6IGNoZWNrZWRBcmd1bWVudHMub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXNbQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTF0pIHtcbiAgICAgICAgICAgIGNhbGxQcm9wZXJ0aWVzID0gdGhpc1tDQUxMX0lOVk9DQVRJT05fVFJBTlNGT1JNRVJfU1lNQk9MXShjYWxsUHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gY2FsbFByb3BlcnRpZXMuY2FsbDtcbiAgICAgICAgY29uc3QgaW50ZXJjZXB0b3JBcmdzID0ge1xuICAgICAgICAgICAgY2xpZW50SW50ZXJjZXB0b3JzOiB0aGlzW0lOVEVSQ0VQVE9SX1NZTUJPTF0sXG4gICAgICAgICAgICBjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVyczogdGhpc1tJTlRFUkNFUFRPUl9QUk9WSURFUl9TWU1CT0xdLFxuICAgICAgICAgICAgY2FsbEludGVyY2VwdG9yczogKF9hID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSxcbiAgICAgICAgICAgIGNhbGxJbnRlcmNlcHRvclByb3ZpZGVyczogKF9iID0gY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMuaW50ZXJjZXB0b3JfcHJvdmlkZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbCA9IGNsaWVudF9pbnRlcmNlcHRvcnNfMS5nZXRJbnRlcmNlcHRpbmdDYWxsKGludGVyY2VwdG9yQXJncywgY2FsbFByb3BlcnRpZXMubWV0aG9kRGVmaW5pdGlvbiwgY2FsbFByb3BlcnRpZXMuY2FsbE9wdGlvbnMsIGNhbGxQcm9wZXJ0aWVzLmNoYW5uZWwpO1xuICAgICAgICAvKiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIGVtaXR0ZXIgaXMgdXNlZC4gVW5mb3J0dW5hdGVseSB3ZSBjYW4ndFxuICAgICAgICAgKiBlbmZvcmNlIHRoaXMgd2l0aCB0aGUgdHlwZSBzeXN0ZW0uIFdlIG5lZWQgdG8gY29uc3RydWN0IHRoaXMgZW1pdHRlclxuICAgICAgICAgKiBiZWZvcmUgY2FsbGluZyB0aGUgQ2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciwgYW5kIHdlIG5lZWQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAgKiBjYWxsIGFmdGVyIHRoYXQuICovXG4gICAgICAgIHN0cmVhbS5jYWxsID0gY2FsbDtcbiAgICAgICAgaWYgKGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmNyZWRlbnRpYWxzKSB7XG4gICAgICAgICAgICBjYWxsLnNldENyZWRlbnRpYWxzKGNhbGxQcm9wZXJ0aWVzLmNhbGxPcHRpb25zLmNyZWRlbnRpYWxzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVjZWl2ZWRTdGF0dXMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2FsbGVyU3RhY2tFcnJvciA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjYWxsLnN0YXJ0KGNhbGxQcm9wZXJ0aWVzLm1ldGFkYXRhLCB7XG4gICAgICAgICAgICBvblJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdtZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucHVzaChtZXNzYWdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlY2VpdmVTdGF0dXMoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlY2VpdmVkU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWRTdGF0dXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMuY29kZSAhPT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlclN0YWNrID0gZ2V0RXJyb3JTdGFja1N0cmluZyhjYWxsZXJTdGFja0Vycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgY2FsbF8xLmNhbGxFcnJvckZyb21TdGF0dXMoc3RhdHVzLCBjYWxsZXJTdGFjaykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xpZW50LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNsaWVudCIsImNhbGxfMSIsInJlcXVpcmUiLCJjaGFubmVsXzEiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsImNvbnN0YW50c18xIiwibWV0YWRhdGFfMSIsImNsaWVudF9pbnRlcmNlcHRvcnNfMSIsIkNIQU5ORUxfU1lNQk9MIiwiU3ltYm9sIiwiSU5URVJDRVBUT1JfU1lNQk9MIiwiSU5URVJDRVBUT1JfUFJPVklERVJfU1lNQk9MIiwiQ0FMTF9JTlZPQ0FUSU9OX1RSQU5TRk9STUVSX1NZTUJPTCIsImlzRnVuY3Rpb24iLCJhcmciLCJnZXRFcnJvclN0YWNrU3RyaW5nIiwiZXJyb3IiLCJzdGFjayIsInNwbGl0Iiwic2xpY2UiLCJqb2luIiwiY29uc3RydWN0b3IiLCJhZGRyZXNzIiwiY3JlZGVudGlhbHMiLCJvcHRpb25zIiwiX2EiLCJfYiIsImFzc2lnbiIsImludGVyY2VwdG9ycyIsImludGVyY2VwdG9yX3Byb3ZpZGVycyIsImxlbmd0aCIsIkVycm9yIiwiY2FsbEludm9jYXRpb25UcmFuc2Zvcm1lciIsImNoYW5uZWxPdmVycmlkZSIsImNoYW5uZWxGYWN0b3J5T3ZlcnJpZGUiLCJDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjbG9zZSIsImdldENoYW5uZWwiLCJ3YWl0Rm9yUmVhZHkiLCJkZWFkbGluZSIsImNhbGxiYWNrIiwiY2hlY2tTdGF0ZSIsImVyciIsIm5ld1N0YXRlIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJlIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJSRUFEWSIsIndhdGNoQ29ubmVjdGl2aXR5U3RhdGUiLCJzZXRJbW1lZGlhdGUiLCJjaGVja09wdGlvbmFsVW5hcnlSZXNwb25zZUFyZ3VtZW50cyIsImFyZzEiLCJhcmcyIiwiYXJnMyIsIm1ldGFkYXRhIiwiTWV0YWRhdGEiLCJtYWtlVW5hcnlSZXF1ZXN0IiwibWV0aG9kIiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJhcmd1bWVudCIsImNoZWNrZWRBcmd1bWVudHMiLCJtZXRob2REZWZpbml0aW9uIiwicGF0aCIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsInJlcXVlc3RTZXJpYWxpemUiLCJyZXNwb25zZURlc2VyaWFsaXplIiwiY2FsbFByb3BlcnRpZXMiLCJjYWxsIiwiQ2xpZW50VW5hcnlDYWxsSW1wbCIsImNoYW5uZWwiLCJjYWxsT3B0aW9ucyIsImVtaXR0ZXIiLCJpbnRlcmNlcHRvckFyZ3MiLCJjbGllbnRJbnRlcmNlcHRvcnMiLCJjbGllbnRJbnRlcmNlcHRvclByb3ZpZGVycyIsImNhbGxJbnRlcmNlcHRvcnMiLCJjYWxsSW50ZXJjZXB0b3JQcm92aWRlcnMiLCJnZXRJbnRlcmNlcHRpbmdDYWxsIiwic2V0Q3JlZGVudGlhbHMiLCJyZXNwb25zZU1lc3NhZ2UiLCJyZWNlaXZlZFN0YXR1cyIsImNhbGxlclN0YWNrRXJyb3IiLCJzdGFydCIsIm9uUmVjZWl2ZU1ldGFkYXRhIiwiZW1pdCIsIm9uUmVjZWl2ZU1lc3NhZ2UiLCJtZXNzYWdlIiwiY2FuY2VsV2l0aFN0YXR1cyIsIlN0YXR1cyIsIklOVEVSTkFMIiwib25SZWNlaXZlU3RhdHVzIiwic3RhdHVzIiwiY29kZSIsIk9LIiwiY2FsbGVyU3RhY2siLCJjYWxsRXJyb3JGcm9tU3RhdHVzIiwiZGV0YWlscyIsInNlbmRNZXNzYWdlIiwiaGFsZkNsb3NlIiwibWFrZUNsaWVudFN0cmVhbVJlcXVlc3QiLCJDbGllbnRXcml0YWJsZVN0cmVhbUltcGwiLCJjaGVja01ldGFkYXRhQW5kT3B0aW9ucyIsIm1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0IiwiQ2xpZW50UmVhZGFibGVTdHJlYW1JbXBsIiwic3RyZWFtIiwicHVzaCIsIm1ha2VCaWRpU3RyZWFtUmVxdWVzdCIsIkNsaWVudER1cGxleFN0cmVhbUltcGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CompressionAlgorithms = void 0;\nvar CompressionAlgorithms;\n(function(CompressionAlgorithms) {\n    CompressionAlgorithms[CompressionAlgorithms[\"identity\"] = 0] = \"identity\";\n    CompressionAlgorithms[CompressionAlgorithms[\"deflate\"] = 1] = \"deflate\";\n    CompressionAlgorithms[CompressionAlgorithms[\"gzip\"] = 2] = \"gzip\";\n})(CompressionAlgorithms = exports.CompressionAlgorithms || (exports.CompressionAlgorithms = {}));\n //# sourceMappingURL=compression-algorithms.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tYWxnb3JpdGhtcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNkJBQTZCLEdBQUcsS0FBSztBQUNyQyxJQUFJRTtBQUNILFVBQVVBLHFCQUFxQjtJQUM1QkEscUJBQXFCLENBQUNBLHFCQUFxQixDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDL0RBLHFCQUFxQixDQUFDQSxxQkFBcUIsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQzlEQSxxQkFBcUIsQ0FBQ0EscUJBQXFCLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztBQUMvRCxHQUFHQSx3QkFBd0JGLFFBQVFFLHFCQUFxQixJQUFLRixDQUFBQSw2QkFBNkIsR0FBRyxDQUFDO0NBRTlGLGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzPzI5MjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjEgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcHJlc3Npb25BbGdvcml0aG1zID0gdm9pZCAwO1xudmFyIENvbXByZXNzaW9uQWxnb3JpdGhtcztcbihmdW5jdGlvbiAoQ29tcHJlc3Npb25BbGdvcml0aG1zKSB7XG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImlkZW50aXR5XCJdID0gMF0gPSBcImlkZW50aXR5XCI7XG4gICAgQ29tcHJlc3Npb25BbGdvcml0aG1zW0NvbXByZXNzaW9uQWxnb3JpdGhtc1tcImRlZmxhdGVcIl0gPSAxXSA9IFwiZGVmbGF0ZVwiO1xuICAgIENvbXByZXNzaW9uQWxnb3JpdGhtc1tDb21wcmVzc2lvbkFsZ29yaXRobXNbXCJnemlwXCJdID0gMl0gPSBcImd6aXBcIjtcbn0pKENvbXByZXNzaW9uQWxnb3JpdGhtcyA9IGV4cG9ydHMuQ29tcHJlc3Npb25BbGdvcml0aG1zIHx8IChleHBvcnRzLkNvbXByZXNzaW9uQWxnb3JpdGhtcyA9IHt9KSk7XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2lvbi1hbGdvcml0aG1zLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNvbXByZXNzaW9uQWxnb3JpdGhtcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/compression-filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst isCompressionAlgorithmKey = (key)=>{\n    return typeof key === \"number\" && typeof compression_algorithms_1.CompressionAlgorithms[key] === \"string\";\n};\nclass CompressionHandler {\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */ async writeMessage(message, compress) {\n        let messageBuffer = message;\n        if (compress) {\n            messageBuffer = await this.compressMessage(messageBuffer);\n        }\n        const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n        output.writeUInt8(compress ? 1 : 0, 0);\n        output.writeUInt32BE(messageBuffer.length, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */ async readMessage(data) {\n        const compressed = data.readUInt8(0) === 1;\n        let messageBuffer = data.slice(5);\n        if (compressed) {\n            messageBuffer = await this.decompressMessage(messageBuffer);\n        }\n        return messageBuffer;\n    }\n}\nclass IdentityHandler extends CompressionHandler {\n    async compressMessage(message) {\n        return message;\n    }\n    async writeMessage(message, compress) {\n        const output = Buffer.allocUnsafe(message.length + 5);\n        /* With \"identity\" compression, messages should always be marked as\n         * uncompressed */ output.writeUInt8(0, 0);\n        output.writeUInt32BE(message.length, 1);\n        message.copy(output, 5);\n        return output;\n    }\n    decompressMessage(message) {\n        return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n}\nclass DeflateHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.deflate(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.inflate(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass GzipHandler extends CompressionHandler {\n    compressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.gzip(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n    decompressMessage(message) {\n        return new Promise((resolve, reject)=>{\n            zlib.unzip(message, (err, output)=>{\n                if (err) {\n                    reject(err);\n                } else {\n                    resolve(output);\n                }\n            });\n        });\n    }\n}\nclass UnknownHandler extends CompressionHandler {\n    constructor(compressionName){\n        super();\n        this.compressionName = compressionName;\n    }\n    compressMessage(message) {\n        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n    }\n    decompressMessage(message) {\n        // This should be unreachable\n        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n    }\n}\nfunction getCompressionHandler(compressionName) {\n    switch(compressionName){\n        case \"identity\":\n            return new IdentityHandler();\n        case \"deflate\":\n            return new DeflateHandler();\n        case \"gzip\":\n            return new GzipHandler();\n        default:\n            return new UnknownHandler(compressionName);\n    }\n}\nclass CompressionFilter extends filter_1.BaseFilter {\n    constructor(channelOptions, sharedFilterConfig){\n        var _a;\n        super();\n        this.sharedFilterConfig = sharedFilterConfig;\n        this.sendCompression = new IdentityHandler();\n        this.receiveCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = \"identity\";\n        const compressionAlgorithmKey = channelOptions[\"grpc.default_compression_algorithm\"];\n        if (compressionAlgorithmKey !== undefined) {\n            if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n                const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n                const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(\",\");\n                /**\n                 * There are two possible situations here:\n                 * 1) We don't have any info yet from the server about what compression it supports\n                 *    In that case we should just use what the client tells us to use\n                 * 2) We've previously received a response from the server including a grpc-accept-encoding header\n                 *    In that case we only want to use the encoding chosen by the client if the server supports it\n                 */ if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n                    this.currentCompressionAlgorithm = clientSelectedEncoding;\n                    this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);\n                }\n            } else {\n                logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n            }\n        }\n    }\n    async sendMetadata(metadata) {\n        const headers = await metadata;\n        headers.set(\"grpc-accept-encoding\", \"identity,deflate,gzip\");\n        headers.set(\"accept-encoding\", \"identity\");\n        // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n        if (this.currentCompressionAlgorithm === \"identity\") {\n            headers.remove(\"grpc-encoding\");\n        } else {\n            headers.set(\"grpc-encoding\", this.currentCompressionAlgorithm);\n        }\n        return headers;\n    }\n    receiveMetadata(metadata) {\n        const receiveEncoding = metadata.get(\"grpc-encoding\");\n        if (receiveEncoding.length > 0) {\n            const encoding = receiveEncoding[0];\n            if (typeof encoding === \"string\") {\n                this.receiveCompression = getCompressionHandler(encoding);\n            }\n        }\n        metadata.remove(\"grpc-encoding\");\n        /* Check to see if the compression we're using to send messages is supported by the server\n         * If not, reset the sendCompression filter and have it use the default IdentityHandler */ const serverSupportedEncodingsHeader = metadata.get(\"grpc-accept-encoding\")[0];\n        if (serverSupportedEncodingsHeader) {\n            this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n            const serverSupportedEncodings = serverSupportedEncodingsHeader.split(\",\");\n            if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n                this.sendCompression = new IdentityHandler();\n                this.currentCompressionAlgorithm = \"identity\";\n            }\n        }\n        metadata.remove(\"grpc-accept-encoding\");\n        return metadata;\n    }\n    async sendMessage(message) {\n        var _a;\n        /* This filter is special. The input message is the bare message bytes,\n         * and the output is a framed and possibly compressed message. For this\n         * reason, this filter should be at the bottom of the filter stack */ const resolvedMessage = await message;\n        let compress;\n        if (this.sendCompression instanceof IdentityHandler) {\n            compress = false;\n        } else {\n            compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2 /* NoCompress */ ) === 0;\n        }\n        return {\n            message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n            flags: resolvedMessage.flags\n        };\n    }\n    async receiveMessage(message) {\n        /* This filter is also special. The input message is framed and possibly\n         * compressed, and the output message is deframed and uncompressed. So\n         * this is another reason that this filter should be at the bottom of the\n         * filter stack. */ return this.receiveCompression.readMessage(await message);\n    }\n}\nexports.CompressionFilter = CompressionFilter;\nclass CompressionFilterFactory {\n    constructor(channel, options){\n        this.channel = channel;\n        this.options = options;\n        this.sharedFilterConfig = {};\n    }\n    createFilter(callStream) {\n        return new CompressionFilter(this.options, this.sharedFilterConfig);\n    }\n}\nexports.CompressionFilterFactory = CompressionFilterFactory; //# sourceMappingURL=compression-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29tcHJlc3Npb24tZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBR0EseUJBQXlCLEdBQUcsS0FBSztBQUNwRSxNQUFNSSxPQUFPQyxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNQywyQkFBMkJELG1CQUFPQSxDQUFDLHdHQUEwQjtBQUNuRSxNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRyxXQUFXSCxtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNSSxVQUFVSixtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNSyw0QkFBNEIsQ0FBQ0M7SUFDL0IsT0FBTyxPQUFPQSxRQUFRLFlBQVksT0FBT0wseUJBQXlCTSxxQkFBcUIsQ0FBQ0QsSUFBSSxLQUFLO0FBQ3JHO0FBQ0EsTUFBTUU7SUFDRjs7OztLQUlDLEdBQ0QsTUFBTUMsYUFBYUMsT0FBTyxFQUFFQyxRQUFRLEVBQUU7UUFDbEMsSUFBSUMsZ0JBQWdCRjtRQUNwQixJQUFJQyxVQUFVO1lBQ1ZDLGdCQUFnQixNQUFNLElBQUksQ0FBQ0MsZUFBZSxDQUFDRDtRQUMvQztRQUNBLE1BQU1FLFNBQVNDLE9BQU9DLFdBQVcsQ0FBQ0osY0FBY0ssTUFBTSxHQUFHO1FBQ3pESCxPQUFPSSxVQUFVLENBQUNQLFdBQVcsSUFBSSxHQUFHO1FBQ3BDRyxPQUFPSyxhQUFhLENBQUNQLGNBQWNLLE1BQU0sRUFBRTtRQUMzQ0wsY0FBY1EsSUFBSSxDQUFDTixRQUFRO1FBQzNCLE9BQU9BO0lBQ1g7SUFDQTs7O0tBR0MsR0FDRCxNQUFNTyxZQUFZQyxJQUFJLEVBQUU7UUFDcEIsTUFBTUMsYUFBYUQsS0FBS0UsU0FBUyxDQUFDLE9BQU87UUFDekMsSUFBSVosZ0JBQWdC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UyxNQUFNLElBQUksQ0FBQ3FDLGVBQWUsQ0FBQ3RDLFlBQVksQ0FBQzhELGdCQUFnQjdELE9BQU8sRUFBRUM7WUFDMUU2RCxPQUFPRCxnQkFBZ0JDLEtBQUs7UUFDaEM7SUFDSjtJQUNBLE1BQU1DLGVBQWUvRCxPQUFPLEVBQUU7UUFDMUI7Ozt5QkFHaUIsR0FDakIsT0FBTyxJQUFJLENBQUNzQyxrQkFBa0IsQ0FBQzNCLFdBQVcsQ0FBQyxNQUFNWDtJQUNyRDtBQUNKO0FBQ0FmLHlCQUF5QixHQUFHRztBQUM1QixNQUFNRDtJQUNGMkMsWUFBWWtDLE9BQU8sRUFBRUMsT0FBTyxDQUFFO1FBQzFCLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQzlCLGtCQUFrQixHQUFHLENBQUM7SUFDL0I7SUFDQStCLGFBQWFDLFVBQVUsRUFBRTtRQUNyQixPQUFPLElBQUkvRSxrQkFBa0IsSUFBSSxDQUFDNkUsT0FBTyxFQUFFLElBQUksQ0FBQzlCLGtCQUFrQjtJQUN0RTtBQUNKO0FBQ0FsRCxnQ0FBZ0MsR0FBR0UsMEJBQ25DLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb21wcmVzc2lvbi1maWx0ZXIuanM/NzVlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkNvbXByZXNzaW9uRmlsdGVyID0gdm9pZCAwO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgY29tcHJlc3Npb25fYWxnb3JpdGhtc18xID0gcmVxdWlyZShcIi4vY29tcHJlc3Npb24tYWxnb3JpdGhtc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGlzQ29tcHJlc3Npb25BbGdvcml0aG1LZXkgPSAoa2V5KSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdudW1iZXInICYmIHR5cGVvZiBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zW2tleV0gPT09ICdzdHJpbmcnO1xufTtcbmNsYXNzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgUmF3IHVuY29tcHJlc3NlZCBtZXNzYWdlIGJ5dGVzXG4gICAgICogQHBhcmFtIGNvbXByZXNzIEluZGljYXRlcyB3aGV0aGVyIHRoZSBtZXNzYWdlIHNob3VsZCBiZSBjb21wcmVzc2VkXG4gICAgICogQHJldHVybiBGcmFtZWQgbWVzc2FnZSwgY29tcHJlc3NlZCBpZiBhcHBsaWNhYmxlXG4gICAgICovXG4gICAgYXN5bmMgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIGNvbXByZXNzKSB7XG4gICAgICAgIGxldCBtZXNzYWdlQnVmZmVyID0gbWVzc2FnZTtcbiAgICAgICAgaWYgKGNvbXByZXNzKSB7XG4gICAgICAgICAgICBtZXNzYWdlQnVmZmVyID0gYXdhaXQgdGhpcy5jb21wcmVzc01lc3NhZ2UobWVzc2FnZUJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG1lc3NhZ2VCdWZmZXIubGVuZ3RoICsgNSk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KGNvbXByZXNzID8gMSA6IDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShtZXNzYWdlQnVmZmVyLmxlbmd0aCwgMSk7XG4gICAgICAgIG1lc3NhZ2VCdWZmZXIuY29weShvdXRwdXQsIDUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YSBGcmFtZWQgbWVzc2FnZSwgcG9zc2libHkgY29tcHJlc3NlZFxuICAgICAqIEByZXR1cm4gVW5jb21wcmVzc2VkIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBhc3luYyByZWFkTWVzc2FnZShkYXRhKSB7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSBkYXRhLnJlYWRVSW50OCgwKSA9PT0gMTtcbiAgICAgICAgbGV0IG1lc3NhZ2VCdWZmZXIgPSBkYXRhLnNsaWNlKDUpO1xuICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgbWVzc2FnZUJ1ZmZlciA9IGF3YWl0IHRoaXMuZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZUJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VCdWZmZXI7XG4gICAgfVxufVxuY2xhc3MgSWRlbnRpdHlIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBhc3luYyBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIGNvbXByZXNzKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXNzYWdlLmxlbmd0aCArIDUpO1xuICAgICAgICAvKiBXaXRoIFwiaWRlbnRpdHlcIiBjb21wcmVzc2lvbiwgbWVzc2FnZXMgc2hvdWxkIGFsd2F5cyBiZSBtYXJrZWQgYXNcbiAgICAgICAgICogdW5jb21wcmVzc2VkICovXG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShtZXNzYWdlLmxlbmd0aCwgMSk7XG4gICAgICAgIG1lc3NhZ2UuY29weShvdXRwdXQsIDUpO1xuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1JlY2VpdmVkIGNvbXByZXNzZWQgbWVzc2FnZSBidXQgXCJncnBjLWVuY29kaW5nXCIgaGVhZGVyIHdhcyBpZGVudGl0eScpKTtcbiAgICB9XG59XG5jbGFzcyBEZWZsYXRlSGFuZGxlciBleHRlbmRzIENvbXByZXNzaW9uSGFuZGxlciB7XG4gICAgY29tcHJlc3NNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHpsaWIuZGVmbGF0ZShtZXNzYWdlLCAoZXJyLCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgemxpYi5pbmZsYXRlKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIEd6aXBIYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgemxpYi5nemlwKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB6bGliLnVuemlwKG1lc3NhZ2UsIChlcnIsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVua25vd25IYW5kbGVyIGV4dGVuZHMgQ29tcHJlc3Npb25IYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wcmVzc2lvbk5hbWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb21wcmVzc2lvbk5hbWUgPSBjb21wcmVzc2lvbk5hbWU7XG4gICAgfVxuICAgIGNvbXByZXNzTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFJlY2VpdmVkIG1lc3NhZ2UgY29tcHJlc3NlZCB3aXRoIHVuc3VwcG9ydGVkIGNvbXByZXNzaW9uIG1ldGhvZCAke3RoaXMuY29tcHJlc3Npb25OYW1lfWApKTtcbiAgICB9XG4gICAgZGVjb21wcmVzc01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB1bnJlYWNoYWJsZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBDb21wcmVzc2lvbiBtZXRob2Qgbm90IHN1cHBvcnRlZDogJHt0aGlzLmNvbXByZXNzaW9uTmFtZX1gKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKGNvbXByZXNzaW9uTmFtZSkge1xuICAgIHN3aXRjaCAoY29tcHJlc3Npb25OYW1lKSB7XG4gICAgICAgIGNhc2UgJ2lkZW50aXR5JzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgIGNhc2UgJ2RlZmxhdGUnOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWZsYXRlSGFuZGxlcigpO1xuICAgICAgICBjYXNlICdnemlwJzpcbiAgICAgICAgICAgIHJldHVybiBuZXcgR3ppcEhhbmRsZXIoKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW5rbm93bkhhbmRsZXIoY29tcHJlc3Npb25OYW1lKTtcbiAgICB9XG59XG5jbGFzcyBDb21wcmVzc2lvbkZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxPcHRpb25zLCBzaGFyZWRGaWx0ZXJDb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyA9IHNoYXJlZEZpbHRlckNvbmZpZztcbiAgICAgICAgdGhpcy5zZW5kQ29tcHJlc3Npb24gPSBuZXcgSWRlbnRpdHlIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMucmVjZWl2ZUNvbXByZXNzaW9uID0gbmV3IElkZW50aXR5SGFuZGxlcigpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9ICdpZGVudGl0eSc7XG4gICAgICAgIGNvbnN0IGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5ID0gY2hhbm5lbE9wdGlvbnNbJ2dycGMuZGVmYXVsdF9jb21wcmVzc2lvbl9hbGdvcml0aG0nXTtcbiAgICAgICAgaWYgKGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzaW9uQWxnb3JpdGhtS2V5KGNvbXByZXNzaW9uQWxnb3JpdGhtS2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudFNlbGVjdGVkRW5jb2RpbmcgPSBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zW2NvbXByZXNzaW9uQWxnb3JpdGhtS2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgPSAoX2EgPSBzaGFyZWRGaWx0ZXJDb25maWcuc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdIZWFkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZXJlIGFyZSB0d28gcG9zc2libGUgc2l0dWF0aW9ucyBoZXJlOlxuICAgICAgICAgICAgICAgICAqIDEpIFdlIGRvbid0IGhhdmUgYW55IGluZm8geWV0IGZyb20gdGhlIHNlcnZlciBhYm91dCB3aGF0IGNvbXByZXNzaW9uIGl0IHN1cHBvcnRzXG4gICAgICAgICAgICAgICAgICogICAgSW4gdGhhdCBjYXNlIHdlIHNob3VsZCBqdXN0IHVzZSB3aGF0IHRoZSBjbGllbnQgdGVsbHMgdXMgdG8gdXNlXG4gICAgICAgICAgICAgICAgICogMikgV2UndmUgcHJldmlvdXNseSByZWNlaXZlZCBhIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlciBpbmNsdWRpbmcgYSBncnBjLWFjY2VwdC1lbmNvZGluZyBoZWFkZXJcbiAgICAgICAgICAgICAgICAgKiAgICBJbiB0aGF0IGNhc2Ugd2Ugb25seSB3YW50IHRvIHVzZSB0aGUgZW5jb2RpbmcgY2hvc2VuIGJ5IHRoZSBjbGllbnQgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyBpdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzIHx8IHNlcnZlclN1cHBvcnRlZEVuY29kaW5ncy5pbmNsdWRlcyhjbGllbnRTZWxlY3RlZEVuY29kaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSA9IGNsaWVudFNlbGVjdGVkRW5jb2Rpbmc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gZ2V0Q29tcHJlc3Npb25IYW5kbGVyKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBJbnZhbGlkIHZhbHVlIHByb3ZpZGVkIGZvciBncnBjLmRlZmF1bHRfY29tcHJlc3Npb25fYWxnb3JpdGhtIG9wdGlvbjogJHtjb21wcmVzc2lvbkFsZ29yaXRobUtleX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IGF3YWl0IG1ldGFkYXRhO1xuICAgICAgICBoZWFkZXJzLnNldCgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHksZGVmbGF0ZSxnemlwJyk7XG4gICAgICAgIGhlYWRlcnMuc2V0KCdhY2NlcHQtZW5jb2RpbmcnLCAnaWRlbnRpdHknKTtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZW5kIHRoZSBoZWFkZXIgaWYgaXQncyBcImlkZW50aXR5XCIgLSAgYmVoYXZpb3IgaXMgaWRlbnRpY2FsOyBzYXZlIHRoZSBiYW5kd2lkdGhcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgICBoZWFkZXJzLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVycy5zZXQoJ2dycGMtZW5jb2RpbmcnLCB0aGlzLmN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCByZWNlaXZlRW5jb2RpbmcgPSBtZXRhZGF0YS5nZXQoJ2dycGMtZW5jb2RpbmcnKTtcbiAgICAgICAgaWYgKHJlY2VpdmVFbmNvZGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGluZyA9IHJlY2VpdmVFbmNvZGluZ1swXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlQ29tcHJlc3Npb24gPSBnZXRDb21wcmVzc2lvbkhhbmRsZXIoZW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICAvKiBDaGVjayB0byBzZWUgaWYgdGhlIGNvbXByZXNzaW9uIHdlJ3JlIHVzaW5nIHRvIHNlbmQgbWVzc2FnZXMgaXMgc3VwcG9ydGVkIGJ5IHRoZSBzZXJ2ZXJcbiAgICAgICAgICogSWYgbm90LCByZXNldCB0aGUgc2VuZENvbXByZXNzaW9uIGZpbHRlciBhbmQgaGF2ZSBpdCB1c2UgdGhlIGRlZmF1bHQgSWRlbnRpdHlIYW5kbGVyICovXG4gICAgICAgIGNvbnN0IHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlciA9IG1ldGFkYXRhLmdldCgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKVswXTtcbiAgICAgICAgaWYgKHNlcnZlclN1cHBvcnRlZEVuY29kaW5nc0hlYWRlcikge1xuICAgICAgICAgICAgdGhpcy5zaGFyZWRGaWx0ZXJDb25maWcuc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdIZWFkZXIgPSBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXI7XG4gICAgICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3MgPSBzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGlmICghc2VydmVyU3VwcG9ydGVkRW5jb2RpbmdzLmluY2x1ZGVzKHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbXByZXNzaW9uID0gbmV3IElkZW50aXR5SGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbXByZXNzaW9uQWxnb3JpdGhtID0gJ2lkZW50aXR5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoJ2dycGMtYWNjZXB0LWVuY29kaW5nJyk7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8qIFRoaXMgZmlsdGVyIGlzIHNwZWNpYWwuIFRoZSBpbnB1dCBtZXNzYWdlIGlzIHRoZSBiYXJlIG1lc3NhZ2UgYnl0ZXMsXG4gICAgICAgICAqIGFuZCB0aGUgb3V0cHV0IGlzIGEgZnJhbWVkIGFuZCBwb3NzaWJseSBjb21wcmVzc2VkIG1lc3NhZ2UuIEZvciB0aGlzXG4gICAgICAgICAqIHJlYXNvbiwgdGhpcyBmaWx0ZXIgc2hvdWxkIGJlIGF0IHRoZSBib3R0b20gb2YgdGhlIGZpbHRlciBzdGFjayAqL1xuICAgICAgICBjb25zdCByZXNvbHZlZE1lc3NhZ2UgPSBhd2FpdCBtZXNzYWdlO1xuICAgICAgICBsZXQgY29tcHJlc3M7XG4gICAgICAgIGlmICh0aGlzLnNlbmRDb21wcmVzc2lvbiBpbnN0YW5jZW9mIElkZW50aXR5SGFuZGxlcikge1xuICAgICAgICAgICAgY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbXByZXNzID0gKCgoX2EgPSByZXNvbHZlZE1lc3NhZ2UuZmxhZ3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApICYgMiAvKiBOb0NvbXByZXNzICovKSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogYXdhaXQgdGhpcy5zZW5kQ29tcHJlc3Npb24ud3JpdGVNZXNzYWdlKHJlc29sdmVkTWVzc2FnZS5tZXNzYWdlLCBjb21wcmVzcyksXG4gICAgICAgICAgICBmbGFnczogcmVzb2x2ZWRNZXNzYWdlLmZsYWdzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIC8qIFRoaXMgZmlsdGVyIGlzIGFsc28gc3BlY2lhbC4gVGhlIGlucHV0IG1lc3NhZ2UgaXMgZnJhbWVkIGFuZCBwb3NzaWJseVxuICAgICAgICAgKiBjb21wcmVzc2VkLCBhbmQgdGhlIG91dHB1dCBtZXNzYWdlIGlzIGRlZnJhbWVkIGFuZCB1bmNvbXByZXNzZWQuIFNvXG4gICAgICAgICAqIHRoaXMgaXMgYW5vdGhlciByZWFzb24gdGhhdCB0aGlzIGZpbHRlciBzaG91bGQgYmUgYXQgdGhlIGJvdHRvbSBvZiB0aGVcbiAgICAgICAgICogZmlsdGVyIHN0YWNrLiAqL1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlQ29tcHJlc3Npb24ucmVhZE1lc3NhZ2UoYXdhaXQgbWVzc2FnZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlciA9IENvbXByZXNzaW9uRmlsdGVyO1xuY2xhc3MgQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihjaGFubmVsLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuc2hhcmVkRmlsdGVyQ29uZmlnID0ge307XG4gICAgfVxuICAgIGNyZWF0ZUZpbHRlcihjYWxsU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcHJlc3Npb25GaWx0ZXIodGhpcy5vcHRpb25zLCB0aGlzLnNoYXJlZEZpbHRlckNvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5Db21wcmVzc2lvbkZpbHRlckZhY3RvcnkgPSBDb21wcmVzc2lvbkZpbHRlckZhY3Rvcnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21wcmVzc2lvbi1maWx0ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiQ29tcHJlc3Npb25GaWx0ZXJGYWN0b3J5IiwiQ29tcHJlc3Npb25GaWx0ZXIiLCJ6bGliIiwicmVxdWlyZSIsImNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSIsImNvbnN0YW50c18xIiwiZmlsdGVyXzEiLCJsb2dnaW5nIiwiaXNDb21wcmVzc2lvbkFsZ29yaXRobUtleSIsImtleSIsIkNvbXByZXNzaW9uQWxnb3JpdGhtcyIsIkNvbXByZXNzaW9uSGFuZGxlciIsIndyaXRlTWVzc2FnZSIsIm1lc3NhZ2UiLCJjb21wcmVzcyIsIm1lc3NhZ2VCdWZmZXIiLCJjb21wcmVzc01lc3NhZ2UiLCJvdXRwdXQiLCJCdWZmZXIiLCJhbGxvY1Vuc2FmZSIsImxlbmd0aCIsIndyaXRlVUludDgiLCJ3cml0ZVVJbnQzMkJFIiwiY29weSIsInJlYWRNZXNzYWdlIiwiZGF0YSIsImNvbXByZXNzZWQiLCJyZWFkVUludDgiLCJzbGljZSIsImRlY29tcHJlc3NNZXNzYWdlIiwiSWRlbnRpdHlIYW5kbGVyIiwiUHJvbWlzZSIsInJlamVjdCIsIkVycm9yIiwiRGVmbGF0ZUhhbmRsZXIiLCJyZXNvbHZlIiwiZGVmbGF0ZSIsImVyciIsImluZmxhdGUiLCJHemlwSGFuZGxlciIsImd6aXAiLCJ1bnppcCIsIlVua25vd25IYW5kbGVyIiwiY29uc3RydWN0b3IiLCJjb21wcmVzc2lvbk5hbWUiLCJnZXRDb21wcmVzc2lvbkhhbmRsZXIiLCJCYXNlRmlsdGVyIiwiY2hhbm5lbE9wdGlvbnMiLCJzaGFyZWRGaWx0ZXJDb25maWciLCJfYSIsInNlbmRDb21wcmVzc2lvbiIsInJlY2VpdmVDb21wcmVzc2lvbiIsImN1cnJlbnRDb21wcmVzc2lvbkFsZ29yaXRobSIsImNvbXByZXNzaW9uQWxnb3JpdGhtS2V5IiwidW5kZWZpbmVkIiwiY2xpZW50U2VsZWN0ZWRFbmNvZGluZyIsInNlcnZlclN1cHBvcnRlZEVuY29kaW5ncyIsInNlcnZlclN1cHBvcnRlZEVuY29kaW5nSGVhZGVyIiwic3BsaXQiLCJpbmNsdWRlcyIsImxvZyIsIkxvZ1ZlcmJvc2l0eSIsIkVSUk9SIiwic2VuZE1ldGFkYXRhIiwibWV0YWRhdGEiLCJoZWFkZXJzIiwic2V0IiwicmVtb3ZlIiwicmVjZWl2ZU1ldGFkYXRhIiwicmVjZWl2ZUVuY29kaW5nIiwiZ2V0IiwiZW5jb2RpbmciLCJzZXJ2ZXJTdXBwb3J0ZWRFbmNvZGluZ3NIZWFkZXIiLCJzZW5kTWVzc2FnZSIsInJlc29sdmVkTWVzc2FnZSIsImZsYWdzIiwicmVjZWl2ZU1lc3NhZ2UiLCJjaGFubmVsIiwib3B0aW9ucyIsImNyZWF0ZUZpbHRlciIsImNhbGxTdHJlYW0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/connectivity-state.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ConnectivityState = void 0;\nvar ConnectivityState;\n(function(ConnectivityState) {\n    ConnectivityState[ConnectivityState[\"IDLE\"] = 0] = \"IDLE\";\n    ConnectivityState[ConnectivityState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    ConnectivityState[ConnectivityState[\"READY\"] = 2] = \"READY\";\n    ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 3] = \"TRANSIENT_FAILURE\";\n    ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {})); //# sourceMappingURL=connectivity-state.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29ubmVjdGl2aXR5LXN0YXRlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pDLElBQUlFO0FBQ0gsVUFBVUEsaUJBQWlCO0lBQ3hCQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRztJQUNuREEsaUJBQWlCLENBQUNBLGlCQUFpQixDQUFDLGFBQWEsR0FBRyxFQUFFLEdBQUc7SUFDekRBLGlCQUFpQixDQUFDQSxpQkFBaUIsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ3BEQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQ2hFQSxpQkFBaUIsQ0FBQ0EsaUJBQWlCLENBQUMsV0FBVyxHQUFHLEVBQUUsR0FBRztBQUMzRCxHQUFHQSxvQkFBb0JGLFFBQVFFLGlCQUFpQixJQUFLRixDQUFBQSx5QkFBeUIsR0FBRyxDQUFDLEtBQ2xGLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25uZWN0aXZpdHktc3RhdGUuanM/NGVlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db25uZWN0aXZpdHlTdGF0ZSA9IHZvaWQgMDtcbnZhciBDb25uZWN0aXZpdHlTdGF0ZTtcbihmdW5jdGlvbiAoQ29ubmVjdGl2aXR5U3RhdGUpIHtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIklETEVcIl0gPSAwXSA9IFwiSURMRVwiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiQ09OTkVDVElOR1wiXSA9IDFdID0gXCJDT05ORUNUSU5HXCI7XG4gICAgQ29ubmVjdGl2aXR5U3RhdGVbQ29ubmVjdGl2aXR5U3RhdGVbXCJSRUFEWVwiXSA9IDJdID0gXCJSRUFEWVwiO1xuICAgIENvbm5lY3Rpdml0eVN0YXRlW0Nvbm5lY3Rpdml0eVN0YXRlW1wiVFJBTlNJRU5UX0ZBSUxVUkVcIl0gPSAzXSA9IFwiVFJBTlNJRU5UX0ZBSUxVUkVcIjtcbiAgICBDb25uZWN0aXZpdHlTdGF0ZVtDb25uZWN0aXZpdHlTdGF0ZVtcIlNIVVRET1dOXCJdID0gNF0gPSBcIlNIVVRET1dOXCI7XG59KShDb25uZWN0aXZpdHlTdGF0ZSA9IGV4cG9ydHMuQ29ubmVjdGl2aXR5U3RhdGUgfHwgKGV4cG9ydHMuQ29ubmVjdGl2aXR5U3RhdGUgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdGl2aXR5LXN0YXRlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkNvbm5lY3Rpdml0eVN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/constants.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports.Propagate = exports.LogVerbosity = exports.Status = void 0;\nvar Status;\n(function(Status) {\n    Status[Status[\"OK\"] = 0] = \"OK\";\n    Status[Status[\"CANCELLED\"] = 1] = \"CANCELLED\";\n    Status[Status[\"UNKNOWN\"] = 2] = \"UNKNOWN\";\n    Status[Status[\"INVALID_ARGUMENT\"] = 3] = \"INVALID_ARGUMENT\";\n    Status[Status[\"DEADLINE_EXCEEDED\"] = 4] = \"DEADLINE_EXCEEDED\";\n    Status[Status[\"NOT_FOUND\"] = 5] = \"NOT_FOUND\";\n    Status[Status[\"ALREADY_EXISTS\"] = 6] = \"ALREADY_EXISTS\";\n    Status[Status[\"PERMISSION_DENIED\"] = 7] = \"PERMISSION_DENIED\";\n    Status[Status[\"RESOURCE_EXHAUSTED\"] = 8] = \"RESOURCE_EXHAUSTED\";\n    Status[Status[\"FAILED_PRECONDITION\"] = 9] = \"FAILED_PRECONDITION\";\n    Status[Status[\"ABORTED\"] = 10] = \"ABORTED\";\n    Status[Status[\"OUT_OF_RANGE\"] = 11] = \"OUT_OF_RANGE\";\n    Status[Status[\"UNIMPLEMENTED\"] = 12] = \"UNIMPLEMENTED\";\n    Status[Status[\"INTERNAL\"] = 13] = \"INTERNAL\";\n    Status[Status[\"UNAVAILABLE\"] = 14] = \"UNAVAILABLE\";\n    Status[Status[\"DATA_LOSS\"] = 15] = \"DATA_LOSS\";\n    Status[Status[\"UNAUTHENTICATED\"] = 16] = \"UNAUTHENTICATED\";\n})(Status = exports.Status || (exports.Status = {}));\nvar LogVerbosity;\n(function(LogVerbosity) {\n    LogVerbosity[LogVerbosity[\"DEBUG\"] = 0] = \"DEBUG\";\n    LogVerbosity[LogVerbosity[\"INFO\"] = 1] = \"INFO\";\n    LogVerbosity[LogVerbosity[\"ERROR\"] = 2] = \"ERROR\";\n    LogVerbosity[LogVerbosity[\"NONE\"] = 3] = \"NONE\";\n})(LogVerbosity = exports.LogVerbosity || (exports.LogVerbosity = {}));\n/**\n * NOTE: This enum is not currently used in any implemented API in this\n * library. It is included only for type parity with the other implementation.\n */ var Propagate;\n(function(Propagate) {\n    Propagate[Propagate[\"DEADLINE\"] = 1] = \"DEADLINE\";\n    Propagate[Propagate[\"CENSUS_STATS_CONTEXT\"] = 2] = \"CENSUS_STATS_CONTEXT\";\n    Propagate[Propagate[\"CENSUS_TRACING_CONTEXT\"] = 4] = \"CENSUS_TRACING_CONTEXT\";\n    Propagate[Propagate[\"CANCELLATION\"] = 8] = \"CANCELLATION\";\n    // https://github.com/grpc/grpc/blob/master/include/grpc/impl/codegen/propagation_bits.h#L43\n    Propagate[Propagate[\"DEFAULTS\"] = 65535] = \"DEFAULTS\";\n})(Propagate = exports.Propagate || (exports.Propagate = {}));\n// -1 means unlimited\nexports.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;\n// 4 MB default\nexports.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024; //# sourceMappingURL=constants.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQ0FBMEMsR0FBR0EsdUNBQXVDLEdBQUdBLGlCQUFpQixHQUFHQSxvQkFBb0IsR0FBR0EsY0FBYyxHQUFHLEtBQUs7QUFDeEosSUFBSU07QUFDSCxVQUFVQSxNQUFNO0lBQ2JBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLEtBQUssR0FBRyxFQUFFLEdBQUc7SUFDM0JBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFlBQVksR0FBRyxFQUFFLEdBQUc7SUFDbENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFVBQVUsR0FBRyxFQUFFLEdBQUc7SUFDaENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLG1CQUFtQixHQUFHLEVBQUUsR0FBRztJQUN6Q0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsb0JBQW9CLEdBQUcsRUFBRSxHQUFHO0lBQzFDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxZQUFZLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLG9CQUFvQixHQUFHLEVBQUUsR0FBRztJQUMxQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMscUJBQXFCLEdBQUcsRUFBRSxHQUFHO0lBQzNDQSxNQUFNLENBQUNBLE1BQU0sQ0FBQyxzQkFBc0IsR0FBRyxFQUFFLEdBQUc7SUFDNUNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLFVBQVUsR0FBRyxHQUFHLEdBQUc7SUFDakNBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGVBQWUsR0FBRyxHQUFHLEdBQUc7SUFDdENBLE1BQU0sQ0FBQ0EsTUFBTSxDQUFDLGdCQUFnQixHQUFHLEdBQUcsR0FBRztJQUN2Q0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsV0FBVyxHQUFHLEdBQUcsR0FBRztJQUNsQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsY0FBYyxHQUFHLEdBQUcsR0FBRztJQUNyQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsWUFBWSxHQUFHLEdBQUcsR0FBRztJQUNuQ0EsTUFBTSxDQUFDQSxNQUFNLENBQUMsa0JBQWtCLEdBQUcsR0FBRyxHQUFHO0FBQzdDLEdBQUdBLFNBQVNOLFFBQVFNLE1BQU0sSUFBS04sQ0FBQUEsY0FBYyxHQUFHLENBQUM7QUFDakQsSUFBSUs7QUFDSCxVQUFVQSxZQUFZO0lBQ25CQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQzFDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0lBQ3pDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQzFDQSxZQUFZLENBQUNBLFlBQVksQ0FBQyxPQUFPLEdBQUcsRUFBRSxHQUFHO0FBQzdDLEdBQUdBLGVBQWVMLFFBQVFLLFlBQVksSUFBS0wsQ0FBQUEsb0JBQW9CLEdBQUcsQ0FBQztBQUNuRTs7O0NBR0MsR0FDRCxJQUFJSTtBQUNILFVBQVVBLFNBQVM7SUFDaEJBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLFdBQVcsR0FBRyxFQUFFLEdBQUc7SUFDdkNBLFNBQVMsQ0FBQ0EsU0FBUyxDQUFDLHVCQUF1QixHQUFHLEVBQUUsR0FBRztJQUNuREEsU0FBUyxDQUFDQSxTQUFTLENBQUMseUJBQXlCLEdBQUcsRUFBRSxHQUFHO0lBQ3JEQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQzNDLDRGQUE0RjtJQUM1RkEsU0FBUyxDQUFDQSxTQUFTLENBQUMsV0FBVyxHQUFHLE1BQU0sR0FBRztBQUMvQyxHQUFHQSxZQUFZSixRQUFRSSxTQUFTLElBQUtKLENBQUFBLGlCQUFpQixHQUFHLENBQUM7QUFDMUQscUJBQXFCO0FBQ3JCQSx1Q0FBdUMsR0FBRyxDQUFDO0FBQzNDLGVBQWU7QUFDZkEsMENBQTBDLEdBQUcsSUFBSSxPQUFPLE1BQ3hELHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9jb25zdGFudHMuanM/MWMyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIID0gZXhwb3J0cy5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIID0gZXhwb3J0cy5Qcm9wYWdhdGUgPSBleHBvcnRzLkxvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuU3RhdHVzID0gdm9pZCAwO1xudmFyIFN0YXR1cztcbihmdW5jdGlvbiAoU3RhdHVzKSB7XG4gICAgU3RhdHVzW1N0YXR1c1tcIk9LXCJdID0gMF0gPSBcIk9LXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkNBTkNFTExFRFwiXSA9IDFdID0gXCJDQU5DRUxMRURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5LTk9XTlwiXSA9IDJdID0gXCJVTktOT1dOXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIklOVkFMSURfQVJHVU1FTlRcIl0gPSAzXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJERUFETElORV9FWENFRURFRFwiXSA9IDRdID0gXCJERUFETElORV9FWENFRURFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJOT1RfRk9VTkRcIl0gPSA1XSA9IFwiTk9UX0ZPVU5EXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkFMUkVBRFlfRVhJU1RTXCJdID0gNl0gPSBcIkFMUkVBRFlfRVhJU1RTXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlBFUk1JU1NJT05fREVOSUVEXCJdID0gN10gPSBcIlBFUk1JU1NJT05fREVOSUVEXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlJFU09VUkNFX0VYSEFVU1RFRFwiXSA9IDhdID0gXCJSRVNPVVJDRV9FWEhBVVNURURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiRkFJTEVEX1BSRUNPTkRJVElPTlwiXSA9IDldID0gXCJGQUlMRURfUFJFQ09ORElUSU9OXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkFCT1JURURcIl0gPSAxMF0gPSBcIkFCT1JURURcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiT1VUX09GX1JBTkdFXCJdID0gMTFdID0gXCJPVVRfT0ZfUkFOR0VcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5JTVBMRU1FTlRFRFwiXSA9IDEyXSA9IFwiVU5JTVBMRU1FTlRFRFwiO1xuICAgIFN0YXR1c1tTdGF0dXNbXCJJTlRFUk5BTFwiXSA9IDEzXSA9IFwiSU5URVJOQUxcIjtcbiAgICBTdGF0dXNbU3RhdHVzW1wiVU5BVkFJTEFCTEVcIl0gPSAxNF0gPSBcIlVOQVZBSUxBQkxFXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIkRBVEFfTE9TU1wiXSA9IDE1XSA9IFwiREFUQV9MT1NTXCI7XG4gICAgU3RhdHVzW1N0YXR1c1tcIlVOQVVUSEVOVElDQVRFRFwiXSA9IDE2XSA9IFwiVU5BVVRIRU5USUNBVEVEXCI7XG59KShTdGF0dXMgPSBleHBvcnRzLlN0YXR1cyB8fCAoZXhwb3J0cy5TdGF0dXMgPSB7fSkpO1xudmFyIExvZ1ZlcmJvc2l0eTtcbihmdW5jdGlvbiAoTG9nVmVyYm9zaXR5KSB7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIkRFQlVHXCJdID0gMF0gPSBcIkRFQlVHXCI7XG4gICAgTG9nVmVyYm9zaXR5W0xvZ1ZlcmJvc2l0eVtcIklORk9cIl0gPSAxXSA9IFwiSU5GT1wiO1xuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJFUlJPUlwiXSA9IDJdID0gXCJFUlJPUlwiO1xuICAgIExvZ1ZlcmJvc2l0eVtMb2dWZXJib3NpdHlbXCJOT05FXCJdID0gM10gPSBcIk5PTkVcIjtcbn0pKExvZ1ZlcmJvc2l0eSA9IGV4cG9ydHMuTG9nVmVyYm9zaXR5IHx8IChleHBvcnRzLkxvZ1ZlcmJvc2l0eSA9IHt9KSk7XG4vKipcbiAqIE5PVEU6IFRoaXMgZW51bSBpcyBub3QgY3VycmVudGx5IHVzZWQgaW4gYW55IGltcGxlbWVudGVkIEFQSSBpbiB0aGlzXG4gKiBsaWJyYXJ5LiBJdCBpcyBpbmNsdWRlZCBvbmx5IGZvciB0eXBlIHBhcml0eSB3aXRoIHRoZSBvdGhlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xudmFyIFByb3BhZ2F0ZTtcbihmdW5jdGlvbiAoUHJvcGFnYXRlKSB7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkRFQURMSU5FXCJdID0gMV0gPSBcIkRFQURMSU5FXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19TVEFUU19DT05URVhUXCJdID0gMl0gPSBcIkNFTlNVU19TVEFUU19DT05URVhUXCI7XG4gICAgUHJvcGFnYXRlW1Byb3BhZ2F0ZVtcIkNFTlNVU19UUkFDSU5HX0NPTlRFWFRcIl0gPSA0XSA9IFwiQ0VOU1VTX1RSQUNJTkdfQ09OVEVYVFwiO1xuICAgIFByb3BhZ2F0ZVtQcm9wYWdhdGVbXCJDQU5DRUxMQVRJT05cIl0gPSA4XSA9IFwiQ0FOQ0VMTEFUSU9OXCI7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9pbmNsdWRlL2dycGMvaW1wbC9jb2RlZ2VuL3Byb3BhZ2F0aW9uX2JpdHMuaCNMNDNcbiAgICBQcm9wYWdhdGVbUHJvcGFnYXRlW1wiREVGQVVMVFNcIl0gPSA2NTUzNV0gPSBcIkRFRkFVTFRTXCI7XG59KShQcm9wYWdhdGUgPSBleHBvcnRzLlByb3BhZ2F0ZSB8fCAoZXhwb3J0cy5Qcm9wYWdhdGUgPSB7fSkpO1xuLy8gLTEgbWVhbnMgdW5saW1pdGVkXG5leHBvcnRzLkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEggPSAtMTtcbi8vIDQgTUIgZGVmYXVsdFxuZXhwb3J0cy5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIID0gNCAqIDEwMjQgKiAxMDI0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEgiLCJERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIIiwiUHJvcGFnYXRlIiwiTG9nVmVyYm9zaXR5IiwiU3RhdHVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline-filter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/deadline-filter.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.DeadlineFilterFactory = exports.DeadlineFilter = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst units = [\n    [\n        \"m\",\n        1\n    ],\n    [\n        \"S\",\n        1000\n    ],\n    [\n        \"M\",\n        60 * 1000\n    ],\n    [\n        \"H\",\n        60 * 60 * 1000\n    ]\n];\nfunction getDeadline(deadline) {\n    const now = new Date().getTime();\n    const timeoutMs = Math.max(deadline - now, 0);\n    for (const [unit, factor] of units){\n        const amount = timeoutMs / factor;\n        if (amount < 1e8) {\n            return String(Math.ceil(amount)) + unit;\n        }\n    }\n    throw new Error(\"Deadline is too far in the future\");\n}\nclass DeadlineFilter extends filter_1.BaseFilter {\n    constructor(channel, callStream){\n        super();\n        this.channel = channel;\n        this.callStream = callStream;\n        this.timer = null;\n        this.deadline = Infinity;\n        this.retreiveDeadline();\n        this.runTimer();\n    }\n    retreiveDeadline() {\n        const callDeadline = this.callStream.getDeadline();\n        if (callDeadline instanceof Date) {\n            this.deadline = callDeadline.getTime();\n        } else {\n            this.deadline = callDeadline;\n        }\n    }\n    runTimer() {\n        var _a, _b;\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        const now = new Date().getTime();\n        const timeout = this.deadline - now;\n        if (timeout <= 0) {\n            process.nextTick(()=>{\n                this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, \"Deadline exceeded\");\n            });\n        } else if (this.deadline !== Infinity) {\n            this.timer = setTimeout(()=>{\n                this.callStream.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, \"Deadline exceeded\");\n            }, timeout);\n            (_b = (_a = this.timer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    refresh() {\n        this.retreiveDeadline();\n        this.runTimer();\n    }\n    async sendMetadata(metadata) {\n        if (this.deadline === Infinity) {\n            return metadata;\n        }\n        /* The input metadata promise depends on the original channel.connect()\n         * promise, so when it is complete that implies that the channel is\n         * connected */ const finalMetadata = await metadata;\n        const timeoutString = getDeadline(this.deadline);\n        finalMetadata.set(\"grpc-timeout\", timeoutString);\n        return finalMetadata;\n    }\n    receiveTrailers(status) {\n        if (this.timer) {\n            clearTimeout(this.timer);\n        }\n        return status;\n    }\n}\nexports.DeadlineFilter = DeadlineFilter;\nclass DeadlineFilterFactory {\n    constructor(channel){\n        this.channel = channel;\n    }\n    createFilter(callStream) {\n        return new DeadlineFilter(this.channel, callStream);\n    }\n}\nexports.DeadlineFilterFactory = DeadlineFilterFactory; //# sourceMappingURL=deadline-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZGVhZGxpbmUtZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCw2QkFBNkIsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUM5RCxNQUFNSSxjQUFjQyxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyx3RUFBVTtBQUNuQyxNQUFNRSxRQUFRO0lBQ1Y7UUFBQztRQUFLO0tBQUU7SUFDUjtRQUFDO1FBQUs7S0FBSztJQUNYO1FBQUM7UUFBSyxLQUFLO0tBQUs7SUFDaEI7UUFBQztRQUFLLEtBQUssS0FBSztLQUFLO0NBQ3hCO0FBQ0QsU0FBU0MsWUFBWUMsUUFBUTtJQUN6QixNQUFNQyxNQUFNLElBQUlDLE9BQU9DLE9BQU87SUFDOUIsTUFBTUMsWUFBWUMsS0FBS0MsR0FBRyxDQUFDTixXQUFXQyxLQUFLO0lBQzNDLEtBQUssTUFBTSxDQUFDTSxNQUFNQyxPQUFPLElBQUlWLE1BQU87UUFDaEMsTUFBTVcsU0FBU0wsWUFBWUk7UUFDM0IsSUFBSUMsU0FBUyxLQUFLO1lBQ2QsT0FBT0MsT0FBT0wsS0FBS00sSUFBSSxDQUFDRixXQUFXRjtRQUN2QztJQUNKO0lBQ0EsTUFBTSxJQUFJSyxNQUFNO0FBQ3BCO0FBQ0EsTUFBTWxCLHVCQUF1QkcsU0FBU2dCLFVBQVU7SUFDNUNDLFlBQVlDLE9BQU8sRUFBRUMsVUFBVSxDQUFFO1FBQzdCLEtBQUs7UUFDTCxJQUFJLENBQUNELE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNqQixRQUFRLEdBQUdrQjtRQUNoQixJQUFJLENBQUNDLGdCQUFnQjtRQUNyQixJQUFJLENBQUNDLFFBQVE7SUFDakI7SUFDQUQsbUJBQW1CO1FBQ2YsTUFBTUUsZUFBZSxJQUFJLENBQUNMLFVBQVUsQ0FBQ2pCLFdBQVc7UUFDaEQsSUFBSXNCLHdCQUF3Qm5CLE1BQU07WUFDOUIsSUFBSSxDQUFDRixRQUFRLEdBQUdxQixhQUFhbEIsT0FBTztRQUN4QyxPQUNLO1lBQ0QsSUFBSSxDQUFDSCxRQUFRLEdBQUdxQjtRQUNwQjtJQUNKO0lBQ0FELFdBQVc7UUFDUCxJQUFJRSxJQUFJQztRQUNSLElBQUksSUFBSSxDQUFDTixLQUFLLEVBQUU7WUFDWk8sYUFBYSxJQUFJLENBQUNQLEtBQUs7UUFDM0I7UUFDQSxNQUFNaEIsTUFBTSxJQUFJQyxPQUFPQyxPQUFPO1FBQzlCLE1BQU1zQixVQUFVLElBQUksQ0FBQ3pCLFFBQVEsR0FBR0M7UUFDaEMsSUFBSXdCLFdBQVcsR0FBRztZQUNkQyxRQUFRQyxRQUFRLENBQUM7Z0JBQ2IsSUFBSSxDQUFDWCxVQUFVLENBQUNZLGdCQUFnQixDQUFDakMsWUFBWWtDLE1BQU0sQ0FBQ0MsaUJBQWlCLEVBQUU7WUFDM0U7UUFDSixPQUNLLElBQUksSUFBSSxDQUFDOUIsUUFBUSxLQUFLa0IsVUFBVTtZQUNqQyxJQUFJLENBQUNELEtBQUssR0FBR2MsV0FBVztnQkFDcEIsSUFBSSxDQUFDZixVQUFVLENBQUNZLGdCQUFnQixDQUFDakMsWUFBWWtDLE1BQU0sQ0FBQ0MsaUJBQWlCLEVBQUU7WUFDM0UsR0FBR0w7WUFDRkYsQ0FBQUEsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ0wsS0FBSyxFQUFFZSxLQUFLLE1BQU0sUUFBUVQsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHVSxJQUFJLENBQUNYO1FBQ2hGO0lBQ0o7SUFDQVksVUFBVTtRQUNOLElBQUksQ0FBQ2YsZ0JBQWdCO1FBQ3JCLElBQUksQ0FBQ0MsUUFBUTtJQUNqQjtJQUNBLE1BQU1lLGFBQWFDLFFBQVEsRUFBRTtRQUN6QixJQUFJLElBQUksQ0FBQ3BDLFFBQVEsS0FBS2tCLFVBQVU7WUFDNUIsT0FBT2tCO1FBQ1g7UUFDQTs7cUJBRWEsR0FDYixNQUFNQyxnQkFBZ0IsTUFBTUQ7UUFDNUIsTUFBTUUsZ0JBQWdCdkMsWUFBWSxJQUFJLENBQUNDLFFBQVE7UUFDL0NxQyxjQUFjRSxHQUFHLENBQUMsZ0JBQWdCRDtRQUNsQyxPQUFPRDtJQUNYO0lBQ0FHLGdCQUFnQkMsTUFBTSxFQUFFO1FBQ3BCLElBQUksSUFBSSxDQUFDeEIsS0FBSyxFQUFFO1lBQ1pPLGFBQWEsSUFBSSxDQUFDUCxLQUFLO1FBQzNCO1FBQ0EsT0FBT3dCO0lBQ1g7QUFDSjtBQUNBbEQsc0JBQXNCLEdBQUdHO0FBQ3pCLE1BQU1EO0lBQ0ZxQixZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0EyQixhQUFhMUIsVUFBVSxFQUFFO1FBQ3JCLE9BQU8sSUFBSXRCLGVBQWUsSUFBSSxDQUFDcUIsT0FBTyxFQUFFQztJQUM1QztBQUNKO0FBQ0F6Qiw2QkFBNkIsR0FBR0UsdUJBQ2hDLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9kZWFkbGluZS1maWx0ZXIuanM/OWQ4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWFkbGluZUZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkRlYWRsaW5lRmlsdGVyID0gdm9pZCAwO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBmaWx0ZXJfMSA9IHJlcXVpcmUoXCIuL2ZpbHRlclwiKTtcbmNvbnN0IHVuaXRzID0gW1xuICAgIFsnbScsIDFdLFxuICAgIFsnUycsIDEwMDBdLFxuICAgIFsnTScsIDYwICogMTAwMF0sXG4gICAgWydIJywgNjAgKiA2MCAqIDEwMDBdLFxuXTtcbmZ1bmN0aW9uIGdldERlYWRsaW5lKGRlYWRsaW5lKSB7XG4gICAgY29uc3Qgbm93ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgdGltZW91dE1zID0gTWF0aC5tYXgoZGVhZGxpbmUgLSBub3csIDApO1xuICAgIGZvciAoY29uc3QgW3VuaXQsIGZhY3Rvcl0gb2YgdW5pdHMpIHtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gdGltZW91dE1zIC8gZmFjdG9yO1xuICAgICAgICBpZiAoYW1vdW50IDwgMWU4KSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKE1hdGguY2VpbChhbW91bnQpKSArIHVuaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWFkbGluZSBpcyB0b28gZmFyIGluIHRoZSBmdXR1cmUnKTtcbn1cbmNsYXNzIERlYWRsaW5lRmlsdGVyIGV4dGVuZHMgZmlsdGVyXzEuQmFzZUZpbHRlciB7XG4gICAgY29uc3RydWN0b3IoY2hhbm5lbCwgY2FsbFN0cmVhbSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICB0aGlzLmNhbGxTdHJlYW0gPSBjYWxsU3RyZWFtO1xuICAgICAgICB0aGlzLnRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLnJldHJlaXZlRGVhZGxpbmUoKTtcbiAgICAgICAgdGhpcy5ydW5UaW1lcigpO1xuICAgIH1cbiAgICByZXRyZWl2ZURlYWRsaW5lKCkge1xuICAgICAgICBjb25zdCBjYWxsRGVhZGxpbmUgPSB0aGlzLmNhbGxTdHJlYW0uZ2V0RGVhZGxpbmUoKTtcbiAgICAgICAgaWYgKGNhbGxEZWFkbGluZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVhZGxpbmUgPSBjYWxsRGVhZGxpbmUuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kZWFkbGluZSA9IGNhbGxEZWFkbGluZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5UaW1lcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMudGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuZGVhZGxpbmUgLSBub3c7XG4gICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRCwgJ0RlYWRsaW5lIGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRlYWRsaW5lICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRCwgJ0RlYWRsaW5lIGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMudGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5yZXRyZWl2ZURlYWRsaW5lKCk7XG4gICAgICAgIHRoaXMucnVuVGltZXIoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmRlYWRsaW5lID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8qIFRoZSBpbnB1dCBtZXRhZGF0YSBwcm9taXNlIGRlcGVuZHMgb24gdGhlIG9yaWdpbmFsIGNoYW5uZWwuY29ubmVjdCgpXG4gICAgICAgICAqIHByb21pc2UsIHNvIHdoZW4gaXQgaXMgY29tcGxldGUgdGhhdCBpbXBsaWVzIHRoYXQgdGhlIGNoYW5uZWwgaXNcbiAgICAgICAgICogY29ubmVjdGVkICovXG4gICAgICAgIGNvbnN0IGZpbmFsTWV0YWRhdGEgPSBhd2FpdCBtZXRhZGF0YTtcbiAgICAgICAgY29uc3QgdGltZW91dFN0cmluZyA9IGdldERlYWRsaW5lKHRoaXMuZGVhZGxpbmUpO1xuICAgICAgICBmaW5hbE1ldGFkYXRhLnNldCgnZ3JwYy10aW1lb3V0JywgdGltZW91dFN0cmluZyk7XG4gICAgICAgIHJldHVybiBmaW5hbE1ldGFkYXRhO1xuICAgIH1cbiAgICByZWNlaXZlVHJhaWxlcnMoc3RhdHVzKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLkRlYWRsaW5lRmlsdGVyID0gRGVhZGxpbmVGaWx0ZXI7XG5jbGFzcyBEZWFkbGluZUZpbHRlckZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5jaGFubmVsID0gY2hhbm5lbDtcbiAgICB9XG4gICAgY3JlYXRlRmlsdGVyKGNhbGxTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWFkbGluZUZpbHRlcih0aGlzLmNoYW5uZWwsIGNhbGxTdHJlYW0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVhZGxpbmVGaWx0ZXJGYWN0b3J5ID0gRGVhZGxpbmVGaWx0ZXJGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVhZGxpbmUtZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkRlYWRsaW5lRmlsdGVyRmFjdG9yeSIsIkRlYWRsaW5lRmlsdGVyIiwiY29uc3RhbnRzXzEiLCJyZXF1aXJlIiwiZmlsdGVyXzEiLCJ1bml0cyIsImdldERlYWRsaW5lIiwiZGVhZGxpbmUiLCJub3ciLCJEYXRlIiwiZ2V0VGltZSIsInRpbWVvdXRNcyIsIk1hdGgiLCJtYXgiLCJ1bml0IiwiZmFjdG9yIiwiYW1vdW50IiwiU3RyaW5nIiwiY2VpbCIsIkVycm9yIiwiQmFzZUZpbHRlciIsImNvbnN0cnVjdG9yIiwiY2hhbm5lbCIsImNhbGxTdHJlYW0iLCJ0aW1lciIsIkluZmluaXR5IiwicmV0cmVpdmVEZWFkbGluZSIsInJ1blRpbWVyIiwiY2FsbERlYWRsaW5lIiwiX2EiLCJfYiIsImNsZWFyVGltZW91dCIsInRpbWVvdXQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjYW5jZWxXaXRoU3RhdHVzIiwiU3RhdHVzIiwiREVBRExJTkVfRVhDRUVERUQiLCJzZXRUaW1lb3V0IiwidW5yZWYiLCJjYWxsIiwicmVmcmVzaCIsInNlbmRNZXRhZGF0YSIsIm1ldGFkYXRhIiwiZmluYWxNZXRhZGF0YSIsInRpbWVvdXRTdHJpbmciLCJzZXQiLCJyZWNlaXZlVHJhaWxlcnMiLCJzdGF0dXMiLCJjcmVhdGVGaWx0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/deadline-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/duration.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isDuration = exports.durationToMs = exports.msToDuration = void 0;\nfunction msToDuration(millis) {\n    return {\n        seconds: millis / 1000 | 0,\n        nanos: millis % 1000 * 1000000 | 0\n    };\n}\nexports.msToDuration = msToDuration;\nfunction durationToMs(duration) {\n    return duration.seconds * 1000 + duration.nanos / 1000000 | 0;\n}\nexports.durationToMs = durationToMs;\nfunction isDuration(value) {\n    return typeof value.seconds === \"number\" && typeof value.nanos === \"number\";\n}\nexports.isDuration = isDuration; //# sourceMappingURL=duration.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZHVyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGtCQUFrQixHQUFHQSxvQkFBb0IsR0FBR0Esb0JBQW9CLEdBQUcsS0FBSztBQUN4RSxTQUFTSSxhQUFhQyxNQUFNO0lBQ3hCLE9BQU87UUFDSEMsU0FBUyxTQUFVLE9BQVE7UUFDM0JDLE9BQU8sU0FBVSxPQUFRLFVBQVU7SUFDdkM7QUFDSjtBQUNBUCxvQkFBb0IsR0FBR0k7QUFDdkIsU0FBU0QsYUFBYUssUUFBUTtJQUMxQixPQUFPLFNBQVVGLE9BQU8sR0FBRyxPQUFPRSxTQUFTRCxLQUFLLEdBQUcsVUFBVztBQUNsRTtBQUNBUCxvQkFBb0IsR0FBR0c7QUFDdkIsU0FBU0QsV0FBV0QsS0FBSztJQUNyQixPQUFPLE9BQVFBLE1BQU1LLE9BQU8sS0FBSyxZQUFjLE9BQU9MLE1BQU1NLEtBQUssS0FBSztBQUMxRTtBQUNBUCxrQkFBa0IsR0FBR0UsWUFDckIsb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2R1cmF0aW9uLmpzP2QxMTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNEdXJhdGlvbiA9IGV4cG9ydHMuZHVyYXRpb25Ub01zID0gZXhwb3J0cy5tc1RvRHVyYXRpb24gPSB2b2lkIDA7XG5mdW5jdGlvbiBtc1RvRHVyYXRpb24obWlsbGlzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2Vjb25kczogKG1pbGxpcyAvIDEwMDApIHwgMCxcbiAgICAgICAgbmFub3M6IChtaWxsaXMgJSAxMDAwKSAqIDEwMDAwMDAgfCAwXG4gICAgfTtcbn1cbmV4cG9ydHMubXNUb0R1cmF0aW9uID0gbXNUb0R1cmF0aW9uO1xuZnVuY3Rpb24gZHVyYXRpb25Ub01zKGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIChkdXJhdGlvbi5zZWNvbmRzICogMTAwMCArIGR1cmF0aW9uLm5hbm9zIC8gMTAwMDAwMCkgfCAwO1xufVxuZXhwb3J0cy5kdXJhdGlvblRvTXMgPSBkdXJhdGlvblRvTXM7XG5mdW5jdGlvbiBpc0R1cmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUuc2Vjb25kcyA9PT0gJ251bWJlcicpICYmICh0eXBlb2YgdmFsdWUubmFub3MgPT09ICdudW1iZXInKTtcbn1cbmV4cG9ydHMuaXNEdXJhdGlvbiA9IGlzRHVyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kdXJhdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpc0R1cmF0aW9uIiwiZHVyYXRpb25Ub01zIiwibXNUb0R1cmF0aW9uIiwibWlsbGlzIiwic2Vjb25kcyIsIm5hbm9zIiwiZHVyYXRpb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/experimental.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nObject.defineProperty(exports, \"trace\", ({\n    enumerable: true,\n    get: function() {\n        return logging_1.trace;\n    }\n}));\nObject.defineProperty(exports, \"log\", ({\n    enumerable: true,\n    get: function() {\n        return logging_1.log;\n    }\n}));\nvar resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nObject.defineProperty(exports, \"registerResolver\", ({\n    enumerable: true,\n    get: function() {\n        return resolver_1.registerResolver;\n    }\n}));\nvar uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nObject.defineProperty(exports, \"uriToString\", ({\n    enumerable: true,\n    get: function() {\n        return uri_parser_1.uriToString;\n    }\n}));\nvar duration_1 = __webpack_require__(/*! ./duration */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nObject.defineProperty(exports, \"durationToMs\", ({\n    enumerable: true,\n    get: function() {\n        return duration_1.durationToMs;\n    }\n}));\nvar backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nObject.defineProperty(exports, \"BackoffTimeout\", ({\n    enumerable: true,\n    get: function() {\n        return backoff_timeout_1.BackoffTimeout;\n    }\n}));\nvar load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nObject.defineProperty(exports, \"createChildChannelControlHelper\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.createChildChannelControlHelper;\n    }\n}));\nObject.defineProperty(exports, \"registerLoadBalancerType\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.registerLoadBalancerType;\n    }\n}));\nObject.defineProperty(exports, \"getFirstUsableConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.getFirstUsableConfig;\n    }\n}));\nObject.defineProperty(exports, \"validateLoadBalancingConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_1.validateLoadBalancingConfig;\n    }\n}));\nvar subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nObject.defineProperty(exports, \"subchannelAddressToString\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_address_1.subchannelAddressToString;\n    }\n}));\nvar load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nObject.defineProperty(exports, \"ChildLoadBalancerHandler\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_child_handler_1.ChildLoadBalancerHandler;\n    }\n}));\nvar picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nObject.defineProperty(exports, \"UnavailablePicker\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.UnavailablePicker;\n    }\n}));\nObject.defineProperty(exports, \"QueuePicker\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.QueuePicker;\n    }\n}));\nObject.defineProperty(exports, \"PickResultType\", ({\n    enumerable: true,\n    get: function() {\n        return picker_1.PickResultType;\n    }\n}));\nvar filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nObject.defineProperty(exports, \"BaseFilter\", ({\n    enumerable: true,\n    get: function() {\n        return filter_1.BaseFilter;\n    }\n}));\nvar filter_stack_1 = __webpack_require__(/*! ./filter-stack */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\");\nObject.defineProperty(exports, \"FilterStackFactory\", ({\n    enumerable: true,\n    get: function() {\n        return filter_stack_1.FilterStackFactory;\n    }\n}));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"registerAdminService\", ({\n    enumerable: true,\n    get: function() {\n        return admin_1.registerAdminService;\n    }\n}));\nvar subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nObject.defineProperty(exports, \"BaseSubchannelWrapper\", ({\n    enumerable: true,\n    get: function() {\n        return subchannel_interface_1.BaseSubchannelWrapper;\n    }\n}));\nvar load_balancer_outlier_detection_1 = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nObject.defineProperty(exports, \"OutlierDetectionLoadBalancingConfig\", ({\n    enumerable: true,\n    get: function() {\n        return load_balancer_outlier_detection_1.OutlierDetectionLoadBalancingConfig;\n    }\n})); //# sourceMappingURL=experimental.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZXhwZXJpbWVudGFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELElBQUlDLFlBQVlDLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DTCx5Q0FBd0M7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsVUFBVUksS0FBSztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQzNHUix1Q0FBc0M7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0gsVUFBVUssR0FBRztJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3ZHLElBQUlDLGFBQWFMLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3JDTCxvREFBbUQ7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0csV0FBV0MsZ0JBQWdCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDbEksSUFBSUMsZUFBZVAsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDekNMLCtDQUE4QztJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSyxhQUFhQyxXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDMUgsSUFBSUMsYUFBYVQsbUJBQU9BLENBQUMsNEVBQVk7QUFDckNMLGdEQUErQztJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPTyxXQUFXQyxZQUFZO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDMUgsSUFBSUMsb0JBQW9CWCxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDbkRMLGtEQUFpRDtJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPUyxrQkFBa0JDLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUNySSxJQUFJQyxrQkFBa0JiLG1CQUFPQSxDQUFDLHNGQUFpQjtBQUMvQ0wsbUVBQWtFO0lBQUVNLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9XLGdCQUFnQkMsK0JBQStCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDcktuQiw0REFBMkQ7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT1csZ0JBQWdCRSx3QkFBd0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUN2SnBCLHdEQUF1RDtJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPVyxnQkFBZ0JHLG9CQUFvQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQy9JckIsK0RBQThEO0lBQUVNLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9XLGdCQUFnQkksMkJBQTJCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDN0osSUFBSUMsdUJBQXVCbEIsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQ3pETCw2REFBNEQ7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2dCLHFCQUFxQkMseUJBQXlCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDOUosSUFBSUMsZ0NBQWdDcEIsbUJBQU9BLENBQUMsa0hBQStCO0FBQzNFTCw0REFBMkQ7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2tCLDhCQUE4QkMsd0JBQXdCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDckssSUFBSUMsV0FBV3RCLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ2pDTCxxREFBb0Q7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFNBQVNDLGlCQUFpQjtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ2xJNUIsK0NBQThDO0lBQUVNLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU9vQixTQUFTRSxXQUFXO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdEg3QixrREFBaUQ7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT29CLFNBQVNHLGNBQWM7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM1SCxJQUFJQyxXQUFXMUIsbUJBQU9BLENBQUMsd0VBQVU7QUFDakNMLDhDQUE2QztJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPd0IsU0FBU0MsVUFBVTtJQUFFO0FBQUUsQ0FBQyxFQUFDO0FBQ3BILElBQUlDLGlCQUFpQjVCLG1CQUFPQSxDQUFDLG9GQUFnQjtBQUM3Q0wsc0RBQXFEO0lBQUVNLFlBQVk7SUFBTUMsS0FBSztRQUFjLE9BQU8wQixlQUFlQyxrQkFBa0I7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMxSSxJQUFJQyxVQUFVOUIsbUJBQU9BLENBQUMsc0VBQVM7QUFDL0JMLHdEQUF1RDtJQUFFTSxZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPNEIsUUFBUUMsb0JBQW9CO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDdkksSUFBSUMseUJBQXlCaEMsbUJBQU9BLENBQUMsb0dBQXdCO0FBQzdETCx5REFBd0Q7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBTzhCLHVCQUF1QkMscUJBQXFCO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDeEosSUFBSUMsb0NBQW9DbEMsbUJBQU9BLENBQUMsMEhBQW1DO0FBQ25GTCx1RUFBc0U7SUFBRU0sWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT2dDLGtDQUFrQ0MsbUNBQW1DO0lBQUU7QUFBRSxDQUFDLEVBQUMsRUFDL0wsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2V4cGVyaW1lbnRhbC5qcz80YWQzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGxvZ2dpbmdfMSA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ0cmFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9nZ2luZ18xLnRyYWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2dnaW5nXzEubG9nOyB9IH0pO1xudmFyIHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyUmVzb2x2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcjsgfSB9KTtcbnZhciB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidXJpVG9TdHJpbmdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZzsgfSB9KTtcbnZhciBkdXJhdGlvbl8xID0gcmVxdWlyZShcIi4vZHVyYXRpb25cIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkdXJhdGlvblRvTXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zOyB9IH0pO1xudmFyIGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFja29mZlRpbWVvdXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0OyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9hZF9iYWxhbmNlcl8xLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEZpcnN0VXNhYmxlQ29uZmlnXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyXzEuZ2V0Rmlyc3RVc2FibGVDb25maWc7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfMS52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWc7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nOyB9IH0pO1xudmFyIGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMS5DaGlsZExvYWRCYWxhbmNlckhhbmRsZXI7IH0gfSk7XG52YXIgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmF2YWlsYWJsZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJRdWV1ZVBpY2tlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUXVldWVQaWNrZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaWNrUmVzdWx0VHlwZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGU7IH0gfSk7XG52YXIgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlRmlsdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfMS5CYXNlRmlsdGVyOyB9IH0pO1xudmFyIGZpbHRlcl9zdGFja18xID0gcmVxdWlyZShcIi4vZmlsdGVyLXN0YWNrXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRmlsdGVyU3RhY2tGYWN0b3J5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJfc3RhY2tfMS5GaWx0ZXJTdGFja0ZhY3Rvcnk7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVnaXN0ZXJBZG1pblNlcnZpY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFkbWluXzEucmVnaXN0ZXJBZG1pblNlcnZpY2U7IH0gfSk7XG52YXIgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQmFzZVN1YmNoYW5uZWxXcmFwcGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdWJjaGFubmVsX2ludGVyZmFjZV8xLkJhc2VTdWJjaGFubmVsV3JhcHBlcjsgfSB9KTtcbnZhciBsb2FkX2JhbGFuY2VyX291dGxpZXJfZGV0ZWN0aW9uXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWdcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb25fMS5PdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZzsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGVyaW1lbnRhbC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJsb2dnaW5nXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsInRyYWNlIiwibG9nIiwicmVzb2x2ZXJfMSIsInJlZ2lzdGVyUmVzb2x2ZXIiLCJ1cmlfcGFyc2VyXzEiLCJ1cmlUb1N0cmluZyIsImR1cmF0aW9uXzEiLCJkdXJhdGlvblRvTXMiLCJiYWNrb2ZmX3RpbWVvdXRfMSIsIkJhY2tvZmZUaW1lb3V0IiwibG9hZF9iYWxhbmNlcl8xIiwiY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciIsInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSIsImdldEZpcnN0VXNhYmxlQ29uZmlnIiwidmFsaWRhdGVMb2FkQmFsYW5jaW5nQ29uZmlnIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nIiwibG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEiLCJDaGlsZExvYWRCYWxhbmNlckhhbmRsZXIiLCJwaWNrZXJfMSIsIlVuYXZhaWxhYmxlUGlja2VyIiwiUXVldWVQaWNrZXIiLCJQaWNrUmVzdWx0VHlwZSIsImZpbHRlcl8xIiwiQmFzZUZpbHRlciIsImZpbHRlcl9zdGFja18xIiwiRmlsdGVyU3RhY2tGYWN0b3J5IiwiYWRtaW5fMSIsInJlZ2lzdGVyQWRtaW5TZXJ2aWNlIiwic3ViY2hhbm5lbF9pbnRlcmZhY2VfMSIsIkJhc2VTdWJjaGFubmVsV3JhcHBlciIsImxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb25fMSIsIk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter-stack.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.FilterStackFactory = exports.FilterStack = void 0;\nclass FilterStack {\n    constructor(filters){\n        this.filters = filters;\n    }\n    sendMetadata(metadata) {\n        let result = metadata;\n        for(let i = 0; i < this.filters.length; i++){\n            result = this.filters[i].sendMetadata(result);\n        }\n        return result;\n    }\n    receiveMetadata(metadata) {\n        let result = metadata;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveMetadata(result);\n        }\n        return result;\n    }\n    sendMessage(message) {\n        let result = message;\n        for(let i = 0; i < this.filters.length; i++){\n            result = this.filters[i].sendMessage(result);\n        }\n        return result;\n    }\n    receiveMessage(message) {\n        let result = message;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveMessage(result);\n        }\n        return result;\n    }\n    receiveTrailers(status) {\n        let result = status;\n        for(let i = this.filters.length - 1; i >= 0; i--){\n            result = this.filters[i].receiveTrailers(result);\n        }\n        return result;\n    }\n    refresh() {\n        for (const filter of this.filters){\n            filter.refresh();\n        }\n    }\n    push(filters) {\n        this.filters.unshift(...filters);\n    }\n    getFilters() {\n        return this.filters;\n    }\n}\nexports.FilterStack = FilterStack;\nclass FilterStackFactory {\n    constructor(factories){\n        this.factories = factories;\n    }\n    push(filterFactories) {\n        this.factories.unshift(...filterFactories);\n    }\n    createFilter(callStream) {\n        return new FilterStack(this.factories.map((factory)=>factory.createFilter(callStream)));\n    }\n}\nexports.FilterStackFactory = FilterStackFactory; //# sourceMappingURL=filter-stack.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLXN0YWNrLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCwwQkFBMEIsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUN4RCxNQUFNRztJQUNGQyxZQUFZQyxPQUFPLENBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ25CO0lBQ0FDLGFBQWFDLFFBQVEsRUFBRTtRQUNuQixJQUFJQyxTQUFTRDtRQUNiLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ0osT0FBTyxDQUFDSyxNQUFNLEVBQUVELElBQUs7WUFDMUNELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0gsWUFBWSxDQUFDRTtRQUMxQztRQUNBLE9BQU9BO0lBQ1g7SUFDQUcsZ0JBQWdCSixRQUFRLEVBQUU7UUFDdEIsSUFBSUMsU0FBU0Q7UUFDYixJQUFLLElBQUlFLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0UsZUFBZSxDQUFDSDtRQUM3QztRQUNBLE9BQU9BO0lBQ1g7SUFDQUksWUFBWUMsT0FBTyxFQUFFO1FBQ2pCLElBQUlMLFNBQVNLO1FBQ2IsSUFBSyxJQUFJSixJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sRUFBRUQsSUFBSztZQUMxQ0QsU0FBUyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ksRUFBRSxDQUFDRyxXQUFXLENBQUNKO1FBQ3pDO1FBQ0EsT0FBT0E7SUFDWDtJQUNBTSxlQUFlRCxPQUFPLEVBQUU7UUFDcEIsSUFBSUwsU0FBU0s7UUFDYixJQUFLLElBQUlKLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ0ssY0FBYyxDQUFDTjtRQUM1QztRQUNBLE9BQU9BO0lBQ1g7SUFDQU8sZ0JBQWdCQyxNQUFNLEVBQUU7UUFDcEIsSUFBSVIsU0FBU1E7UUFDYixJQUFLLElBQUlQLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLE1BQU0sR0FBRyxHQUFHRCxLQUFLLEdBQUdBLElBQUs7WUFDL0NELFNBQVMsSUFBSSxDQUFDSCxPQUFPLENBQUNJLEVBQUUsQ0FBQ00sZUFBZSxDQUFDUDtRQUM3QztRQUNBLE9BQU9BO0lBQ1g7SUFDQVMsVUFBVTtRQUNOLEtBQUssTUFBTUMsVUFBVSxJQUFJLENBQUNiLE9BQU8sQ0FBRTtZQUMvQmEsT0FBT0QsT0FBTztRQUNsQjtJQUNKO0lBQ0FFLEtBQUtkLE9BQU8sRUFBRTtRQUNWLElBQUksQ0FBQ0EsT0FBTyxDQUFDZSxPQUFPLElBQUlmO0lBQzVCO0lBQ0FnQixhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNoQixPQUFPO0lBQ3ZCO0FBQ0o7QUFDQUwsbUJBQW1CLEdBQUdHO0FBQ3RCLE1BQU1EO0lBQ0ZFLFlBQVlrQixTQUFTLENBQUU7UUFDbkIsSUFBSSxDQUFDQSxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0FILEtBQUtJLGVBQWUsRUFBRTtRQUNsQixJQUFJLENBQUNELFNBQVMsQ0FBQ0YsT0FBTyxJQUFJRztJQUM5QjtJQUNBQyxhQUFhQyxVQUFVLEVBQUU7UUFDckIsT0FBTyxJQUFJdEIsWUFBWSxJQUFJLENBQUNtQixTQUFTLENBQUNJLEdBQUcsQ0FBQyxDQUFDQyxVQUFZQSxRQUFRSCxZQUFZLENBQUNDO0lBQ2hGO0FBQ0o7QUFDQXpCLDBCQUEwQixHQUFHRSxvQkFDN0Isd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2ZpbHRlci1zdGFjay5qcz83NTMwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IGV4cG9ydHMuRmlsdGVyU3RhY2sgPSB2b2lkIDA7XG5jbGFzcyBGaWx0ZXJTdGFjayB7XG4gICAgY29uc3RydWN0b3IoZmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnMgPSBmaWx0ZXJzO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnNlbmRNZXRhZGF0YShyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWV0YWRhdGE7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZmlsdGVyc1tpXS5yZWNlaXZlTWV0YWRhdGEocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBtZXNzYWdlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnNlbmRNZXNzYWdlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gbWVzc2FnZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZmlsdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5maWx0ZXJzW2ldLnJlY2VpdmVNZXNzYWdlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RhdHVzO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmZpbHRlcnNbaV0ucmVjZWl2ZVRyYWlsZXJzKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2YgdGhpcy5maWx0ZXJzKSB7XG4gICAgICAgICAgICBmaWx0ZXIucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHB1c2goZmlsdGVycykge1xuICAgICAgICB0aGlzLmZpbHRlcnMudW5zaGlmdCguLi5maWx0ZXJzKTtcbiAgICB9XG4gICAgZ2V0RmlsdGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycztcbiAgICB9XG59XG5leHBvcnRzLkZpbHRlclN0YWNrID0gRmlsdGVyU3RhY2s7XG5jbGFzcyBGaWx0ZXJTdGFja0ZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGZhY3Rvcmllcykge1xuICAgICAgICB0aGlzLmZhY3RvcmllcyA9IGZhY3RvcmllcztcbiAgICB9XG4gICAgcHVzaChmaWx0ZXJGYWN0b3JpZXMpIHtcbiAgICAgICAgdGhpcy5mYWN0b3JpZXMudW5zaGlmdCguLi5maWx0ZXJGYWN0b3JpZXMpO1xuICAgIH1cbiAgICBjcmVhdGVGaWx0ZXIoY2FsbFN0cmVhbSkge1xuICAgICAgICByZXR1cm4gbmV3IEZpbHRlclN0YWNrKHRoaXMuZmFjdG9yaWVzLm1hcCgoZmFjdG9yeSkgPT4gZmFjdG9yeS5jcmVhdGVGaWx0ZXIoY2FsbFN0cmVhbSkpKTtcbiAgICB9XG59XG5leHBvcnRzLkZpbHRlclN0YWNrRmFjdG9yeSA9IEZpbHRlclN0YWNrRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpbHRlci1zdGFjay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGaWx0ZXJTdGFja0ZhY3RvcnkiLCJGaWx0ZXJTdGFjayIsImNvbnN0cnVjdG9yIiwiZmlsdGVycyIsInNlbmRNZXRhZGF0YSIsIm1ldGFkYXRhIiwicmVzdWx0IiwiaSIsImxlbmd0aCIsInJlY2VpdmVNZXRhZGF0YSIsInNlbmRNZXNzYWdlIiwibWVzc2FnZSIsInJlY2VpdmVNZXNzYWdlIiwicmVjZWl2ZVRyYWlsZXJzIiwic3RhdHVzIiwicmVmcmVzaCIsImZpbHRlciIsInB1c2giLCJ1bnNoaWZ0IiwiZ2V0RmlsdGVycyIsImZhY3RvcmllcyIsImZpbHRlckZhY3RvcmllcyIsImNyZWF0ZUZpbHRlciIsImNhbGxTdHJlYW0iLCJtYXAiLCJmYWN0b3J5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/filter-stack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/filter.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseFilter = void 0;\nclass BaseFilter {\n    async sendMetadata(metadata) {\n        return metadata;\n    }\n    receiveMetadata(metadata) {\n        return metadata;\n    }\n    async sendMessage(message) {\n        return message;\n    }\n    async receiveMessage(message) {\n        return message;\n    }\n    receiveTrailers(status) {\n        return status;\n    }\n    refresh() {}\n}\nexports.BaseFilter = BaseFilter; //# sourceMappingURL=filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvZmlsdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxrQkFBa0IsR0FBRyxLQUFLO0FBQzFCLE1BQU1FO0lBQ0YsTUFBTUMsYUFBYUMsUUFBUSxFQUFFO1FBQ3pCLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCRCxRQUFRLEVBQUU7UUFDdEIsT0FBT0E7SUFDWDtJQUNBLE1BQU1FLFlBQVlDLE9BQU8sRUFBRTtRQUN2QixPQUFPQTtJQUNYO0lBQ0EsTUFBTUMsZUFBZUQsT0FBTyxFQUFFO1FBQzFCLE9BQU9BO0lBQ1g7SUFDQUUsZ0JBQWdCQyxNQUFNLEVBQUU7UUFDcEIsT0FBT0E7SUFDWDtJQUNBQyxVQUFVLENBQUU7QUFDaEI7QUFDQVgsa0JBQWtCLEdBQUdFLFlBQ3JCLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9maWx0ZXIuanM/MGYzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlRmlsdGVyID0gdm9pZCAwO1xuY2xhc3MgQmFzZUZpbHRlciB7XG4gICAgYXN5bmMgc2VuZE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmVjZWl2ZU1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gICAgcmVjZWl2ZVRyYWlsZXJzKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH1cbiAgICByZWZyZXNoKCkgeyB9XG59XG5leHBvcnRzLkJhc2VGaWx0ZXIgPSBCYXNlRmlsdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIkJhc2VGaWx0ZXIiLCJzZW5kTWV0YWRhdGEiLCJtZXRhZGF0YSIsInJlY2VpdmVNZXRhZGF0YSIsInNlbmRNZXNzYWdlIiwibWVzc2FnZSIsInJlY2VpdmVNZXNzYWdlIiwicmVjZWl2ZVRyYWlsZXJzIiwic3RhdHVzIiwicmVmcmVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/http_proxy.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst TRACER_NAME = \"proxy\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n    let proxyEnv = \"\";\n    let envVar = \"\";\n    /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n     * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n     * fallback behavior can be removed if there's a demand for it.\n     */ if (process.env.grpc_proxy) {\n        envVar = \"grpc_proxy\";\n        proxyEnv = process.env.grpc_proxy;\n    } else if (process.env.https_proxy) {\n        envVar = \"https_proxy\";\n        proxyEnv = process.env.https_proxy;\n    } else if (process.env.http_proxy) {\n        envVar = \"http_proxy\";\n        proxyEnv = process.env.http_proxy;\n    } else {\n        return {};\n    }\n    let proxyUrl;\n    try {\n        proxyUrl = new url_1.URL(proxyEnv);\n    } catch (e) {\n        logging_1.log(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n        return {};\n    }\n    if (proxyUrl.protocol !== \"http:\") {\n        logging_1.log(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n        return {};\n    }\n    let userCred = null;\n    if (proxyUrl.username) {\n        if (proxyUrl.password) {\n            logging_1.log(constants_1.LogVerbosity.INFO, \"userinfo found in proxy URI\");\n            userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n        } else {\n            userCred = proxyUrl.username;\n        }\n    }\n    const hostname = proxyUrl.hostname;\n    let port = proxyUrl.port;\n    /* The proxy URL uses the scheme \"http:\", which has a default port number of\n     * 80. We need to set that explicitly here if it is omitted because otherwise\n     * it will use gRPC's default port 443. */ if (port === \"\") {\n        port = \"80\";\n    }\n    const result = {\n        address: `${hostname}:${port}`\n    };\n    if (userCred) {\n        result.creds = userCred;\n    }\n    trace(\"Proxy server \" + result.address + \" set by environment variable \" + envVar);\n    return result;\n}\nfunction getNoProxyHostList() {\n    /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */ let noProxyStr = process.env.no_grpc_proxy;\n    let envVar = \"no_grpc_proxy\";\n    if (!noProxyStr) {\n        noProxyStr = process.env.no_proxy;\n        envVar = \"no_proxy\";\n    }\n    if (noProxyStr) {\n        trace(\"No proxy server list set by environment variable \" + envVar);\n        return noProxyStr.split(\",\");\n    } else {\n        return [];\n    }\n}\nfunction mapProxyName(target, options) {\n    var _a;\n    const noProxyResult = {\n        target: target,\n        extraOptions: {}\n    };\n    if (((_a = options[\"grpc.enable_http_proxy\"]) !== null && _a !== void 0 ? _a : 1) === 0) {\n        return noProxyResult;\n    }\n    if (target.scheme === \"unix\") {\n        return noProxyResult;\n    }\n    const proxyInfo = getProxyInfo();\n    if (!proxyInfo.address) {\n        return noProxyResult;\n    }\n    const hostPort = uri_parser_1.splitHostPort(target.path);\n    if (!hostPort) {\n        return noProxyResult;\n    }\n    const serverHost = hostPort.host;\n    for (const host of getNoProxyHostList()){\n        if (host === serverHost) {\n            trace(\"Not using proxy for target in no_proxy list: \" + uri_parser_1.uriToString(target));\n            return noProxyResult;\n        }\n    }\n    const extraOptions = {\n        \"grpc.http_connect_target\": uri_parser_1.uriToString(target)\n    };\n    if (proxyInfo.creds) {\n        extraOptions[\"grpc.http_connect_creds\"] = proxyInfo.creds;\n    }\n    return {\n        target: {\n            scheme: \"dns\",\n            path: proxyInfo.address\n        },\n        extraOptions: extraOptions\n    };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n    if (!(\"grpc.http_connect_target\" in channelOptions)) {\n        return Promise.resolve({});\n    }\n    const realTarget = channelOptions[\"grpc.http_connect_target\"];\n    const parsedTarget = uri_parser_1.parseUri(realTarget);\n    if (parsedTarget === null) {\n        return Promise.resolve({});\n    }\n    const options = {\n        method: \"CONNECT\",\n        path: parsedTarget.path\n    };\n    const headers = {\n        Host: parsedTarget.path\n    };\n    // Connect to the subchannel address as a proxy\n    if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n        options.host = address.host;\n        options.port = address.port;\n    } else {\n        options.socketPath = address.path;\n    }\n    if (\"grpc.http_connect_creds\" in channelOptions) {\n        headers[\"Proxy-Authorization\"] = \"Basic \" + Buffer.from(channelOptions[\"grpc.http_connect_creds\"]).toString(\"base64\");\n    }\n    options.headers = headers;\n    const proxyAddressString = subchannel_address_1.subchannelAddressToString(address);\n    trace(\"Using proxy \" + proxyAddressString + \" to connect to \" + options.path);\n    return new Promise((resolve, reject)=>{\n        const request = http.request(options);\n        request.once(\"connect\", (res, socket, head)=>{\n            var _a;\n            request.removeAllListeners();\n            socket.removeAllListeners();\n            if (res.statusCode === 200) {\n                trace(\"Successfully connected to \" + options.path + \" through proxy \" + proxyAddressString);\n                if (\"secureContext\" in connectionOptions) {\n                    /* The proxy is connecting to a TLS server, so upgrade this socket\n                     * connection to a TLS connection.\n                     * This is a workaround for https://github.com/nodejs/node/issues/32922\n                     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */ const targetPath = resolver_1.getDefaultAuthority(parsedTarget);\n                    const hostPort = uri_parser_1.splitHostPort(targetPath);\n                    const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n                    const cts = tls.connect(Object.assign({\n                        host: remoteHost,\n                        servername: remoteHost,\n                        socket: socket\n                    }, connectionOptions), ()=>{\n                        trace(\"Successfully established a TLS connection to \" + options.path + \" through proxy \" + proxyAddressString);\n                        resolve({\n                            socket: cts,\n                            realTarget: parsedTarget\n                        });\n                    });\n                    cts.on(\"error\", (error)=>{\n                        trace(\"Failed to establish a TLS connection to \" + options.path + \" through proxy \" + proxyAddressString + \" with error \" + error.message);\n                        reject();\n                    });\n                } else {\n                    trace(\"Successfully established a plaintext connection to \" + options.path + \" through proxy \" + proxyAddressString);\n                    resolve({\n                        socket,\n                        realTarget: parsedTarget\n                    });\n                }\n            } else {\n                logging_1.log(constants_1.LogVerbosity.ERROR, \"Failed to connect to \" + options.path + \" through proxy \" + proxyAddressString + \" with status \" + res.statusCode);\n                reject();\n            }\n        });\n        request.once(\"error\", (err)=>{\n            request.removeAllListeners();\n            logging_1.log(constants_1.LogVerbosity.ERROR, \"Failed to connect to proxy \" + proxyAddressString + \" with error \" + err.message);\n            reject();\n        });\n        request.end();\n    });\n}\nexports.getProxiedConnection = getProxiedConnection; //# sourceMappingURL=http_proxy.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaHR0cF9wcm94eS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsNEJBQTRCLEdBQUdBLG9CQUFvQixHQUFHLEtBQUs7QUFDM0QsTUFBTUksWUFBWUMsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUcsT0FBT0gsbUJBQU9BLENBQUMsa0JBQU07QUFDM0IsTUFBTUksTUFBTUosbUJBQU9BLENBQUMsZ0JBQUs7QUFDekIsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTU0sdUJBQXVCTixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVEsUUFBUVIsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTVMsY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZOLFFBQVFLLEtBQUssQ0FBQ1QsWUFBWVcsWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0EsU0FBU0c7SUFDTCxJQUFJQyxXQUFXO0lBQ2YsSUFBSUMsU0FBUztJQUNiOzs7S0FHQyxHQUNELElBQUlDLFFBQVFDLEdBQUcsQ0FBQ0MsVUFBVSxFQUFFO1FBQ3hCSCxTQUFTO1FBQ1RELFdBQVdFLFFBQVFDLEdBQUcsQ0FBQ0MsVUFBVTtJQUNyQyxPQUNLLElBQUlGLFFBQVFDLEdBQUcsQ0FBQ0UsV0FBVyxFQUFFO1FBQzlCSixTQUFTO1FBQ1RELFdBQVdFLFFBQVFDLEdBQUcsQ0FBQ0UsV0FBVztJQUN0QyxPQUNLLElBQUlILFFBQVFDLEdBQUcsQ0FBQ0csVUFBVSxFQUFF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RCxNQUFNLHdEQUNGaUMsUUFBUVEsSUFBSSxHQUNaLG9CQUNBbUI7b0JBQ0paLFFBQVE7d0JBQ0prQjt3QkFDQWpCLFlBQVlDO29CQUNoQjtnQkFDSjtZQUNKLE9BQ0s7Z0JBQ0Q3RCxVQUFVMEIsR0FBRyxDQUFDeEIsWUFBWVcsWUFBWSxDQUFDYyxLQUFLLEVBQUUsMEJBQzFDaUIsUUFBUVEsSUFBSSxHQUNaLG9CQUNBbUIscUJBQ0Esa0JBQ0FLLElBQUlJLFVBQVU7Z0JBQ2xCUDtZQUNKO1FBQ0o7UUFDQUMsUUFBUUMsSUFBSSxDQUFDLFNBQVMsQ0FBQ2dCO1lBQ25CakIsUUFBUUssa0JBQWtCO1lBQzFCL0UsVUFBVTBCLEdBQUcsQ0FBQ3hCLFlBQVlXLFlBQVksQ0FBQ2MsS0FBSyxFQUFFLGdDQUMxQzRDLHFCQUNBLGlCQUNBb0IsSUFBSUQsT0FBTztZQUNmakI7UUFDSjtRQUNBQyxRQUFRa0IsR0FBRztJQUNmO0FBQ0o7QUFDQWhHLDRCQUE0QixHQUFHRSxzQkFDL0Isc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2h0dHBfcHJveHkuanM/MjhlMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRQcm94aWVkQ29ubmVjdGlvbiA9IGV4cG9ydHMubWFwUHJveHlOYW1lID0gdm9pZCAwO1xuY29uc3QgbG9nZ2luZ18xID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuY29uc3QgdGxzID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncHJveHknO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5mdW5jdGlvbiBnZXRQcm94eUluZm8oKSB7XG4gICAgbGV0IHByb3h5RW52ID0gJyc7XG4gICAgbGV0IGVudlZhciA9ICcnO1xuICAgIC8qIFByZWZlciB1c2luZyAnZ3JwY19wcm94eScuIEZhbGxiYWNrIG9uICdodHRwX3Byb3h5JyBpZiBpdCBpcyBub3Qgc2V0LlxuICAgICAqIEFsc28gcHJlZmVyIHVzaW5nICdodHRwc19wcm94eScgd2l0aCBmYWxsYmFjayBvbiAnaHR0cF9wcm94eScuIFRoZVxuICAgICAqIGZhbGxiYWNrIGJlaGF2aW9yIGNhbiBiZSByZW1vdmVkIGlmIHRoZXJlJ3MgYSBkZW1hbmQgZm9yIGl0LlxuICAgICAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5ncnBjX3Byb3h5KSB7XG4gICAgICAgIGVudlZhciA9ICdncnBjX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5ncnBjX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5odHRwc19wcm94eSkge1xuICAgICAgICBlbnZWYXIgPSAnaHR0cHNfcHJveHknO1xuICAgICAgICBwcm94eUVudiA9IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5odHRwX3Byb3h5KSB7XG4gICAgICAgIGVudlZhciA9ICdodHRwX3Byb3h5JztcbiAgICAgICAgcHJveHlFbnYgPSBwcm9jZXNzLmVudi5odHRwX3Byb3h5O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBsZXQgcHJveHlVcmw7XG4gICAgdHJ5IHtcbiAgICAgICAgcHJveHlVcmwgPSBuZXcgdXJsXzEuVVJMKHByb3h5RW52KTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2luZ18xLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBjYW5ub3QgcGFyc2UgdmFsdWUgb2YgXCIke2VudlZhcn1cIiBlbnYgdmFyYCk7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKHByb3h5VXJsLnByb3RvY29sICE9PSAnaHR0cDonKSB7XG4gICAgICAgIGxvZ2dpbmdfMS5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCBgXCIke3Byb3h5VXJsLnByb3RvY29sfVwiIHNjaGVtZSBub3Qgc3VwcG9ydGVkIGluIHByb3h5IFVSSWApO1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGxldCB1c2VyQ3JlZCA9IG51bGw7XG4gICAgaWYgKHByb3h5VXJsLnVzZXJuYW1lKSB7XG4gICAgICAgIGlmIChwcm94eVVybC5wYXNzd29yZCkge1xuICAgICAgICAgICAgbG9nZ2luZ18xLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTywgJ3VzZXJpbmZvIGZvdW5kIGluIHByb3h5IFVSSScpO1xuICAgICAgICAgICAgdXNlckNyZWQgPSBgJHtwcm94eVVybC51c2VybmFtZX06JHtwcm94eVVybC5wYXNzd29yZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXNlckNyZWQgPSBwcm94eVVybC51c2VybmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBob3N0bmFtZSA9IHByb3h5VXJsLmhvc3RuYW1lO1xuICAgIGxldCBwb3J0ID0gcHJveHlVcmwucG9ydDtcbiAgICAvKiBUaGUgcHJveHkgVVJMIHVzZXMgdGhlIHNjaGVtZSBcImh0dHA6XCIsIHdoaWNoIGhhcyBhIGRlZmF1bHQgcG9ydCBudW1iZXIgb2ZcbiAgICAgKiA4MC4gV2UgbmVlZCB0byBzZXQgdGhhdCBleHBsaWNpdGx5IGhlcmUgaWYgaXQgaXMgb21pdHRlZCBiZWNhdXNlIG90aGVyd2lzZVxuICAgICAqIGl0IHdpbGwgdXNlIGdSUEMncyBkZWZhdWx0IHBvcnQgNDQzLiAqL1xuICAgIGlmIChwb3J0ID09PSAnJykge1xuICAgICAgICBwb3J0ID0gJzgwJztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBhZGRyZXNzOiBgJHtob3N0bmFtZX06JHtwb3J0fWAsXG4gICAgfTtcbiAgICBpZiAodXNlckNyZWQpIHtcbiAgICAgICAgcmVzdWx0LmNyZWRzID0gdXNlckNyZWQ7XG4gICAgfVxuICAgIHRyYWNlKCdQcm94eSBzZXJ2ZXIgJyArIHJlc3VsdC5hZGRyZXNzICsgJyBzZXQgYnkgZW52aXJvbm1lbnQgdmFyaWFibGUgJyArIGVudlZhcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdldE5vUHJveHlIb3N0TGlzdCgpIHtcbiAgICAvKiBQcmVmZXIgdXNpbmcgJ25vX2dycGNfcHJveHknLiBGYWxsYmFjayBvbiAnbm9fcHJveHknIGlmIGl0IGlzIG5vdCBzZXQuICovXG4gICAgbGV0IG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19ncnBjX3Byb3h5O1xuICAgIGxldCBlbnZWYXIgPSAnbm9fZ3JwY19wcm94eSc7XG4gICAgaWYgKCFub1Byb3h5U3RyKSB7XG4gICAgICAgIG5vUHJveHlTdHIgPSBwcm9jZXNzLmVudi5ub19wcm94eTtcbiAgICAgICAgZW52VmFyID0gJ25vX3Byb3h5JztcbiAgICB9XG4gICAgaWYgKG5vUHJveHlTdHIpIHtcbiAgICAgICAgdHJhY2UoJ05vIHByb3h5IHNlcnZlciBsaXN0IHNldCBieSBlbnZpcm9ubWVudCB2YXJpYWJsZSAnICsgZW52VmFyKTtcbiAgICAgICAgcmV0dXJuIG5vUHJveHlTdHIuc3BsaXQoJywnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBQcm94eU5hbWUodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG5vUHJveHlSZXN1bHQgPSB7XG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBleHRyYU9wdGlvbnM6IHt9LFxuICAgIH07XG4gICAgaWYgKCgoX2EgPSBvcHRpb25zWydncnBjLmVuYWJsZV9odHRwX3Byb3h5J10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0LnNjaGVtZSA9PT0gJ3VuaXgnKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBwcm94eUluZm8gPSBnZXRQcm94eUluZm8oKTtcbiAgICBpZiAoIXByb3h5SW5mby5hZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBob3N0UG9ydCA9IHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KHRhcmdldC5wYXRoKTtcbiAgICBpZiAoIWhvc3RQb3J0KSB7XG4gICAgICAgIHJldHVybiBub1Byb3h5UmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBzZXJ2ZXJIb3N0ID0gaG9zdFBvcnQuaG9zdDtcbiAgICBmb3IgKGNvbnN0IGhvc3Qgb2YgZ2V0Tm9Qcm94eUhvc3RMaXN0KCkpIHtcbiAgICAgICAgaWYgKGhvc3QgPT09IHNlcnZlckhvc3QpIHtcbiAgICAgICAgICAgIHRyYWNlKCdOb3QgdXNpbmcgcHJveHkgZm9yIHRhcmdldCBpbiBub19wcm94eSBsaXN0OiAnICsgdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRhcmdldCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5vUHJveHlSZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZXh0cmFPcHRpb25zID0ge1xuICAgICAgICAnZ3JwYy5odHRwX2Nvbm5lY3RfdGFyZ2V0JzogdXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRhcmdldCksXG4gICAgfTtcbiAgICBpZiAocHJveHlJbmZvLmNyZWRzKSB7XG4gICAgICAgIGV4dHJhT3B0aW9uc1snZ3JwYy5odHRwX2Nvbm5lY3RfY3JlZHMnXSA9IHByb3h5SW5mby5jcmVkcztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICBzY2hlbWU6ICdkbnMnLFxuICAgICAgICAgICAgcGF0aDogcHJveHlJbmZvLmFkZHJlc3MsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhT3B0aW9uczogZXh0cmFPcHRpb25zLFxuICAgIH07XG59XG5leHBvcnRzLm1hcFByb3h5TmFtZSA9IG1hcFByb3h5TmFtZTtcbmZ1bmN0aW9uIGdldFByb3hpZWRDb25uZWN0aW9uKGFkZHJlc3MsIGNoYW5uZWxPcHRpb25zLCBjb25uZWN0aW9uT3B0aW9ucykge1xuICAgIGlmICghKCdncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnIGluIGNoYW5uZWxPcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9XG4gICAgY29uc3QgcmVhbFRhcmdldCA9IGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF90YXJnZXQnXTtcbiAgICBjb25zdCBwYXJzZWRUYXJnZXQgPSB1cmlfcGFyc2VyXzEucGFyc2VVcmkocmVhbFRhcmdldCk7XG4gICAgaWYgKHBhcnNlZFRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgbWV0aG9kOiAnQ09OTkVDVCcsXG4gICAgICAgIHBhdGg6IHBhcnNlZFRhcmdldC5wYXRoLFxuICAgIH07XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgSG9zdDogcGFyc2VkVGFyZ2V0LnBhdGgsXG4gICAgfTtcbiAgICAvLyBDb25uZWN0IHRvIHRoZSBzdWJjaGFubmVsIGFkZHJlc3MgYXMgYSBwcm94eVxuICAgIGlmIChzdWJjaGFubmVsX2FkZHJlc3NfMS5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIG9wdGlvbnMuaG9zdCA9IGFkZHJlc3MuaG9zdDtcbiAgICAgICAgb3B0aW9ucy5wb3J0ID0gYWRkcmVzcy5wb3J0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gYWRkcmVzcy5wYXRoO1xuICAgIH1cbiAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X2NyZWRzJyBpbiBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICBoZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPVxuICAgICAgICAgICAgJ0Jhc2ljICcgK1xuICAgICAgICAgICAgICAgIEJ1ZmZlci5mcm9tKGNoYW5uZWxPcHRpb25zWydncnBjLmh0dHBfY29ubmVjdF9jcmVkcyddKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIG9wdGlvbnMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgY29uc3QgcHJveHlBZGRyZXNzU3RyaW5nID0gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKTtcbiAgICB0cmFjZSgnVXNpbmcgcHJveHkgJyArIHByb3h5QWRkcmVzc1N0cmluZyArICcgdG8gY29ubmVjdCB0byAnICsgb3B0aW9ucy5wYXRoKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KG9wdGlvbnMpO1xuICAgICAgICByZXF1ZXN0Lm9uY2UoJ2Nvbm5lY3QnLCAocmVzLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdTdWNjZXNzZnVsbHkgY29ubmVjdGVkIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXG4gICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKCdzZWN1cmVDb250ZXh0JyBpbiBjb25uZWN0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAvKiBUaGUgcHJveHkgaXMgY29ubmVjdGluZyB0byBhIFRMUyBzZXJ2ZXIsIHNvIHVwZ3JhZGUgdGhpcyBzb2NrZXRcbiAgICAgICAgICAgICAgICAgICAgICogY29ubmVjdGlvbiB0byBhIFRMUyBjb25uZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjkyMlxuICAgICAgICAgICAgICAgICAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL3B1bGwvMTM2OSBmb3IgbW9yZSBpbmZvLiAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KHBhcnNlZFRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvc3RQb3J0ID0gdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQodGFyZ2V0UGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbW90ZUhvc3QgPSAoX2EgPSBob3N0UG9ydCA9PT0gbnVsbCB8fCBob3N0UG9ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9zdFBvcnQuaG9zdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGFyZ2V0UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3RzID0gdGxzLmNvbm5lY3QoT2JqZWN0LmFzc2lnbih7IGhvc3Q6IHJlbW90ZUhvc3QsIHNlcnZlcm5hbWU6IHJlbW90ZUhvc3QsIHNvY2tldDogc29ja2V0IH0sIGNvbm5lY3Rpb25PcHRpb25zKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1N1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCBhIFRMUyBjb25uZWN0aW9uIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgc29ja2V0OiBjdHMsIHJlYWxUYXJnZXQ6IHBhcnNlZFRhcmdldCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGN0cy5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlKCdGYWlsZWQgdG8gZXN0YWJsaXNoIGEgVExTIGNvbm5lY3Rpb24gdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wYXRoICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHRocm91Z2ggcHJveHkgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggZXJyb3IgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnU3VjY2Vzc2Z1bGx5IGVzdGFibGlzaGVkIGEgcGxhaW50ZXh0IGNvbm5lY3Rpb24gdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnBhdGggK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyB0aHJvdWdoIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsVGFyZ2V0OiBwYXJzZWRUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dpbmdfMS5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SLCAnRmFpbGVkIHRvIGNvbm5lY3QgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucGF0aCArXG4gICAgICAgICAgICAgICAgICAgICcgdGhyb3VnaCBwcm94eSAnICtcbiAgICAgICAgICAgICAgICAgICAgcHJveHlBZGRyZXNzU3RyaW5nICtcbiAgICAgICAgICAgICAgICAgICAgJyB3aXRoIHN0YXR1cyAnICtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5vbmNlKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHJlcXVlc3QucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICBsb2dnaW5nXzEubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgJ0ZhaWxlZCB0byBjb25uZWN0IHRvIHByb3h5ICcgK1xuICAgICAgICAgICAgICAgIHByb3h5QWRkcmVzc1N0cmluZyArXG4gICAgICAgICAgICAgICAgJyB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZ2V0UHJveGllZENvbm5lY3Rpb24gPSBnZXRQcm94aWVkQ29ubmVjdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWh0dHBfcHJveHkuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0UHJveGllZENvbm5lY3Rpb24iLCJtYXBQcm94eU5hbWUiLCJsb2dnaW5nXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJyZXNvbHZlcl8xIiwiaHR0cCIsInRscyIsImxvZ2dpbmciLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsInVyaV9wYXJzZXJfMSIsInVybF8xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsImdldFByb3h5SW5mbyIsInByb3h5RW52IiwiZW52VmFyIiwicHJvY2VzcyIsImVudiIsImdycGNfcHJveHkiLCJodHRwc19wcm94eSIsImh0dHBfcHJveHkiLCJwcm94eVVybCIsIlVSTCIsImUiLCJsb2ciLCJFUlJPUiIsInByb3RvY29sIiwidXNlckNyZWQiLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiSU5GTyIsImhvc3RuYW1lIiwicG9ydCIsInJlc3VsdCIsImFkZHJlc3MiLCJjcmVkcyIsImdldE5vUHJveHlIb3N0TGlzdCIsIm5vUHJveHlTdHIiLCJub19ncnBjX3Byb3h5Iiwibm9fcHJveHkiLCJzcGxpdCIsInRhcmdldCIsIm9wdGlvbnMiLCJfYSIsIm5vUHJveHlSZXN1bHQiLCJleHRyYU9wdGlvbnMiLCJzY2hlbWUiLCJwcm94eUluZm8iLCJob3N0UG9ydCIsInNwbGl0SG9zdFBvcnQiLCJwYXRoIiwic2VydmVySG9zdCIsImhvc3QiLCJ1cmlUb1N0cmluZyIsImNoYW5uZWxPcHRpb25zIiwiY29ubmVjdGlvbk9wdGlvbnMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlYWxUYXJnZXQiLCJwYXJzZWRUYXJnZXQiLCJwYXJzZVVyaSIsIm1ldGhvZCIsImhlYWRlcnMiLCJIb3N0IiwiaXNUY3BTdWJjaGFubmVsQWRkcmVzcyIsInNvY2tldFBhdGgiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJwcm94eUFkZHJlc3NTdHJpbmciLCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nIiwicmVqZWN0IiwicmVxdWVzdCIsIm9uY2UiLCJyZXMiLCJzb2NrZXQiLCJoZWFkIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwic3RhdHVzQ29kZSIsInRhcmdldFBhdGgiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicmVtb3RlSG9zdCIsImN0cyIsImNvbm5lY3QiLCJhc3NpZ24iLCJzZXJ2ZXJuYW1lIiwib24iLCJlcnJvciIsIm1lc3NhZ2UiLCJlcnIiLCJlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.experimental = exports.StatusBuilder = exports.getClientChannel = exports.ServerCredentials = exports.Server = exports.setLogVerbosity = exports.setLogger = exports.load = exports.loadObject = exports.CallCredentials = exports.ChannelCredentials = exports.waitForClientReady = exports.closeClient = exports.Channel = exports.makeGenericClientConstructor = exports.makeClientConstructor = exports.loadPackageDefinition = exports.Client = exports.compressionAlgorithms = exports.propagate = exports.connectivityState = exports.status = exports.logVerbosity = exports.Metadata = exports.credentials = void 0;\nconst call_credentials_1 = __webpack_require__(/*! ./call-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/call-credentials.js\");\nObject.defineProperty(exports, \"CallCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return call_credentials_1.CallCredentials;\n    }\n}));\nconst channel_1 = __webpack_require__(/*! ./channel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel.js\");\nObject.defineProperty(exports, \"Channel\", ({\n    enumerable: true,\n    get: function() {\n        return channel_1.ChannelImplementation;\n    }\n}));\nconst compression_algorithms_1 = __webpack_require__(/*! ./compression-algorithms */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/compression-algorithms.js\");\nObject.defineProperty(exports, \"compressionAlgorithms\", ({\n    enumerable: true,\n    get: function() {\n        return compression_algorithms_1.CompressionAlgorithms;\n    }\n}));\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nObject.defineProperty(exports, \"connectivityState\", ({\n    enumerable: true,\n    get: function() {\n        return connectivity_state_1.ConnectivityState;\n    }\n}));\nconst channel_credentials_1 = __webpack_require__(/*! ./channel-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-credentials.js\");\nObject.defineProperty(exports, \"ChannelCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return channel_credentials_1.ChannelCredentials;\n    }\n}));\nconst client_1 = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\");\nObject.defineProperty(exports, \"Client\", ({\n    enumerable: true,\n    get: function() {\n        return client_1.Client;\n    }\n}));\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nObject.defineProperty(exports, \"logVerbosity\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.LogVerbosity;\n    }\n}));\nObject.defineProperty(exports, \"status\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.Status;\n    }\n}));\nObject.defineProperty(exports, \"propagate\", ({\n    enumerable: true,\n    get: function() {\n        return constants_1.Propagate;\n    }\n}));\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst make_client_1 = __webpack_require__(/*! ./make-client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\");\nObject.defineProperty(exports, \"loadPackageDefinition\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.loadPackageDefinition;\n    }\n}));\nObject.defineProperty(exports, \"makeClientConstructor\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.makeClientConstructor;\n    }\n}));\nObject.defineProperty(exports, \"makeGenericClientConstructor\", ({\n    enumerable: true,\n    get: function() {\n        return make_client_1.makeClientConstructor;\n    }\n}));\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nObject.defineProperty(exports, \"Metadata\", ({\n    enumerable: true,\n    get: function() {\n        return metadata_1.Metadata;\n    }\n}));\nconst server_1 = __webpack_require__(/*! ./server */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js\");\nObject.defineProperty(exports, \"Server\", ({\n    enumerable: true,\n    get: function() {\n        return server_1.Server;\n    }\n}));\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nObject.defineProperty(exports, \"ServerCredentials\", ({\n    enumerable: true,\n    get: function() {\n        return server_credentials_1.ServerCredentials;\n    }\n}));\nconst status_builder_1 = __webpack_require__(/*! ./status-builder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\");\nObject.defineProperty(exports, \"StatusBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return status_builder_1.StatusBuilder;\n    }\n}));\n/**** Client Credentials ****/ // Using assign only copies enumerable properties, which is what we want\nexports.credentials = {\n    /**\n     * Combine a ChannelCredentials with any number of CallCredentials into a\n     * single ChannelCredentials object.\n     * @param channelCredentials The ChannelCredentials object.\n     * @param callCredentials Any number of CallCredentials objects.\n     * @return The resulting ChannelCredentials object.\n     */ combineChannelCredentials: (channelCredentials, ...callCredentials)=>{\n        return callCredentials.reduce((acc, other)=>acc.compose(other), channelCredentials);\n    },\n    /**\n     * Combine any number of CallCredentials into a single CallCredentials\n     * object.\n     * @param first The first CallCredentials object.\n     * @param additional Any number of additional CallCredentials objects.\n     * @return The resulting CallCredentials object.\n     */ combineCallCredentials: (first, ...additional)=>{\n        return additional.reduce((acc, other)=>acc.compose(other), first);\n    },\n    // from channel-credentials.ts\n    createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,\n    createSsl: channel_credentials_1.ChannelCredentials.createSsl,\n    createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,\n    // from call-credentials.ts\n    createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,\n    createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,\n    createEmpty: call_credentials_1.CallCredentials.createEmpty\n};\n/**\n * Close a Client object.\n * @param client The client to close.\n */ exports.closeClient = (client)=>client.close();\nexports.waitForClientReady = (client, deadline, callback)=>client.waitForReady(deadline, callback);\n/* eslint-enable @typescript-eslint/no-explicit-any */ /**** Unimplemented function stubs ****/ /* eslint-disable @typescript-eslint/no-explicit-any */ exports.loadObject = (value, options)=>{\n    throw new Error(\"Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead\");\n};\nexports.load = (filename, format, options)=>{\n    throw new Error(\"Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead\");\n};\nexports.setLogger = (logger)=>{\n    logging.setLogger(logger);\n};\nexports.setLogVerbosity = (verbosity)=>{\n    logging.setLoggerVerbosity(verbosity);\n};\nexports.getClientChannel = (client)=>{\n    return client_1.Client.prototype.getChannel.call(client);\n};\nvar client_interceptors_1 = __webpack_require__(/*! ./client-interceptors */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client-interceptors.js\");\nObject.defineProperty(exports, \"ListenerBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.ListenerBuilder;\n    }\n}));\nObject.defineProperty(exports, \"RequesterBuilder\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.RequesterBuilder;\n    }\n}));\nObject.defineProperty(exports, \"InterceptingCall\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.InterceptingCall;\n    }\n}));\nObject.defineProperty(exports, \"InterceptorConfigurationError\", ({\n    enumerable: true,\n    get: function() {\n        return client_interceptors_1.InterceptorConfigurationError;\n    }\n}));\nvar channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nObject.defineProperty(exports, \"getChannelzServiceDefinition\", ({\n    enumerable: true,\n    get: function() {\n        return channelz_1.getChannelzServiceDefinition;\n    }\n}));\nObject.defineProperty(exports, \"getChannelzHandlers\", ({\n    enumerable: true,\n    get: function() {\n        return channelz_1.getChannelzHandlers;\n    }\n}));\nvar admin_1 = __webpack_require__(/*! ./admin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/admin.js\");\nObject.defineProperty(exports, \"addAdminServicesToServer\", ({\n    enumerable: true,\n    get: function() {\n        return admin_1.addAdminServicesToServer;\n    }\n}));\nconst experimental = __webpack_require__(/*! ./experimental */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nexports.experimental = experimental;\nconst resolver_dns = __webpack_require__(/*! ./resolver-dns */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\");\nconst resolver_uds = __webpack_require__(/*! ./resolver-uds */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\");\nconst resolver_ip = __webpack_require__(/*! ./resolver-ip */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\");\nconst load_balancer_pick_first = __webpack_require__(/*! ./load-balancer-pick-first */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\");\nconst load_balancer_round_robin = __webpack_require__(/*! ./load-balancer-round-robin */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\");\nconst load_balancer_outlier_detection = __webpack_require__(/*! ./load-balancer-outlier-detection */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\");\nconst channelz = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@grpc/grpc-js/package.json\").version);\n(()=>{\n    logging.trace(constants_1.LogVerbosity.DEBUG, \"index\", \"Loading @grpc/grpc-js version \" + clientVersion);\n    resolver_dns.setup();\n    resolver_uds.setup();\n    resolver_ip.setup();\n    load_balancer_pick_first.setup();\n    load_balancer_round_robin.setup();\n    load_balancer_outlier_detection.setup();\n    channelz.setup();\n})(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG9CQUFvQixHQUFHQSxxQkFBcUIsR0FBR0Esd0JBQXdCLEdBQUdBLHlCQUF5QixHQUFHQSxjQUFjLEdBQUdBLHVCQUF1QixHQUFHQSxpQkFBaUIsR0FBR0EsWUFBWSxHQUFHQSxrQkFBa0IsR0FBR0EsdUJBQXVCLEdBQUdBLDBCQUEwQixHQUFHQSwwQkFBMEIsR0FBR0EsbUJBQW1CLEdBQUdBLGVBQWUsR0FBR0Esb0NBQW9DLEdBQUdBLDZCQUE2QixHQUFHQSw2QkFBNkIsR0FBR0EsY0FBYyxHQUFHQSw2QkFBNkIsR0FBR0EsaUJBQWlCLEdBQUdBLHlCQUF5QixHQUFHQSxjQUFjLEdBQUdBLG9CQUFvQixHQUFHQSxnQkFBZ0IsR0FBR0EsbUJBQW1CLEdBQUcsS0FBSztBQUNubUIsTUFBTTJCLHFCQUFxQkMsbUJBQU9BLENBQUMsNEZBQW9CO0FBQ3ZEOUIsbURBQWtEO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPSCxtQkFBbUJoQixlQUFlO0lBQUU7QUFBRSxDQUFDLEVBQUM7QUFDeEksTUFBTW9CLFlBQVlILG1CQUFPQSxDQUFDLDBFQUFXO0FBQ3JDOUIsMkNBQTBDO0lBQUUrQixZQUFZO0lBQU1DLEtBQUs7UUFBYyxPQUFPQyxVQUFVQyxxQkFBcUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUM3SCxNQUFNQywyQkFBMkJMLG1CQUFPQSxDQUFDLHdHQUEwQjtBQUNuRTlCLHlEQUF3RDtJQUFFK0IsWUFBWTtJQUFNQyxLQUFLO1FBQWMsT0FBT0cseUJBQXlCQyxxQkFBcUI7SUFBRTtBQUFFLENBQUMsRUFBQztBQUMxSixNQUFNQyx1QkFBdUJQLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRDlCLHFEQUFv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QUFDNEQsS0FBSyxFQUFFLFNBQVMsbUNBQW1DSDtJQUMxRlAsYUFBYVcsS0FBSztJQUNsQlYsYUFBYVUsS0FBSztJQUNsQlQsWUFBWVMsS0FBSztJQUNqQlIseUJBQXlCUSxLQUFLO0lBQzlCUCwwQkFBMEJPLEtBQUs7SUFDL0JOLGdDQUFnQ00sS0FBSztJQUNyQ0wsU0FBU0ssS0FBSztBQUNsQixNQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9pbmRleC5qcz8zOTVlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4cGVyaW1lbnRhbCA9IGV4cG9ydHMuU3RhdHVzQnVpbGRlciA9IGV4cG9ydHMuZ2V0Q2xpZW50Q2hhbm5lbCA9IGV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSBleHBvcnRzLlNlcnZlciA9IGV4cG9ydHMuc2V0TG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5zZXRMb2dnZXIgPSBleHBvcnRzLmxvYWQgPSBleHBvcnRzLmxvYWRPYmplY3QgPSBleHBvcnRzLkNhbGxDcmVkZW50aWFscyA9IGV4cG9ydHMuQ2hhbm5lbENyZWRlbnRpYWxzID0gZXhwb3J0cy53YWl0Rm9yQ2xpZW50UmVhZHkgPSBleHBvcnRzLmNsb3NlQ2xpZW50ID0gZXhwb3J0cy5DaGFubmVsID0gZXhwb3J0cy5tYWtlR2VuZXJpY0NsaWVudENvbnN0cnVjdG9yID0gZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSBleHBvcnRzLmxvYWRQYWNrYWdlRGVmaW5pdGlvbiA9IGV4cG9ydHMuQ2xpZW50ID0gZXhwb3J0cy5jb21wcmVzc2lvbkFsZ29yaXRobXMgPSBleHBvcnRzLnByb3BhZ2F0ZSA9IGV4cG9ydHMuY29ubmVjdGl2aXR5U3RhdGUgPSBleHBvcnRzLnN0YXR1cyA9IGV4cG9ydHMubG9nVmVyYm9zaXR5ID0gZXhwb3J0cy5NZXRhZGF0YSA9IGV4cG9ydHMuY3JlZGVudGlhbHMgPSB2b2lkIDA7XG5jb25zdCBjYWxsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jYWxsLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FsbENyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsX2NyZWRlbnRpYWxzXzEuQ2FsbENyZWRlbnRpYWxzOyB9IH0pO1xuY29uc3QgY2hhbm5lbF8xID0gcmVxdWlyZShcIi4vY2hhbm5lbFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNoYW5uZWxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNoYW5uZWxfMS5DaGFubmVsSW1wbGVtZW50YXRpb247IH0gfSk7XG5jb25zdCBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEgPSByZXF1aXJlKFwiLi9jb21wcmVzc2lvbi1hbGdvcml0aG1zXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY29tcHJlc3Npb25BbGdvcml0aG1zXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21wcmVzc2lvbl9hbGdvcml0aG1zXzEuQ29tcHJlc3Npb25BbGdvcml0aG1zOyB9IH0pO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjb25uZWN0aXZpdHlTdGF0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGU7IH0gfSk7XG5jb25zdCBjaGFubmVsX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLWNyZWRlbnRpYWxzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2hhbm5lbENyZWRlbnRpYWxzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzOyB9IH0pO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF8xLkNsaWVudDsgfSB9KTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9nVmVyYm9zaXR5XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHk7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzdGF0dXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0YW50c18xLlN0YXR1czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInByb3BhZ2F0ZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RhbnRzXzEuUHJvcGFnYXRlOyB9IH0pO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBtYWtlX2NsaWVudF8xID0gcmVxdWlyZShcIi4vbWFrZS1jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJsb2FkUGFja2FnZURlZmluaXRpb25cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubG9hZFBhY2thZ2VEZWZpbml0aW9uOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibWFrZUNsaWVudENvbnN0cnVjdG9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYWtlX2NsaWVudF8xLm1ha2VDbGllbnRDb25zdHJ1Y3RvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm1ha2VHZW5lcmljQ2xpZW50Q29uc3RydWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ha2VfY2xpZW50XzEubWFrZUNsaWVudENvbnN0cnVjdG9yOyB9IH0pO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWV0YWRhdGFcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ldGFkYXRhXzEuTWV0YWRhdGE7IH0gfSk7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyXzEuU2VydmVyOyB9IH0pO1xuY29uc3Qgc2VydmVyX2NyZWRlbnRpYWxzXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItY3JlZGVudGlhbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZXJ2ZXJDcmVkZW50aWFsc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyX2NyZWRlbnRpYWxzXzEuU2VydmVyQ3JlZGVudGlhbHM7IH0gfSk7XG5jb25zdCBzdGF0dXNfYnVpbGRlcl8xID0gcmVxdWlyZShcIi4vc3RhdHVzLWJ1aWxkZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdGF0dXNCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0dXNfYnVpbGRlcl8xLlN0YXR1c0J1aWxkZXI7IH0gfSk7XG4vKioqKiBDbGllbnQgQ3JlZGVudGlhbHMgKioqKi9cbi8vIFVzaW5nIGFzc2lnbiBvbmx5IGNvcGllcyBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIHdoaWNoIGlzIHdoYXQgd2Ugd2FudFxuZXhwb3J0cy5jcmVkZW50aWFscyA9IHtcbiAgICAvKipcbiAgICAgKiBDb21iaW5lIGEgQ2hhbm5lbENyZWRlbnRpYWxzIHdpdGggYW55IG51bWJlciBvZiBDYWxsQ3JlZGVudGlhbHMgaW50byBhXG4gICAgICogc2luZ2xlIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICogQHBhcmFtIGNoYW5uZWxDcmVkZW50aWFscyBUaGUgQ2hhbm5lbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gY2FsbENyZWRlbnRpYWxzIEFueSBudW1iZXIgb2YgQ2FsbENyZWRlbnRpYWxzIG9iamVjdHMuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENoYW5uZWxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgY29tYmluZUNoYW5uZWxDcmVkZW50aWFsczogKGNoYW5uZWxDcmVkZW50aWFscywgLi4uY2FsbENyZWRlbnRpYWxzKSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxsQ3JlZGVudGlhbHMucmVkdWNlKChhY2MsIG90aGVyKSA9PiBhY2MuY29tcG9zZShvdGhlciksIGNoYW5uZWxDcmVkZW50aWFscyk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDb21iaW5lIGFueSBudW1iZXIgb2YgQ2FsbENyZWRlbnRpYWxzIGludG8gYSBzaW5nbGUgQ2FsbENyZWRlbnRpYWxzXG4gICAgICogb2JqZWN0LlxuICAgICAqIEBwYXJhbSBmaXJzdCBUaGUgZmlyc3QgQ2FsbENyZWRlbnRpYWxzIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gYWRkaXRpb25hbCBBbnkgbnVtYmVyIG9mIGFkZGl0aW9uYWwgQ2FsbENyZWRlbnRpYWxzIG9iamVjdHMuXG4gICAgICogQHJldHVybiBUaGUgcmVzdWx0aW5nIENhbGxDcmVkZW50aWFscyBvYmplY3QuXG4gICAgICovXG4gICAgY29tYmluZUNhbGxDcmVkZW50aWFsczogKGZpcnN0LCAuLi5hZGRpdGlvbmFsKSA9PiB7XG4gICAgICAgIHJldHVybiBhZGRpdGlvbmFsLnJlZHVjZSgoYWNjLCBvdGhlcikgPT4gYWNjLmNvbXBvc2Uob3RoZXIpLCBmaXJzdCk7XG4gICAgfSxcbiAgICAvLyBmcm9tIGNoYW5uZWwtY3JlZGVudGlhbHMudHNcbiAgICBjcmVhdGVJbnNlY3VyZTogY2hhbm5lbF9jcmVkZW50aWFsc18xLkNoYW5uZWxDcmVkZW50aWFscy5jcmVhdGVJbnNlY3VyZSxcbiAgICBjcmVhdGVTc2w6IGNoYW5uZWxfY3JlZGVudGlhbHNfMS5DaGFubmVsQ3JlZGVudGlhbHMuY3JlYXRlU3NsLFxuICAgIGNyZWF0ZUZyb21TZWN1cmVDb250ZXh0OiBjaGFubmVsX2NyZWRlbnRpYWxzXzEuQ2hhbm5lbENyZWRlbnRpYWxzLmNyZWF0ZUZyb21TZWN1cmVDb250ZXh0LFxuICAgIC8vIGZyb20gY2FsbC1jcmVkZW50aWFscy50c1xuICAgIGNyZWF0ZUZyb21NZXRhZGF0YUdlbmVyYXRvcjogY2FsbF9jcmVkZW50aWFsc18xLkNhbGxDcmVkZW50aWFscy5jcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IsXG4gICAgY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWw6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRnJvbUdvb2dsZUNyZWRlbnRpYWwsXG4gICAgY3JlYXRlRW1wdHk6IGNhbGxfY3JlZGVudGlhbHNfMS5DYWxsQ3JlZGVudGlhbHMuY3JlYXRlRW1wdHksXG59O1xuLyoqXG4gKiBDbG9zZSBhIENsaWVudCBvYmplY3QuXG4gKiBAcGFyYW0gY2xpZW50IFRoZSBjbGllbnQgdG8gY2xvc2UuXG4gKi9cbmV4cG9ydHMuY2xvc2VDbGllbnQgPSAoY2xpZW50KSA9PiBjbGllbnQuY2xvc2UoKTtcbmV4cG9ydHMud2FpdEZvckNsaWVudFJlYWR5ID0gKGNsaWVudCwgZGVhZGxpbmUsIGNhbGxiYWNrKSA9PiBjbGllbnQud2FpdEZvclJlYWR5KGRlYWRsaW5lLCBjYWxsYmFjayk7XG4vKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKioqIFVuaW1wbGVtZW50ZWQgZnVuY3Rpb24gc3R1YnMgKioqKi9cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmV4cG9ydHMubG9hZE9iamVjdCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGF2YWlsYWJsZSBpbiB0aGlzIGxpYnJhcnkuIFVzZSBAZ3JwYy9wcm90by1sb2FkZXIgYW5kIGxvYWRQYWNrYWdlRGVmaW5pdGlvbiBpbnN0ZWFkJyk7XG59O1xuZXhwb3J0cy5sb2FkID0gKGZpbGVuYW1lLCBmb3JtYXQsIG9wdGlvbnMpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhdmFpbGFibGUgaW4gdGhpcyBsaWJyYXJ5LiBVc2UgQGdycGMvcHJvdG8tbG9hZGVyIGFuZCBsb2FkUGFja2FnZURlZmluaXRpb24gaW5zdGVhZCcpO1xufTtcbmV4cG9ydHMuc2V0TG9nZ2VyID0gKGxvZ2dlcikgPT4ge1xuICAgIGxvZ2dpbmcuc2V0TG9nZ2VyKGxvZ2dlcik7XG59O1xuZXhwb3J0cy5zZXRMb2dWZXJib3NpdHkgPSAodmVyYm9zaXR5KSA9PiB7XG4gICAgbG9nZ2luZy5zZXRMb2dnZXJWZXJib3NpdHkodmVyYm9zaXR5KTtcbn07XG5leHBvcnRzLmdldENsaWVudENoYW5uZWwgPSAoY2xpZW50KSA9PiB7XG4gICAgcmV0dXJuIGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUuZ2V0Q2hhbm5lbC5jYWxsKGNsaWVudCk7XG59O1xudmFyIGNsaWVudF9pbnRlcmNlcHRvcnNfMSA9IHJlcXVpcmUoXCIuL2NsaWVudC1pbnRlcmNlcHRvcnNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJMaXN0ZW5lckJ1aWxkZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5MaXN0ZW5lckJ1aWxkZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZXF1ZXN0ZXJCdWlsZGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbGllbnRfaW50ZXJjZXB0b3JzXzEuUmVxdWVzdGVyQnVpbGRlcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludGVyY2VwdGluZ0NhbGxcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5JbnRlcmNlcHRpbmdDYWxsOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNsaWVudF9pbnRlcmNlcHRvcnNfMS5JbnRlcmNlcHRvckNvbmZpZ3VyYXRpb25FcnJvcjsgfSB9KTtcbnZhciBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGFubmVselNlcnZpY2VEZWZpbml0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsel8xLmdldENoYW5uZWx6U2VydmljZURlZmluaXRpb247IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRDaGFubmVsekhhbmRsZXJzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjaGFubmVsel8xLmdldENoYW5uZWx6SGFuZGxlcnM7IH0gfSk7XG52YXIgYWRtaW5fMSA9IHJlcXVpcmUoXCIuL2FkbWluXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhZG1pbl8xLmFkZEFkbWluU2VydmljZXNUb1NlcnZlcjsgfSB9KTtcbmNvbnN0IGV4cGVyaW1lbnRhbCA9IHJlcXVpcmUoXCIuL2V4cGVyaW1lbnRhbFwiKTtcbmV4cG9ydHMuZXhwZXJpbWVudGFsID0gZXhwZXJpbWVudGFsO1xuY29uc3QgcmVzb2x2ZXJfZG5zID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItZG5zXCIpO1xuY29uc3QgcmVzb2x2ZXJfdWRzID0gcmVxdWlyZShcIi4vcmVzb2x2ZXItdWRzXCIpO1xuY29uc3QgcmVzb2x2ZXJfaXAgPSByZXF1aXJlKFwiLi9yZXNvbHZlci1pcFwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcGlja19maXJzdCA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItcGljay1maXJzdFwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfcm91bmRfcm9iaW4gPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLXJvdW5kLXJvYmluXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbiA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXItb3V0bGllci1kZXRlY3Rpb25cIik7XG5jb25zdCBjaGFubmVseiA9IHJlcXVpcmUoXCIuL2NoYW5uZWx6XCIpO1xuY29uc3QgY2xpZW50VmVyc2lvbiA9IHJlcXVpcmUoJy4uLy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb247XG4oKCkgPT4ge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCAnaW5kZXgnLCAnTG9hZGluZyBAZ3JwYy9ncnBjLWpzIHZlcnNpb24gJyArIGNsaWVudFZlcnNpb24pO1xuICAgIHJlc29sdmVyX2Rucy5zZXR1cCgpO1xuICAgIHJlc29sdmVyX3Vkcy5zZXR1cCgpO1xuICAgIHJlc29sdmVyX2lwLnNldHVwKCk7XG4gICAgbG9hZF9iYWxhbmNlcl9waWNrX2ZpcnN0LnNldHVwKCk7XG4gICAgbG9hZF9iYWxhbmNlcl9yb3VuZF9yb2Jpbi5zZXR1cCgpO1xuICAgIGxvYWRfYmFsYW5jZXJfb3V0bGllcl9kZXRlY3Rpb24uc2V0dXAoKTtcbiAgICBjaGFubmVsei5zZXR1cCgpO1xufSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImV4cGVyaW1lbnRhbCIsIlN0YXR1c0J1aWxkZXIiLCJnZXRDbGllbnRDaGFubmVsIiwiU2VydmVyQ3JlZGVudGlhbHMiLCJTZXJ2ZXIiLCJzZXRMb2dWZXJib3NpdHkiLCJzZXRMb2dnZXIiLCJsb2FkIiwibG9hZE9iamVjdCIsIkNhbGxDcmVkZW50aWFscyIsIkNoYW5uZWxDcmVkZW50aWFscyIsIndhaXRGb3JDbGllbnRSZWFkeSIsImNsb3NlQ2xpZW50IiwiQ2hhbm5lbCIsIm1ha2VHZW5lcmljQ2xpZW50Q29uc3RydWN0b3IiLCJtYWtlQ2xpZW50Q29uc3RydWN0b3IiLCJsb2FkUGFja2FnZURlZmluaXRpb24iLCJDbGllbnQiLCJjb21wcmVzc2lvbkFsZ29yaXRobXMiLCJwcm9wYWdhdGUiLCJjb25uZWN0aXZpdHlTdGF0ZSIsInN0YXR1cyIsImxvZ1ZlcmJvc2l0eSIsIk1ldGFkYXRhIiwiY3JlZGVudGlhbHMiLCJjYWxsX2NyZWRlbnRpYWxzXzEiLCJyZXF1aXJlIiwiZW51bWVyYWJsZSIsImdldCIsImNoYW5uZWxfMSIsIkNoYW5uZWxJbXBsZW1lbnRhdGlvbiIsImNvbXByZXNzaW9uX2FsZ29yaXRobXNfMSIsIkNvbXByZXNzaW9uQWxnb3JpdGhtcyIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwiQ29ubmVjdGl2aXR5U3RhdGUiLCJjaGFubmVsX2NyZWRlbnRpYWxzXzEiLCJjbGllbnRfMSIsImNvbnN0YW50c18xIiwiTG9nVmVyYm9zaXR5IiwiU3RhdHVzIiwiUHJvcGFnYXRlIiwibG9nZ2luZyIsIm1ha2VfY2xpZW50XzEiLCJtZXRhZGF0YV8xIiwic2VydmVyXzEiLCJzZXJ2ZXJfY3JlZGVudGlhbHNfMSIsInN0YXR1c19idWlsZGVyXzEiLCJjb21iaW5lQ2hhbm5lbENyZWRlbnRpYWxzIiwiY2hhbm5lbENyZWRlbnRpYWxzIiwiY2FsbENyZWRlbnRpYWxzIiwicmVkdWNlIiwiYWNjIiwib3RoZXIiLCJjb21wb3NlIiwiY29tYmluZUNhbGxDcmVkZW50aWFscyIsImZpcnN0IiwiYWRkaXRpb25hbCIsImNyZWF0ZUluc2VjdXJlIiwiY3JlYXRlU3NsIiwiY3JlYXRlRnJvbVNlY3VyZUNvbnRleHQiLCJjcmVhdGVGcm9tTWV0YWRhdGFHZW5lcmF0b3IiLCJjcmVhdGVGcm9tR29vZ2xlQ3JlZGVudGlhbCIsImNyZWF0ZUVtcHR5IiwiY2xpZW50IiwiY2xvc2UiLCJkZWFkbGluZSIsImNhbGxiYWNrIiwid2FpdEZvclJlYWR5Iiwib3B0aW9ucyIsIkVycm9yIiwiZmlsZW5hbWUiLCJmb3JtYXQiLCJsb2dnZXIiLCJ2ZXJib3NpdHkiLCJzZXRMb2dnZXJWZXJib3NpdHkiLCJwcm90b3R5cGUiLCJnZXRDaGFubmVsIiwiY2FsbCIsImNsaWVudF9pbnRlcmNlcHRvcnNfMSIsIkxpc3RlbmVyQnVpbGRlciIsIlJlcXVlc3RlckJ1aWxkZXIiLCJJbnRlcmNlcHRpbmdDYWxsIiwiSW50ZXJjZXB0b3JDb25maWd1cmF0aW9uRXJyb3IiLCJjaGFubmVsel8xIiwiZ2V0Q2hhbm5lbHpTZXJ2aWNlRGVmaW5pdGlvbiIsImdldENoYW5uZWx6SGFuZGxlcnMiLCJhZG1pbl8xIiwiYWRkQWRtaW5TZXJ2aWNlc1RvU2VydmVyIiwicmVzb2x2ZXJfZG5zIiwicmVzb2x2ZXJfdWRzIiwicmVzb2x2ZXJfaXAiLCJsb2FkX2JhbGFuY2VyX3BpY2tfZmlyc3QiLCJsb2FkX2JhbGFuY2VyX3JvdW5kX3JvYmluIiwibG9hZF9iYWxhbmNlcl9vdXRsaWVyX2RldGVjdGlvbiIsImNoYW5uZWx6IiwiY2xpZW50VmVyc2lvbiIsInZlcnNpb24iLCJ0cmFjZSIsIkRFQlVHIiwic2V0dXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ChildLoadBalancerHandler = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst TYPE_NAME = \"child_load_balancer_helper\";\nclass ChildLoadBalancerHandler {\n    constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        this.currentChild = null;\n        this.pendingChild = null;\n        this.ChildPolicyHelper = class {\n            constructor(parent){\n                this.parent = parent;\n                this.child = null;\n            }\n            createSubchannel(subchannelAddress, subchannelArgs) {\n                return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n            }\n            updateState(connectivityState, picker) {\n                var _a;\n                if (this.calledByPendingChild()) {\n                    if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                        return;\n                    }\n                    (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n                    this.parent.currentChild = this.parent.pendingChild;\n                    this.parent.pendingChild = null;\n                } else if (!this.calledByCurrentChild()) {\n                    return;\n                }\n                this.parent.channelControlHelper.updateState(connectivityState, picker);\n            }\n            requestReresolution() {\n                var _a;\n                const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n                if (this.child === latestChild) {\n                    this.parent.channelControlHelper.requestReresolution();\n                }\n            }\n            setChild(newChild) {\n                this.child = newChild;\n            }\n            addChannelzChild(child) {\n                this.parent.channelControlHelper.addChannelzChild(child);\n            }\n            removeChannelzChild(child) {\n                this.parent.channelControlHelper.removeChannelzChild(child);\n            }\n            calledByPendingChild() {\n                return this.child === this.parent.pendingChild;\n            }\n            calledByCurrentChild() {\n                return this.child === this.parent.currentChild;\n            }\n        };\n    }\n    /**\n     * Prerequisites: lbConfig !== null and lbConfig.name is registered\n     * @param addressList\n     * @param lbConfig\n     * @param attributes\n     */ updateAddressList(addressList, lbConfig, attributes) {\n        let childToUpdate;\n        if (this.currentChild === null || this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {\n            const newHelper = new this.ChildPolicyHelper(this);\n            const newChild = load_balancer_1.createLoadBalancer(lbConfig, newHelper);\n            newHelper.setChild(newChild);\n            if (this.currentChild === null) {\n                this.currentChild = newChild;\n                childToUpdate = this.currentChild;\n            } else {\n                if (this.pendingChild) {\n                    this.pendingChild.destroy();\n                }\n                this.pendingChild = newChild;\n                childToUpdate = this.pendingChild;\n            }\n        } else {\n            if (this.pendingChild === null) {\n                childToUpdate = this.currentChild;\n            } else {\n                childToUpdate = this.pendingChild;\n            }\n        }\n        childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n    }\n    exitIdle() {\n        if (this.currentChild) {\n            this.currentChild.exitIdle();\n            if (this.pendingChild) {\n                this.pendingChild.exitIdle();\n            }\n        }\n    }\n    resetBackoff() {\n        if (this.currentChild) {\n            this.currentChild.resetBackoff();\n            if (this.pendingChild) {\n                this.pendingChild.resetBackoff();\n            }\n        }\n    }\n    destroy() {\n        if (this.currentChild) {\n            this.currentChild.destroy();\n            this.currentChild = null;\n        }\n        if (this.pendingChild) {\n            this.pendingChild.destroy();\n            this.pendingChild = null;\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler; //# sourceMappingURL=load-balancer-child-handler.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxnQ0FBZ0MsR0FBRyxLQUFLO0FBQ3hDLE1BQU1HLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1FLFlBQVk7QUFDbEIsTUFBTUo7SUFDRkssWUFBWUMsb0JBQW9CLENBQUU7UUFDOUIsSUFBSSxDQUFDQSxvQkFBb0IsR0FBR0E7UUFDNUIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztZQUNyQkosWUFBWUssTUFBTSxDQUFFO2dCQUNoQixJQUFJLENBQUNBLE1BQU0sR0FBR0E7Z0JBQ2QsSUFBSSxDQUFDQyxLQUFLLEdBQUc7WUFDakI7WUFDQUMsaUJBQWlCQyxpQkFBaUIsRUFBRUMsY0FBYyxFQUFFO2dCQUNoRCxPQUFPLElBQUksQ0FBQ0osTUFBTSxDQUFDSixvQkFBb0IsQ0FBQ00sZ0JBQWdCLENBQUNDLG1CQUFtQkM7WUFDaEY7WUFDQUMsWUFBWUMsaUJBQWlCLEVBQUVDLE1BQU0sRUFBRTtnQkFDbkMsSUFBSUM7Z0JBQ0osSUFBSSxJQUFJLENBQUNDLG9CQUFvQixJQUFJO29CQUM3QixJQUFJSCxzQkFBc0JiLHFCQUFxQmlCLGlCQUFpQixDQUFDQyxVQUFVLEVBQUU7d0JBQ3pFO29CQUNKO29CQUNDSCxDQUFBQSxLQUFLLElBQUksQ0FBQ1IsTUFBTSxDQUFDSCxZQUFZLE1BQU0sUUFBUVcsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSSxPQUFPO29CQUMvRSxJQUFJLENBQUNa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aUMsWUFBWTtZQUM5QixJQUFJLElBQUksQ0FBQ2hDLFlBQVksRUFBRTtnQkFDbkIsSUFBSSxDQUFDQSxZQUFZLENBQUNnQyxZQUFZO1lBQ2xDO1FBQ0o7SUFDSjtJQUNBbEIsVUFBVTtRQUNOLElBQUksSUFBSSxDQUFDZixZQUFZLEVBQUU7WUFDbkIsSUFBSSxDQUFDQSxZQUFZLENBQUNlLE9BQU87WUFDekIsSUFBSSxDQUFDZixZQUFZLEdBQUc7UUFDeEI7UUFDQSxJQUFJLElBQUksQ0FBQ0MsWUFBWSxFQUFFO1lBQ25CLElBQUksQ0FBQ0EsWUFBWSxDQUFDYyxPQUFPO1lBQ3pCLElBQUksQ0FBQ2QsWUFBWSxHQUFHO1FBQ3hCO0lBQ0o7SUFDQTJCLGNBQWM7UUFDVixPQUFPL0I7SUFDWDtBQUNKO0FBQ0FOLGdDQUFnQyxHQUFHRSwwQkFDbkMsdURBQXVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlci5qcz83ZTEwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDIwIGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG5jb25zdCBjb25uZWN0aXZpdHlfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3Rpdml0eS1zdGF0ZVwiKTtcbmNvbnN0IFRZUEVfTkFNRSA9ICdjaGlsZF9sb2FkX2JhbGFuY2VyX2hlbHBlcic7XG5jbGFzcyBDaGlsZExvYWRCYWxhbmNlckhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMuQ2hpbGRQb2xpY3lIZWxwZXIgPSBjbGFzcyB7XG4gICAgICAgICAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNyZWF0ZVN1YmNoYW5uZWwoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FsbGVkQnlQZW5kaW5nQ2hpbGQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGl2aXR5U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZCA9IHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQucGVuZGluZ0NoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXRoaXMuY2FsbGVkQnlDdXJyZW50Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF0ZXN0Q2hpbGQgPSAoX2EgPSB0aGlzLnBhcmVudC5wZW5kaW5nQ2hpbGQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucGFyZW50LmN1cnJlbnRDaGlsZDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGlsZCA9PT0gbGF0ZXN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldENoaWxkKG5ld0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZCA9IG5ld0NoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkQ2hhbm5lbHpDaGlsZChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlQ2hhbm5lbHpDaGlsZChjaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGVkQnlQZW5kaW5nQ2hpbGQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQgPT09IHRoaXMucGFyZW50LnBlbmRpbmdDaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxlZEJ5Q3VycmVudENoaWxkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkID09PSB0aGlzLnBhcmVudC5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXJlcXVpc2l0ZXM6IGxiQ29uZmlnICE9PSBudWxsIGFuZCBsYkNvbmZpZy5uYW1lIGlzIHJlZ2lzdGVyZWRcbiAgICAgKiBAcGFyYW0gYWRkcmVzc0xpc3RcbiAgICAgKiBAcGFyYW0gbGJDb25maWdcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlc1xuICAgICAqL1xuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZywgYXR0cmlidXRlcykge1xuICAgICAgICBsZXQgY2hpbGRUb1VwZGF0ZTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkID09PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5nZXRUeXBlTmFtZSgpICE9PSBsYkNvbmZpZy5nZXRMb2FkQmFsYW5jZXJOYW1lKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0hlbHBlciA9IG5ldyB0aGlzLkNoaWxkUG9saWN5SGVscGVyKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hpbGQgPSBsb2FkX2JhbGFuY2VyXzEuY3JlYXRlTG9hZEJhbGFuY2VyKGxiQ29uZmlnLCBuZXdIZWxwZXIpO1xuICAgICAgICAgICAgbmV3SGVscGVyLnNldENoaWxkKG5ld0NoaWxkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkID0gbmV3Q2hpbGQ7XG4gICAgICAgICAgICAgICAgY2hpbGRUb1VwZGF0ZSA9IHRoaXMuY3VycmVudENoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQgPSBuZXdDaGlsZDtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5jdXJyZW50Q2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGlsZFRvVXBkYXRlID0gdGhpcy5wZW5kaW5nQ2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRUb1VwZGF0ZS51cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGlsZC5leGl0SWRsZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NoaWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2hpbGQuZXhpdElkbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2hpbGQucmVzZXRCYWNrb2ZmKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdDaGlsZC5yZXNldEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENoaWxkID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0NoaWxkID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUeXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG59XG5leHBvcnRzLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlciA9IENoaWxkTG9hZEJhbGFuY2VySGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvYWQtYmFsYW5jZXItY2hpbGQtaGFuZGxlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJDaGlsZExvYWRCYWxhbmNlckhhbmRsZXIiLCJsb2FkX2JhbGFuY2VyXzEiLCJyZXF1aXJlIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJUWVBFX05BTUUiLCJjb25zdHJ1Y3RvciIsImNoYW5uZWxDb250cm9sSGVscGVyIiwiY3VycmVudENoaWxkIiwicGVuZGluZ0NoaWxkIiwiQ2hpbGRQb2xpY3lIZWxwZXIiLCJwYXJlbnQiLCJjaGlsZCIsImNyZWF0ZVN1YmNoYW5uZWwiLCJzdWJjaGFubmVsQWRkcmVzcyIsInN1YmNoYW5uZWxBcmdzIiwidXBkYXRlU3RhdGUiLCJjb25uZWN0aXZpdHlTdGF0ZSIsInBpY2tlciIsIl9hIiwiY2FsbGVkQnlQZW5kaW5nQ2hpbGQiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIkNPTk5FQ1RJTkciLCJkZXN0cm95IiwiY2FsbGVkQnlDdXJyZW50Q2hpbGQiLCJyZXF1ZXN0UmVyZXNvbHV0aW9uIiwibGF0ZXN0Q2hpbGQiLCJzZXRDaGlsZCIsIm5ld0NoaWxkIiwiYWRkQ2hhbm5lbHpDaGlsZCIsInJlbW92ZUNoYW5uZWx6Q2hpbGQiLCJ1cGRhdGVBZGRyZXNzTGlzdCIsImFkZHJlc3NMaXN0IiwibGJDb25maWciLCJhdHRyaWJ1dGVzIiwiY2hpbGRUb1VwZGF0ZSIsImdldFR5cGVOYW1lIiwiZ2V0TG9hZEJhbGFuY2VyTmFtZSIsIm5ld0hlbHBlciIsImNyZWF0ZUxvYWRCYWxhbmNlciIsImV4aXRJZGxlIiwicmVzZXRCYWNrb2ZmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var _a;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.OutlierDetectionLoadBalancer = exports.OutlierDetectionLoadBalancingConfig = void 0;\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst duration_1 = __webpack_require__(/*! ./duration */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/duration.js\");\nconst experimental_1 = __webpack_require__(/*! ./experimental */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/experimental.js\");\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst subchannel_interface_1 = __webpack_require__(/*! ./subchannel-interface */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"outlier_detection\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"outlier_detection\";\nconst OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : \"true\") === \"true\";\nconst defaultSuccessRateEjectionConfig = {\n    stdev_factor: 1900,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 100\n};\nconst defaultFailurePercentageEjectionConfig = {\n    threshold: 85,\n    enforcement_percentage: 100,\n    minimum_hosts: 5,\n    request_volume: 50\n};\nfunction validateFieldType(obj, fieldName, expectedType, objectName) {\n    if (fieldName in obj && typeof obj[fieldName] !== expectedType) {\n        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);\n    }\n}\nfunction validatePositiveDuration(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    if (fieldName in obj) {\n        if (!duration_1.isDuration(obj[fieldName])) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);\n        }\n        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576000000 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {\n            throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);\n        }\n    }\n}\nfunction validatePercentage(obj, fieldName, objectName) {\n    const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;\n    validateFieldType(obj, fieldName, \"number\", objectName);\n    if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {\n        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);\n    }\n}\nclass OutlierDetectionLoadBalancingConfig {\n    constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy){\n        this.childPolicy = childPolicy;\n        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 10000;\n        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 30000;\n        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 300000;\n        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;\n        this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;\n        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;\n    }\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    toJsonObject() {\n        return {\n            interval: duration_1.msToDuration(this.intervalMs),\n            base_ejection_time: duration_1.msToDuration(this.baseEjectionTimeMs),\n            max_ejection_time: duration_1.msToDuration(this.maxEjectionTimeMs),\n            max_ejection_percent: this.maxEjectionPercent,\n            success_rate_ejection: this.successRateEjection,\n            failure_percentage_ejection: this.failurePercentageEjection,\n            child_policy: this.childPolicy.map((policy)=>policy.toJsonObject())\n        };\n    }\n    getIntervalMs() {\n        return this.intervalMs;\n    }\n    getBaseEjectionTimeMs() {\n        return this.baseEjectionTimeMs;\n    }\n    getMaxEjectionTimeMs() {\n        return this.maxEjectionTimeMs;\n    }\n    getMaxEjectionPercent() {\n        return this.maxEjectionPercent;\n    }\n    getSuccessRateEjectionConfig() {\n        return this.successRateEjection;\n    }\n    getFailurePercentageEjectionConfig() {\n        return this.failurePercentageEjection;\n    }\n    getChildPolicy() {\n        return this.childPolicy;\n    }\n    copyWithChildPolicy(childPolicy) {\n        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);\n    }\n    static createFromJson(obj) {\n        var _a;\n        validatePositiveDuration(obj, \"interval\");\n        validatePositiveDuration(obj, \"base_ejection_time\");\n        validatePositiveDuration(obj, \"max_ejection_time\");\n        validatePercentage(obj, \"max_ejection_percent\");\n        if (\"success_rate_ejection\" in obj) {\n            if (typeof obj.success_rate_ejection !== \"object\") {\n                throw new Error(\"outlier detection config success_rate_ejection must be an object\");\n            }\n            validateFieldType(obj.success_rate_ejection, \"stdev_factor\", \"number\", \"success_rate_ejection\");\n            validatePercentage(obj.success_rate_ejection, \"enforcement_percentage\", \"success_rate_ejection\");\n            validateFieldType(obj.success_rate_ejection, \"minimum_hosts\", \"number\", \"success_rate_ejection\");\n            validateFieldType(obj.success_rate_ejection, \"request_volume\", \"number\", \"success_rate_ejection\");\n        }\n        if (\"failure_percentage_ejection\" in obj) {\n            if (typeof obj.failure_percentage_ejection !== \"object\") {\n                throw new Error(\"outlier detection config failure_percentage_ejection must be an object\");\n            }\n            validatePercentage(obj.failure_percentage_ejection, \"threshold\", \"failure_percentage_ejection\");\n            validatePercentage(obj.failure_percentage_ejection, \"enforcement_percentage\", \"failure_percentage_ejection\");\n            validateFieldType(obj.failure_percentage_ejection, \"minimum_hosts\", \"number\", \"failure_percentage_ejection\");\n            validateFieldType(obj.failure_percentage_ejection, \"request_volume\", \"number\", \"failure_percentage_ejection\");\n        }\n        return new OutlierDetectionLoadBalancingConfig(obj.interval ? duration_1.durationToMs(obj.interval) : null, obj.base_ejection_time ? duration_1.durationToMs(obj.base_ejection_time) : null, obj.max_ejection_time ? duration_1.durationToMs(obj.max_ejection_time) : null, (_a = obj.max_ejection_percent) !== null && _a !== void 0 ? _a : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));\n    }\n}\nexports.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;\nclass OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {\n    constructor(childSubchannel, mapEntry){\n        super(childSubchannel);\n        this.mapEntry = mapEntry;\n        this.stateListeners = [];\n        this.ejected = false;\n        this.refCount = 0;\n        this.childSubchannelState = childSubchannel.getConnectivityState();\n        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState)=>{\n            this.childSubchannelState = newState;\n            if (!this.ejected) {\n                for (const listener of this.stateListeners){\n                    listener(this, previousState, newState);\n                }\n            }\n        });\n    }\n    getConnectivityState() {\n        if (this.ejected) {\n            return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n        } else {\n            return this.childSubchannelState;\n        }\n    }\n    /**\n     * Add a listener function to be called whenever the wrapper's\n     * connectivity state changes.\n     * @param listener\n     */ addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */ removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    ref() {\n        this.child.ref();\n        this.refCount += 1;\n    }\n    unref() {\n        this.child.unref();\n        this.refCount -= 1;\n        if (this.refCount <= 0) {\n            if (this.mapEntry) {\n                const index = this.mapEntry.subchannelWrappers.indexOf(this);\n                if (index >= 0) {\n                    this.mapEntry.subchannelWrappers.splice(index, 1);\n                }\n            }\n        }\n    }\n    eject() {\n        this.ejected = true;\n        for (const listener of this.stateListeners){\n            listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        }\n    }\n    uneject() {\n        this.ejected = false;\n        for (const listener of this.stateListeners){\n            listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);\n        }\n    }\n    getMapEntry() {\n        return this.mapEntry;\n    }\n    getWrappedSubchannel() {\n        return this.child;\n    }\n}\nfunction createEmptyBucket() {\n    return {\n        success: 0,\n        failure: 0\n    };\n}\nclass CallCounter {\n    constructor(){\n        this.activeBucket = createEmptyBucket();\n        this.inactiveBucket = createEmptyBucket();\n    }\n    addSuccess() {\n        this.activeBucket.success += 1;\n    }\n    addFailure() {\n        this.activeBucket.failure += 1;\n    }\n    switchBuckets() {\n        this.inactiveBucket = this.activeBucket;\n        this.activeBucket = createEmptyBucket();\n    }\n    getLastSuccesses() {\n        return this.inactiveBucket.success;\n    }\n    getLastFailures() {\n        return this.inactiveBucket.failure;\n    }\n}\nclass OutlierDetectionCounterFilter extends filter_1.BaseFilter {\n    constructor(callCounter){\n        super();\n        this.callCounter = callCounter;\n    }\n    receiveTrailers(status) {\n        if (status.code === constants_1.Status.OK) {\n            this.callCounter.addSuccess();\n        } else {\n            this.callCounter.addFailure();\n        }\n        return status;\n    }\n}\nclass OutlierDetectionCounterFilterFactory {\n    constructor(callCounter){\n        this.callCounter = callCounter;\n    }\n    createFilter(callStream) {\n        return new OutlierDetectionCounterFilter(this.callCounter);\n    }\n}\nclass OutlierDetectionPicker {\n    constructor(wrappedPicker, countCalls){\n        this.wrappedPicker = wrappedPicker;\n        this.countCalls = countCalls;\n    }\n    pick(pickArgs) {\n        const wrappedPick = this.wrappedPicker.pick(pickArgs);\n        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {\n            const subchannelWrapper = wrappedPick.subchannel;\n            const mapEntry = subchannelWrapper.getMapEntry();\n            if (mapEntry) {\n                const extraFilterFactories = [\n                    ...wrappedPick.extraFilterFactories\n                ];\n                if (this.countCalls) {\n                    extraFilterFactories.push(new OutlierDetectionCounterFilterFactory(mapEntry.counter));\n                }\n                return Object.assign(Object.assign({}, wrappedPick), {\n                    subchannel: subchannelWrapper.getWrappedSubchannel(),\n                    extraFilterFactories: extraFilterFactories\n                });\n            } else {\n                return Object.assign(Object.assign({}, wrappedPick), {\n                    subchannel: subchannelWrapper.getWrappedSubchannel()\n                });\n            }\n        } else {\n            return wrappedPick;\n        }\n    }\n}\nclass OutlierDetectionLoadBalancer {\n    constructor(channelControlHelper){\n        this.addressMap = new Map();\n        this.latestConfig = null;\n        this.timerStartTime = null;\n        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler(experimental_1.createChildChannelControlHelper(channelControlHelper, {\n            createSubchannel: (subchannelAddress, subchannelArgs)=>{\n                const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n                const mapEntry = this.addressMap.get(subchannel_address_1.subchannelAddressToString(subchannelAddress));\n                const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);\n                if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {\n                    // If the address is ejected, propagate that to the new subchannel wrapper\n                    subchannelWrapper.eject();\n                }\n                mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);\n                return subchannelWrapper;\n            },\n            updateState: (connectivityState, picker)=>{\n                if (connectivityState === connectivity_state_1.ConnectivityState.READY) {\n                    channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));\n                } else {\n                    channelControlHelper.updateState(connectivityState, picker);\n                }\n            }\n        }));\n        this.ejectionTimer = setInterval(()=>{}, 0);\n        clearInterval(this.ejectionTimer);\n    }\n    isCountingEnabled() {\n        return this.latestConfig !== null && (this.latestConfig.getSuccessRateEjectionConfig() !== null || this.latestConfig.getFailurePercentageEjectionConfig() !== null);\n    }\n    getCurrentEjectionPercent() {\n        let ejectionCount = 0;\n        for (const mapEntry of this.addressMap.values()){\n            if (mapEntry.currentEjectionTimestamp !== null) {\n                ejectionCount += 1;\n            }\n        }\n        return ejectionCount * 100 / this.addressMap.size;\n    }\n    runSuccessRateCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();\n        if (!successRateConfig) {\n            return;\n        }\n        trace(\"Running success rate check\");\n        // Step 1\n        const targetRequestVolume = successRateConfig.request_volume;\n        let addresesWithTargetVolume = 0;\n        const successRates = [];\n        for (const mapEntry of this.addressMap.values()){\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= targetRequestVolume) {\n                addresesWithTargetVolume += 1;\n                successRates.push(successes / (successes + failures));\n            }\n        }\n        trace(\"Found \" + addresesWithTargetVolume + \" success rate candidates; currentEjectionPercent=\" + this.getCurrentEjectionPercent() + \" successRates=[\" + successRates + \"]\");\n        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        const successRateMean = successRates.reduce((a, b)=>a + b) / successRates.length;\n        let successRateDeviationSum = 0;\n        for (const rate of successRates){\n            const deviation = rate - successRateMean;\n            successRateDeviationSum += deviation * deviation;\n        }\n        const successRateVariance = successRateDeviationSum / successRates.length;\n        const successRateStdev = Math.sqrt(successRateVariance);\n        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1000);\n        trace(\"stdev=\" + successRateStdev + \" ejectionThreshold=\" + ejectionThreshold);\n        // Step 3\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            // Step 3.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 3.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures < targetRequestVolume) {\n                continue;\n            }\n            // Step 3.iii\n            const successRate = successes / (successes + failures);\n            trace(\"Checking candidate \" + address + \" successRate=\" + successRate);\n            if (successRate < ejectionThreshold) {\n                const randomNumber = Math.random() * 100;\n                trace(\"Candidate \" + address + \" randomNumber=\" + randomNumber + \" enforcement_percentage=\" + successRateConfig.enforcement_percentage);\n                if (randomNumber < successRateConfig.enforcement_percentage) {\n                    trace(\"Ejecting candidate \" + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    runFailurePercentageCheck(ejectionTimestamp) {\n        if (!this.latestConfig) {\n            return;\n        }\n        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();\n        if (!failurePercentageConfig) {\n            return;\n        }\n        trace(\"Running failure percentage check. threshold=\" + failurePercentageConfig.threshold + \" request volume threshold=\" + failurePercentageConfig.request_volume);\n        // Step 1\n        let addressesWithTargetVolume = 0;\n        for (const mapEntry of this.addressMap.values()){\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            if (successes + failures >= failurePercentageConfig.request_volume) {\n                addressesWithTargetVolume += 1;\n            }\n        }\n        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {\n            return;\n        }\n        // Step 2\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            // Step 2.i\n            if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {\n                break;\n            }\n            // Step 2.ii\n            const successes = mapEntry.counter.getLastSuccesses();\n            const failures = mapEntry.counter.getLastFailures();\n            trace(\"Candidate successes=\" + successes + \" failures=\" + failures);\n            if (successes + failures < failurePercentageConfig.request_volume) {\n                continue;\n            }\n            // Step 2.iii\n            const failurePercentage = failures * 100 / (failures + successes);\n            if (failurePercentage > failurePercentageConfig.threshold) {\n                const randomNumber = Math.random() * 100;\n                trace(\"Candidate \" + address + \" randomNumber=\" + randomNumber + \" enforcement_percentage=\" + failurePercentageConfig.enforcement_percentage);\n                if (randomNumber < failurePercentageConfig.enforcement_percentage) {\n                    trace(\"Ejecting candidate \" + address);\n                    this.eject(mapEntry, ejectionTimestamp);\n                }\n            }\n        }\n    }\n    eject(mapEntry, ejectionTimestamp) {\n        mapEntry.currentEjectionTimestamp = new Date();\n        mapEntry.ejectionTimeMultiplier += 1;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers){\n            subchannelWrapper.eject();\n        }\n    }\n    uneject(mapEntry) {\n        mapEntry.currentEjectionTimestamp = null;\n        for (const subchannelWrapper of mapEntry.subchannelWrappers){\n            subchannelWrapper.uneject();\n        }\n    }\n    switchAllBuckets() {\n        for (const mapEntry of this.addressMap.values()){\n            mapEntry.counter.switchBuckets();\n        }\n    }\n    startTimer(delayMs) {\n        this.ejectionTimer = setTimeout(()=>this.runChecks(), delayMs);\n    }\n    runChecks() {\n        const ejectionTimestamp = new Date();\n        trace(\"Ejection timer running\");\n        this.switchAllBuckets();\n        if (!this.latestConfig) {\n            return;\n        }\n        this.timerStartTime = ejectionTimestamp;\n        this.startTimer(this.latestConfig.getIntervalMs());\n        this.runSuccessRateCheck(ejectionTimestamp);\n        this.runFailurePercentageCheck(ejectionTimestamp);\n        for (const [address, mapEntry] of this.addressMap.entries()){\n            if (mapEntry.currentEjectionTimestamp === null) {\n                if (mapEntry.ejectionTimeMultiplier > 0) {\n                    mapEntry.ejectionTimeMultiplier -= 1;\n                }\n            } else {\n                const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();\n                const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();\n                const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());\n                returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));\n                if (returnTime < new Date()) {\n                    trace(\"Unejecting \" + address);\n                    this.uneject(mapEntry);\n                }\n            }\n        }\n    }\n    updateAddressList(addressList, lbConfig, attributes) {\n        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {\n            return;\n        }\n        const subchannelAddresses = new Set();\n        for (const address of addressList){\n            subchannelAddresses.add(subchannel_address_1.subchannelAddressToString(address));\n        }\n        for (const address of subchannelAddresses){\n            if (!this.addressMap.has(address)) {\n                trace(\"Adding map entry for \" + address);\n                this.addressMap.set(address, {\n                    counter: new CallCounter(),\n                    currentEjectionTimestamp: null,\n                    ejectionTimeMultiplier: 0,\n                    subchannelWrappers: []\n                });\n            }\n        }\n        for (const key of this.addressMap.keys()){\n            if (!subchannelAddresses.has(key)) {\n                trace(\"Removing map entry for \" + key);\n                this.addressMap.delete(key);\n            }\n        }\n        const childPolicy = load_balancer_1.getFirstUsableConfig(lbConfig.getChildPolicy(), true);\n        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);\n        if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {\n            if (this.timerStartTime) {\n                trace(\"Previous timer existed. Replacing timer\");\n                clearTimeout(this.ejectionTimer);\n                const remainingDelay = lbConfig.getIntervalMs() - (new Date().getTime() - this.timerStartTime.getTime());\n                this.startTimer(remainingDelay);\n            } else {\n                trace(\"Starting new timer\");\n                this.timerStartTime = new Date();\n                this.startTimer(lbConfig.getIntervalMs());\n                this.switchAllBuckets();\n            }\n        } else {\n            trace(\"Counting disabled. Cancelling timer.\");\n            this.timerStartTime = null;\n            clearTimeout(this.ejectionTimer);\n            for (const mapEntry of this.addressMap.values()){\n                this.uneject(mapEntry);\n                mapEntry.ejectionTimeMultiplier = 0;\n            }\n        }\n        this.latestConfig = lbConfig;\n    }\n    exitIdle() {\n        this.childBalancer.exitIdle();\n    }\n    resetBackoff() {\n        this.childBalancer.resetBackoff();\n    }\n    destroy() {\n        clearTimeout(this.ejectionTimer);\n        this.childBalancer.destroy();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;\nfunction setup() {\n    if (OUTLIER_DETECTION_ENABLED) {\n        experimental_1.registerLoadBalancerType(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);\n    }\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-outlier-detection.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELElBQUlBO0FBQ0pDLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxhQUFhLEdBQUdBLG9DQUFvQyxHQUFHQSwyQ0FBMkMsR0FBRyxLQUFLO0FBQzFHLE1BQU1LLHVCQUF1QkMsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1FLGFBQWFGLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1HLGlCQUFpQkgsbUJBQU9BLENBQUMsb0ZBQWdCO0FBQy9DLE1BQU1JLFdBQVdKLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1LLGtCQUFrQkwsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1NLGdDQUFnQ04sbUJBQU9BLENBQUMsa0hBQStCO0FBQzdFLE1BQU1PLFdBQVdQLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1RLHVCQUF1QlIsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1TLHlCQUF5QlQsbUJBQU9BLENBQUMsb0dBQXdCO0FBQy9ELE1BQU1VLFVBQVVWLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1XLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmSCxRQUFRRSxLQUFLLENBQUNYLFlBQVlhLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBLE1BQU1HLFlBQVk7QUFDbEIsTUFBTUMsNEJBQTRCLENBQUMsQ0FBQzFCLEtBQUsyQixRQUFRQyxHQUFHLENBQUNDLDBDQUEwQyxNQUFNLFFBQVE3QixPQUFPLEtBQUssSUFBSUEsS0FBSyxNQUFLLE1BQU87QUFDOUksTUFBTThCLG1DQUFtQztJ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azovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9sb2FkLWJhbGFuY2VyLW91dGxpZXItZGV0ZWN0aW9uLmpzPzAwNmEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjIgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbnZhciBfYTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0dXAgPSBleHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIgPSBleHBvcnRzLk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnID0gdm9pZCAwO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IGR1cmF0aW9uXzEgPSByZXF1aXJlKFwiLi9kdXJhdGlvblwiKTtcbmNvbnN0IGV4cGVyaW1lbnRhbF8xID0gcmVxdWlyZShcIi4vZXhwZXJpbWVudGFsXCIpO1xuY29uc3QgZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJcIik7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3QgbG9hZF9iYWxhbmNlcl9jaGlsZF9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyLWNoaWxkLWhhbmRsZXJcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9pbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtaW50ZXJmYWNlXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdvdXRsaWVyX2RldGVjdGlvbic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICdvdXRsaWVyX2RldGVjdGlvbic7XG5jb25zdCBPVVRMSUVSX0RFVEVDVElPTl9FTkFCTEVEID0gKChfYSA9IHByb2Nlc3MuZW52LkdSUENfRVhQRVJJTUVOVEFMX0VOQUJMRV9PVVRMSUVSX0RFVEVDVElPTikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ3RydWUnKSA9PT0gJ3RydWUnO1xuY29uc3QgZGVmYXVsdFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcgPSB7XG4gICAgc3RkZXZfZmFjdG9yOiAxOTAwLFxuICAgIGVuZm9yY2VtZW50X3BlcmNlbnRhZ2U6IDEwMCxcbiAgICBtaW5pbXVtX2hvc3RzOiA1LFxuICAgIHJlcXVlc3Rfdm9sdW1lOiAxMDBcbn07XG5jb25zdCBkZWZhdWx0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZyA9IHtcbiAgICB0aHJlc2hvbGQ6IDg1LFxuICAgIGVuZm9yY2VtZW50X3BlcmNlbnRhZ2U6IDEwMCxcbiAgICBtaW5pbXVtX2hvc3RzOiA1LFxuICAgIHJlcXVlc3Rfdm9sdW1lOiA1MFxufTtcbmZ1bmN0aW9uIHZhbGlkYXRlRmllbGRUeXBlKG9iaiwgZmllbGROYW1lLCBleHBlY3RlZFR5cGUsIG9iamVjdE5hbWUpIHtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaiAmJiB0eXBlb2Ygb2JqW2ZpZWxkTmFtZV0gIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICBjb25zdCBmdWxsRmllbGROYW1lID0gb2JqZWN0TmFtZSA/IGAke29iamVjdE5hbWV9LiR7ZmllbGROYW1lfWAgOiBmaWVsZE5hbWU7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IGV4cGVjdGVkICR7ZXhwZWN0ZWRUeXBlfSwgZ290ICR7dHlwZW9mIG9ialtmaWVsZE5hbWVdfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9zaXRpdmVEdXJhdGlvbihvYmosIGZpZWxkTmFtZSwgb2JqZWN0TmFtZSkge1xuICAgIGNvbnN0IGZ1bGxGaWVsZE5hbWUgPSBvYmplY3ROYW1lID8gYCR7b2JqZWN0TmFtZX0uJHtmaWVsZE5hbWV9YCA6IGZpZWxkTmFtZTtcbiAgICBpZiAoZmllbGROYW1lIGluIG9iaikge1xuICAgICAgICBpZiAoIWR1cmF0aW9uXzEuaXNEdXJhdGlvbihvYmpbZmllbGROYW1lXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0bGllciBkZXRlY3Rpb24gY29uZmlnICR7ZnVsbEZpZWxkTmFtZX0gcGFyc2UgZXJyb3I6IGV4cGVjdGVkIER1cmF0aW9uLCBnb3QgJHt0eXBlb2Ygb2JqW2ZpZWxkTmFtZV19YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEob2JqW2ZpZWxkTmFtZV0uc2Vjb25kcyA+PSAwICYmIG9ialtmaWVsZE5hbWVdLnNlY29uZHMgPD0gMzE1NTc2MDAwMDAwICYmIG9ialtmaWVsZE5hbWVdLm5hbm9zID49IDAgJiYgb2JqW2ZpZWxkTmFtZV0ubmFub3MgPD0gOTk5OTk5OTk5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogdmFsdWVzIG91dCBvZiByYW5nZSBmb3Igbm9uLW5lZ2F0aXZlIER1YXJhdGlvbmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVQZXJjZW50YWdlKG9iaiwgZmllbGROYW1lLCBvYmplY3ROYW1lKSB7XG4gICAgY29uc3QgZnVsbEZpZWxkTmFtZSA9IG9iamVjdE5hbWUgPyBgJHtvYmplY3ROYW1lfS4ke2ZpZWxkTmFtZX1gIDogZmllbGROYW1lO1xuICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iaiwgZmllbGROYW1lLCAnbnVtYmVyJywgb2JqZWN0TmFtZSk7XG4gICAgaWYgKGZpZWxkTmFtZSBpbiBvYmogJiYgIShvYmpbZmllbGROYW1lXSA+PSAwICYmIG9ialtmaWVsZE5hbWVdIDw9IDEwMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgJHtmdWxsRmllbGROYW1lfSBwYXJzZSBlcnJvcjogdmFsdWUgb3V0IG9mIHJhbmdlIGZvciBwZXJjZW50YWdlICgwLTEwMClgKTtcbiAgICB9XG59XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoaW50ZXJ2YWxNcywgYmFzZUVqZWN0aW9uVGltZU1zLCBtYXhFamVjdGlvblRpbWVNcywgbWF4RWplY3Rpb25QZXJjZW50LCBzdWNjZXNzUmF0ZUVqZWN0aW9uLCBmYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uLCBjaGlsZFBvbGljeSkge1xuICAgICAgICB0aGlzLmNoaWxkUG9saWN5ID0gY2hpbGRQb2xpY3k7XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxNcyA9IGludGVydmFsTXMgIT09IG51bGwgJiYgaW50ZXJ2YWxNcyAhPT0gdm9pZCAwID8gaW50ZXJ2YWxNcyA6IDEwMDAwO1xuICAgICAgICB0aGlzLmJhc2VFamVjdGlvblRpbWVNcyA9IGJhc2VFamVjdGlvblRpbWVNcyAhPT0gbnVsbCAmJiBiYXNlRWplY3Rpb25UaW1lTXMgIT09IHZvaWQgMCA/IGJhc2VFamVjdGlvblRpbWVNcyA6IDMwMDAwO1xuICAgICAgICB0aGlzLm1heEVqZWN0aW9uVGltZU1zID0gbWF4RWplY3Rpb25UaW1lTXMgIT09IG51bGwgJiYgbWF4RWplY3Rpb25UaW1lTXMgIT09IHZvaWQgMCA/IG1heEVqZWN0aW9uVGltZU1zIDogMzAwMDAwO1xuICAgICAgICB0aGlzLm1heEVqZWN0aW9uUGVyY2VudCA9IG1heEVqZWN0aW9uUGVyY2VudCAhPT0gbnVsbCAmJiBtYXhFamVjdGlvblBlcmNlbnQgIT09IHZvaWQgMCA/IG1heEVqZWN0aW9uUGVyY2VudCA6IDEwO1xuICAgICAgICB0aGlzLnN1Y2Nlc3NSYXRlRWplY3Rpb24gPSBzdWNjZXNzUmF0ZUVqZWN0aW9uID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZyksIHN1Y2Nlc3NSYXRlRWplY3Rpb24pIDogbnVsbDtcbiAgICAgICAgdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uID0gZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWcpLCBmYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uKSA6IG51bGw7XG4gICAgfVxuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIHRvSnNvbk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGludGVydmFsOiBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbih0aGlzLmludGVydmFsTXMpLFxuICAgICAgICAgICAgYmFzZV9lamVjdGlvbl90aW1lOiBkdXJhdGlvbl8xLm1zVG9EdXJhdGlvbih0aGlzLmJhc2VFamVjdGlvblRpbWVNcyksXG4gICAgICAgICAgICBtYXhfZWplY3Rpb25fdGltZTogZHVyYXRpb25fMS5tc1RvRHVyYXRpb24odGhpcy5tYXhFamVjdGlvblRpbWVNcyksXG4gICAgICAgICAgICBtYXhfZWplY3Rpb25fcGVyY2VudDogdGhpcy5tYXhFamVjdGlvblBlcmNlbnQsXG4gICAgICAgICAgICBzdWNjZXNzX3JhdGVfZWplY3Rpb246IHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbixcbiAgICAgICAgICAgIGZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbjogdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uLFxuICAgICAgICAgICAgY2hpbGRfcG9saWN5OiB0aGlzLmNoaWxkUG9saWN5Lm1hcChwb2xpY3kgPT4gcG9saWN5LnRvSnNvbk9iamVjdCgpKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRJbnRlcnZhbE1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbE1zO1xuICAgIH1cbiAgICBnZXRCYXNlRWplY3Rpb25UaW1lTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VFamVjdGlvblRpbWVNcztcbiAgICB9XG4gICAgZ2V0TWF4RWplY3Rpb25UaW1lTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heEVqZWN0aW9uVGltZU1zO1xuICAgIH1cbiAgICBnZXRNYXhFamVjdGlvblBlcmNlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1heEVqZWN0aW9uUGVyY2VudDtcbiAgICB9XG4gICAgZ2V0U3VjY2Vzc1JhdGVFamVjdGlvbkNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbjtcbiAgICB9XG4gICAgZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbjtcbiAgICB9XG4gICAgZ2V0Q2hpbGRQb2xpY3koKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkUG9saWN5O1xuICAgIH1cbiAgICBjb3B5V2l0aENoaWxkUG9saWN5KGNoaWxkUG9saWN5KSB7XG4gICAgICAgIHJldHVybiBuZXcgT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcodGhpcy5pbnRlcnZhbE1zLCB0aGlzLmJhc2VFamVjdGlvblRpbWVNcywgdGhpcy5tYXhFamVjdGlvblRpbWVNcywgdGhpcy5tYXhFamVjdGlvblBlcmNlbnQsIHRoaXMuc3VjY2Vzc1JhdGVFamVjdGlvbiwgdGhpcy5mYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uLCBjaGlsZFBvbGljeSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24ob2JqLCAnaW50ZXJ2YWwnKTtcbiAgICAgICAgdmFsaWRhdGVQb3NpdGl2ZUR1cmF0aW9uKG9iaiwgJ2Jhc2VfZWplY3Rpb25fdGltZScpO1xuICAgICAgICB2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24ob2JqLCAnbWF4X2VqZWN0aW9uX3RpbWUnKTtcbiAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iaiwgJ21heF9lamVjdGlvbl9wZXJjZW50Jyk7XG4gICAgICAgIGlmICgnc3VjY2Vzc19yYXRlX2VqZWN0aW9uJyBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ291dGxpZXIgZGV0ZWN0aW9uIGNvbmZpZyBzdWNjZXNzX3JhdGVfZWplY3Rpb24gbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdzdGRldl9mYWN0b3InLCAnbnVtYmVyJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVQZXJjZW50YWdlKG9iai5zdWNjZXNzX3JhdGVfZWplY3Rpb24sICdlbmZvcmNlbWVudF9wZXJjZW50YWdlJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ21pbmltdW1faG9zdHMnLCAnbnVtYmVyJywgJ3N1Y2Nlc3NfcmF0ZV9lamVjdGlvbicpO1xuICAgICAgICAgICAgdmFsaWRhdGVGaWVsZFR5cGUob2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgJ3JlcXVlc3Rfdm9sdW1lJywgJ251bWJlcicsICdzdWNjZXNzX3JhdGVfZWplY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2ZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbicgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRsaWVyIGRldGVjdGlvbiBjb25maWcgZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxpZGF0ZVBlcmNlbnRhZ2Uob2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgJ3RocmVzaG9sZCcsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcbiAgICAgICAgICAgIHZhbGlkYXRlUGVyY2VudGFnZShvYmouZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uLCAnZW5mb3JjZW1lbnRfcGVyY2VudGFnZScsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICdtaW5pbXVtX2hvc3RzJywgJ251bWJlcicsICdmYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24nKTtcbiAgICAgICAgICAgIHZhbGlkYXRlRmllbGRUeXBlKG9iai5mYWlsdXJlX3BlcmNlbnRhZ2VfZWplY3Rpb24sICdyZXF1ZXN0X3ZvbHVtZScsICdudW1iZXInLCAnZmFpbHVyZV9wZXJjZW50YWdlX2VqZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyhvYmouaW50ZXJ2YWwgPyBkdXJhdGlvbl8xLmR1cmF0aW9uVG9NcyhvYmouaW50ZXJ2YWwpIDogbnVsbCwgb2JqLmJhc2VfZWplY3Rpb25fdGltZSA/IGR1cmF0aW9uXzEuZHVyYXRpb25Ub01zKG9iai5iYXNlX2VqZWN0aW9uX3RpbWUpIDogbnVsbCwgb2JqLm1heF9lamVjdGlvbl90aW1lID8gZHVyYXRpb25fMS5kdXJhdGlvblRvTXMob2JqLm1heF9lamVjdGlvbl90aW1lKSA6IG51bGwsIChfYSA9IG9iai5tYXhfZWplY3Rpb25fcGVyY2VudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCwgb2JqLnN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiwgb2JqLmZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiwgb2JqLmNoaWxkX3BvbGljeS5tYXAobG9hZF9iYWxhbmNlcl8xLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZykpO1xuICAgIH1cbn1cbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNpbmdDb25maWcgPSBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZztcbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25TdWJjaGFubmVsV3JhcHBlciBleHRlbmRzIHN1YmNoYW5uZWxfaW50ZXJmYWNlXzEuQmFzZVN1YmNoYW5uZWxXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZFN1YmNoYW5uZWwsIG1hcEVudHJ5KSB7XG4gICAgICAgIHN1cGVyKGNoaWxkU3ViY2hhbm5lbCk7XG4gICAgICAgIHRoaXMubWFwRW50cnkgPSBtYXBFbnRyeTtcbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmVqZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWZDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuY2hpbGRTdWJjaGFubmVsU3RhdGUgPSBjaGlsZFN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcbiAgICAgICAgY2hpbGRTdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIoKHN1YmNoYW5uZWwsIHByZXZpb3VzU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWplY3RlZCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcih0aGlzLCBwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgd3JhcHBlcidzXG4gICAgICogY29ubmVjdGl2aXR5IHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICovXG4gICAgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnN0YXRlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBsaXN0ZW5lciBwcmV2aW91c2x5IGFkZGVkIHdpdGggYGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIEEgcmVmZXJlbmNlIHRvIGEgZnVuY3Rpb24gcHJldmlvdXNseSBwYXNzZWQgdG9cbiAgICAgKiAgICAgYGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXJgXG4gICAgICovXG4gICAgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lckluZGV4ID0gdGhpcy5zdGF0ZUxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgaWYgKGxpc3RlbmVySW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5zcGxpY2UobGlzdGVuZXJJbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnJlZigpO1xuICAgICAgICB0aGlzLnJlZkNvdW50ICs9IDE7XG4gICAgfVxuICAgIHVucmVmKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnVucmVmKCk7XG4gICAgICAgIHRoaXMucmVmQ291bnQgLT0gMTtcbiAgICAgICAgaWYgKHRoaXMucmVmQ291bnQgPD0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWFwRW50cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzLmluZGV4T2YodGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBFbnRyeS5zdWJjaGFubmVsV3JhcHBlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWplY3QoKSB7XG4gICAgICAgIHRoaXMuZWplY3RlZCA9IHRydWU7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5zdGF0ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgdGhpcy5jaGlsZFN1YmNoYW5uZWxTdGF0ZSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVuZWplY3QoKSB7XG4gICAgICAgIHRoaXMuZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuc3RhdGVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHRoaXMsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCB0aGlzLmNoaWxkU3ViY2hhbm5lbFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRNYXBFbnRyeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwRW50cnk7XG4gICAgfVxuICAgIGdldFdyYXBwZWRTdWJjaGFubmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eUJ1Y2tldCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiAwLFxuICAgICAgICBmYWlsdXJlOiAwXG4gICAgfTtcbn1cbmNsYXNzIENhbGxDb3VudGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVCdWNrZXQgPSBjcmVhdGVFbXB0eUJ1Y2tldCgpO1xuICAgICAgICB0aGlzLmluYWN0aXZlQnVja2V0ID0gY3JlYXRlRW1wdHlCdWNrZXQoKTtcbiAgICB9XG4gICAgYWRkU3VjY2VzcygpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVCdWNrZXQuc3VjY2VzcyArPSAxO1xuICAgIH1cbiAgICBhZGRGYWlsdXJlKCkge1xuICAgICAgICB0aGlzLmFjdGl2ZUJ1Y2tldC5mYWlsdXJlICs9IDE7XG4gICAgfVxuICAgIHN3aXRjaEJ1Y2tldHMoKSB7XG4gICAgICAgIHRoaXMuaW5hY3RpdmVCdWNrZXQgPSB0aGlzLmFjdGl2ZUJ1Y2tldDtcbiAgICAgICAgdGhpcy5hY3RpdmVCdWNrZXQgPSBjcmVhdGVFbXB0eUJ1Y2tldCgpO1xuICAgIH1cbiAgICBnZXRMYXN0U3VjY2Vzc2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmFjdGl2ZUJ1Y2tldC5zdWNjZXNzO1xuICAgIH1cbiAgICBnZXRMYXN0RmFpbHVyZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluYWN0aXZlQnVja2V0LmZhaWx1cmU7XG4gICAgfVxufVxuY2xhc3MgT3V0bGllckRldGVjdGlvbkNvdW50ZXJGaWx0ZXIgZXh0ZW5kcyBmaWx0ZXJfMS5CYXNlRmlsdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsQ291bnRlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhbGxDb3VudGVyID0gY2FsbENvdW50ZXI7XG4gICAgfVxuICAgIHJlY2VpdmVUcmFpbGVycyhzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbENvdW50ZXIuYWRkU3VjY2VzcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYWxsQ291bnRlci5hZGRGYWlsdXJlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG59XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uQ291bnRlckZpbHRlckZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNhbGxDb3VudGVyKSB7XG4gICAgICAgIHRoaXMuY2FsbENvdW50ZXIgPSBjYWxsQ291bnRlcjtcbiAgICB9XG4gICAgY3JlYXRlRmlsdGVyKGNhbGxTdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPdXRsaWVyRGV0ZWN0aW9uQ291bnRlckZpbHRlcih0aGlzLmNhbGxDb3VudGVyKTtcbiAgICB9XG59XG5jbGFzcyBPdXRsaWVyRGV0ZWN0aW9uUGlja2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih3cmFwcGVkUGlja2VyLCBjb3VudENhbGxzKSB7XG4gICAgICAgIHRoaXMud3JhcHBlZFBpY2tlciA9IHdyYXBwZWRQaWNrZXI7XG4gICAgICAgIHRoaXMuY291bnRDYWxscyA9IGNvdW50Q2FsbHM7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgY29uc3Qgd3JhcHBlZFBpY2sgPSB0aGlzLndyYXBwZWRQaWNrZXIucGljayhwaWNrQXJncyk7XG4gICAgICAgIGlmICh3cmFwcGVkUGljay5waWNrUmVzdWx0VHlwZSA9PT0gcGlja2VyXzEuUGlja1Jlc3VsdFR5cGUuQ09NUExFVEUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyID0gd3JhcHBlZFBpY2suc3ViY2hhbm5lbDtcbiAgICAgICAgICAgIGNvbnN0IG1hcEVudHJ5ID0gc3ViY2hhbm5lbFdyYXBwZXIuZ2V0TWFwRW50cnkoKTtcbiAgICAgICAgICAgIGlmIChtYXBFbnRyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhRmlsdGVyRmFjdG9yaWVzID0gWy4uLndyYXBwZWRQaWNrLmV4dHJhRmlsdGVyRmFjdG9yaWVzXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudENhbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhRmlsdGVyRmFjdG9yaWVzLnB1c2gobmV3IE91dGxpZXJEZXRlY3Rpb25Db3VudGVyRmlsdGVyRmFjdG9yeShtYXBFbnRyeS5jb3VudGVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHdyYXBwZWRQaWNrKSwgeyBzdWJjaGFubmVsOiBzdWJjaGFubmVsV3JhcHBlci5nZXRXcmFwcGVkU3ViY2hhbm5lbCgpLCBleHRyYUZpbHRlckZhY3RvcmllczogZXh0cmFGaWx0ZXJGYWN0b3JpZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cmFwcGVkUGljayksIHsgc3ViY2hhbm5lbDogc3ViY2hhbm5lbFdyYXBwZXIuZ2V0V3JhcHBlZFN1YmNoYW5uZWwoKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVkUGljaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuYWRkcmVzc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBudWxsO1xuICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZEJhbGFuY2VyID0gbmV3IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlcihleHBlcmltZW50YWxfMS5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKGNoYW5uZWxDb250cm9sSGVscGVyLCB7XG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsOiAoc3ViY2hhbm5lbEFkZHJlc3MsIHN1YmNoYW5uZWxBcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxTdWJjaGFubmVsID0gY2hhbm5lbENvbnRyb2xIZWxwZXIuY3JlYXRlU3ViY2hhbm5lbChzdWJjaGFubmVsQWRkcmVzcywgc3ViY2hhbm5lbEFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcEVudHJ5ID0gdGhpcy5hZGRyZXNzTWFwLmdldChzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKHN1YmNoYW5uZWxBZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgPSBuZXcgT3V0bGllckRldGVjdGlvblN1YmNoYW5uZWxXcmFwcGVyKG9yaWdpbmFsU3ViY2hhbm5lbCwgbWFwRW50cnkpO1xuICAgICAgICAgICAgICAgIGlmICgobWFwRW50cnkgPT09IG51bGwgfHwgbWFwRW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFkZHJlc3MgaXMgZWplY3RlZCwgcHJvcGFnYXRlIHRoYXQgdG8gdGhlIG5ldyBzdWJjaGFubmVsIHdyYXBwZXJcbiAgICAgICAgICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRW50cnkgPT09IG51bGwgfHwgbWFwRW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycy5wdXNoKHN1YmNoYW5uZWxXcmFwcGVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ViY2hhbm5lbFdyYXBwZXI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgbmV3IE91dGxpZXJEZXRlY3Rpb25QaWNrZXIocGlja2VyLCB0aGlzLmlzQ291bnRpbmdFbmFibGVkKCkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxDb250cm9sSGVscGVyLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVqZWN0aW9uVGltZXIgPSBzZXRJbnRlcnZhbCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgfVxuICAgIGlzQ291bnRpbmdFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRlc3RDb25maWcgIT09IG51bGwgJiZcbiAgICAgICAgICAgICh0aGlzLmxhdGVzdENvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCkgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdENvbmZpZy5nZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCkgIT09IG51bGwpO1xuICAgIH1cbiAgICBnZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkge1xuICAgICAgICBsZXQgZWplY3Rpb25Db3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAobWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWplY3Rpb25Db3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZWplY3Rpb25Db3VudCAqIDEwMCkgLyB0aGlzLmFkZHJlc3NNYXAuc2l6ZTtcbiAgICB9XG4gICAgcnVuU3VjY2Vzc1JhdGVDaGVjayhlamVjdGlvblRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoIXRoaXMubGF0ZXN0Q29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVDb25maWcgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRTdWNjZXNzUmF0ZUVqZWN0aW9uQ29uZmlnKCk7XG4gICAgICAgIGlmICghc3VjY2Vzc1JhdGVDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZSgnUnVubmluZyBzdWNjZXNzIHJhdGUgY2hlY2snKTtcbiAgICAgICAgLy8gU3RlcCAxXG4gICAgICAgIGNvbnN0IHRhcmdldFJlcXVlc3RWb2x1bWUgPSBzdWNjZXNzUmF0ZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZTtcbiAgICAgICAgbGV0IGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSA9IDA7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgZmFpbHVyZXMgPj0gdGFyZ2V0UmVxdWVzdFZvbHVtZSkge1xuICAgICAgICAgICAgICAgIGFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSArPSAxO1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3NSYXRlcy5wdXNoKHN1Y2Nlc3NlcyAvIChzdWNjZXNzZXMgKyBmYWlsdXJlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdGb3VuZCAnICsgYWRkcmVzZXNXaXRoVGFyZ2V0Vm9sdW1lICsgJyBzdWNjZXNzIHJhdGUgY2FuZGlkYXRlczsgY3VycmVudEVqZWN0aW9uUGVyY2VudD0nICsgdGhpcy5nZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkgKyAnIHN1Y2Nlc3NSYXRlcz1bJyArIHN1Y2Nlc3NSYXRlcyArICddJyk7XG4gICAgICAgIGlmIChhZGRyZXNlc1dpdGhUYXJnZXRWb2x1bWUgPCBzdWNjZXNzUmF0ZUNvbmZpZy5taW5pbXVtX2hvc3RzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RlcCAyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlTWVhbiA9IHN1Y2Nlc3NSYXRlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiKSAvIHN1Y2Nlc3NSYXRlcy5sZW5ndGg7XG4gICAgICAgIGxldCBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcmF0ZSBvZiBzdWNjZXNzUmF0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRldmlhdGlvbiA9IHJhdGUgLSBzdWNjZXNzUmF0ZU1lYW47XG4gICAgICAgICAgICBzdWNjZXNzUmF0ZURldmlhdGlvblN1bSArPSBkZXZpYXRpb24gKiBkZXZpYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVWYXJpYW5jZSA9IHN1Y2Nlc3NSYXRlRGV2aWF0aW9uU3VtIC8gc3VjY2Vzc1JhdGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1JhdGVTdGRldiA9IE1hdGguc3FydChzdWNjZXNzUmF0ZVZhcmlhbmNlKTtcbiAgICAgICAgY29uc3QgZWplY3Rpb25UaHJlc2hvbGQgPSBzdWNjZXNzUmF0ZU1lYW4gLSBzdWNjZXNzUmF0ZVN0ZGV2ICogKHN1Y2Nlc3NSYXRlQ29uZmlnLnN0ZGV2X2ZhY3RvciAvIDEwMDApO1xuICAgICAgICB0cmFjZSgnc3RkZXY9JyArIHN1Y2Nlc3NSYXRlU3RkZXYgKyAnIGVqZWN0aW9uVGhyZXNob2xkPScgKyBlamVjdGlvblRocmVzaG9sZCk7XG4gICAgICAgIC8vIFN0ZXAgM1xuICAgICAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBtYXBFbnRyeV0gb2YgdGhpcy5hZGRyZXNzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgLy8gU3RlcCAzLmlcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEN1cnJlbnRFamVjdGlvblBlcmNlbnQoKSA+PSB0aGlzLmxhdGVzdENvbmZpZy5nZXRNYXhFamVjdGlvblBlcmNlbnQoKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3RlcCAzLmlpXG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyBmYWlsdXJlcyA8IHRhcmdldFJlcXVlc3RWb2x1bWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMy5paWlcbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3NSYXRlID0gc3VjY2Vzc2VzIC8gKHN1Y2Nlc3NlcyArIGZhaWx1cmVzKTtcbiAgICAgICAgICAgIHRyYWNlKCdDaGVja2luZyBjYW5kaWRhdGUgJyArIGFkZHJlc3MgKyAnIHN1Y2Nlc3NSYXRlPScgKyBzdWNjZXNzUmF0ZSk7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzc1JhdGUgPCBlamVjdGlvblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmRvbU51bWJlciA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ0NhbmRpZGF0ZSAnICsgYWRkcmVzcyArICcgcmFuZG9tTnVtYmVyPScgKyByYW5kb21OdW1iZXIgKyAnIGVuZm9yY2VtZW50X3BlcmNlbnRhZ2U9JyArIHN1Y2Nlc3NSYXRlQ29uZmlnLmVuZm9yY2VtZW50X3BlcmNlbnRhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChyYW5kb21OdW1iZXIgPCBzdWNjZXNzUmF0ZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNlKCdFamVjdGluZyBjYW5kaWRhdGUgJyArIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVqZWN0KG1hcEVudHJ5LCBlamVjdGlvblRpbWVzdGFtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJ1bkZhaWx1cmVQZXJjZW50YWdlQ2hlY2soZWplY3Rpb25UaW1lc3RhbXApIHtcbiAgICAgICAgaWYgKCF0aGlzLmxhdGVzdENvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnID0gdGhpcy5sYXRlc3RDb25maWcuZ2V0RmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbkNvbmZpZygpO1xuICAgICAgICBpZiAoIWZhaWx1cmVQZXJjZW50YWdlQ29uZmlnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2UoJ1J1bm5pbmcgZmFpbHVyZSBwZXJjZW50YWdlIGNoZWNrLiB0aHJlc2hvbGQ9JyArIGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLnRocmVzaG9sZCArICcgcmVxdWVzdCB2b2x1bWUgdGhyZXNob2xkPScgKyBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSk7XG4gICAgICAgIC8vIFN0ZXAgMVxuICAgICAgICBsZXQgYWRkcmVzc2VzV2l0aFRhcmdldFZvbHVtZSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgbWFwRW50cnkgb2YgdGhpcy5hZGRyZXNzTWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWNjZXNzZXMgPSBtYXBFbnRyeS5jb3VudGVyLmdldExhc3RTdWNjZXNzZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0RmFpbHVyZXMoKTtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyBmYWlsdXJlcyA+PSBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5yZXF1ZXN0X3ZvbHVtZSkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3Nlc1dpdGhUYXJnZXRWb2x1bWUgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzc2VzV2l0aFRhcmdldFZvbHVtZSA8IGZhaWx1cmVQZXJjZW50YWdlQ29uZmlnLm1pbmltdW1faG9zdHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdGVwIDJcbiAgICAgICAgZm9yIChjb25zdCBbYWRkcmVzcywgbWFwRW50cnldIG9mIHRoaXMuYWRkcmVzc01hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIC8vIFN0ZXAgMi5pXG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDdXJyZW50RWplY3Rpb25QZXJjZW50KCkgPj0gdGhpcy5sYXRlc3RDb25maWcuZ2V0TWF4RWplY3Rpb25QZXJjZW50KCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMi5paVxuICAgICAgICAgICAgY29uc3Qgc3VjY2Vzc2VzID0gbWFwRW50cnkuY291bnRlci5nZXRMYXN0U3VjY2Vzc2VzKCk7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG1hcEVudHJ5LmNvdW50ZXIuZ2V0TGFzdEZhaWx1cmVzKCk7XG4gICAgICAgICAgICB0cmFjZSgnQ2FuZGlkYXRlIHN1Y2Nlc3Nlcz0nICsgc3VjY2Vzc2VzICsgJyBmYWlsdXJlcz0nICsgZmFpbHVyZXMpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyArIGZhaWx1cmVzIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcucmVxdWVzdF92b2x1bWUpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0ZXAgMi5paWlcbiAgICAgICAgICAgIGNvbnN0IGZhaWx1cmVQZXJjZW50YWdlID0gKGZhaWx1cmVzICogMTAwKSAvIChmYWlsdXJlcyArIHN1Y2Nlc3Nlcyk7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZVBlcmNlbnRhZ2UgPiBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21OdW1iZXIgPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgIHRyYWNlKCdDYW5kaWRhdGUgJyArIGFkZHJlc3MgKyAnIHJhbmRvbU51bWJlcj0nICsgcmFuZG9tTnVtYmVyICsgJyBlbmZvcmNlbWVudF9wZXJjZW50YWdlPScgKyBmYWlsdXJlUGVyY2VudGFnZUNvbmZpZy5lbmZvcmNlbWVudF9wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZG9tTnVtYmVyIDwgZmFpbHVyZVBlcmNlbnRhZ2VDb25maWcuZW5mb3JjZW1lbnRfcGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgICAgICB0cmFjZSgnRWplY3RpbmcgY2FuZGlkYXRlICcgKyBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlamVjdChtYXBFbnRyeSwgZWplY3Rpb25UaW1lc3RhbXApIHtcbiAgICAgICAgbWFwRW50cnkuY3VycmVudEVqZWN0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciArPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWxXcmFwcGVyIG9mIG1hcEVudHJ5LnN1YmNoYW5uZWxXcmFwcGVycykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbFdyYXBwZXIuZWplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmVqZWN0KG1hcEVudHJ5KSB7XG4gICAgICAgIG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbFdyYXBwZXIgb2YgbWFwRW50cnkuc3ViY2hhbm5lbFdyYXBwZXJzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlci51bmVqZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3dpdGNoQWxsQnVja2V0cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBtYXBFbnRyeSBvZiB0aGlzLmFkZHJlc3NNYXAudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG1hcEVudHJ5LmNvdW50ZXIuc3dpdGNoQnVja2V0cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXJ0VGltZXIoZGVsYXlNcykge1xuICAgICAgICB0aGlzLmVqZWN0aW9uVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMucnVuQ2hlY2tzKCksIGRlbGF5TXMpO1xuICAgIH1cbiAgICBydW5DaGVja3MoKSB7XG4gICAgICAgIGNvbnN0IGVqZWN0aW9uVGltZXN0YW1wID0gbmV3IERhdGUoKTtcbiAgICAgICAgdHJhY2UoJ0VqZWN0aW9uIHRpbWVyIHJ1bm5pbmcnKTtcbiAgICAgICAgdGhpcy5zd2l0Y2hBbGxCdWNrZXRzKCk7XG4gICAgICAgIGlmICghdGhpcy5sYXRlc3RDb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gZWplY3Rpb25UaW1lc3RhbXA7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lcih0aGlzLmxhdGVzdENvbmZpZy5nZXRJbnRlcnZhbE1zKCkpO1xuICAgICAgICB0aGlzLnJ1blN1Y2Nlc3NSYXRlQ2hlY2soZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICB0aGlzLnJ1bkZhaWx1cmVQZXJjZW50YWdlQ2hlY2soZWplY3Rpb25UaW1lc3RhbXApO1xuICAgICAgICBmb3IgKGNvbnN0IFthZGRyZXNzLCBtYXBFbnRyeV0gb2YgdGhpcy5hZGRyZXNzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgaWYgKG1hcEVudHJ5LmN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXBFbnRyeS5lamVjdGlvblRpbWVNdWx0aXBsaWVyIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUVqZWN0aW9uVGltZU1zID0gdGhpcy5sYXRlc3RDb25maWcuZ2V0QmFzZUVqZWN0aW9uVGltZU1zKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4RWplY3Rpb25UaW1lTXMgPSB0aGlzLmxhdGVzdENvbmZpZy5nZXRNYXhFamVjdGlvblRpbWVNcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldHVyblRpbWUgPSBuZXcgRGF0ZShtYXBFbnRyeS5jdXJyZW50RWplY3Rpb25UaW1lc3RhbXAuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICByZXR1cm5UaW1lLnNldE1pbGxpc2Vjb25kcyhyZXR1cm5UaW1lLmdldE1pbGxpc2Vjb25kcygpICsgTWF0aC5taW4oYmFzZUVqZWN0aW9uVGltZU1zICogbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciwgTWF0aC5tYXgoYmFzZUVqZWN0aW9uVGltZU1zLCBtYXhFamVjdGlvblRpbWVNcykpKTtcbiAgICAgICAgICAgICAgICBpZiAocmV0dXJuVGltZSA8IG5ldyBEYXRlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2UoJ1VuZWplY3RpbmcgJyArIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuZWplY3QobWFwRW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgaWYgKCEobGJDb25maWcgaW5zdGFuY2VvZiBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJjaGFubmVsQWRkcmVzc2VzID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgYWRkcmVzc0xpc3QpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWxBZGRyZXNzZXMuYWRkKHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoYWRkcmVzcykpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgYWRkcmVzcyBvZiBzdWJjaGFubmVsQWRkcmVzc2VzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWRkcmVzc01hcC5oYXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICB0cmFjZSgnQWRkaW5nIG1hcCBlbnRyeSBmb3IgJyArIGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkcmVzc01hcC5zZXQoYWRkcmVzcywge1xuICAgICAgICAgICAgICAgICAgICBjb3VudGVyOiBuZXcgQ2FsbENvdW50ZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEVqZWN0aW9uVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlamVjdGlvblRpbWVNdWx0aXBsaWVyOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdWJjaGFubmVsV3JhcHBlcnM6IFtdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5hZGRyZXNzTWFwLmtleXMoKSkge1xuICAgICAgICAgICAgaWYgKCFzdWJjaGFubmVsQWRkcmVzc2VzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1JlbW92aW5nIG1hcCBlbnRyeSBmb3IgJyArIGtleSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRyZXNzTWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkUG9saWN5ID0gbG9hZF9iYWxhbmNlcl8xLmdldEZpcnN0VXNhYmxlQ29uZmlnKGxiQ29uZmlnLmdldENoaWxkUG9saWN5KCksIHRydWUpO1xuICAgICAgICB0aGlzLmNoaWxkQmFsYW5jZXIudXBkYXRlQWRkcmVzc0xpc3QoYWRkcmVzc0xpc3QsIGNoaWxkUG9saWN5LCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGxiQ29uZmlnLmdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWcoKSB8fCBsYkNvbmZpZy5nZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRpbWVyU3RhcnRUaW1lKSB7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1ByZXZpb3VzIHRpbWVyIGV4aXN0ZWQuIFJlcGxhY2luZyB0aW1lcicpO1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmVqZWN0aW9uVGltZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ0RlbGF5ID0gbGJDb25maWcuZ2V0SW50ZXJ2YWxNcygpIC0gKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSB0aGlzLnRpbWVyU3RhcnRUaW1lLmdldFRpbWUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKHJlbWFpbmluZ0RlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdTdGFydGluZyBuZXcgdGltZXInKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyU3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VGltZXIobGJDb25maWcuZ2V0SW50ZXJ2YWxNcygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN3aXRjaEFsbEJ1Y2tldHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyYWNlKCdDb3VudGluZyBkaXNhYmxlZC4gQ2FuY2VsbGluZyB0aW1lci4nKTtcbiAgICAgICAgICAgIHRoaXMudGltZXJTdGFydFRpbWUgPSBudWxsO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG1hcEVudHJ5IG9mIHRoaXMuYWRkcmVzc01hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5lamVjdChtYXBFbnRyeSk7XG4gICAgICAgICAgICAgICAgbWFwRW50cnkuZWplY3Rpb25UaW1lTXVsdGlwbGllciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXRlc3RDb25maWcgPSBsYkNvbmZpZztcbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5yZXNldEJhY2tvZmYoKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZWplY3Rpb25UaW1lcik7XG4gICAgICAgIHRoaXMuY2hpbGRCYWxhbmNlci5kZXN0cm95KCk7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciA9IE91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBpZiAoT1VUTElFUl9ERVRFQ1RJT05fRU5BQkxFRCkge1xuICAgICAgICBleHBlcmltZW50YWxfMS5yZWdpc3RlckxvYWRCYWxhbmNlclR5cGUoVFlQRV9OQU1FLCBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2VyLCBPdXRsaWVyRGV0ZWN0aW9uTG9hZEJhbGFuY2luZ0NvbmZpZyk7XG4gICAgfVxufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1vdXRsaWVyLWRldGVjdGlvbi5qcy5tYXAiXSwibmFtZXMiOlsiX2EiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNldHVwIiwiT3V0bGllckRldGVjdGlvbkxvYWRCYWxhbmNlciIsIk91dGxpZXJEZXRlY3Rpb25Mb2FkQmFsYW5jaW5nQ29uZmlnIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJkdXJhdGlvbl8xIiwiZXhwZXJpbWVudGFsXzEiLCJmaWx0ZXJfMSIsImxvYWRfYmFsYW5jZXJfMSIsImxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xIiwicGlja2VyXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsInN1YmNoYW5uZWxfaW50ZXJmYWNlXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIk9VVExJRVJfREVURUNUSU9OX0VOQUJMRUQiLCJwcm9jZXNzIiwiZW52IiwiR1JQQ19FWFBFUklNRU5UQUxfRU5BQkxFX09VVExJRVJfREVURUNUSU9OIiwiZGVmYXVsdFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWciLCJzdGRldl9mYWN0b3IiLCJlbmZvcmNlbWVudF9wZXJjZW50YWdlIiwibWluaW11bV9ob3N0cyIsInJlcXVlc3Rfdm9sdW1lIiwiZGVmYXVsdEZhaWx1cmVQZXJjZW50YWdlRWplY3Rpb25Db25maWciLCJ0aHJlc2hvbGQiLCJ2YWxpZGF0ZUZpZWxkVHlwZSIsIm9iaiIsImZpZWxkTmFtZSIsImV4cGVjdGVkVHlwZSIsIm9iamVjdE5hbWUiLCJmdWxsRmllbGROYW1lIiwiRXJyb3IiLCJ2YWxpZGF0ZVBvc2l0aXZlRHVyYXRpb24iLCJpc0R1cmF0aW9uIiwic2Vjb25kcyIsIm5hbm9zIiwidmFsaWRhdGVQZXJjZW50YWdlIiwiY29uc3RydWN0b3IiLCJpbnRlcnZhbE1zIiwiYmFzZUVqZWN0aW9uVGltZU1zIiwibWF4RWplY3Rpb25UaW1lTXMiLCJtYXhFamVjdGlvblBlcmNlbnQiLCJzdWNjZXNzUmF0ZUVqZWN0aW9uIiwiZmFpbHVyZVBlcmNlbnRhZ2VFamVjdGlvbiIsImNoaWxkUG9saWN5IiwiYXNzaWduIiwiZ2V0TG9hZEJhbGFuY2VyTmFtZSIsInRvSnNvbk9iamVjdCIsImludGVydmFsIiwibXNUb0R1cmF0aW9uIiwiYmFzZV9lamVjdGlvbl90aW1lIiwibWF4X2VqZWN0aW9uX3RpbWUiLCJtYXhfZWplY3Rpb25fcGVyY2VudCIsInN1Y2Nlc3NfcmF0ZV9lamVjdGlvbiIsImZhaWx1cmVfcGVyY2VudGFnZV9lamVjdGlvbiIsImNoaWxkX3BvbGljeSIsIm1hcCIsInBvbGljeSIsImdldEludGVydmFsTXMiLCJnZXRCYXNlRWplY3Rpb25UaW1lTXMiLCJnZXRNYXhFamVjdGlvblRpbWVNcyIsImdldE1heEVqZWN0aW9uUGVyY2VudCIsImdldFN1Y2Nlc3NSYXRlRWplY3Rpb25Db25maWciLCJnZXRGYWlsdXJlUGVyY2VudGFnZUVqZWN0aW9uQ29uZmlnIiwiZ2V0Q2hpbGRQb2xpY3kiLCJjb3B5V2l0aENoaWxkUG9saWN5IiwiY3JlYXRlRnJvbUpzb24iLCJkdXJhdGlvblRvTXMiLCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWciLCJPdXRsaWVyRGV0ZWN0aW9uU3ViY2hhbm5lbFdyYXBwZXIiLCJCYXNlU3ViY2hhbm5lbFdyYXBwZXIiLCJjaGlsZFN1YmNoYW5uZWwiLCJtYXBFbnRyeSIsInN0YXRlTGlzdGVuZXJzIiwiZWplY3RlZCIsInJlZkNvdW50IiwiY2hpbGRTdWJjaGFubmVsU3RhdGUiLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsImFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJzdWJjaGFubmVsIiwicHJldmlvdXNTdGF0ZSIsIm5ld1N0YXRlIiwibGlzdGVuZXIiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIlRSQU5TSUVOVF9GQUlMVVJFIiwicHVzaCIsInJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJsaXN0ZW5lckluZGV4IiwiaW5kZXhPZiIsInNwbGljZSIsInJlZiIsImNoaWxkIiwidW5yZWYiLCJpbmRleCIsInN1YmNoYW5uZWxXcmFwcGVycyIsImVqZWN0IiwidW5lamVjdCIsImdldE1hcEVudHJ5IiwiZ2V0V3JhcHBlZFN1YmNoYW5uZWwiLCJjcmVhdGVFbXB0eUJ1Y2tldCIsInN1Y2Nlc3MiLCJmYWlsdXJlIiwiQ2FsbENvdW50ZXIiLCJhY3RpdmVCdWNrZXQiLCJpbmFjdGl2ZUJ1Y2tldCIsImFkZFN1Y2Nlc3MiLCJhZGRGYWlsdXJlIiwic3dpdGNoQnVja2V0cyIsImdldExhc3RTdWNjZXNzZXMiLCJnZXRMYXN0RmFpbHVyZXMiLCJPdXRsaWVyRGV0ZWN0aW9uQ291bnRlckZpbHRlciIsIkJhc2VGaWx0ZXIiLCJjYWxsQ291bnRlciIsInJlY2VpdmVUcmFpbGVycyIsInN0YXR1cyIsImNvZGUiLCJTdGF0dXMiLCJPSyIsIk91dGxpZXJEZXRlY3Rpb25Db3VudGVyRmlsdGVyRmFjdG9yeSIsImNyZWF0ZUZpbHRlciIsImNhbGxTdHJlYW0iLCJPdXRsaWVyRGV0ZWN0aW9uUGlja2VyIiwid3JhcHBlZFBpY2tlciIsImNvdW50Q2FsbHMiLCJwaWNrIiwicGlja0FyZ3MiLCJ3cmFwcGVkUGljayIsInBpY2tSZXN1bHRUeXBlIiwiUGlja1Jlc3VsdFR5cGUiLCJDT01QTEVURSIsInN1YmNoYW5uZWxXcmFwcGVyIiwiZXh0cmFGaWx0ZXJGYWN0b3JpZXMiLCJjb3VudGVyIiwiY2hhbm5lbENvbnRyb2xIZWxwZXIiLCJhZGRyZXNzTWFwIiwiTWFwIiwibGF0ZXN0Q29uZmlnIiwidGltZXJTdGFydFRpbWUiLCJjaGlsZEJhbGFuY2VyIiwiQ2hpbGRMb2FkQmFsYW5jZXJIYW5kbGVyIiwiY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciIsImNyZWF0ZVN1YmNoYW5uZWwiLCJzdWJjaGFubmVsQWRkcmVzcyIsInN1YmNoYW5uZWxBcmdzIiwib3JpZ2luYWxTdWJjaGFubmVsIiwiZ2V0Iiwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyIsImN1cnJlbnRFamVjdGlvblRpbWVzdGFtcCIsInVwZGF0ZVN0YXRlIiwiY29ubmVjdGl2aXR5U3RhdGUiLCJwaWNrZXIiLCJSRUFEWSIsImlzQ291bnRpbmdFbmFibGVkIiwiZWplY3Rpb25UaW1lciIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImdldEN1cnJlbnRFamVjdGlvblBlcmNlbnQiLCJlamVjdGlvbkNvdW50IiwidmFsdWVzIiwic2l6ZSIsInJ1blN1Y2Nlc3NSYXRlQ2hlY2siLCJlamVjdGlvblRpbWVzdGFtcCIsInN1Y2Nlc3NSYXRlQ29uZmlnIiwidGFyZ2V0UmVxdWVzdFZvbHVtZSIsImFkZHJlc2VzV2l0aFRhcmdldFZvbHVtZSIsInN1Y2Nlc3NSYXRlcyIsInN1Y2Nlc3NlcyIsImZhaWx1cmVzIiwic3VjY2Vzc1JhdGVNZWFuIiwicmVkdWNlIiwiYSIsImIiLCJsZW5ndGgiLCJzdWNjZXNzUmF0ZURldmlhdGlvblN1bSIsInJhdGUiLCJkZXZpYXRpb24iLCJzdWNjZXNzUmF0ZVZhcmlhbmNlIiwic3VjY2Vzc1JhdGVTdGRldiIsIk1hdGgiLCJzcXJ0IiwiZWplY3Rpb25UaHJlc2hvbGQiLCJhZGRyZXNzIiwiZW50cmllcyIsInN1Y2Nlc3NSYXRlIiwicmFuZG9tTnVtYmVyIiwicmFuZG9tIiwicnVuRmFpbHVyZVBlcmNlbnRhZ2VDaGVjayIsImZhaWx1cmVQZXJjZW50YWdlQ29uZmlnIiwiYWRkcmVzc2VzV2l0aFRhcmdldFZvbHVtZSIsImZhaWx1cmVQZXJjZW50YWdlIiwiRGF0ZSIsImVqZWN0aW9uVGltZU11bHRpcGxpZXIiLCJzd2l0Y2hBbGxCdWNrZXRzIiwic3RhcnRUaW1lciIsImRlbGF5TXMiLCJzZXRUaW1lb3V0IiwicnVuQ2hlY2tzIiwicmV0dXJuVGltZSIsImdldFRpbWUiLCJzZXRNaWxsaXNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJtaW4iLCJtYXgiLCJ1cGRhdGVBZGRyZXNzTGlzdCIsImFkZHJlc3NMaXN0IiwibGJDb25maWciLCJhdHRyaWJ1dGVzIiwic3ViY2hhbm5lbEFkZHJlc3NlcyIsIlNldCIsImFkZCIsImhhcyIsInNldCIsImtleSIsImtleXMiLCJkZWxldGUiLCJnZXRGaXJzdFVzYWJsZUNvbmZpZyIsImNsZWFyVGltZW91dCIsInJlbWFpbmluZ0RlbGF5IiwiZXhpdElkbGUiLCJyZXNldEJhY2tvZmYiLCJkZXN0cm95IiwiZ2V0VHlwZU5hbWUiLCJyZWdpc3RlckxvYWRCYWxhbmNlclR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"pick_first\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"pick_first\";\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */ const CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor(){}\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {}\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new PickFirstLoadBalancingConfig();\n    }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */ class PickFirstPicker {\n    constructor(subchannel){\n        this.subchannel = subchannel;\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: this.subchannel,\n            status: null,\n            extraFilterFactories: [],\n            onCallStarted: null\n        };\n    }\n}\nclass PickFirstLoadBalancer {\n    /**\n     * Load balancer that attempts to connect to each backend in the address list\n     * in order, and picks the first one that connects, using it for every\n     * request.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     */ constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        /**\n         * The list of backend addresses most recently passed to `updateAddressList`.\n         */ this.latestAddressList = [];\n        /**\n         * The list of subchannels this load balancer is currently attempting to\n         * connect to.\n         */ this.subchannels = [];\n        /**\n         * The current connectivity state of the load balancer.\n         */ this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The index within the `subchannels` array of the subchannel with the most\n         * recently started connection attempt.\n         */ this.currentSubchannelIndex = 0;\n        /**\n         * The currently picked subchannel used for making calls. Populated if\n         * and only if the load balancer's current state is READY. In that case,\n         * the subchannel's current state is also READY.\n         */ this.currentPick = null;\n        this.triedAllSubchannels = false;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n        };\n        this.subchannelStateListener = (subchannel, previousState, newState)=>{\n            this.subchannelStateCounts[previousState] -= 1;\n            this.subchannelStateCounts[newState] += 1;\n            /* If the subchannel we most recently attempted to start connecting\n             * to goes into TRANSIENT_FAILURE, immediately try to start\n             * connecting to the next one instead of waiting for the connection\n             * delay timer. */ if (subchannel === this.subchannels[this.currentSubchannelIndex] && newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.startNextSubchannelConnecting();\n            }\n            if (newState === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                return;\n            } else {\n                if (this.triedAllSubchannels && this.subchannelStateCounts[connectivity_state_1.ConnectivityState.IDLE] === this.subchannels.length) {\n                    /* If all of the subchannels are IDLE we should go back to a\n                     * basic IDLE state where there is no subchannel list to avoid\n                     * holding unused resources. We do not reset triedAllSubchannels\n                     * because that is a reminder to request reresolution the next time\n                     * this LB policy needs to connect. */ this.resetSubchannelList(false);\n                    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n                    return;\n                }\n                if (this.currentPick === null) {\n                    if (this.triedAllSubchannels) {\n                        let newLBState;\n                        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n                        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n                        } else {\n                            newLBState = connectivity_state_1.ConnectivityState.IDLE;\n                        }\n                        if (newLBState !== this.currentState) {\n                            if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                                this.updateState(newLBState, new picker_1.UnavailablePicker());\n                            } else {\n                                this.updateState(newLBState, new picker_1.QueuePicker(this));\n                            }\n                        }\n                    } else {\n                        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                    }\n                }\n            }\n        };\n        this.pickedSubchannelStateListener = (subchannel, previousState, newState)=>{\n            if (newState !== connectivity_state_1.ConnectivityState.READY) {\n                this.currentPick = null;\n                subchannel.unref();\n                subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n                this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n                if (this.subchannels.length > 0) {\n                    if (this.triedAllSubchannels) {\n                        let newLBState;\n                        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n                        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n                            newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n                        } else {\n                            newLBState = connectivity_state_1.ConnectivityState.IDLE;\n                        }\n                        if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                            this.updateState(newLBState, new picker_1.UnavailablePicker());\n                        } else {\n                            this.updateState(newLBState, new picker_1.QueuePicker(this));\n                        }\n                    } else {\n                        this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                    }\n                } else {\n                    /* We don't need to backoff here because this only happens if a\n                     * subchannel successfully connects then disconnects, so it will not\n                     * create a loop of attempting to connect to an unreachable backend\n                     */ this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n                }\n            }\n        };\n        this.connectionDelayTimeout = setTimeout(()=>{}, 0);\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    startNextSubchannelConnecting() {\n        if (this.triedAllSubchannels) {\n            return;\n        }\n        for (const [index, subchannel] of this.subchannels.entries()){\n            if (index > this.currentSubchannelIndex) {\n                const subchannelState = subchannel.getConnectivityState();\n                if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                    this.startConnecting(index);\n                    return;\n                }\n            }\n        }\n        this.triedAllSubchannels = true;\n    }\n    /**\n     * Have a single subchannel in the `subchannels` list start connecting.\n     * @param subchannelIndex The index into the `subchannels` list.\n     */ startConnecting(subchannelIndex) {\n        clearTimeout(this.connectionDelayTimeout);\n        this.currentSubchannelIndex = subchannelIndex;\n        if (this.subchannels[subchannelIndex].getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n            trace(\"Start connecting to subchannel with address \" + this.subchannels[subchannelIndex].getAddress());\n            process.nextTick(()=>{\n                this.subchannels[subchannelIndex].startConnecting();\n            });\n        }\n        this.connectionDelayTimeout = setTimeout(()=>{\n            this.startNextSubchannelConnecting();\n        }, CONNECTION_DELAY_INTERVAL_MS);\n    }\n    pickSubchannel(subchannel) {\n        trace(\"Pick subchannel with address \" + subchannel.getAddress());\n        if (this.currentPick !== null) {\n            this.currentPick.unref();\n            this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n        }\n        this.currentPick = subchannel;\n        this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(subchannel));\n        subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n        subchannel.ref();\n        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        this.resetSubchannelList();\n        clearTimeout(this.connectionDelayTimeout);\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList(resetTriedAllSubchannels = true) {\n        for (const subchannel of this.subchannels){\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.currentSubchannelIndex = 0;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n        };\n        this.subchannels = [];\n        if (resetTriedAllSubchannels) {\n            this.triedAllSubchannels = false;\n        }\n    }\n    /**\n     * Start connecting to the address list most recently passed to\n     * `updateAddressList`.\n     */ connectToAddressList() {\n        this.resetSubchannelList();\n        trace(\"Connect to address list \" + this.latestAddressList.map((address)=>subchannel_address_1.subchannelAddressToString(address)));\n        this.subchannels = this.latestAddressList.map((address)=>this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels){\n            subchannel.ref();\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n        }\n        for (const subchannel of this.subchannels){\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;\n            if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n                this.pickSubchannel(subchannel);\n                this.resetSubchannelList();\n                return;\n            }\n        }\n        for (const [index, subchannel] of this.subchannels.entries()){\n            const subchannelState = subchannel.getConnectivityState();\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n                this.startConnecting(index);\n                if (this.currentPick === null) {\n                    this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n                }\n                return;\n            }\n        }\n        // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n        if (this.currentPick === null) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n        }\n    }\n    updateAddressList(addressList, lbConfig) {\n        // lbConfig has no useful information for pick first load balancing\n        /* To avoid unnecessary churn, we only do something with this address list\n         * if we're not currently trying to establish a connection, or if the new\n         * address list is different from the existing one */ if (this.subchannels.length === 0 || !this.latestAddressList.every((value, index)=>addressList[index] === value)) {\n            this.latestAddressList = addressList;\n            this.connectToAddressList();\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.triedAllSubchannels) {\n            this.channelControlHelper.requestReresolution();\n        }\n        for (const subchannel of this.subchannels){\n            subchannel.startConnecting();\n        }\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            if (this.latestAddressList.length > 0) {\n                this.connectToAddressList();\n            }\n        }\n    }\n    resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */ }\n    destroy() {\n        this.resetSubchannelList();\n        if (this.currentPick !== null) {\n            /* Unref can cause a state change, which can cause a change in the value\n             * of this.currentPick, so we hold a local reference to make sure that\n             * does not impact this function. */ const currentPick = this.currentPick;\n            currentPick.unref();\n            currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n            this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n        }\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n    load_balancer_1.registerLoadBalancerType(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n    load_balancer_1.registerDefaultLoadBalancerType(TYPE_NAME);\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-pick-first.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxhQUFhLEdBQUdBLDZCQUE2QixHQUFHQSxvQ0FBb0MsR0FBRyxLQUFLO0FBQzVGLE1BQU1LLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1NLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmSixRQUFRRyxLQUFLLENBQUNGLFlBQVlJLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBLE1BQU1HLFlBQVk7QUFDbEI7OztDQUdDLEdBQ0QsTUFBTUMsK0JBQStCO0FBQ3JDLE1BQU1kO0lBQ0ZlLHNCQUFzQjtRQUNsQixPQUFPRjtJQUNYO0lBQ0FHLGFBQWMsQ0FBRTtJQUNoQkMsZUFBZTtRQUNYLE9BQU87WUFDSCxDQUFDSixVQUFVLEVBQUUsQ0FBQztRQUNsQjtJQUNKO0lBQ0EsOERBQThEO0lBQzlELE9BQU9LLGVBQWVDLEdBQUcsRUFBRTtRQUN2QixPQUFPLElBQUluQjtJQUNmO0FBQ0o7QUFDQUosb0NBQW9DLEdBQUdJO0FBQ3ZDOzs7Q0FHQyxHQUNELE1BQU1vQjtJQUNGSixZQUFZSyxVQUFVLENBQUU7UUFDcEIsSUFBSSxDQUFDQSxVQUFVLEdBQUdBO0lBQ3RCO0lBQ0FDLEtBQUtDLFFBQVEs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LHFCQUFxQitCLGlCQUFpQixDQUFDQyxJQUFJLEVBQUU7WUFDbkUsSUFBSSxJQUFJLENBQUNKLGlCQUFpQixDQUFDa0IsTUFBTSxHQUFHLEdBQUc7Z0JBQ25DLElBQUksQ0FBQzRCLG9CQUFvQjtZQUM3QjtRQUNKO0lBQ0o7SUFDQVcsZUFBZTtJQUNYO3dCQUNnQixHQUNwQjtJQUNBQyxVQUFVO1FBQ04sSUFBSSxDQUFDdkMsbUJBQW1CO1FBQ3hCLElBQUksSUFBSSxDQUFDYixXQUFXLEtBQUssTUFBTTtZQUMzQjs7OENBRWtDLEdBQ2xDLE1BQU1BLGNBQWMsSUFBSSxDQUFDQSxXQUFXO1lBQ3BDQSxZQUFZbUIsS0FBSztZQUNqQm5CLFlBQVlvQiwrQkFBK0IsQ0FBQyxJQUFJLENBQUNGLDZCQUE2QjtZQUM5RSxJQUFJLENBQUN6QixvQkFBb0IsQ0FBQzRCLG1CQUFtQixDQUFDckIsWUFBWXNCLGNBQWM7UUFDNUU7SUFDSjtJQUNBK0IsY0FBYztRQUNWLE9BQU83RTtJQUNYO0FBQ0o7QUFDQWpCLDZCQUE2QixHQUFHRztBQUNoQyxTQUFTRDtJQUNMRyxnQkFBZ0IwRix3QkFBd0IsQ0FBQzlFLFdBQVdkLHVCQUF1QkM7SUFDM0VDLGdCQUFnQjJGLCtCQUErQixDQUFDL0U7QUFDcEQ7QUFDQWpCLGFBQWEsR0FBR0UsT0FDaEIsb0RBQW9EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXItcGljay1maXJzdC5qcz81MzgxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jZXIgPSBleHBvcnRzLlBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcgPSB2b2lkIDA7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IHN1YmNoYW5uZWxfYWRkcmVzc18xID0gcmVxdWlyZShcIi4vc3ViY2hhbm5lbC1hZGRyZXNzXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ3BpY2tfZmlyc3QnO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBUWVBFX05BTUUgPSAncGlja19maXJzdCc7XG4vKipcbiAqIERlbGF5IGFmdGVyIHN0YXJ0aW5nIGEgY29ubmVjdGlvbiBvbiBhIHN1YmNoYW5uZWwgYmVmb3JlIHN0YXJ0aW5nIGFcbiAqIGNvbm5lY3Rpb24gb24gdGhlIG5leHQgc3ViY2hhbm5lbCBpbiB0aGUgbGlzdCwgZm9yIEhhcHB5IEV5ZWJhbGxzIGFsZ29yaXRobS5cbiAqL1xuY29uc3QgQ09OTkVDVElPTl9ERUxBWV9JTlRFUlZBTF9NUyA9IDI1MDtcbmNsYXNzIFBpY2tGaXJzdExvYWRCYWxhbmNpbmdDb25maWcge1xuICAgIGdldExvYWRCYWxhbmNlck5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG4gICAgdG9Kc29uT2JqZWN0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW1RZUEVfTkFNRV06IHt9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSnNvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKCk7XG4gICAgfVxufVxuZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnID0gUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZztcbi8qKlxuICogUGlja2VyIGZvciBhIGBQaWNrRmlyc3RMb2FkQmFsYW5jZXJgIGluIHRoZSBSRUFEWSBzdGF0ZS4gQWx3YXlzIHJldHVybnMgdGhlXG4gKiBwaWNrZWQgc3ViY2hhbm5lbC5cbiAqL1xuY2xhc3MgUGlja0ZpcnN0UGlja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzdWJjaGFubmVsKSB7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbCA9IHN1YmNoYW5uZWw7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IHRoaXMuc3ViY2hhbm5lbCxcbiAgICAgICAgICAgIHN0YXR1czogbnVsbCxcbiAgICAgICAgICAgIGV4dHJhRmlsdGVyRmFjdG9yaWVzOiBbXSxcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgUGlja0ZpcnN0TG9hZEJhbGFuY2VyIHtcbiAgICAvKipcbiAgICAgKiBMb2FkIGJhbGFuY2VyIHRoYXQgYXR0ZW1wdHMgdG8gY29ubmVjdCB0byBlYWNoIGJhY2tlbmQgaW4gdGhlIGFkZHJlc3MgbGlzdFxuICAgICAqIGluIG9yZGVyLCBhbmQgcGlja3MgdGhlIGZpcnN0IG9uZSB0aGF0IGNvbm5lY3RzLCB1c2luZyBpdCBmb3IgZXZlcnlcbiAgICAgKiByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBjaGFubmVsQ29udHJvbEhlbHBlciBgQ2hhbm5lbENvbnRyb2xIZWxwZXJgIGluc3RhbmNlIHByb3ZpZGVkIGJ5XG4gICAgICogICAgIHRoaXMgbG9hZCBiYWxhbmNlcidzIG93bmVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIGJhY2tlbmQgYWRkcmVzc2VzIG1vc3QgcmVjZW50bHkgcGFzc2VkIHRvIGB1cGRhdGVBZGRyZXNzTGlzdGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhdGVzdEFkZHJlc3NMaXN0ID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgbGlzdCBvZiBzdWJjaGFubmVscyB0aGlzIGxvYWQgYmFsYW5jZXIgaXMgY3VycmVudGx5IGF0dGVtcHRpbmcgdG9cbiAgICAgICAgICogY29ubmVjdCB0by5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZSBvZiB0aGUgbG9hZCBiYWxhbmNlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBpbmRleCB3aXRoaW4gdGhlIGBzdWJjaGFubmVsc2AgYXJyYXkgb2YgdGhlIHN1YmNoYW5uZWwgd2l0aCB0aGUgbW9zdFxuICAgICAgICAgKiByZWNlbnRseSBzdGFydGVkIGNvbm5lY3Rpb24gYXR0ZW1wdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudGx5IHBpY2tlZCBzdWJjaGFubmVsIHVzZWQgZm9yIG1ha2luZyBjYWxscy4gUG9wdWxhdGVkIGlmXG4gICAgICAgICAqIGFuZCBvbmx5IGlmIHRoZSBsb2FkIGJhbGFuY2VyJ3MgY3VycmVudCBzdGF0ZSBpcyBSRUFEWS4gSW4gdGhhdCBjYXNlLFxuICAgICAgICAgKiB0aGUgc3ViY2hhbm5lbCdzIGN1cnJlbnQgc3RhdGUgaXMgYWxzbyBSRUFEWS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBudWxsO1xuICAgICAgICB0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHMgPSB7XG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR106IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV06IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIgPSAoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW3ByZXZpb3VzU3RhdGVdIC09IDE7XG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tuZXdTdGF0ZV0gKz0gMTtcbiAgICAgICAgICAgIC8qIElmIHRoZSBzdWJjaGFubmVsIHdlIG1vc3QgcmVjZW50bHkgYXR0ZW1wdGVkIHRvIHN0YXJ0IGNvbm5lY3RpbmdcbiAgICAgICAgICAgICAqIHRvIGdvZXMgaW50byBUUkFOU0lFTlRfRkFJTFVSRSwgaW1tZWRpYXRlbHkgdHJ5IHRvIHN0YXJ0XG4gICAgICAgICAgICAgKiBjb25uZWN0aW5nIHRvIHRoZSBuZXh0IG9uZSBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgKiBkZWxheSB0aW1lci4gKi9cbiAgICAgICAgICAgIGlmIChzdWJjaGFubmVsID09PSB0aGlzLnN1YmNoYW5uZWxzW3RoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleF0gJiZcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0TmV4dFN1YmNoYW5uZWxDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waWNrU3ViY2hhbm5lbChzdWJjaGFubmVsKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmllZEFsbFN1YmNoYW5uZWxzICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEVdID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgYWxsIG9mIHRoZSBzdWJjaGFubmVscyBhcmUgSURMRSB3ZSBzaG91bGQgZ28gYmFjayB0byBhXG4gICAgICAgICAgICAgICAgICAgICAqIGJhc2ljIElETEUgc3RhdGUgd2hlcmUgdGhlcmUgaXMgbm8gc3ViY2hhbm5lbCBsaXN0IHRvIGF2b2lkXG4gICAgICAgICAgICAgICAgICAgICAqIGhvbGRpbmcgdW51c2VkIHJlc291cmNlcy4gV2UgZG8gbm90IHJlc2V0IHRyaWVkQWxsU3ViY2hhbm5lbHNcbiAgICAgICAgICAgICAgICAgICAgICogYmVjYXVzZSB0aGF0IGlzIGEgcmVtaW5kZXIgdG8gcmVxdWVzdCByZXJlc29sdXRpb24gdGhlIG5leHQgdGltZVxuICAgICAgICAgICAgICAgICAgICAgKiB0aGlzIExCIHBvbGljeSBuZWVkcyB0byBjb25uZWN0LiAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJpZWRBbGxTdWJjaGFubmVscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0xCU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR10gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TEJTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0gPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMQlN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMQlN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdMQlN0YXRlICE9PSB0aGlzLmN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdMQlN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKG5ld0xCU3RhdGUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUobmV3TEJTdGF0ZSwgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGlja2VkU3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIgPSAoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSAhPT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQaWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsLnVucmVmKCk7XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbC5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMucGlja2VkU3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVtb3ZlQ2hhbm5lbHpDaGlsZChzdWJjaGFubmVsLmdldENoYW5uZWx6UmVmKCkpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN1YmNoYW5uZWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJpZWRBbGxTdWJjaGFubmVscykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0xCU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR10gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TEJTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0gPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMQlN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMQlN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdMQlN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUobmV3TEJTdGF0ZSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShuZXdMQlN0YXRlLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBXZSBkb24ndCBuZWVkIHRvIGJhY2tvZmYgaGVyZSBiZWNhdXNlIHRoaXMgb25seSBoYXBwZW5zIGlmIGFcbiAgICAgICAgICAgICAgICAgICAgICogc3ViY2hhbm5lbCBzdWNjZXNzZnVsbHkgY29ubmVjdHMgdGhlbiBkaXNjb25uZWN0cywgc28gaXQgd2lsbCBub3RcbiAgICAgICAgICAgICAgICAgICAgICogY3JlYXRlIGEgbG9vcCBvZiBhdHRlbXB0aW5nIHRvIGNvbm5lY3QgdG8gYW4gdW5yZWFjaGFibGUgYmFja2VuZFxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcbiAgICB9XG4gICAgc3RhcnROZXh0U3ViY2hhbm5lbENvbm5lY3RpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgc3ViY2hhbm5lbF0gb2YgdGhpcy5zdWJjaGFubmVscy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IHRoaXMuY3VycmVudFN1YmNoYW5uZWxJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoc3ViY2hhbm5lbFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICAgICAgICAgIHN1YmNoYW5uZWxTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZyhpbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmllZEFsbFN1YmNoYW5uZWxzID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGF2ZSBhIHNpbmdsZSBzdWJjaGFubmVsIGluIHRoZSBgc3ViY2hhbm5lbHNgIGxpc3Qgc3RhcnQgY29ubmVjdGluZy5cbiAgICAgKiBAcGFyYW0gc3ViY2hhbm5lbEluZGV4IFRoZSBpbmRleCBpbnRvIHRoZSBgc3ViY2hhbm5lbHNgIGxpc3QuXG4gICAgICovXG4gICAgc3RhcnRDb25uZWN0aW5nKHN1YmNoYW5uZWxJbmRleCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0aW9uRGVsYXlUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3ViY2hhbm5lbEluZGV4ID0gc3ViY2hhbm5lbEluZGV4O1xuICAgICAgICBpZiAodGhpcy5zdWJjaGFubmVsc1tzdWJjaGFubmVsSW5kZXhdLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09XG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0cmFjZSgnU3RhcnQgY29ubmVjdGluZyB0byBzdWJjaGFubmVsIHdpdGggYWRkcmVzcyAnICtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxzW3N1YmNoYW5uZWxJbmRleF0uZ2V0QWRkcmVzcygpKTtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbHNbc3ViY2hhbm5lbEluZGV4XS5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkRlbGF5VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZygpO1xuICAgICAgICB9LCBDT05ORUNUSU9OX0RFTEFZX0lOVEVSVkFMX01TKTtcbiAgICB9XG4gICAgcGlja1N1YmNoYW5uZWwoc3ViY2hhbm5lbCkge1xuICAgICAgICB0cmFjZSgnUGljayBzdWJjaGFubmVsIHdpdGggYWRkcmVzcyAnICsgc3ViY2hhbm5lbC5nZXRBZGRyZXNzKCkpO1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGljayAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGljay51bnJlZigpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGljay5yZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMucGlja2VkU3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFBpY2sgPSBzdWJjaGFubmVsO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZLCBuZXcgUGlja0ZpcnN0UGlja2VyKHN1YmNoYW5uZWwpKTtcbiAgICAgICAgc3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMucGlja2VkU3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICBzdWJjaGFubmVsLnJlZigpO1xuICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3Rpb25EZWxheVRpbWVvdXQpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKSB7XG4gICAgICAgIHRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY3VycmVudFN0YXRlXSArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShuZXdTdGF0ZSwgcGlja2VyKTtcbiAgICB9XG4gICAgcmVzZXRTdWJjaGFubmVsTGlzdChyZXNldFRyaWVkQWxsU3ViY2hhbm5lbHMgPSB0cnVlKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnVucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRTdWJjaGFubmVsSW5kZXggPSAwO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50cyA9IHtcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV05dOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgICAgICBpZiAocmVzZXRUcmllZEFsbFN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBjb25uZWN0aW5nIHRvIHRoZSBhZGRyZXNzIGxpc3QgbW9zdCByZWNlbnRseSBwYXNzZWQgdG9cbiAgICAgKiBgdXBkYXRlQWRkcmVzc0xpc3RgLlxuICAgICAqL1xuICAgIGNvbm5lY3RUb0FkZHJlc3NMaXN0KCkge1xuICAgICAgICB0aGlzLnJlc2V0U3ViY2hhbm5lbExpc3QoKTtcbiAgICAgICAgdHJhY2UoJ0Nvbm5lY3QgdG8gYWRkcmVzcyBsaXN0ICcgK1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RBZGRyZXNzTGlzdC5tYXAoKGFkZHJlc3MpID0+IHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoYWRkcmVzcykpKTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QubWFwKChhZGRyZXNzKSA9PiB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoYWRkcmVzcywge30pKTtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsIG9mIHRoaXMuc3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbc3ViY2hhbm5lbC5nZXRDb25uZWN0aXZpdHlTdGF0ZSgpXSArPSAxO1xuICAgICAgICAgICAgaWYgKHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpY2tTdWJjaGFubmVsKHN1YmNoYW5uZWwpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRTdWJjaGFubmVsTGlzdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtpbmRleCwgc3ViY2hhbm5lbF0gb2YgdGhpcy5zdWJjaGFubmVscy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHxcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZyhpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGNvZGUgcmVhY2hlcyB0aGlzIHBvaW50LCBldmVyeSBzdWJjaGFubmVsIG11c3QgYmUgaW4gVFJBTlNJRU5UX0ZBSUxVUkVcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBpY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUsIG5ldyBwaWNrZXJfMS5VbmF2YWlsYWJsZVBpY2tlcigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgLy8gbGJDb25maWcgaGFzIG5vIHVzZWZ1bCBpbmZvcm1hdGlvbiBmb3IgcGljayBmaXJzdCBsb2FkIGJhbGFuY2luZ1xuICAgICAgICAvKiBUbyBhdm9pZCB1bm5lY2Vzc2FyeSBjaHVybiwgd2Ugb25seSBkbyBzb21ldGhpbmcgd2l0aCB0aGlzIGFkZHJlc3MgbGlzdFxuICAgICAgICAgKiBpZiB3ZSdyZSBub3QgY3VycmVudGx5IHRyeWluZyB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uLCBvciBpZiB0aGUgbmV3XG4gICAgICAgICAqIGFkZHJlc3MgbGlzdCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZXhpc3Rpbmcgb25lICovXG4gICAgICAgIGlmICh0aGlzLnN1YmNoYW5uZWxzLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgIXRoaXMubGF0ZXN0QWRkcmVzc0xpc3QuZXZlcnkoKHZhbHVlLCBpbmRleCkgPT4gYWRkcmVzc0xpc3RbaW5kZXhdID09PSB2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QgPSBhZGRyZXNzTGlzdDtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRvQWRkcmVzc0xpc3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGl0SWRsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFIHx8XG4gICAgICAgICAgICB0aGlzLnRyaWVkQWxsU3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnN0YXJ0Q29ubmVjdGluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0QWRkcmVzc0xpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdFRvQWRkcmVzc0xpc3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIC8qIFRoZSBwaWNrIGZpcnN0IGxvYWQgYmFsYW5jZXIgZG9lcyBub3QgaGF2ZSBhIGNvbm5lY3Rpb24gYmFja29mZiwgc28gdGhpc1xuICAgICAgICAgKiBkb2VzIG5vdGhpbmcgKi9cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQaWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvKiBVbnJlZiBjYW4gY2F1c2UgYSBzdGF0ZSBjaGFuZ2UsIHdoaWNoIGNhbiBjYXVzZSBhIGNoYW5nZSBpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgICAqIG9mIHRoaXMuY3VycmVudFBpY2ssIHNvIHdlIGhvbGQgYSBsb2NhbCByZWZlcmVuY2UgdG8gbWFrZSBzdXJlIHRoYXRcbiAgICAgICAgICAgICAqIGRvZXMgbm90IGltcGFjdCB0aGlzIGZ1bmN0aW9uLiAqL1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFBpY2sgPSB0aGlzLmN1cnJlbnRQaWNrO1xuICAgICAgICAgICAgY3VycmVudFBpY2sudW5yZWYoKTtcbiAgICAgICAgICAgIGN1cnJlbnRQaWNrLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5waWNrZWRTdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQoY3VycmVudFBpY2suZ2V0Q2hhbm5lbHpSZWYoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHlwZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBUWVBFX05BTUU7XG4gICAgfVxufVxuZXhwb3J0cy5QaWNrRmlyc3RMb2FkQmFsYW5jZXIgPSBQaWNrRmlyc3RMb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKFRZUEVfTkFNRSwgUGlja0ZpcnN0TG9hZEJhbGFuY2VyLCBQaWNrRmlyc3RMb2FkQmFsYW5jaW5nQ29uZmlnKTtcbiAgICBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZShUWVBFX05BTUUpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1waWNrLWZpcnN0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInNldHVwIiwiUGlja0ZpcnN0TG9hZEJhbGFuY2VyIiwiUGlja0ZpcnN0TG9hZEJhbGFuY2luZ0NvbmZpZyIsImxvYWRfYmFsYW5jZXJfMSIsInJlcXVpcmUiLCJjb25uZWN0aXZpdHlfc3RhdGVfMSIsInBpY2tlcl8xIiwic3ViY2hhbm5lbF9hZGRyZXNzXzEiLCJsb2dnaW5nIiwiY29uc3RhbnRzXzEiLCJUUkFDRVJfTkFNRSIsInRyYWNlIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiVFlQRV9OQU1FIiwiQ09OTkVDVElPTl9ERUxBWV9JTlRFUlZBTF9NUyIsImdldExvYWRCYWxhbmNlck5hbWUiLCJjb25zdHJ1Y3RvciIsInRvSnNvbk9iamVjdCIsImNyZWF0ZUZyb21Kc29uIiwib2JqIiwiUGlja0ZpcnN0UGlja2VyIiwic3ViY2hhbm5lbCIsInBpY2siLCJwaWNrQXJncyIsInBpY2tSZXN1bHRUeXBlIiwiUGlja1Jlc3VsdFR5cGUiLCJDT01QTEVURSIsInN0YXR1cyIsImV4dHJhRmlsdGVyRmFjdG9yaWVzIiwib25DYWxsU3RhcnRlZCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwibGF0ZXN0QWRkcmVzc0xpc3QiLCJzdWJjaGFubmVscyIsImN1cnJlbnRTdGF0ZSIsIkNvbm5lY3Rpdml0eVN0YXRlIiwiSURMRSIsImN1cnJlbnRTdWJjaGFubmVsSW5kZXgiLCJjdXJyZW50UGljayIsInRyaWVkQWxsU3ViY2hhbm5lbHMiLCJzdWJjaGFubmVsU3RhdGVDb3VudHMiLCJDT05ORUNUSU5HIiwiUkVBRFkiLCJTSFVURE9XTiIsIlRSQU5TSUVOVF9GQUlMVVJFIiwic3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIiLCJwcmV2aW91c1N0YXRlIiwibmV3U3RhdGUiLCJzdGFydE5leHRTdWJjaGFubmVsQ29ubmVjdGluZyIsInBpY2tTdWJjaGFubmVsIiwibGVuZ3RoIiwicmVzZXRTdWJjaGFubmVsTGlzdCIsInVwZGF0ZVN0YXRlIiwiUXVldWVQaWNrZXIiLCJuZXdMQlN0YXRlIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJwaWNrZWRTdWJjaGFubmVsU3RhdGVMaXN0ZW5lciIsInVucmVmIiwicmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInJlbW92ZUNoYW5uZWx6Q2hpbGQiLCJnZXRDaGFubmVselJlZiIsImNvbm5lY3Rpb25EZWxheVRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiaW5kZXgiLCJlbnRyaWVzIiwic3ViY2hhbm5lbFN0YXRlIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJzdGFydENvbm5lY3RpbmciLCJzdWJjaGFubmVsSW5kZXgiLCJnZXRBZGRyZXNzIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInJlZiIsImFkZENoYW5uZWx6Q2hpbGQiLCJwaWNrZXIiLCJyZXNldFRyaWVkQWxsU3ViY2hhbm5lbHMiLCJjb25uZWN0VG9BZGRyZXNzTGlzdCIsIm1hcCIsImFkZHJlc3MiLCJzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nIiwiY3JlYXRlU3ViY2hhbm5lbCIsInVwZGF0ZUFkZHJlc3NMaXN0IiwiYWRkcmVzc0xpc3QiLCJsYkNvbmZpZyIsImV2ZXJ5IiwiZXhpdElkbGUiLCJyZXF1ZXN0UmVyZXNvbHV0aW9uIiwicmVzZXRCYWNrb2ZmIiwiZGVzdHJveSIsImdldFR5cGVOYW1lIiwicmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlIiwicmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst TRACER_NAME = \"round_robin\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = \"round_robin\";\nclass RoundRobinLoadBalancingConfig {\n    getLoadBalancerName() {\n        return TYPE_NAME;\n    }\n    constructor(){}\n    toJsonObject() {\n        return {\n            [TYPE_NAME]: {}\n        };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static createFromJson(obj) {\n        return new RoundRobinLoadBalancingConfig();\n    }\n}\nclass RoundRobinPicker {\n    constructor(subchannelList, nextIndex = 0){\n        this.subchannelList = subchannelList;\n        this.nextIndex = nextIndex;\n    }\n    pick(pickArgs) {\n        const pickedSubchannel = this.subchannelList[this.nextIndex];\n        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n        return {\n            pickResultType: picker_1.PickResultType.COMPLETE,\n            subchannel: pickedSubchannel,\n            status: null,\n            extraFilterFactories: [],\n            onCallStarted: null\n        };\n    }\n    /**\n     * Check what the next subchannel returned would be. Used by the load\n     * balancer implementation to preserve this part of the picker state if\n     * possible when a subchannel connects or disconnects.\n     */ peekNextSubchannel() {\n        return this.subchannelList[this.nextIndex];\n    }\n}\nclass RoundRobinLoadBalancer {\n    constructor(channelControlHelper){\n        this.channelControlHelper = channelControlHelper;\n        this.subchannels = [];\n        this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        this.currentReadyPicker = null;\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n        };\n        this.subchannelStateListener = (subchannel, previousState, newState)=>{\n            this.subchannelStateCounts[previousState] -= 1;\n            this.subchannelStateCounts[newState] += 1;\n            this.calculateAndUpdateState();\n            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE || newState === connectivity_state_1.ConnectivityState.IDLE) {\n                this.channelControlHelper.requestReresolution();\n                subchannel.startConnecting();\n            }\n        };\n    }\n    calculateAndUpdateState() {\n        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.READY] > 0) {\n            const readySubchannels = this.subchannels.filter((subchannel)=>subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n            let index = 0;\n            if (this.currentReadyPicker !== null) {\n                index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n                if (index < 0) {\n                    index = 0;\n                }\n            }\n            this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n        } else {\n            this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n    }\n    updateState(newState, picker) {\n        trace(connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (newState === connectivity_state_1.ConnectivityState.READY) {\n            this.currentReadyPicker = picker;\n        } else {\n            this.currentReadyPicker = null;\n        }\n        this.currentState = newState;\n        this.channelControlHelper.updateState(newState, picker);\n    }\n    resetSubchannelList() {\n        for (const subchannel of this.subchannels){\n            subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n            subchannel.unref();\n            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        }\n        this.subchannelStateCounts = {\n            [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n            [connectivity_state_1.ConnectivityState.IDLE]: 0,\n            [connectivity_state_1.ConnectivityState.READY]: 0,\n            [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n            [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n        };\n        this.subchannels = [];\n    }\n    updateAddressList(addressList, lbConfig) {\n        this.resetSubchannelList();\n        trace(\"Connect to address list \" + addressList.map((address)=>subchannel_address_1.subchannelAddressToString(address)));\n        this.subchannels = addressList.map((address)=>this.channelControlHelper.createSubchannel(address, {}));\n        for (const subchannel of this.subchannels){\n            subchannel.ref();\n            subchannel.addConnectivityStateListener(this.subchannelStateListener);\n            this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n            const subchannelState = subchannel.getConnectivityState();\n            this.subchannelStateCounts[subchannelState] += 1;\n            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                subchannel.startConnecting();\n            }\n        }\n        this.calculateAndUpdateState();\n    }\n    exitIdle() {\n        for (const subchannel of this.subchannels){\n            subchannel.startConnecting();\n        }\n    }\n    resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n         * does nothing */ }\n    destroy() {\n        this.resetSubchannelList();\n    }\n    getTypeName() {\n        return TYPE_NAME;\n    }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n    load_balancer_1.registerLoadBalancerType(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup; //# sourceMappingURL=load-balancer-round-robin.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQ3RELE1BQU1JLGtCQUFrQkMsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pELE1BQU1DLHVCQUF1QkQsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1JLFVBQVVKLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1NLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmSixRQUFRRyxLQUFLLENBQUNGLFlBQVlJLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBLE1BQU1HLFlBQVk7QUFDbEIsTUFBTUM7SUFDRkMsc0JBQXNCO1FBQ2xCLE9BQU9GO0lBQ1g7SUFDQUcsYUFBYyxDQUFFO0lBQ2hCQyxlQUFlO1FBQ1gsT0FBTztZQUNILENBQUNKLFVBQVUsRUFBRSxDQUFDO1FBQ2xCO0lBQ0o7SUFDQSw4REFBOEQ7SUFDOUQsT0FBT0ssZUFBZUMsR0FBRyxFQUFFO1FBQ3ZCLE9BQU8sSUFBSUw7SUFDZjtBQUNKO0FBQ0EsTUFBTU07SUFDRkosWUFBWUssY0FBYyxFQUFFQyxZQUFZLENBQUMsQ0FBRTtRQUN2QyxJQUFJLENBQUNELGNBQWMsR0FBR0E7UUFDdEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBO0lBQ3JCO0lBQ0FDLEtBQUtDLFFBQVEsRUFBRTtRQUNYLE1BQU1DLG1CQUFtQixJQUFJLENBQUNK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MkIsZUFBZTtJQUNYO3dCQUNnQixHQUNwQjtJQUNBQyxVQUFVO1FBQ04sSUFBSSxDQUFDbEIsbUJBQW1CO0lBQzVCO0lBQ0FtQixjQUFjO1FBQ1YsT0FBT25FO0lBQ1g7QUFDSjtBQUNBaEIsOEJBQThCLEdBQUdHO0FBQ2pDLFNBQVNEO0lBQ0xFLGdCQUFnQmdGLHdCQUF3QixDQUFDcEUsV0FBV2Isd0JBQXdCYztBQUNoRjtBQUNBakIsYUFBYSxHQUFHRSxPQUNoQixxREFBcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcz85ZWQ4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gZXhwb3J0cy5Sb3VuZFJvYmluTG9hZEJhbGFuY2VyID0gdm9pZCAwO1xuY29uc3QgbG9hZF9iYWxhbmNlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlclwiKTtcbmNvbnN0IGNvbm5lY3Rpdml0eV9zdGF0ZV8xID0gcmVxdWlyZShcIi4vY29ubmVjdGl2aXR5LXN0YXRlXCIpO1xuY29uc3QgcGlja2VyXzEgPSByZXF1aXJlKFwiLi9waWNrZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdyb3VuZF9yb2Jpbic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IFRZUEVfTkFNRSA9ICdyb3VuZF9yb2Jpbic7XG5jbGFzcyBSb3VuZFJvYmluTG9hZEJhbGFuY2luZ0NvbmZpZyB7XG4gICAgZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFRZUEVfTkFNRTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7IH1cbiAgICB0b0pzb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBbVFlQRV9OQU1FXToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgc3RhdGljIGNyZWF0ZUZyb21Kc29uKG9iaikge1xuICAgICAgICByZXR1cm4gbmV3IFJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnKCk7XG4gICAgfVxufVxuY2xhc3MgUm91bmRSb2JpblBpY2tlciB7XG4gICAgY29uc3RydWN0b3Ioc3ViY2hhbm5lbExpc3QsIG5leHRJbmRleCA9IDApIHtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsTGlzdCA9IHN1YmNoYW5uZWxMaXN0O1xuICAgICAgICB0aGlzLm5leHRJbmRleCA9IG5leHRJbmRleDtcbiAgICB9XG4gICAgcGljayhwaWNrQXJncykge1xuICAgICAgICBjb25zdCBwaWNrZWRTdWJjaGFubmVsID0gdGhpcy5zdWJjaGFubmVsTGlzdFt0aGlzLm5leHRJbmRleF07XG4gICAgICAgIHRoaXMubmV4dEluZGV4ID0gKHRoaXMubmV4dEluZGV4ICsgMSkgJSB0aGlzLnN1YmNoYW5uZWxMaXN0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBwaWNrZXJfMS5QaWNrUmVzdWx0VHlwZS5DT01QTEVURSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IHBpY2tlZFN1YmNoYW5uZWwsXG4gICAgICAgICAgICBzdGF0dXM6IG51bGwsXG4gICAgICAgICAgICBleHRyYUZpbHRlckZhY3RvcmllczogW10sXG4gICAgICAgICAgICBvbkNhbGxTdGFydGVkOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGF0IHRoZSBuZXh0IHN1YmNoYW5uZWwgcmV0dXJuZWQgd291bGQgYmUuIFVzZWQgYnkgdGhlIGxvYWRcbiAgICAgKiBiYWxhbmNlciBpbXBsZW1lbnRhdGlvbiB0byBwcmVzZXJ2ZSB0aGlzIHBhcnQgb2YgdGhlIHBpY2tlciBzdGF0ZSBpZlxuICAgICAqIHBvc3NpYmxlIHdoZW4gYSBzdWJjaGFubmVsIGNvbm5lY3RzIG9yIGRpc2Nvbm5lY3RzLlxuICAgICAqL1xuICAgIHBlZWtOZXh0U3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViY2hhbm5lbExpc3RbdGhpcy5uZXh0SW5kZXhdO1xuICAgIH1cbn1cbmNsYXNzIFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEU7XG4gICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHMgPSB7XG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR106IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlNIVVRET1dOXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV06IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIgPSAoc3ViY2hhbm5lbCwgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW3ByZXZpb3VzU3RhdGVdIC09IDE7XG4gICAgICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tuZXdTdGF0ZV0gKz0gMTtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlQW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUgfHxcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIucmVxdWVzdFJlcmVzb2x1dGlvbigpO1xuICAgICAgICAgICAgICAgIHN1YmNoYW5uZWwuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhbGN1bGF0ZUFuZFVwZGF0ZVN0YXRlKCkge1xuICAgICAgICBpZiAodGhpcy5zdWJjaGFubmVsU3RhdGVDb3VudHNbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcmVhZHlTdWJjaGFubmVscyA9IHRoaXMuc3ViY2hhbm5lbHMuZmlsdGVyKChzdWJjaGFubmVsKSA9PiBzdWJjaGFubmVsLmdldENvbm5lY3Rpdml0eVN0YXRlKCkgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVhZHlQaWNrZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHJlYWR5U3ViY2hhbm5lbHMuaW5kZXhPZih0aGlzLmN1cnJlbnRSZWFkeVBpY2tlci5wZWVrTmV4dFN1YmNoYW5uZWwoKSk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSwgbmV3IFJvdW5kUm9iaW5QaWNrZXIocmVhZHlTdWJjaGFubmVscywgaW5kZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU3RhdGUoY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORywgbmV3IHBpY2tlcl8xLlF1ZXVlUGlja2VyKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50c1tjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0gPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFLCBuZXcgcGlja2VyXzEuVW5hdmFpbGFibGVQaWNrZXIoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcikge1xuICAgICAgICB0cmFjZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVt0aGlzLmN1cnJlbnRTdGF0ZV0gK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW25ld1N0YXRlXSk7XG4gICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFJlYWR5UGlja2VyID0gcGlja2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVhZHlQaWNrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIudXBkYXRlU3RhdGUobmV3U3RhdGUsIHBpY2tlcik7XG4gICAgfVxuICAgIHJlc2V0U3ViY2hhbm5lbExpc3QoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc3ViY2hhbm5lbCBvZiB0aGlzLnN1YmNoYW5uZWxzKSB7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICBzdWJjaGFubmVsLnVucmVmKCk7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLnJlbW92ZUNoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YmNoYW5uZWxTdGF0ZUNvdW50cyA9IHtcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFXTogMCxcbiAgICAgICAgICAgIFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV06IDAsXG4gICAgICAgICAgICBbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuU0hVVERPV05dOiAwLFxuICAgICAgICAgICAgW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXTogMCxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVscyA9IFtdO1xuICAgIH1cbiAgICB1cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbGJDb25maWcpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgICAgIHRyYWNlKCdDb25uZWN0IHRvIGFkZHJlc3MgbGlzdCAnICtcbiAgICAgICAgICAgIGFkZHJlc3NMaXN0Lm1hcCgoYWRkcmVzcykgPT4gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhhZGRyZXNzKSkpO1xuICAgICAgICB0aGlzLnN1YmNoYW5uZWxzID0gYWRkcmVzc0xpc3QubWFwKChhZGRyZXNzKSA9PiB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmNyZWF0ZVN1YmNoYW5uZWwoYWRkcmVzcywge30pKTtcbiAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsIG9mIHRoaXMuc3ViY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIHN1YmNoYW5uZWwucmVmKCk7XG4gICAgICAgICAgICBzdWJjaGFubmVsLmFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIodGhpcy5zdWJjaGFubmVsU3RhdGVMaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQoc3ViY2hhbm5lbC5nZXRDaGFubmVselJlZigpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1YmNoYW5uZWxTdGF0ZSA9IHN1YmNoYW5uZWwuZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbFN0YXRlQ291bnRzW3N1YmNoYW5uZWxTdGF0ZV0gKz0gMTtcbiAgICAgICAgICAgIGlmIChzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUgfHxcbiAgICAgICAgICAgICAgICBzdWJjaGFubmVsU3RhdGUgPT09IGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKSB7XG4gICAgICAgICAgICAgICAgc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUFuZFVwZGF0ZVN0YXRlKCk7XG4gICAgfVxuICAgIGV4aXRJZGxlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHN1YmNoYW5uZWwgb2YgdGhpcy5zdWJjaGFubmVscykge1xuICAgICAgICAgICAgc3ViY2hhbm5lbC5zdGFydENvbm5lY3RpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNldEJhY2tvZmYoKSB7XG4gICAgICAgIC8qIFRoZSBwaWNrIGZpcnN0IGxvYWQgYmFsYW5jZXIgZG9lcyBub3QgaGF2ZSBhIGNvbm5lY3Rpb24gYmFja29mZiwgc28gdGhpc1xuICAgICAgICAgKiBkb2VzIG5vdGhpbmcgKi9cbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5yZXNldFN1YmNoYW5uZWxMaXN0KCk7XG4gICAgfVxuICAgIGdldFR5cGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gVFlQRV9OQU1FO1xuICAgIH1cbn1cbmV4cG9ydHMuUm91bmRSb2JpbkxvYWRCYWxhbmNlciA9IFJvdW5kUm9iaW5Mb2FkQmFsYW5jZXI7XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICBsb2FkX2JhbGFuY2VyXzEucmVnaXN0ZXJMb2FkQmFsYW5jZXJUeXBlKFRZUEVfTkFNRSwgUm91bmRSb2JpbkxvYWRCYWxhbmNlciwgUm91bmRSb2JpbkxvYWRCYWxhbmNpbmdDb25maWcpO1xufVxuZXhwb3J0cy5zZXR1cCA9IHNldHVwO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9hZC1iYWxhbmNlci1yb3VuZC1yb2Jpbi5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIlJvdW5kUm9iaW5Mb2FkQmFsYW5jZXIiLCJsb2FkX2JhbGFuY2VyXzEiLCJyZXF1aXJlIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJwaWNrZXJfMSIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwibG9nZ2luZyIsImNvbnN0YW50c18xIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIlRZUEVfTkFNRSIsIlJvdW5kUm9iaW5Mb2FkQmFsYW5jaW5nQ29uZmlnIiwiZ2V0TG9hZEJhbGFuY2VyTmFtZSIsImNvbnN0cnVjdG9yIiwidG9Kc29uT2JqZWN0IiwiY3JlYXRlRnJvbUpzb24iLCJvYmoiLCJSb3VuZFJvYmluUGlja2VyIiwic3ViY2hhbm5lbExpc3QiLCJuZXh0SW5kZXgiLCJwaWNrIiwicGlja0FyZ3MiLCJwaWNrZWRTdWJjaGFubmVsIiwibGVuZ3RoIiwicGlja1Jlc3VsdFR5cGUiLCJQaWNrUmVzdWx0VHlwZSIsIkNPTVBMRVRFIiwic3ViY2hhbm5lbCIsInN0YXR1cyIsImV4dHJhRmlsdGVyRmFjdG9yaWVzIiwib25DYWxsU3RhcnRlZCIsInBlZWtOZXh0U3ViY2hhbm5lbCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwic3ViY2hhbm5lbHMiLCJjdXJyZW50U3RhdGUiLCJDb25uZWN0aXZpdHlTdGF0ZSIsIklETEUiLCJjdXJyZW50UmVhZHlQaWNrZXIiLCJzdWJjaGFubmVsU3RhdGVDb3VudHMiLCJDT05ORUNUSU5HIiwiUkVBRFkiLCJTSFVURE9XTiIsIlRSQU5TSUVOVF9GQUlMVVJFIiwic3ViY2hhbm5lbFN0YXRlTGlzdGVuZXIiLCJwcmV2aW91c1N0YXRlIiwibmV3U3RhdGUiLCJjYWxjdWxhdGVBbmRVcGRhdGVTdGF0ZSIsInJlcXVlc3RSZXJlc29sdXRpb24iLCJzdGFydENvbm5lY3RpbmciLCJyZWFkeVN1YmNoYW5uZWxzIiwiZmlsdGVyIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJpbmRleCIsImluZGV4T2YiLCJ1cGRhdGVTdGF0ZSIsIlF1ZXVlUGlja2VyIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJwaWNrZXIiLCJyZXNldFN1YmNoYW5uZWxMaXN0IiwicmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsInVucmVmIiwicmVtb3ZlQ2hhbm5lbHpDaGlsZCIsImdldENoYW5uZWx6UmVmIiwidXBkYXRlQWRkcmVzc0xpc3QiLCJhZGRyZXNzTGlzdCIsImxiQ29uZmlnIiwibWFwIiwiYWRkcmVzcyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJjcmVhdGVTdWJjaGFubmVsIiwicmVmIiwiYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsImFkZENoYW5uZWx6Q2hpbGQiLCJzdWJjaGFubmVsU3RhdGUiLCJleGl0SWRsZSIsInJlc2V0QmFja29mZiIsImRlc3Ryb3kiLCJnZXRUeXBlTmFtZSIsInJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js":
/*!***************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/load-balancer.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.validateLoadBalancingConfig = exports.getFirstUsableConfig = exports.isLoadBalancerNameRegistered = exports.createLoadBalancer = exports.registerDefaultLoadBalancerType = exports.registerLoadBalancerType = exports.createChildChannelControlHelper = void 0;\n/**\n * Create a child ChannelControlHelper that overrides some methods of the\n * parent while letting others pass through to the parent unmodified. This\n * allows other code to create these children without needing to know about\n * all of the methods to be passed through.\n * @param parent\n * @param overrides\n */ function createChildChannelControlHelper(parent, overrides) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    return {\n        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),\n        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),\n        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),\n        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),\n        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent)\n    };\n}\nexports.createChildChannelControlHelper = createChildChannelControlHelper;\nconst registeredLoadBalancerTypes = {};\nlet defaultLoadBalancerType = null;\nfunction registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {\n    registeredLoadBalancerTypes[typeName] = {\n        LoadBalancer: loadBalancerType,\n        LoadBalancingConfig: loadBalancingConfigType\n    };\n}\nexports.registerLoadBalancerType = registerLoadBalancerType;\nfunction registerDefaultLoadBalancerType(typeName) {\n    defaultLoadBalancerType = typeName;\n}\nexports.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;\nfunction createLoadBalancer(config, channelControlHelper) {\n    const typeName = config.getLoadBalancerName();\n    if (typeName in registeredLoadBalancerTypes) {\n        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);\n    } else {\n        return null;\n    }\n}\nexports.createLoadBalancer = createLoadBalancer;\nfunction isLoadBalancerNameRegistered(typeName) {\n    return typeName in registeredLoadBalancerTypes;\n}\nexports.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;\nfunction getFirstUsableConfig(configs, fallbackTodefault = false) {\n    for (const config of configs){\n        if (config.getLoadBalancerName() in registeredLoadBalancerTypes) {\n            return config;\n        }\n    }\n    if (fallbackTodefault) {\n        if (defaultLoadBalancerType) {\n            return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();\n        } else {\n            return null;\n        }\n    } else {\n        return null;\n    }\n}\nexports.getFirstUsableConfig = getFirstUsableConfig;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction validateLoadBalancingConfig(obj) {\n    if (!(obj !== null && typeof obj === \"object\")) {\n        throw new Error(\"Load balancing config must be an object\");\n    }\n    const keys = Object.keys(obj);\n    if (keys.length !== 1) {\n        throw new Error(\"Provided load balancing config has multiple conflicting entries\");\n    }\n    const typeName = keys[0];\n    if (typeName in registeredLoadBalancerTypes) {\n        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);\n    } else {\n        throw new Error(`Unrecognized load balancing config name ${typeName}`);\n    }\n}\nexports.validateLoadBalancingConfig = validateLoadBalancingConfig; //# sourceMappingURL=load-balancer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9hZC1iYWxhbmNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUNBQW1DLEdBQUdBLDRCQUE0QixHQUFHQSxvQ0FBb0MsR0FBR0EsMEJBQTBCLEdBQUdBLHVDQUF1QyxHQUFHQSxnQ0FBZ0MsR0FBR0EsdUNBQXVDLEdBQUcsS0FBSztBQUNyUTs7Ozs7OztDQU9DLEdBQ0QsU0FBU1EsZ0NBQWdDQyxNQUFNLEVBQUVDLFNBQVM7SUFDdEQsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUM7SUFDeEMsT0FBTztRQUNIQyxrQkFBa0IsQ0FBQ1QsS0FBSyxDQUFDRCxLQUFLRCxVQUFVVyxnQkFBZ0IsTUFBTSxRQUFRVixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdXLElBQUksQ0FBQ1osVUFBUyxNQUFPLFFBQVFFLE9BQU8sS0FBSyxJQUFJQSxLQUFLSCxPQUFPWSxnQkFBZ0IsQ0FBQ0MsSUFBSSxDQUFDYjtRQUNqTGMsYUFBYSxDQUFDVCxLQUFLLENBQUNELEtBQUtILFVBQVVhLFdBQVcsTUFBTSxRQUFRVixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdTLElBQUksQ0FBQ1osVUFBUyxNQUFPLFFBQVFJLE9BQU8sS0FBSyxJQUFJQSxLQUFLTCxPQUFPYyxXQUFXLENBQUNELElBQUksQ0FBQ2I7UUFDbEtlLHFCQUFxQixDQUFDUixLQUFLLENBQUNELEtBQUtMLFVBQVVjLG1CQUFtQixNQUFNLFFBQVFULE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR08sSUFBSSxDQUFDWixVQUFTLE1BQU8sUUFBUU0sT0FBTyxLQUFLLElBQUlBLEtBQUtQLE9BQU9lLG1CQUFtQixDQUFDRixJQUFJLENBQUNiO1FBQzFMZ0Isa0JBQWtCLENBQUNQLEtBQUssQ0FBQ0QsS0FBS1AsVUFBVWUsZ0JBQWdCLE1BQU0sUUFBUVIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHSyxJQUFJLENBQUNaLFVBQVMsTUFBTyxRQUFRUSxPQUFPLEtBQUssSUFBSUEsS0FBS1QsT0FBT2dCLGdCQUFnQixDQUFDSCxJQUFJLENBQUNiO1FBQ2pMaUIscUJBQXFCLENBQUNOLEtBQUssQ0FBQ0QsS0FBS1QsVUFBVWdCLG1CQUFtQixNQUFNLFFBQVFQLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0csSUFBSSxDQUFDWixVQUFTLE1BQU8sUUFBUVUsT0FBTyxLQUFLLElBQUlBLEtBQUtYLE9BQU9pQixtQkFBbUIsQ0FBQ0osSUFBSSxDQUFDYjtJQUM5TDtBQUNKO0FBQ0FULHVDQUF1QyxHQUFHUTtBQUMxQyxNQUFNbUIsOEJBQThCLENBQUM7QUFDckMsSUFBSUMsMEJBQTBCO0FBQzlCLFNBQVNyQix5QkFBeUJzQixRQUFRLEVBQUVDLGdCQUFnQixFQUFFQyx1QkFBdUI7SUFDakZKLDJCQUEyQixDQUFDRSxTQUFTLEdBQUc7UUFDcENHLGNBQWNGO1FBQ2RHLHFCQUFxQkY7SUFDekI7QUFDSjtBQUNBL0IsZ0NBQWdDLEdBQUdPO0FBQ25DLFNBQVNELGdDQUFnQ3VCLFFBQVE7SUFDN0NELDBCQUEwQkM7QUFDOUI7QUFDQTdCLHVDQUF1QyxHQUFHTTtBQUMxQyxTQUFTRCxtQkFBbUI2QixNQUFNLEVBQUVDLG9CQUFvQjtJQUNwRCxNQUFNTixXQUFXSyxPQUFPRSxtQkFBbUI7SUFDM0MsSUFBSVAsWUFBWUYsNkJBQTZCO1FBQ3pDLE9BQU8sSUFBSUEsMkJBQTJCLENBQUNFLFNBQVMsQ0FBQ0csWUFBWSxDQUFDRztJQUNsRSxPQUNLO1FBQ0QsT0FBTztJQUNYO0FBQ0o7QUFDQW5DLDBCQUEwQixHQUFHSztBQUM3QixTQUFTRCw2QkFBNkJ5QixRQUFRO0lBQzFDLE9BQU9BLFlBQVlGO0FBQ3ZCO0FBQ0EzQixvQ0FBb0MsR0FBR0k7QUFDdkMsU0FBU0QscUJBQXFCa0MsT0FBTyxFQUFFQyxvQkFBb0IsS0FBSztJQUM1RCxLQUFLLE1BQU1KLFVBQVVHLFFBQVM7UUFDMUIsSUFBSUgsT0FBT0UsbUJBQW1CLE1BQU1ULDZCQUE2QjtZQUM3RCxPQUFPTztRQUNYO0lBQ0o7SUFDQSxJQUFJSSxtQkFBbUI7UUFDbkIsSUFBSVYseUJBQXlCO1lBQ3pCLE9BQU8sSUFBSUQsMkJBQTJCLENBQUNDLHdCQUF3QixDQUFDSyxtQkFBbUI7UUFDdkYsT0FDSztZQUNELE9BQU87UUFDWDtJQUNKLE9BQ0s7UUFDRCxPQUFPO0lBQ1g7QUFDSjtBQUNBakMsNEJBQTRCLEdBQUdHO0FBQy9CLDhEQUE4RDtBQUM5RCxTQUFTRCw0QkFBNEJxQyxHQUFHO0lBQ3BDLElBQUksQ0FBRUEsQ0FBQUEsUUFBUSxRQUFRLE9BQU9BLFFBQVEsUUFBTyxHQUFJO1FBQzVDLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBLE1BQU1DLE9BQU8zQyxPQUFPMkMsSUFBSSxDQUFDRjtJQUN6QixJQUFJRSxLQUFLQyxNQUFNLEtBQUssR0FBRztRQUNuQixNQUFNLElBQUlGLE1BQU07SUFDcEI7SUFDQSxNQUFNWCxXQUFXWSxJQUFJLENBQUMsRUFBRTtJQUN4QixJQUFJWixZQUFZRiw2QkFBNkI7UUFDekMsT0FBT0EsMkJBQTJCLENBQUNFLFNBQVMsQ0FBQ0ksbUJBQW1CLENBQUNVLGNBQWMsQ0FBQ0osR0FBRyxDQUFDVixTQUFTO0lBQ2pHLE9BQ0s7UUFDRCxNQUFNLElBQUlXLE1BQU0sQ0FBQyx3Q0FBd0MsRUFBRVgsU0FBUyxDQUFDO0lBQ3pFO0FBQ0o7QUFDQTdCLG1DQUFtQyxHQUFHRSw2QkFDdEMseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL2xvYWQtYmFsYW5jZXIuanM/MjdjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcgPSBleHBvcnRzLmdldEZpcnN0VXNhYmxlQ29uZmlnID0gZXhwb3J0cy5pc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkID0gZXhwb3J0cy5jcmVhdGVMb2FkQmFsYW5jZXIgPSBleHBvcnRzLnJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUgPSBleHBvcnRzLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSA9IGV4cG9ydHMuY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlciA9IHZvaWQgMDtcbi8qKlxuICogQ3JlYXRlIGEgY2hpbGQgQ2hhbm5lbENvbnRyb2xIZWxwZXIgdGhhdCBvdmVycmlkZXMgc29tZSBtZXRob2RzIG9mIHRoZVxuICogcGFyZW50IHdoaWxlIGxldHRpbmcgb3RoZXJzIHBhc3MgdGhyb3VnaCB0byB0aGUgcGFyZW50IHVubW9kaWZpZWQuIFRoaXNcbiAqIGFsbG93cyBvdGhlciBjb2RlIHRvIGNyZWF0ZSB0aGVzZSBjaGlsZHJlbiB3aXRob3V0IG5lZWRpbmcgdG8ga25vdyBhYm91dFxuICogYWxsIG9mIHRoZSBtZXRob2RzIHRvIGJlIHBhc3NlZCB0aHJvdWdoLlxuICogQHBhcmFtIHBhcmVudFxuICogQHBhcmFtIG92ZXJyaWRlc1xuICovXG5mdW5jdGlvbiBjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyKHBhcmVudCwgb3ZlcnJpZGVzKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNyZWF0ZVN1YmNoYW5uZWw6IChfYiA9IChfYSA9IG92ZXJyaWRlcy5jcmVhdGVTdWJjaGFubmVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBwYXJlbnQuY3JlYXRlU3ViY2hhbm5lbC5iaW5kKHBhcmVudCksXG4gICAgICAgIHVwZGF0ZVN0YXRlOiAoX2QgPSAoX2MgPSBvdmVycmlkZXMudXBkYXRlU3RhdGUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iaW5kKG92ZXJyaWRlcykpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHBhcmVudC51cGRhdGVTdGF0ZS5iaW5kKHBhcmVudCksXG4gICAgICAgIHJlcXVlc3RSZXJlc29sdXRpb246IChfZiA9IChfZSA9IG92ZXJyaWRlcy5yZXF1ZXN0UmVyZXNvbHV0aW9uKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBwYXJlbnQucmVxdWVzdFJlcmVzb2x1dGlvbi5iaW5kKHBhcmVudCksXG4gICAgICAgIGFkZENoYW5uZWx6Q2hpbGQ6IChfaCA9IChfZyA9IG92ZXJyaWRlcy5hZGRDaGFubmVsekNoaWxkKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBwYXJlbnQuYWRkQ2hhbm5lbHpDaGlsZC5iaW5kKHBhcmVudCksXG4gICAgICAgIHJlbW92ZUNoYW5uZWx6Q2hpbGQ6IChfayA9IChfaiA9IG92ZXJyaWRlcy5yZW1vdmVDaGFubmVsekNoaWxkKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouYmluZChvdmVycmlkZXMpKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiBwYXJlbnQucmVtb3ZlQ2hhbm5lbHpDaGlsZC5iaW5kKHBhcmVudClcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyID0gY3JlYXRlQ2hpbGRDaGFubmVsQ29udHJvbEhlbHBlcjtcbmNvbnN0IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcyA9IHt9O1xubGV0IGRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlID0gbnVsbDtcbmZ1bmN0aW9uIHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSh0eXBlTmFtZSwgbG9hZEJhbGFuY2VyVHlwZSwgbG9hZEJhbGFuY2luZ0NvbmZpZ1R5cGUpIHtcbiAgICByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbdHlwZU5hbWVdID0ge1xuICAgICAgICBMb2FkQmFsYW5jZXI6IGxvYWRCYWxhbmNlclR5cGUsXG4gICAgICAgIExvYWRCYWxhbmNpbmdDb25maWc6IGxvYWRCYWxhbmNpbmdDb25maWdUeXBlLFxuICAgIH07XG59XG5leHBvcnRzLnJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZSA9IHJlZ2lzdGVyTG9hZEJhbGFuY2VyVHlwZTtcbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUodHlwZU5hbWUpIHtcbiAgICBkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZSA9IHR5cGVOYW1lO1xufVxuZXhwb3J0cy5yZWdpc3RlckRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlID0gcmVnaXN0ZXJEZWZhdWx0TG9hZEJhbGFuY2VyVHlwZTtcbmZ1bmN0aW9uIGNyZWF0ZUxvYWRCYWxhbmNlcihjb25maWcsIGNoYW5uZWxDb250cm9sSGVscGVyKSB7XG4gICAgY29uc3QgdHlwZU5hbWUgPSBjb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpO1xuICAgIGlmICh0eXBlTmFtZSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXNbdHlwZU5hbWVdLkxvYWRCYWxhbmNlcihjaGFubmVsQ29udHJvbEhlbHBlcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUxvYWRCYWxhbmNlciA9IGNyZWF0ZUxvYWRCYWxhbmNlcjtcbmZ1bmN0aW9uIGlzTG9hZEJhbGFuY2VyTmFtZVJlZ2lzdGVyZWQodHlwZU5hbWUpIHtcbiAgICByZXR1cm4gdHlwZU5hbWUgaW4gcmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzO1xufVxuZXhwb3J0cy5pc0xvYWRCYWxhbmNlck5hbWVSZWdpc3RlcmVkID0gaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZDtcbmZ1bmN0aW9uIGdldEZpcnN0VXNhYmxlQ29uZmlnKGNvbmZpZ3MsIGZhbGxiYWNrVG9kZWZhdWx0ID0gZmFsc2UpIHtcbiAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBjb25maWdzKSB7XG4gICAgICAgIGlmIChjb25maWcuZ2V0TG9hZEJhbGFuY2VyTmFtZSgpIGluIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmFsbGJhY2tUb2RlZmF1bHQpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRMb2FkQmFsYW5jZXJUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1tkZWZhdWx0TG9hZEJhbGFuY2VyVHlwZV0uTG9hZEJhbGFuY2luZ0NvbmZpZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0Rmlyc3RVc2FibGVDb25maWcgPSBnZXRGaXJzdFVzYWJsZUNvbmZpZztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcob2JqKSB7XG4gICAgaWYgKCEob2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWQgYmFsYW5jaW5nIGNvbmZpZyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBpZiAoa2V5cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlZCBsb2FkIGJhbGFuY2luZyBjb25maWcgaGFzIG11bHRpcGxlIGNvbmZsaWN0aW5nIGVudHJpZXMnKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZU5hbWUgPSBrZXlzWzBdO1xuICAgIGlmICh0eXBlTmFtZSBpbiByZWdpc3RlcmVkTG9hZEJhbGFuY2VyVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRMb2FkQmFsYW5jZXJUeXBlc1t0eXBlTmFtZV0uTG9hZEJhbGFuY2luZ0NvbmZpZy5jcmVhdGVGcm9tSnNvbihvYmpbdHlwZU5hbWVdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGxvYWQgYmFsYW5jaW5nIGNvbmZpZyBuYW1lICR7dHlwZU5hbWV9YCk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWcgPSB2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2FkLWJhbGFuY2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyIsImdldEZpcnN0VXNhYmxlQ29uZmlnIiwiaXNMb2FkQmFsYW5jZXJOYW1lUmVnaXN0ZXJlZCIsImNyZWF0ZUxvYWRCYWxhbmNlciIsInJlZ2lzdGVyRGVmYXVsdExvYWRCYWxhbmNlclR5cGUiLCJyZWdpc3RlckxvYWRCYWxhbmNlclR5cGUiLCJjcmVhdGVDaGlsZENoYW5uZWxDb250cm9sSGVscGVyIiwicGFyZW50Iiwib3ZlcnJpZGVzIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJfaCIsIl9qIiwiX2siLCJjcmVhdGVTdWJjaGFubmVsIiwiYmluZCIsInVwZGF0ZVN0YXRlIiwicmVxdWVzdFJlcmVzb2x1dGlvbiIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZW1vdmVDaGFubmVsekNoaWxkIiwicmVnaXN0ZXJlZExvYWRCYWxhbmNlclR5cGVzIiwiZGVmYXVsdExvYWRCYWxhbmNlclR5cGUiLCJ0eXBlTmFtZSIsImxvYWRCYWxhbmNlclR5cGUiLCJsb2FkQmFsYW5jaW5nQ29uZmlnVHlwZSIsIkxvYWRCYWxhbmNlciIsIkxvYWRCYWxhbmNpbmdDb25maWciLCJjb25maWciLCJjaGFubmVsQ29udHJvbEhlbHBlciIsImdldExvYWRCYWxhbmNlck5hbWUiLCJjb25maWdzIiwiZmFsbGJhY2tUb2RlZmF1bHQiLCJvYmoiLCJFcnJvciIsImtleXMiLCJsZW5ndGgiLCJjcmVhdGVGcm9tSnNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js":
/*!*********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/logging.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ var _a, _b, _c, _d;\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.isTracerEnabled = exports.trace = exports.log = exports.setLoggerVerbosity = exports.setLogger = exports.getLogger = void 0;\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst DEFAULT_LOGGER = {\n    error: (message, ...optionalParams)=>{\n        console.error(\"E \" + message, ...optionalParams);\n    },\n    info: (message, ...optionalParams)=>{\n        console.error(\"I \" + message, ...optionalParams);\n    },\n    debug: (message, ...optionalParams)=>{\n        console.error(\"D \" + message, ...optionalParams);\n    }\n};\nlet _logger = DEFAULT_LOGGER;\nlet _logVerbosity = constants_1.LogVerbosity.ERROR;\nconst verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : \"\";\nswitch(verbosityString.toUpperCase()){\n    case \"DEBUG\":\n        _logVerbosity = constants_1.LogVerbosity.DEBUG;\n        break;\n    case \"INFO\":\n        _logVerbosity = constants_1.LogVerbosity.INFO;\n        break;\n    case \"ERROR\":\n        _logVerbosity = constants_1.LogVerbosity.ERROR;\n        break;\n    case \"NONE\":\n        _logVerbosity = constants_1.LogVerbosity.NONE;\n        break;\n    default:\n}\nexports.getLogger = ()=>{\n    return _logger;\n};\nexports.setLogger = (logger)=>{\n    _logger = logger;\n};\nexports.setLoggerVerbosity = (verbosity)=>{\n    _logVerbosity = verbosity;\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexports.log = (severity, ...args)=>{\n    let logFunction;\n    if (severity >= _logVerbosity) {\n        switch(severity){\n            case constants_1.LogVerbosity.DEBUG:\n                logFunction = _logger.debug;\n                break;\n            case constants_1.LogVerbosity.INFO:\n                logFunction = _logger.info;\n                break;\n            case constants_1.LogVerbosity.ERROR:\n                logFunction = _logger.error;\n                break;\n        }\n        /* Fall back to _logger.error when other methods are not available for\n         * compatiblity with older behavior that always logged to _logger.error */ if (!logFunction) {\n            logFunction = _logger.error;\n        }\n        if (logFunction) {\n            logFunction.bind(_logger)(...args);\n        }\n    }\n};\nconst tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : \"\";\nconst enabledTracers = new Set();\nconst disabledTracers = new Set();\nfor (const tracerName of tracersString.split(\",\")){\n    if (tracerName.startsWith(\"-\")) {\n        disabledTracers.add(tracerName.substring(1));\n    } else {\n        enabledTracers.add(tracerName);\n    }\n}\nconst allEnabled = enabledTracers.has(\"all\");\nfunction trace(severity, tracer, text) {\n    if (isTracerEnabled(tracer)) {\n        exports.log(severity, new Date().toISOString() + \" | \" + tracer + \" | \" + text);\n    }\n}\nexports.trace = trace;\nfunction isTracerEnabled(tracer) {\n    return !disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer));\n}\nexports.isTracerEnabled = isTracerEnabled; //# sourceMappingURL=logging.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELElBQUlBLElBQUlDLElBQUlDLElBQUlDO0FBQ2hCQyw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsdUJBQXVCLEdBQUdBLGFBQWEsR0FBR0EsV0FBVyxHQUFHQSwwQkFBMEIsR0FBR0EsaUJBQWlCLEdBQUdBLGlCQUFpQixHQUFHLEtBQUs7QUFDbEksTUFBTVEsY0FBY0MsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUMsaUJBQWlCO0lBQ25CQyxPQUFPLENBQUNDLFNBQVMsR0FBR0M7UUFDaEJDLFFBQVFILEtBQUssQ0FBQyxPQUFPQyxZQUFZQztJQUNyQztJQUNBRSxNQUFNLENBQUNILFNBQVMsR0FBR0M7UUFDZkMsUUFBUUgsS0FBSyxDQUFDLE9BQU9DLFlBQVlDO0lBQ3JDO0lBQ0FHLE9BQU8sQ0FBQ0osU0FBUyxHQUFHQztRQUNoQkMsUUFBUUgsS0FBSyxDQUFDLE9BQU9DLFlBQVlDO0lBQ3JDO0FBQ0o7QUFDQSxJQUFJSSxVQUFVUDtBQUNkLElBQUlRLGdCQUFnQlYsWUFBWVcsWUFBWSxDQUFDQyxLQUFLO0FBQ2xELE1BQU1DLGtCQUFrQixDQUFDMUIsS0FBSyxDQUFDRCxLQUFLNEIsUUFBUUMsR0FBRyxDQUFDQyxtQkFBbUIsTUFBTSxRQUFROUIsT0FBTyxLQUFLLElBQUlBLEtBQUs0QixRQUFRQyxHQUFHLENBQUNFLGNBQWMsTUFBTSxRQUFROUIsT0FBTyxLQUFLLElBQUlBLEtBQUs7QUFDbkssT0FBUTBCLGdCQUFnQkssV0FBVztJQUMvQixLQUFLO1FBQ0RSLGdCQUFnQlYsWUFBWVcsWUFBWSxDQUFDUSxLQUFLO1FBQzlDO0lBQ0osS0FBSztRQUNEVCxnQkFBZ0JWLFlBQVlXLFlBQVksQ0FBQ1MsSUFBSTtRQUM3QztJQUNKLEtBQUs7UUFDRFYsZ0JBQWdCVixZQUFZVyxZQUFZLENBQUNDLEtBQUs7UUFDOUM7SUFDSixLQUFLO1FBQ0RGLGdCQUFnQlYsWUFBWVcsWUFBWSxDQUFDVSxJQUFJO1FBQzdDO0lBQ0o7QUFFSjtBQUNBN0IsaUJBQWlCLEdBQUc7SUFDaEIsT0FBT2lCO0FBQ1g7QUFDQWpCLGlCQUFpQixHQUFHLENBQUM4QjtJQUNqQmIsVUFBVWE7QUFDZDtBQUNBOUIsMEJBQTBCLEdBQUcsQ0FBQytCO0lBQzFCYixnQkFBZ0JhO0FBQ3BCO0FBQ0EsOERBQThEO0FBQzlEL0IsV0FBVyxHQUFHLENBQUNnQyxVQUFVLEdBQUdDO0lBQ3hCLElBQUlDO0lBQ0osSUFBSUYsWUFBWWQsZUFBZTtRQUMzQixPQUFRYztZQUNKLEtBQUt4QixZQUFZVyxZQUFZLENBQUNRLEtBQUs7Z0JBQy9CTyxjQUFjakIsUUFBUUQsS0FBSztnQkFDM0I7WUFDSixLQUFLUixZQUFZVyxZQUFZLENBQUNTLElBQUk7Z0JBQzlCTSxjQUFjakIsUUFBUUYsSUFBSTtnQkFDMUI7WUFDSixLQUFLUCxZQUFZVyxZQUFZLENBQUNDLEtBQUs7Z0JBQy9CYyxjQUFjakIsUUFBUU4sS0FBSztnQkFDM0I7UUFDUjtRQUNBO2dGQUN3RSxHQUN4RSxJQUFJLENBQUN1QixhQUFhO1lBQ2RBLGNBQWNqQixRQUFRTixLQUFLO1FBQy9CO1FBQ0EsSUFBSXVCLGFBQWE7WUFDYkEsWUFBWUMsSUFBSSxDQUFDbEIsWUFBWWdCO1FBQ2pDO0lBQ0o7QUFDSjtBQUNBLE1BQU1HLGdCQUFnQixDQUFDdkMsS0FBSyxDQUFDRCxLQUFLMEIsUUFBUUMsR0FBRyxDQUFDYyxlQUFlLE1BQU0sUUFBUXpDLE9BQU8sS0FBSyxJQUFJQSxLQUFLMEIsUUFBUUMsR0FBRyxDQUFDZSxVQUFVLE1BQU0sUUFBUXpDLE9BQU8sS0FBSyxJQUFJQSxLQUFLO0FBQ3pKLE1BQU0wQyxpQkFBaUIsSUFBSUM7QUFDM0IsTUFBTUMsa0JBQWtCLElBQUlEO0FBQzVCLEtBQUssTUFBTUUsY0FBY04sY0FBY08sS0FBSyxDQUFDLEtBQU07SUFDL0MsSUFBSUQsV0FBV0UsVUFBVSxDQUFDLE1BQU07UUFDNUJILGdCQUFnQkksR0FBRyxDQUFDSCxXQUFXSSxTQUFTLENBQUM7SUFDN0MsT0FDSztRQUNEUCxlQUFlTSxHQUFHLENBQUNIO0lBQ3ZCO0FBQ0o7QUFDQSxNQUFNSyxhQUFhUixlQUFlUyxHQUFHLENBQUM7QUFDdEMsU0FBUzdDLE1BQU02QixRQUFRLEVBQUVpQixNQUFNLEVBQUVDLElBQUk7SUFDakMsSUFBSWhELGdCQUFnQitDLFNBQVM7UUFDekJqRCxRQUFRSSxHQUFHLENBQUM0QixVQUFVLElBQUltQixPQUFPQyxXQUFXLEtBQUssUUFBUUgsU0FBUyxRQUFRQztJQUM5RTtBQUNKO0FBQ0FsRCxhQUFhLEdBQUdHO0FBQ2hCLFNBQVNELGdCQUFnQitDLE1BQU07SUFDM0IsT0FBTyxDQUFDUixnQkFBZ0JPLEdBQUcsQ0FBQ0MsV0FDdkJGLENBQUFBLGNBQWNSLGVBQWVTLEdBQUcsQ0FBQ0MsT0FBTTtBQUNoRDtBQUNBakQsdUJBQXVCLEdBQUdFLGlCQUMxQixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbG9nZ2luZy5qcz80NTNkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG52YXIgX2EsIF9iLCBfYywgX2Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzVHJhY2VyRW5hYmxlZCA9IGV4cG9ydHMudHJhY2UgPSBleHBvcnRzLmxvZyA9IGV4cG9ydHMuc2V0TG9nZ2VyVmVyYm9zaXR5ID0gZXhwb3J0cy5zZXRMb2dnZXIgPSBleHBvcnRzLmdldExvZ2dlciA9IHZvaWQgMDtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgREVGQVVMVF9MT0dHRVIgPSB7XG4gICAgZXJyb3I6IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfSxcbiAgICBpbmZvOiAobWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpID0+IHtcbiAgICAgICAgY29uc29sZS5lcnJvcignSSAnICsgbWVzc2FnZSwgLi4ub3B0aW9uYWxQYXJhbXMpO1xuICAgIH0sXG4gICAgZGVidWc6IChtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcykgPT4ge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdEICcgKyBtZXNzYWdlLCAuLi5vcHRpb25hbFBhcmFtcyk7XG4gICAgfSxcbn07XG5sZXQgX2xvZ2dlciA9IERFRkFVTFRfTE9HR0VSO1xubGV0IF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1I7XG5jb25zdCB2ZXJib3NpdHlTdHJpbmcgPSAoX2IgPSAoX2EgPSBwcm9jZXNzLmVudi5HUlBDX05PREVfVkVSQk9TSVRZKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBwcm9jZXNzLmVudi5HUlBDX1ZFUkJPU0lUWSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJyc7XG5zd2l0Y2ggKHZlcmJvc2l0eVN0cmluZy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgY2FzZSAnREVCVUcnOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdJTkZPJzpcbiAgICAgICAgX2xvZ1ZlcmJvc2l0eSA9IGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5JTkZPO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdFUlJPUic6XG4gICAgICAgIF9sb2dWZXJib3NpdHkgPSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1I7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ05PTkUnOlxuICAgICAgICBfbG9nVmVyYm9zaXR5ID0gY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5Lk5PTkU7XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgLy8gSWdub3JlIGFueSBvdGhlciB2YWx1ZXNcbn1cbmV4cG9ydHMuZ2V0TG9nZ2VyID0gKCkgPT4ge1xuICAgIHJldHVybiBfbG9nZ2VyO1xufTtcbmV4cG9ydHMuc2V0TG9nZ2VyID0gKGxvZ2dlcikgPT4ge1xuICAgIF9sb2dnZXIgPSBsb2dnZXI7XG59O1xuZXhwb3J0cy5zZXRMb2dnZXJWZXJib3NpdHkgPSAodmVyYm9zaXR5KSA9PiB7XG4gICAgX2xvZ1ZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbn07XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0cy5sb2cgPSAoc2V2ZXJpdHksIC4uLmFyZ3MpID0+IHtcbiAgICBsZXQgbG9nRnVuY3Rpb247XG4gICAgaWYgKHNldmVyaXR5ID49IF9sb2dWZXJib3NpdHkpIHtcbiAgICAgICAgc3dpdGNoIChzZXZlcml0eSkge1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUc6XG4gICAgICAgICAgICAgICAgbG9nRnVuY3Rpb24gPSBfbG9nZ2VyLmRlYnVnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuSU5GTzpcbiAgICAgICAgICAgICAgICBsb2dGdW5jdGlvbiA9IF9sb2dnZXIuaW5mbztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkVSUk9SOlxuICAgICAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5lcnJvcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvKiBGYWxsIGJhY2sgdG8gX2xvZ2dlci5lcnJvciB3aGVuIG90aGVyIG1ldGhvZHMgYXJlIG5vdCBhdmFpbGFibGUgZm9yXG4gICAgICAgICAqIGNvbXBhdGlibGl0eSB3aXRoIG9sZGVyIGJlaGF2aW9yIHRoYXQgYWx3YXlzIGxvZ2dlZCB0byBfbG9nZ2VyLmVycm9yICovXG4gICAgICAgIGlmICghbG9nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGxvZ0Z1bmN0aW9uID0gX2xvZ2dlci5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9nRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGxvZ0Z1bmN0aW9uLmJpbmQoX2xvZ2dlcikoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgdHJhY2Vyc1N0cmluZyA9IChfZCA9IChfYyA9IHByb2Nlc3MuZW52LkdSUENfTk9ERV9UUkFDRSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogcHJvY2Vzcy5lbnYuR1JQQ19UUkFDRSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogJyc7XG5jb25zdCBlbmFibGVkVHJhY2VycyA9IG5ldyBTZXQoKTtcbmNvbnN0IGRpc2FibGVkVHJhY2VycyA9IG5ldyBTZXQoKTtcbmZvciAoY29uc3QgdHJhY2VyTmFtZSBvZiB0cmFjZXJzU3RyaW5nLnNwbGl0KCcsJykpIHtcbiAgICBpZiAodHJhY2VyTmFtZS5zdGFydHNXaXRoKCctJykpIHtcbiAgICAgICAgZGlzYWJsZWRUcmFjZXJzLmFkZCh0cmFjZXJOYW1lLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbmFibGVkVHJhY2Vycy5hZGQodHJhY2VyTmFtZSk7XG4gICAgfVxufVxuY29uc3QgYWxsRW5hYmxlZCA9IGVuYWJsZWRUcmFjZXJzLmhhcygnYWxsJyk7XG5mdW5jdGlvbiB0cmFjZShzZXZlcml0eSwgdHJhY2VyLCB0ZXh0KSB7XG4gICAgaWYgKGlzVHJhY2VyRW5hYmxlZCh0cmFjZXIpKSB7XG4gICAgICAgIGV4cG9ydHMubG9nKHNldmVyaXR5LCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCkgKyAnIHwgJyArIHRyYWNlciArICcgfCAnICsgdGV4dCk7XG4gICAgfVxufVxuZXhwb3J0cy50cmFjZSA9IHRyYWNlO1xuZnVuY3Rpb24gaXNUcmFjZXJFbmFibGVkKHRyYWNlcikge1xuICAgIHJldHVybiAhZGlzYWJsZWRUcmFjZXJzLmhhcyh0cmFjZXIpICYmXG4gICAgICAgIChhbGxFbmFibGVkIHx8IGVuYWJsZWRUcmFjZXJzLmhhcyh0cmFjZXIpKTtcbn1cbmV4cG9ydHMuaXNUcmFjZXJFbmFibGVkID0gaXNUcmFjZXJFbmFibGVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9nZ2luZy5qcy5tYXAiXSwibmFtZXMiOlsiX2EiLCJfYiIsIl9jIiwiX2QiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImlzVHJhY2VyRW5hYmxlZCIsInRyYWNlIiwibG9nIiwic2V0TG9nZ2VyVmVyYm9zaXR5Iiwic2V0TG9nZ2VyIiwiZ2V0TG9nZ2VyIiwiY29uc3RhbnRzXzEiLCJyZXF1aXJlIiwiREVGQVVMVF9MT0dHRVIiLCJlcnJvciIsIm1lc3NhZ2UiLCJvcHRpb25hbFBhcmFtcyIsImNvbnNvbGUiLCJpbmZvIiwiZGVidWciLCJfbG9nZ2VyIiwiX2xvZ1ZlcmJvc2l0eSIsIkxvZ1ZlcmJvc2l0eSIsIkVSUk9SIiwidmVyYm9zaXR5U3RyaW5nIiwicHJvY2VzcyIsImVudiIsIkdSUENfTk9ERV9WRVJCT1NJVFkiLCJHUlBDX1ZFUkJPU0lUWSIsInRvVXBwZXJDYXNlIiwiREVCVUciLCJJTkZPIiwiTk9ORSIsImxvZ2dlciIsInZlcmJvc2l0eSIsInNldmVyaXR5IiwiYXJncyIsImxvZ0Z1bmN0aW9uIiwiYmluZCIsInRyYWNlcnNTdHJpbmciLCJHUlBDX05PREVfVFJBQ0UiLCJHUlBDX1RSQUNFIiwiZW5hYmxlZFRyYWNlcnMiLCJTZXQiLCJkaXNhYmxlZFRyYWNlcnMiLCJ0cmFjZXJOYW1lIiwic3BsaXQiLCJzdGFydHNXaXRoIiwiYWRkIiwic3Vic3RyaW5nIiwiYWxsRW5hYmxlZCIsImhhcyIsInRyYWNlciIsInRleHQiLCJEYXRlIiwidG9JU09TdHJpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/make-client.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.loadPackageDefinition = exports.makeClientConstructor = void 0;\nconst client_1 = __webpack_require__(/*! ./client */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/client.js\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */ const requesterFuncs = {\n    unary: client_1.Client.prototype.makeUnaryRequest,\n    server_stream: client_1.Client.prototype.makeServerStreamRequest,\n    client_stream: client_1.Client.prototype.makeClientStreamRequest,\n    bidi: client_1.Client.prototype.makeBidiStreamRequest\n};\n/**\n * Returns true, if given key is included in the blacklisted\n * keys.\n * @param key key for check, string.\n */ function isPrototypePolluted(key) {\n    return [\n        \"__proto__\",\n        \"prototype\",\n        \"constructor\"\n    ].includes(key);\n}\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */ function makeClientConstructor(methods, serviceName, classOptions) {\n    if (!classOptions) {\n        classOptions = {};\n    }\n    class ServiceClientImpl extends client_1.Client {\n    }\n    Object.keys(methods).forEach((name)=>{\n        if (isPrototypePolluted(name)) {\n            return;\n        }\n        const attrs = methods[name];\n        let methodType;\n        // TODO(murgatroid99): Verify that we don't need this anymore\n        if (typeof name === \"string\" && name.charAt(0) === \"$\") {\n            throw new Error(\"Method names cannot start with $\");\n        }\n        if (attrs.requestStream) {\n            if (attrs.responseStream) {\n                methodType = \"bidi\";\n            } else {\n                methodType = \"client_stream\";\n            }\n        } else {\n            if (attrs.responseStream) {\n                methodType = \"server_stream\";\n            } else {\n                methodType = \"unary\";\n            }\n        }\n        const serialize = attrs.requestSerialize;\n        const deserialize = attrs.responseDeserialize;\n        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n        ServiceClientImpl.prototype[name] = methodFunc;\n        // Associate all provided attributes with the method\n        Object.assign(ServiceClientImpl.prototype[name], attrs);\n        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {\n            ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];\n        }\n    });\n    ServiceClientImpl.service = methods;\n    ServiceClientImpl.serviceName = serviceName;\n    return ServiceClientImpl;\n}\nexports.makeClientConstructor = makeClientConstructor;\nfunction partial(fn, path, serialize, deserialize) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function(...args) {\n        return fn.call(this, path, serialize, deserialize, ...args);\n    };\n}\nfunction isProtobufTypeDefinition(obj) {\n    return \"format\" in obj;\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */ function loadPackageDefinition(packageDef) {\n    const result = {};\n    for(const serviceFqn in packageDef){\n        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {\n            const service = packageDef[serviceFqn];\n            const nameComponents = serviceFqn.split(\".\");\n            if (nameComponents.some((comp)=>isPrototypePolluted(comp))) {\n                continue;\n            }\n            const serviceName = nameComponents[nameComponents.length - 1];\n            let current = result;\n            for (const packageName of nameComponents.slice(0, -1)){\n                if (!current[packageName]) {\n                    current[packageName] = {};\n                }\n                current = current[packageName];\n            }\n            if (isProtobufTypeDefinition(service)) {\n                current[serviceName] = service;\n            } else {\n                current[serviceName] = makeClientConstructor(service, serviceName, {});\n            }\n        }\n    }\n    return result;\n}\nexports.loadPackageDefinition = loadPackageDefinition; //# sourceMappingURL=make-client.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWFrZS1jbGllbnQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSw2QkFBNkIsR0FBRyxLQUFLO0FBQ3JFLE1BQU1JLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DOzs7O0NBSUMsR0FDRCxNQUFNQyxpQkFBaUI7SUFDbkJDLE9BQU9ILFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDQyxnQkFBZ0I7SUFDakRDLGVBQWVQLFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDRyx1QkFBdUI7SUFDaEVDLGVBQWVULFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDSyx1QkFBdUI7SUFDaEVDLE1BQU1YLFNBQVNJLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDTyxxQkFBcUI7QUFDekQ7QUFDQTs7OztDQUlDLEdBQ0QsU0FBU0Msb0JBQW9CQyxHQUFHO0lBQzVCLE9BQU87UUFBQztRQUFhO1FBQWE7S0FBYyxDQUFDQyxRQUFRLENBQUNEO0FBQzlEO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNmLHNCQUFzQmlCLE9BQU8sRUFBRUMsV0FBVyxFQUFFQyxZQUFZO0lBQzdELElBQUksQ0FBQ0EsY0FBYztRQUNmQSxlQUFlLENBQUM7SUFDcEI7SUFDQSxNQUFNQywwQkFBMEJuQixTQUFTSSxNQUFNO0lBQy9DO0lBQ0FWLE9BQU8wQixJQUFJLENBQUNKLFNBQVNLLE9BQU8sQ0FBQyxDQUFDQztRQUMxQixJQUFJVCxvQkFBb0JTLE9BQU87WUFDM0I7UUFDSjtRQUNBLE1BQU1DLFFBQVFQLE9BQU8sQ0FBQ00sS0FBSztRQUMzQixJQUFJRTtRQUNKLDZEQUE2RDtRQUM3RCxJQUFJLE9BQU9GLFNBQVMsWUFBWUEsS0FBS0csTUFBTSxDQUFDLE9BQU8sS0FBSztZQUNwRCxNQUFNLElBQUlDLE1BQU07UUFDcEI7UUFDQSxJQUFJSCxNQUFNSSxhQUFhLEVBQUU7WUFDckIsSUFBSUosTUFBTUssY0FBYyxFQUFFO2dCQUN0QkosYUFBYTtZQUNqQixPQUNLO2dCQUNEQSxhQUFhO1lBQ2pCO1FBQ0osT0FDSztZQUNELElBQUlELE1BQU1LLGNBQWMsRUFBRTtnQkFDdEJKLGFBQWE7WUFDakIsT0FDSztnQkFDREEsYUFBYTtZQUNqQjtRQUNKO1FBQ0EsTUFBTUssWUFBWU4sTUFBTU8sZ0JBQWdCO1FBQ3hDLE1BQU1DLGNBQWNSLE1BQU1TLG1CQUFtQjtRQUM3QyxNQUFNQyxhQUFhQyxRQUFRaEMsY0FBYyxDQUFDc0IsV0FBVyxFQUFFRCxNQUFNWSxJQUFJLEVBQUVOLFdBQVdFO1FBQzlFWixrQkFBa0JkLFNBQVMsQ0FBQ2lCLEtBQUssR0FBR1c7UUFDcEMsb0RBQW9EO1FBQ3BEdkMsT0FBTzBDLE1BQU0sQ0FBQ2pCLGtCQUFrQmQsU0FBUyxDQUFDaUIsS0FBSyxFQUFFQztRQUNqRCxJQUFJQSxNQUFNYyxZQUFZLElBQUksQ0FBQ3hCLG9CQUFvQlUsTUFBTWMsWUFBWSxHQUFHO1lBQ2hFbEIsa0JBQWtCZCxTQUFTLENBQUNrQixNQUFNYyxZQUFZLENBQUMsR0FDM0NsQixrQkFBa0JkLFNBQVMsQ0FBQ2lCLEtBQUs7UUFDekM7SUFDSjtJQUNBSCxrQkFBa0JtQixPQUFPLEdBQUd0QjtJQUM1Qkcsa0JBQWtCRixXQUFXLEdBQUdBO0lBQ2hDLE9BQU9FO0FBQ1g7QUFDQXZCLDZCQUE2QixHQUFHRztBQUNoQyxTQUFTbUMsUUFBUUssRUFBRSxFQUFFSixJQUFJLEVBQUVOLFNBQVMsRUFBRUUsV0FBVztJQUM3Qyw4REFBOEQ7SUFDOUQsT0FBTyxTQUFVLEdBQUdTLElBQUk7UUFDcEIsT0FBT0QsR0FBR0UsSUFBSSxDQUFDLElBQUksRUFBRU4sTUFBTU4sV0FBV0UsZ0JBQWdCUztJQUMxRDtBQUNKO0FBQ0EsU0FBU0UseUJBQXlCQyxHQUFHO0lBQ2pDLE9BQU8sWUFBWUE7QUFDdkI7QUFDQTs7OztDQUlDLEdBQ0QsU0FBUzdDLHNCQUFzQjhDLFVBQVU7SUFDckMsTUFBTUMsU0FBUyxDQUFDO0lBQ2hCLElBQUssTUFBTUMsY0FBY0YsV0FBWTtRQUNqQyxJQUFJbEQsT0FBT1csU0FBUyxDQUFDMEMsY0FBYyxDQUFDTixJQUFJLENBQUNHLFlBQVlFLGFBQWE7WUFDOUQsTUFBTVIsVUFBVU0sVUFBVSxDQUFDRSxXQUFXO1lBQ3RDLE1BQU1FLGlCQUFpQkYsV0FBV0csS0FBSyxDQUFDO1lBQ3hDLElBQUlELGVBQWVFLElBQUksQ0FBQyxDQUFDQyxPQUFTdEMsb0JBQW9Cc0MsUUFBUTtnQkFDMUQ7WUFDSjtZQUNBLE1BQU1sQyxjQUFjK0IsY0FBYyxDQUFDQSxlQUFlSSxNQUFNLEdBQUcsRUFBRTtZQUM3RCxJQUFJQyxVQUFVUjtZQUNkLEtBQUssTUFBTVMsZUFBZU4sZUFBZU8sS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFJO2dCQUNuRCxJQUFJLENBQUNGLE9BQU8sQ0FBQ0MsWUFBWSxFQUFFO29CQUN2QkQsT0FBTyxDQUFDQyxZQUFZLEdBQUcsQ0FBQztnQkFDNUI7Z0JBQ0FELFVBQVVBLE9BQU8sQ0FBQ0MsWUFBWTtZQUNsQztZQUNBLElBQUlaLHlCQUF5QkosVUFBVTtnQkFDbkNlLE9BQU8sQ0FBQ3BDLFlBQVksR0FBR3FCO1lBQzNCLE9BQ0s7Z0JBQ0RlLE9BQU8sQ0FBQ3BDLFlBQVksR0FBR2xCLHNCQUFzQnVDLFNBQVNyQixhQUFhLENBQUM7WUFDeEU7UUFDSjtJQUNKO0lBQ0EsT0FBTzRCO0FBQ1g7QUFDQWpELDZCQUE2QixHQUFHRSx1QkFDaEMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21ha2UtY2xpZW50LmpzPzZiYmIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZFBhY2thZ2VEZWZpbml0aW9uID0gZXhwb3J0cy5tYWtlQ2xpZW50Q29uc3RydWN0b3IgPSB2b2lkIDA7XG5jb25zdCBjbGllbnRfMSA9IHJlcXVpcmUoXCIuL2NsaWVudFwiKTtcbi8qKlxuICogTWFwIHdpdGggc2hvcnQgbmFtZXMgZm9yIGVhY2ggb2YgdGhlIHJlcXVlc3RlciBtYWtlciBmdW5jdGlvbnMuIFVzZWQgaW5cbiAqIG1ha2VDbGllbnRDb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuY29uc3QgcmVxdWVzdGVyRnVuY3MgPSB7XG4gICAgdW5hcnk6IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZVVuYXJ5UmVxdWVzdCxcbiAgICBzZXJ2ZXJfc3RyZWFtOiBjbGllbnRfMS5DbGllbnQucHJvdG90eXBlLm1ha2VTZXJ2ZXJTdHJlYW1SZXF1ZXN0LFxuICAgIGNsaWVudF9zdHJlYW06IGNsaWVudF8xLkNsaWVudC5wcm90b3R5cGUubWFrZUNsaWVudFN0cmVhbVJlcXVlc3QsXG4gICAgYmlkaTogY2xpZW50XzEuQ2xpZW50LnByb3RvdHlwZS5tYWtlQmlkaVN0cmVhbVJlcXVlc3QsXG59O1xuLyoqXG4gKiBSZXR1cm5zIHRydWUsIGlmIGdpdmVuIGtleSBpcyBpbmNsdWRlZCBpbiB0aGUgYmxhY2tsaXN0ZWRcbiAqIGtleXMuXG4gKiBAcGFyYW0ga2V5IGtleSBmb3IgY2hlY2ssIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGVQb2xsdXRlZChrZXkpIHtcbiAgICByZXR1cm4gWydfX3Byb3RvX18nLCAncHJvdG90eXBlJywgJ2NvbnN0cnVjdG9yJ10uaW5jbHVkZXMoa2V5KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGNvbnN0cnVjdG9yIGZvciBhIGNsaWVudCB3aXRoIHRoZSBnaXZlbiBtZXRob2RzLCBhcyBzcGVjaWZpZWQgaW5cbiAqIHRoZSBtZXRob2RzIGFyZ3VtZW50LiBUaGUgcmVzdWx0aW5nIGNsYXNzIHdpbGwgaGF2ZSBhbiBpbnN0YW5jZSBtZXRob2QgZm9yXG4gKiBlYWNoIG1ldGhvZCBpbiB0aGUgc2VydmljZSwgd2hpY2ggaXMgYSBwYXJ0aWFsIGFwcGxpY2F0aW9uIG9mIG9uZSBvZiB0aGVcbiAqIFtDbGllbnRde0BsaW5rIGdycGMuQ2xpZW50fSByZXF1ZXN0IG1ldGhvZHMsIGRlcGVuZGluZyBvbiBgcmVxdWVzdFNlcmlhbGl6ZWBcbiAqIGFuZCBgcmVzcG9uc2VTZXJpYWxpemVgLCB3aXRoIHRoZSBgbWV0aG9kYCwgYHNlcmlhbGl6ZWAsIGFuZCBgZGVzZXJpYWxpemVgXG4gKiBhcmd1bWVudHMgcHJlZGVmaW5lZC5cbiAqIEBwYXJhbSBtZXRob2RzIEFuIG9iamVjdCBtYXBwaW5nIG1ldGhvZCBuYW1lcyB0b1xuICogICAgIG1ldGhvZCBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gc2VydmljZU5hbWUgVGhlIGZ1bGx5IHF1YWxpZmllZCBuYW1lIG9mIHRoZSBzZXJ2aWNlXG4gKiBAcGFyYW0gY2xhc3NPcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LlxuICogQHJldHVybiBOZXcgY2xpZW50IGNvbnN0cnVjdG9yLCB3aGljaCBpcyBhIHN1YmNsYXNzIG9mXG4gKiAgICAge0BsaW5rIGdycGMuQ2xpZW50fSwgYW5kIGhhcyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgdGhhdCBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gbWFrZUNsaWVudENvbnN0cnVjdG9yKG1ldGhvZHMsIHNlcnZpY2VOYW1lLCBjbGFzc09wdGlvbnMpIHtcbiAgICBpZiAoIWNsYXNzT3B0aW9ucykge1xuICAgICAgICBjbGFzc09wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY2xhc3MgU2VydmljZUNsaWVudEltcGwgZXh0ZW5kcyBjbGllbnRfMS5DbGllbnQge1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhtZXRob2RzKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgIGlmIChpc1Byb3RvdHlwZVBvbGx1dGVkKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cnMgPSBtZXRob2RzW25hbWVdO1xuICAgICAgICBsZXQgbWV0aG9kVHlwZTtcbiAgICAgICAgLy8gVE9ETyhtdXJnYXRyb2lkOTkpOiBWZXJpZnkgdGhhdCB3ZSBkb24ndCBuZWVkIHRoaXMgYW55bW9yZVxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnICYmIG5hbWUuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0aG9kIG5hbWVzIGNhbm5vdCBzdGFydCB3aXRoICQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXR0cnMucmVxdWVzdFN0cmVhbSkge1xuICAgICAgICAgICAgaWYgKGF0dHJzLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdiaWRpJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnY2xpZW50X3N0cmVhbSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBtZXRob2RUeXBlID0gJ3NlcnZlcl9zdHJlYW0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICd1bmFyeSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VyaWFsaXplID0gYXR0cnMucmVxdWVzdFNlcmlhbGl6ZTtcbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemUgPSBhdHRycy5yZXNwb25zZURlc2VyaWFsaXplO1xuICAgICAgICBjb25zdCBtZXRob2RGdW5jID0gcGFydGlhbChyZXF1ZXN0ZXJGdW5jc1ttZXRob2RUeXBlXSwgYXR0cnMucGF0aCwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSk7XG4gICAgICAgIFNlcnZpY2VDbGllbnRJbXBsLnByb3RvdHlwZVtuYW1lXSA9IG1ldGhvZEZ1bmM7XG4gICAgICAgIC8vIEFzc29jaWF0ZSBhbGwgcHJvdmlkZWQgYXR0cmlidXRlcyB3aXRoIHRoZSBtZXRob2RcbiAgICAgICAgT2JqZWN0LmFzc2lnbihTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbbmFtZV0sIGF0dHJzKTtcbiAgICAgICAgaWYgKGF0dHJzLm9yaWdpbmFsTmFtZSAmJiAhaXNQcm90b3R5cGVQb2xsdXRlZChhdHRycy5vcmlnaW5hbE5hbWUpKSB7XG4gICAgICAgICAgICBTZXJ2aWNlQ2xpZW50SW1wbC5wcm90b3R5cGVbYXR0cnMub3JpZ2luYWxOYW1lXSA9XG4gICAgICAgICAgICAgICAgU2VydmljZUNsaWVudEltcGwucHJvdG90eXBlW25hbWVdO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgU2VydmljZUNsaWVudEltcGwuc2VydmljZSA9IG1ldGhvZHM7XG4gICAgU2VydmljZUNsaWVudEltcGwuc2VydmljZU5hbWUgPSBzZXJ2aWNlTmFtZTtcbiAgICByZXR1cm4gU2VydmljZUNsaWVudEltcGw7XG59XG5leHBvcnRzLm1ha2VDbGllbnRDb25zdHJ1Y3RvciA9IG1ha2VDbGllbnRDb25zdHJ1Y3RvcjtcbmZ1bmN0aW9uIHBhcnRpYWwoZm4sIHBhdGgsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBwYXRoLCBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaXNQcm90b2J1ZlR5cGVEZWZpbml0aW9uKG9iaikge1xuICAgIHJldHVybiAnZm9ybWF0JyBpbiBvYmo7XG59XG4vKipcbiAqIExvYWQgYSBnUlBDIHBhY2thZ2UgZGVmaW5pdGlvbiBhcyBhIGdSUEMgb2JqZWN0IGhpZXJhcmNoeS5cbiAqIEBwYXJhbSBwYWNrYWdlRGVmIFRoZSBwYWNrYWdlIGRlZmluaXRpb24gb2JqZWN0LlxuICogQHJldHVybiBUaGUgcmVzdWx0aW5nIGdSUEMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBsb2FkUGFja2FnZURlZmluaXRpb24ocGFja2FnZURlZikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3Qgc2VydmljZUZxbiBpbiBwYWNrYWdlRGVmKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocGFja2FnZURlZiwgc2VydmljZUZxbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2UgPSBwYWNrYWdlRGVmW3NlcnZpY2VGcW5dO1xuICAgICAgICAgICAgY29uc3QgbmFtZUNvbXBvbmVudHMgPSBzZXJ2aWNlRnFuLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICBpZiAobmFtZUNvbXBvbmVudHMuc29tZSgoY29tcCkgPT4gaXNQcm90b3R5cGVQb2xsdXRlZChjb21wKSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VOYW1lID0gbmFtZUNvbXBvbmVudHNbbmFtZUNvbXBvbmVudHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IHJlc3VsdDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFja2FnZU5hbWUgb2YgbmFtZUNvbXBvbmVudHMuc2xpY2UoMCwgLTEpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50W3BhY2thZ2VOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50W3BhY2thZ2VOYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYWNrYWdlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNQcm90b2J1ZlR5cGVEZWZpbml0aW9uKHNlcnZpY2UpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFtzZXJ2aWNlTmFtZV0gPSBzZXJ2aWNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFtzZXJ2aWNlTmFtZV0gPSBtYWtlQ2xpZW50Q29uc3RydWN0b3Ioc2VydmljZSwgc2VydmljZU5hbWUsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5sb2FkUGFja2FnZURlZmluaXRpb24gPSBsb2FkUGFja2FnZURlZmluaXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYWtlLWNsaWVudC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJsb2FkUGFja2FnZURlZmluaXRpb24iLCJtYWtlQ2xpZW50Q29uc3RydWN0b3IiLCJjbGllbnRfMSIsInJlcXVpcmUiLCJyZXF1ZXN0ZXJGdW5jcyIsInVuYXJ5IiwiQ2xpZW50IiwicHJvdG90eXBlIiwibWFrZVVuYXJ5UmVxdWVzdCIsInNlcnZlcl9zdHJlYW0iLCJtYWtlU2VydmVyU3RyZWFtUmVxdWVzdCIsImNsaWVudF9zdHJlYW0iLCJtYWtlQ2xpZW50U3RyZWFtUmVxdWVzdCIsImJpZGkiLCJtYWtlQmlkaVN0cmVhbVJlcXVlc3QiLCJpc1Byb3RvdHlwZVBvbGx1dGVkIiwia2V5IiwiaW5jbHVkZXMiLCJtZXRob2RzIiwic2VydmljZU5hbWUiLCJjbGFzc09wdGlvbnMiLCJTZXJ2aWNlQ2xpZW50SW1wbCIsImtleXMiLCJmb3JFYWNoIiwibmFtZSIsImF0dHJzIiwibWV0aG9kVHlwZSIsImNoYXJBdCIsIkVycm9yIiwicmVxdWVzdFN0cmVhbSIsInJlc3BvbnNlU3RyZWFtIiwic2VyaWFsaXplIiwicmVxdWVzdFNlcmlhbGl6ZSIsImRlc2VyaWFsaXplIiwicmVzcG9uc2VEZXNlcmlhbGl6ZSIsIm1ldGhvZEZ1bmMiLCJwYXJ0aWFsIiwicGF0aCIsImFzc2lnbiIsIm9yaWdpbmFsTmFtZSIsInNlcnZpY2UiLCJmbiIsImFyZ3MiLCJjYWxsIiwiaXNQcm90b2J1ZlR5cGVEZWZpbml0aW9uIiwib2JqIiwicGFja2FnZURlZiIsInJlc3VsdCIsInNlcnZpY2VGcW4iLCJoYXNPd25Qcm9wZXJ0eSIsIm5hbWVDb21wb25lbnRzIiwic3BsaXQiLCJzb21lIiwiY29tcCIsImxlbmd0aCIsImN1cnJlbnQiLCJwYWNrYWdlTmFtZSIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/make-client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.MaxMessageSizeFilterFactory = exports.MaxMessageSizeFilter = void 0;\nconst filter_1 = __webpack_require__(/*! ./filter */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/filter.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nclass MaxMessageSizeFilter extends filter_1.BaseFilter {\n    constructor(options, callStream){\n        super();\n        this.options = options;\n        this.callStream = callStream;\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        if (\"grpc.max_send_message_length\" in options) {\n            this.maxSendMessageSize = options[\"grpc.max_send_message_length\"];\n        }\n        if (\"grpc.max_receive_message_length\" in options) {\n            this.maxReceiveMessageSize = options[\"grpc.max_receive_message_length\"];\n        }\n    }\n    async sendMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */ if (this.maxSendMessageSize === -1) {\n            return message;\n        } else {\n            const concreteMessage = await message;\n            if (concreteMessage.message.length > this.maxSendMessageSize) {\n                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`);\n                return Promise.reject(\"Message too large\");\n            } else {\n                return concreteMessage;\n            }\n        }\n    }\n    async receiveMessage(message) {\n        /* A configured size of -1 means that there is no limit, so skip the check\n         * entirely */ if (this.maxReceiveMessageSize === -1) {\n            return message;\n        } else {\n            const concreteMessage = await message;\n            if (concreteMessage.length > this.maxReceiveMessageSize) {\n                this.callStream.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`);\n                return Promise.reject(\"Message too large\");\n            } else {\n                return concreteMessage;\n            }\n        }\n    }\n}\nexports.MaxMessageSizeFilter = MaxMessageSizeFilter;\nclass MaxMessageSizeFilterFactory {\n    constructor(options){\n        this.options = options;\n    }\n    createFilter(callStream) {\n        return new MaxMessageSizeFilter(this.options, callStream);\n    }\n}\nexports.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory; //# sourceMappingURL=max-message-size-filter.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWF4LW1lc3NhZ2Utc2l6ZS1maWx0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELG1DQUFtQyxHQUFHQSw0QkFBNEIsR0FBRyxLQUFLO0FBQzFFLE1BQU1JLFdBQVdDLG1CQUFPQSxDQUFDLHdFQUFVO0FBQ25DLE1BQU1DLGNBQWNELG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1GLDZCQUE2QkMsU0FBU0csVUFBVTtJQUNsREMsWUFBWUMsT0FBTyxFQUFFQyxVQUFVLENBQUU7UUFDN0IsS0FBSztRQUNMLElBQUksQ0FBQ0QsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLGtCQUFrQixHQUFHTCxZQUFZTSwrQkFBK0I7UUFDckUsSUFBSSxDQUFDQyxxQkFBcUIsR0FBR1AsWUFBWVEsa0NBQWtDO1FBQzNFLElBQUksa0NBQWtDTCxTQUFTO1lBQzNDLElBQUksQ0FBQ0Usa0JBQWtCLEdBQUdGLE9BQU8sQ0FBQywrQkFBK0I7UUFDckU7UUFDQSxJQUFJLHFDQUFxQ0EsU0FBUztZQUM5QyxJQUFJLENBQUNJLHFCQUFxQixHQUFHSixPQUFPLENBQUMsa0NBQWtDO1FBQzNFO0lBQ0o7SUFDQSxNQUFNTSxZQUFZQyxPQUFPLEVBQUU7UUFDdkI7b0JBQ1ksR0FDWixJQUFJLElBQUksQ0FBQ0wsa0JBQWtCLEtBQUssQ0FBQyxHQUFHO1lBQ2hDLE9BQU9LO1FBQ1gsT0FDSztZQUNELE1BQU1DLGtCQUFrQixNQUFNRDtZQUM5QixJQUFJQyxnQkFBZ0JELE9BQU8sQ0FBQ0UsTUFBTSxHQUFHLElBQUksQ0FBQ1Asa0JBQWtCLEVBQUU7Z0JBQzFELElBQUksQ0FBQ0QsVUFBVSxDQUFDUyxnQkFBZ0IsQ0FBQ2IsWUFBWWMsTUFBTSxDQUFDQyxrQkFBa0IsRUFBRSxDQUFDLDhCQUE4QixFQUFFSixnQkFBZ0JELE9BQU8sQ0FBQ0UsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUNQLGtCQUFrQixDQUFDLENBQUMsQ0FBQztnQkFDekssT0FBT1csUUFBUUMsTUFBTSxDQUFDO1lBQzFCLE9BQ0s7Z0JBQ0QsT0FBT047WUFDWDtRQUNKO0lBQ0o7SUFDQSxNQUFNTyxlQUFlUixPQUFPLEVBQUU7UUFDMUI7b0JBQ1ksR0FDWixJQUFJLElBQUksQ0FBQ0gscUJBQXFCLEtBQUssQ0FBQyxHQUFHO1lBQ25DLE9BQU9HO1FBQ1gsT0FDSztZQUNELE1BQU1DLGtCQUFrQixNQUFNRDtZQUM5QixJQUFJQyxnQkFBZ0JDLE1BQU0sR0FBRyxJQUFJLENBQUNMLHFCQUFxQixFQUFFO2dCQUNyRCxJQUFJLENBQUNILFVBQVUsQ0FBQ1MsZ0JBQWdCLENBQUNiLFlBQVljLE1BQU0sQ0FBQ0Msa0JBQWtCLEVBQUUsQ0FBQyxrQ0FBa0MsRUFBRUosZ0JBQWdCQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQ0wscUJBQXFCLENBQUMsQ0FBQyxDQUFDO2dCQUN4SyxPQUFPUyxRQUFRQyxNQUFNLENBQUM7WUFDMUIsT0FDSztnQkFDRCxPQUFPTjtZQUNYO1FBQ0o7SUFDSjtBQUNKO0FBQ0FqQiw0QkFBNEIsR0FBR0c7QUFDL0IsTUFBTUQ7SUFDRk0sWUFBWUMsT0FBTyxDQUFFO1FBQ2pCLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNuQjtJQUNBZ0IsYUFBYWYsVUFBVSxFQUFFO1FBQ3JCLE9BQU8sSUFBSVAscUJBQXFCLElBQUksQ0FBQ00sT0FBTyxFQUFFQztJQUNsRDtBQUNKO0FBQ0FWLG1DQUFtQyxHQUFHRSw2QkFDdEMsbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21heC1tZXNzYWdlLXNpemUtZmlsdGVyLmpzP2FjNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMjAgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5ID0gZXhwb3J0cy5NYXhNZXNzYWdlU2l6ZUZpbHRlciA9IHZvaWQgMDtcbmNvbnN0IGZpbHRlcl8xID0gcmVxdWlyZShcIi4vZmlsdGVyXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jbGFzcyBNYXhNZXNzYWdlU2l6ZUZpbHRlciBleHRlbmRzIGZpbHRlcl8xLkJhc2VGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGNhbGxTdHJlYW0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jYWxsU3RyZWFtID0gY2FsbFN0cmVhbTtcbiAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPSBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9TRU5EX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSA9IGNvbnN0YW50c18xLkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEg7XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSA9IG9wdGlvbnNbJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIC8qIEEgY29uZmlndXJlZCBzaXplIG9mIC0xIG1lYW5zIHRoYXQgdGhlcmUgaXMgbm8gbGltaXQsIHNvIHNraXAgdGhlIGNoZWNrXG4gICAgICAgICAqIGVudGlyZWx5ICovXG4gICAgICAgIGlmICh0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY29uY3JldGVNZXNzYWdlID0gYXdhaXQgbWVzc2FnZTtcbiAgICAgICAgICAgIGlmIChjb25jcmV0ZU1lc3NhZ2UubWVzc2FnZS5sZW5ndGggPiB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFN0cmVhbS5jYW5jZWxXaXRoU3RhdHVzKGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsIGBTZW50IG1lc3NhZ2UgbGFyZ2VyIHRoYW4gbWF4ICgke2NvbmNyZXRlTWVzc2FnZS5tZXNzYWdlLmxlbmd0aH0gdnMuICR7dGhpcy5tYXhTZW5kTWVzc2FnZVNpemV9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnTWVzc2FnZSB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25jcmV0ZU1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAvKiBBIGNvbmZpZ3VyZWQgc2l6ZSBvZiAtMSBtZWFucyB0aGF0IHRoZXJlIGlzIG5vIGxpbWl0LCBzbyBza2lwIHRoZSBjaGVja1xuICAgICAgICAgKiBlbnRpcmVseSAqL1xuICAgICAgICBpZiAodGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmNyZXRlTWVzc2FnZSA9IGF3YWl0IG1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoY29uY3JldGVNZXNzYWdlLmxlbmd0aCA+IHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsU3RyZWFtLmNhbmNlbFdpdGhTdGF0dXMoY29uc3RhbnRzXzEuU3RhdHVzLlJFU09VUkNFX0VYSEFVU1RFRCwgYFJlY2VpdmVkIG1lc3NhZ2UgbGFyZ2VyIHRoYW4gbWF4ICgke2NvbmNyZXRlTWVzc2FnZS5sZW5ndGh9IHZzLiAke3RoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplfSlgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ01lc3NhZ2UgdG9vIGxhcmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY3JldGVNZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5NYXhNZXNzYWdlU2l6ZUZpbHRlciA9IE1heE1lc3NhZ2VTaXplRmlsdGVyO1xuY2xhc3MgTWF4TWVzc2FnZVNpemVGaWx0ZXJGYWN0b3J5IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGNyZWF0ZUZpbHRlcihjYWxsU3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWF4TWVzc2FnZVNpemVGaWx0ZXIodGhpcy5vcHRpb25zLCBjYWxsU3RyZWFtKTtcbiAgICB9XG59XG5leHBvcnRzLk1heE1lc3NhZ2VTaXplRmlsdGVyRmFjdG9yeSA9IE1heE1lc3NhZ2VTaXplRmlsdGVyRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1heC1tZXNzYWdlLXNpemUtZmlsdGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk1heE1lc3NhZ2VTaXplRmlsdGVyRmFjdG9yeSIsIk1heE1lc3NhZ2VTaXplRmlsdGVyIiwiZmlsdGVyXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJCYXNlRmlsdGVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiY2FsbFN0cmVhbSIsIm1heFNlbmRNZXNzYWdlU2l6ZSIsIkRFRkFVTFRfTUFYX1NFTkRfTUVTU0FHRV9MRU5HVEgiLCJtYXhSZWNlaXZlTWVzc2FnZVNpemUiLCJERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIIiwic2VuZE1lc3NhZ2UiLCJtZXNzYWdlIiwiY29uY3JldGVNZXNzYWdlIiwibGVuZ3RoIiwiY2FuY2VsV2l0aFN0YXR1cyIsIlN0YXR1cyIsIlJFU09VUkNFX0VYSEFVU1RFRCIsIlByb21pc2UiLCJyZWplY3QiLCJyZWNlaXZlTWVzc2FnZSIsImNyZWF0ZUZpbHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/metadata.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Metadata = void 0;\nconst logging_1 = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;\nconst LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;\nfunction isLegalKey(key) {\n    return LEGAL_KEY_REGEX.test(key);\n}\nfunction isLegalNonBinaryValue(value) {\n    return LEGAL_NON_BINARY_VALUE_REGEX.test(value);\n}\nfunction isBinaryKey(key) {\n    return key.endsWith(\"-bin\");\n}\nfunction isCustomMetadata(key) {\n    return !key.startsWith(\"grpc-\");\n}\nfunction normalizeKey(key) {\n    return key.toLowerCase();\n}\nfunction validate(key, value) {\n    if (!isLegalKey(key)) {\n        throw new Error('Metadata key \"' + key + '\" contains illegal characters');\n    }\n    if (value !== null && value !== undefined) {\n        if (isBinaryKey(key)) {\n            if (!Buffer.isBuffer(value)) {\n                throw new Error(\"keys that end with '-bin' must have Buffer values\");\n            }\n        } else {\n            if (Buffer.isBuffer(value)) {\n                throw new Error(\"keys that don't end with '-bin' must have String values\");\n            }\n            if (!isLegalNonBinaryValue(value)) {\n                throw new Error('Metadata string value \"' + value + '\" contains illegal characters');\n            }\n        }\n    }\n}\n/**\n * A class for storing metadata. Keys are normalized to lowercase ASCII.\n */ class Metadata {\n    constructor(options = {}){\n        this.internalRepr = new Map();\n        this.options = options;\n    }\n    /**\n     * Sets the given value for the given key by replacing any other values\n     * associated with that key. Normalizes the key.\n     * @param key The key to whose value should be set.\n     * @param value The value to set. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */ set(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        this.internalRepr.set(key, [\n            value\n        ]);\n    }\n    /**\n     * Adds the given value for the given key by appending to a list of previous\n     * values associated with that key. Normalizes the key.\n     * @param key The key for which a new value should be appended.\n     * @param value The value to add. Must be a buffer if and only\n     *   if the normalized key ends with '-bin'.\n     */ add(key, value) {\n        key = normalizeKey(key);\n        validate(key, value);\n        const existingValue = this.internalRepr.get(key);\n        if (existingValue === undefined) {\n            this.internalRepr.set(key, [\n                value\n            ]);\n        } else {\n            existingValue.push(value);\n        }\n    }\n    /**\n     * Removes the given key and any associated values. Normalizes the key.\n     * @param key The key whose values should be removed.\n     */ remove(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        this.internalRepr.delete(key);\n    }\n    /**\n     * Gets a list of all values associated with the key. Normalizes the key.\n     * @param key The key whose value should be retrieved.\n     * @return A list of values associated with the given key.\n     */ get(key) {\n        key = normalizeKey(key);\n        // validate(key);\n        return this.internalRepr.get(key) || [];\n    }\n    /**\n     * Gets a plain object mapping each key to the first value associated with it.\n     * This reflects the most common way that people will want to see metadata.\n     * @return A key/value mapping of the metadata.\n     */ getMap() {\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            if (values.length > 0) {\n                const v = values[0];\n                result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;\n            }\n        }\n        return result;\n    }\n    /**\n     * Clones the metadata object.\n     * @return The newly cloned object.\n     */ clone() {\n        const newMetadata = new Metadata(this.options);\n        const newInternalRepr = newMetadata.internalRepr;\n        for (const [key, value] of this.internalRepr){\n            const clonedValue = value.map((v)=>{\n                if (Buffer.isBuffer(v)) {\n                    return Buffer.from(v);\n                } else {\n                    return v;\n                }\n            });\n            newInternalRepr.set(key, clonedValue);\n        }\n        return newMetadata;\n    }\n    /**\n     * Merges all key-value pairs from a given Metadata object into this one.\n     * If both this object and the given object have values in the same key,\n     * values from the other Metadata object will be appended to this object's\n     * values.\n     * @param other A Metadata object.\n     */ merge(other) {\n        for (const [key, values] of other.internalRepr){\n            const mergedValue = (this.internalRepr.get(key) || []).concat(values);\n            this.internalRepr.set(key, mergedValue);\n        }\n    }\n    setOptions(options) {\n        this.options = options;\n    }\n    getOptions() {\n        return this.options;\n    }\n    /**\n     * Creates an OutgoingHttpHeaders object that can be used with the http2 API.\n     */ toHttp2Headers() {\n        // NOTE: Node <8.9 formats http2 headers incorrectly.\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            // We assume that the user's interaction with this object is limited to\n            // through its public API (i.e. keys and values are already validated).\n            result[key] = values.map(bufToString);\n        }\n        return result;\n    }\n    // For compatibility with the other Metadata implementation\n    _getCoreRepresentation() {\n        return this.internalRepr;\n    }\n    /**\n     * This modifies the behavior of JSON.stringify to show an object\n     * representation of the metadata map.\n     */ toJSON() {\n        const result = {};\n        for (const [key, values] of this.internalRepr){\n            result[key] = values;\n        }\n        return result;\n    }\n    /**\n     * Returns a new Metadata object based fields in a given IncomingHttpHeaders\n     * object.\n     * @param headers An IncomingHttpHeaders object.\n     */ static fromHttp2Headers(headers) {\n        const result = new Metadata();\n        for (const key of Object.keys(headers)){\n            // Reserved headers (beginning with `:`) are not valid keys.\n            if (key.charAt(0) === \":\") {\n                continue;\n            }\n            const values = headers[key];\n            try {\n                if (isBinaryKey(key)) {\n                    if (Array.isArray(values)) {\n                        values.forEach((value)=>{\n                            result.add(key, Buffer.from(value, \"base64\"));\n                        });\n                    } else if (values !== undefined) {\n                        if (isCustomMetadata(key)) {\n                            values.split(\",\").forEach((v)=>{\n                                result.add(key, Buffer.from(v.trim(), \"base64\"));\n                            });\n                        } else {\n                            result.add(key, Buffer.from(values, \"base64\"));\n                        }\n                    }\n                } else {\n                    if (Array.isArray(values)) {\n                        values.forEach((value)=>{\n                            result.add(key, value);\n                        });\n                    } else if (values !== undefined) {\n                        result.add(key, values);\n                    }\n                }\n            } catch (error) {\n                const message = `Failed to add metadata entry ${key}: ${values}. ${error.message}. For more information see https://github.com/grpc/grpc-node/issues/1173`;\n                logging_1.log(constants_1.LogVerbosity.ERROR, message);\n            }\n        }\n        return result;\n    }\n}\nexports.Metadata = Metadata;\nconst bufToString = (val)=>{\n    return Buffer.isBuffer(val) ? val.toString(\"base64\") : val;\n}; //# sourceMappingURL=metadata.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvbWV0YWRhdGEuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGdCQUFnQixHQUFHLEtBQUs7QUFDeEIsTUFBTUcsWUFBWUMsbUJBQU9BLENBQUMsMEVBQVc7QUFDckMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUUsa0JBQWtCO0FBQ3hCLE1BQU1DLCtCQUErQjtBQUNyQyxTQUFTQyxXQUFXQyxHQUFHO0lBQ25CLE9BQU9ILGdCQUFnQkksSUFBSSxDQUFDRDtBQUNoQztBQUNBLFNBQVNFLHNCQUFzQlYsS0FBSztJQUNoQyxPQUFPTSw2QkFBNkJHLElBQUksQ0FBQ1Q7QUFDN0M7QUFDQSxTQUFTVyxZQUFZSCxHQUFHO0lBQ3BCLE9BQU9BLElBQUlJLFFBQVEsQ0FBQztBQUN4QjtBQUNBLFNBQVNDLGlCQUFpQkwsR0FBRztJQUN6QixPQUFPLENBQUNBLElBQUlNLFVBQVUsQ0FBQztBQUMzQjtBQUNBLFNBQVNDLGFBQWFQLEdBQUc7SUFDckIsT0FBT0EsSUFBSVEsV0FBVztBQUMxQjtBQUNBLFNBQVNDLFNBQVNULEdBQUcsRUFBRVIsS0FBSztJQUN4QixJQUFJLENBQUNPLFdBQVdDLE1BQU07UUFDbEIsTUFBTSxJQUFJVSxNQUFNLG1CQUFtQlYsTUFBTTtJQUM3QztJQUNBLElBQUlSLFVBQVUsUUFBUUEsVUFBVW1CLFdBQVc7UUFDdkMsSUFBSVIsWUFBWUgsTUFBTTtZQUNsQixJQUFJLENBQUNZLE9BQU9DLFFBQVEsQ0FBQ3JCLFFBQVE7Z0JBQ3pCLE1BQU0sSUFBSWtCLE1BQU07WUFDcEI7UUFDSixPQUNLO1lBQ0QsSUFBSUUsT0FBT0MsUUFBUSxDQUFDckIsUUFBUTtnQkFDeEIsTUFBTSxJQUFJa0IsTUFBTTtZQUNwQjtZQUNBLElBQUksQ0FB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LElBQUlOLGlCQUFpQkwsTUFBTTs0QkFDdkIyQixPQUFPMEIsS0FBSyxDQUFDLEtBQUtELE9BQU8sQ0FBQyxDQUFDdkI7Z0NBQ3ZCSCxPQUFPUCxHQUFHLENBQUNuQixLQUFLWSxPQUFPa0IsSUFBSSxDQUFDRCxFQUFFeUIsSUFBSSxJQUFJOzRCQUMxQzt3QkFDSixPQUNLOzRCQUNENUIsT0FBT1AsR0FBRyxDQUFDbkIsS0FBS1ksT0FBT2tCLElBQUksQ0FBQ0gsUUFBUTt3QkFDeEM7b0JBQ0o7Z0JBQ0osT0FDSztvQkFDRCxJQUFJdUIsTUFBTUMsT0FBTyxDQUFDeEIsU0FBUzt3QkFDdkJBLE9BQU95QixPQUFPLENBQUMsQ0FBQzVEOzRCQUNaa0MsT0FBT1AsR0FBRyxDQUFDbkIsS0FBS1I7d0JBQ3BCO29CQUNKLE9BQ0ssSUFBSW1DLFdBQVdoQixXQUFXO3dCQUMzQmUsT0FBT1AsR0FBRyxDQUFDbkIsS0FBSzJCO29CQUNwQjtnQkFDSjtZQUNKLEVBQ0EsT0FBTzRCLE9BQU87Z0JBQ1YsTUFBTUMsVUFBVSxDQUFDLDZCQUE2QixFQUFFeEQsSUFBSSxFQUFFLEVBQUUyQixPQUFPLEVBQUUsRUFBRTRCLE1BQU1DLE9BQU8sQ0FBQyx3RUFBd0UsQ0FBQztnQkFDMUo5RCxVQUFVK0QsR0FBRyxDQUFDN0QsWUFBWThELFlBQVksQ0FBQ0MsS0FBSyxFQUFFSDtZQUNsRDtRQUNKO1FBQ0EsT0FBTzlCO0lBQ1g7QUFDSjtBQUNBbkMsZ0JBQWdCLEdBQUdFO0FBQ25CLE1BQU1rRCxjQUFjLENBQUNpQjtJQUNqQixPQUFPaEQsT0FBT0MsUUFBUSxDQUFDK0MsT0FBT0EsSUFBSUMsUUFBUSxDQUFDLFlBQVlEO0FBQzNELEdBQ0Esb0NBQW9DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL21ldGFkYXRhLmpzPzFjNWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0YWRhdGEgPSB2b2lkIDA7XG5jb25zdCBsb2dnaW5nXzEgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBMRUdBTF9LRVlfUkVHRVggPSAvXlswLTlhLXpfLi1dKyQvO1xuY29uc3QgTEVHQUxfTk9OX0JJTkFSWV9WQUxVRV9SRUdFWCA9IC9eWyAtfl0qJC87XG5mdW5jdGlvbiBpc0xlZ2FsS2V5KGtleSkge1xuICAgIHJldHVybiBMRUdBTF9LRVlfUkVHRVgudGVzdChrZXkpO1xufVxuZnVuY3Rpb24gaXNMZWdhbE5vbkJpbmFyeVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIExFR0FMX05PTl9CSU5BUllfVkFMVUVfUkVHRVgudGVzdCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0JpbmFyeUtleShrZXkpIHtcbiAgICByZXR1cm4ga2V5LmVuZHNXaXRoKCctYmluJyk7XG59XG5mdW5jdGlvbiBpc0N1c3RvbU1ldGFkYXRhKGtleSkge1xuICAgIHJldHVybiAha2V5LnN0YXJ0c1dpdGgoJ2dycGMtJyk7XG59XG5mdW5jdGlvbiBub3JtYWxpemVLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGUoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghaXNMZWdhbEtleShrZXkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YWRhdGEga2V5IFwiJyArIGtleSArICdcIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMnKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzQmluYXJ5S2V5KGtleSkpIHtcbiAgICAgICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleXMgdGhhdCBlbmQgd2l0aCAnLWJpbicgbXVzdCBoYXZlIEJ1ZmZlciB2YWx1ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImtleXMgdGhhdCBkb24ndCBlbmQgd2l0aCAnLWJpbicgbXVzdCBoYXZlIFN0cmluZyB2YWx1ZXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTGVnYWxOb25CaW5hcnlWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01ldGFkYXRhIHN0cmluZyB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBjbGFzcyBmb3Igc3RvcmluZyBtZXRhZGF0YS4gS2V5cyBhcmUgbm9ybWFsaXplZCB0byBsb3dlcmNhc2UgQVNDSUkuXG4gKi9cbmNsYXNzIE1ldGFkYXRhIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5IGJ5IHJlcGxhY2luZyBhbnkgb3RoZXIgdmFsdWVzXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoYXQga2V5LiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHRvIHdob3NlIHZhbHVlIHNob3VsZCBiZSBzZXQuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuIE11c3QgYmUgYSBidWZmZXIgaWYgYW5kIG9ubHlcbiAgICAgKiAgIGlmIHRoZSBub3JtYWxpemVkIGtleSBlbmRzIHdpdGggJy1iaW4nLlxuICAgICAqL1xuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICB2YWxpZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgW3ZhbHVlXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIHZhbHVlIGZvciB0aGUgZ2l2ZW4ga2V5IGJ5IGFwcGVuZGluZyB0byBhIGxpc3Qgb2YgcHJldmlvdXNcbiAgICAgKiB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoYXQga2V5LiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IGZvciB3aGljaCBhIG5ldyB2YWx1ZSBzaG91bGQgYmUgYXBwZW5kZWQuXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuIE11c3QgYmUgYSBidWZmZXIgaWYgYW5kIG9ubHlcbiAgICAgKiAgIGlmIHRoZSBub3JtYWxpemVkIGtleSBlbmRzIHdpdGggJy1iaW4nLlxuICAgICAqL1xuICAgIGFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgIGtleSA9IG5vcm1hbGl6ZUtleShrZXkpO1xuICAgICAgICB2YWxpZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdWYWx1ZSA9IHRoaXMuaW50ZXJuYWxSZXByLmdldChrZXkpO1xuICAgICAgICBpZiAoZXhpc3RpbmdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmludGVybmFsUmVwci5zZXQoa2V5LCBbdmFsdWVdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4ga2V5IGFuZCBhbnkgYXNzb2NpYXRlZCB2YWx1ZXMuIE5vcm1hbGl6ZXMgdGhlIGtleS5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgd2hvc2UgdmFsdWVzIHNob3VsZCBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZShrZXkpIHtcbiAgICAgICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG4gICAgICAgIC8vIHZhbGlkYXRlKGtleSk7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxSZXByLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBhbGwgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5LiBOb3JtYWxpemVzIHRoZSBrZXkuXG4gICAgICogQHBhcmFtIGtleSBUaGUga2V5IHdob3NlIHZhbHVlIHNob3VsZCBiZSByZXRyaWV2ZWQuXG4gICAgICogQHJldHVybiBBIGxpc3Qgb2YgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqL1xuICAgIGdldChrZXkpIHtcbiAgICAgICAga2V5ID0gbm9ybWFsaXplS2V5KGtleSk7XG4gICAgICAgIC8vIHZhbGlkYXRlKGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsUmVwci5nZXQoa2V5KSB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHBsYWluIG9iamVjdCBtYXBwaW5nIGVhY2gga2V5IHRvIHRoZSBmaXJzdCB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICAgICogVGhpcyByZWZsZWN0cyB0aGUgbW9zdCBjb21tb24gd2F5IHRoYXQgcGVvcGxlIHdpbGwgd2FudCB0byBzZWUgbWV0YWRhdGEuXG4gICAgICogQHJldHVybiBBIGtleS92YWx1ZSBtYXBwaW5nIG9mIHRoZSBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZXNbMF07XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBCdWZmZXIuaXNCdWZmZXIodikgPyBCdWZmZXIuZnJvbSh2KSA6IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvbmVzIHRoZSBtZXRhZGF0YSBvYmplY3QuXG4gICAgICogQHJldHVybiBUaGUgbmV3bHkgY2xvbmVkIG9iamVjdC5cbiAgICAgKi9cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgbmV3TWV0YWRhdGEgPSBuZXcgTWV0YWRhdGEodGhpcy5vcHRpb25zKTtcbiAgICAgICAgY29uc3QgbmV3SW50ZXJuYWxSZXByID0gbmV3TWV0YWRhdGEuaW50ZXJuYWxSZXByO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiB0aGlzLmludGVybmFsUmVwcikge1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkVmFsdWUgPSB2YWx1ZS5tYXAoKHYpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCdWZmZXIuZnJvbSh2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3SW50ZXJuYWxSZXByLnNldChrZXksIGNsb25lZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3TWV0YWRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhbGwga2V5LXZhbHVlIHBhaXJzIGZyb20gYSBnaXZlbiBNZXRhZGF0YSBvYmplY3QgaW50byB0aGlzIG9uZS5cbiAgICAgKiBJZiBib3RoIHRoaXMgb2JqZWN0IGFuZCB0aGUgZ2l2ZW4gb2JqZWN0IGhhdmUgdmFsdWVzIGluIHRoZSBzYW1lIGtleSxcbiAgICAgKiB2YWx1ZXMgZnJvbSB0aGUgb3RoZXIgTWV0YWRhdGEgb2JqZWN0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpcyBvYmplY3Qnc1xuICAgICAqIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gb3RoZXIgQSBNZXRhZGF0YSBvYmplY3QuXG4gICAgICovXG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIG90aGVyLmludGVybmFsUmVwcikge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkVmFsdWUgPSAodGhpcy5pbnRlcm5hbFJlcHIuZ2V0KGtleSkgfHwgW10pLmNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFJlcHIuc2V0KGtleSwgbWVyZ2VkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBnZXRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIE91dGdvaW5nSHR0cEhlYWRlcnMgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgd2l0aCB0aGUgaHR0cDIgQVBJLlxuICAgICAqL1xuICAgIHRvSHR0cDJIZWFkZXJzKCkge1xuICAgICAgICAvLyBOT1RFOiBOb2RlIDw4LjkgZm9ybWF0cyBodHRwMiBoZWFkZXJzIGluY29ycmVjdGx5LlxuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZXNdIG9mIHRoaXMuaW50ZXJuYWxSZXByKSB7XG4gICAgICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCB0aGUgdXNlcidzIGludGVyYWN0aW9uIHdpdGggdGhpcyBvYmplY3QgaXMgbGltaXRlZCB0b1xuICAgICAgICAgICAgLy8gdGhyb3VnaCBpdHMgcHVibGljIEFQSSAoaS5lLiBrZXlzIGFuZCB2YWx1ZXMgYXJlIGFscmVhZHkgdmFsaWRhdGVkKS5cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzLm1hcChidWZUb1N0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgb3RoZXIgTWV0YWRhdGEgaW1wbGVtZW50YXRpb25cbiAgICBfZ2V0Q29yZVJlcHJlc2VudGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbFJlcHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgbW9kaWZpZXMgdGhlIGJlaGF2aW9yIG9mIEpTT04uc3RyaW5naWZ5IHRvIHNob3cgYW4gb2JqZWN0XG4gICAgICogcmVwcmVzZW50YXRpb24gb2YgdGhlIG1ldGFkYXRhIG1hcC5cbiAgICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlc10gb2YgdGhpcy5pbnRlcm5hbFJlcHIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgTWV0YWRhdGEgb2JqZWN0IGJhc2VkIGZpZWxkcyBpbiBhIGdpdmVuIEluY29taW5nSHR0cEhlYWRlcnNcbiAgICAgKiBvYmplY3QuXG4gICAgICogQHBhcmFtIGhlYWRlcnMgQW4gSW5jb21pbmdIdHRwSGVhZGVycyBvYmplY3QuXG4gICAgICovXG4gICAgc3RhdGljIGZyb21IdHRwMkhlYWRlcnMoaGVhZGVycykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWV0YWRhdGEoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoaGVhZGVycykpIHtcbiAgICAgICAgICAgIC8vIFJlc2VydmVkIGhlYWRlcnMgKGJlZ2lubmluZyB3aXRoIGA6YCkgYXJlIG5vdCB2YWxpZCBrZXlzLlxuICAgICAgICAgICAgaWYgKGtleS5jaGFyQXQoMCkgPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gaGVhZGVyc1trZXldO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoaXNCaW5hcnlLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSwgQnVmZmVyLmZyb20odmFsdWUsICdiYXNlNjQnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ3VzdG9tTWV0YWRhdGEoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5zcGxpdCgnLCcpLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHYudHJpbSgpLCAnYmFzZTY0JykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIEJ1ZmZlci5mcm9tKHZhbHVlcywgJ2Jhc2U2NCcpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgRmFpbGVkIHRvIGFkZCBtZXRhZGF0YSBlbnRyeSAke2tleX06ICR7dmFsdWVzfS4gJHtlcnJvci5tZXNzYWdlfS4gRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL2dycGMtbm9kZS9pc3N1ZXMvMTE3M2A7XG4gICAgICAgICAgICAgICAgbG9nZ2luZ18xLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0cy5NZXRhZGF0YSA9IE1ldGFkYXRhO1xuY29uc3QgYnVmVG9TdHJpbmcgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcih2YWwpID8gdmFsLnRvU3RyaW5nKCdiYXNlNjQnKSA6IHZhbDtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXRhZGF0YS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJNZXRhZGF0YSIsImxvZ2dpbmdfMSIsInJlcXVpcmUiLCJjb25zdGFudHNfMSIsIkxFR0FMX0tFWV9SRUdFWCIsIkxFR0FMX05PTl9CSU5BUllfVkFMVUVfUkVHRVgiLCJpc0xlZ2FsS2V5Iiwia2V5IiwidGVzdCIsImlzTGVnYWxOb25CaW5hcnlWYWx1ZSIsImlzQmluYXJ5S2V5IiwiZW5kc1dpdGgiLCJpc0N1c3RvbU1ldGFkYXRhIiwic3RhcnRzV2l0aCIsIm5vcm1hbGl6ZUtleSIsInRvTG93ZXJDYXNlIiwidmFsaWRhdGUiLCJFcnJvciIsInVuZGVmaW5lZCIsIkJ1ZmZlciIsImlzQnVmZmVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiaW50ZXJuYWxSZXByIiwiTWFwIiwic2V0IiwiYWRkIiwiZXhpc3RpbmdWYWx1ZSIsImdldCIsInB1c2giLCJyZW1vdmUiLCJkZWxldGUiLCJnZXRNYXAiLCJyZXN1bHQiLCJ2YWx1ZXMiLCJsZW5ndGgiLCJ2IiwiZnJvbSIsImNsb25lIiwibmV3TWV0YWRhdGEiLCJuZXdJbnRlcm5hbFJlcHIiLCJjbG9uZWRWYWx1ZSIsIm1hcCIsIm1lcmdlIiwib3RoZXIiLCJtZXJnZWRWYWx1ZSIsImNvbmNhdCIsInNldE9wdGlvbnMiLCJnZXRPcHRpb25zIiwidG9IdHRwMkhlYWRlcnMiLCJidWZUb1N0cmluZyIsIl9nZXRDb3JlUmVwcmVzZW50YXRpb24iLCJ0b0pTT04iLCJmcm9tSHR0cDJIZWFkZXJzIiwiaGVhZGVycyIsImtleXMiLCJjaGFyQXQiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwic3BsaXQiLCJ0cmltIiwiZXJyb3IiLCJtZXNzYWdlIiwibG9nIiwiTG9nVmVyYm9zaXR5IiwiRVJST1IiLCJ2YWwiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/picker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.QueuePicker = exports.UnavailablePicker = exports.PickResultType = void 0;\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nvar PickResultType;\n(function(PickResultType) {\n    PickResultType[PickResultType[\"COMPLETE\"] = 0] = \"COMPLETE\";\n    PickResultType[PickResultType[\"QUEUE\"] = 1] = \"QUEUE\";\n    PickResultType[PickResultType[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n    PickResultType[PickResultType[\"DROP\"] = 3] = \"DROP\";\n})(PickResultType = exports.PickResultType || (exports.PickResultType = {}));\n/**\n * A standard picker representing a load balancer in the TRANSIENT_FAILURE\n * state. Always responds to every pick request with an UNAVAILABLE status.\n */ class UnavailablePicker {\n    constructor(status){\n        if (status !== undefined) {\n            this.status = status;\n        } else {\n            this.status = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: \"No connection established\",\n                metadata: new metadata_1.Metadata()\n            };\n        }\n    }\n    pick(pickArgs) {\n        return {\n            pickResultType: PickResultType.TRANSIENT_FAILURE,\n            subchannel: null,\n            status: this.status,\n            extraFilterFactories: [],\n            onCallStarted: null\n        };\n    }\n}\nexports.UnavailablePicker = UnavailablePicker;\n/**\n * A standard picker representing a load balancer in the IDLE or CONNECTING\n * state. Always responds to every pick request with a QUEUE pick result\n * indicating that the pick should be tried again with the next `Picker`. Also\n * reports back to the load balancer that a connection should be established\n * once any pick is attempted.\n */ class QueuePicker {\n    // Constructed with a load balancer. Calls exitIdle on it the first time pick is called\n    constructor(loadBalancer){\n        this.loadBalancer = loadBalancer;\n        this.calledExitIdle = false;\n    }\n    pick(pickArgs) {\n        if (!this.calledExitIdle) {\n            process.nextTick(()=>{\n                this.loadBalancer.exitIdle();\n            });\n            this.calledExitIdle = true;\n        }\n        return {\n            pickResultType: PickResultType.QUEUE,\n            subchannel: null,\n            status: null,\n            extraFilterFactories: [],\n            onCallStarted: null\n        };\n    }\n}\nexports.QueuePicker = QueuePicker; //# sourceMappingURL=picker.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxtQkFBbUIsR0FBR0EseUJBQXlCLEdBQUdBLHNCQUFzQixHQUFHLEtBQUs7QUFDaEYsTUFBTUssYUFBYUMsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsSUFBSUY7QUFDSCxVQUFVQSxjQUFjO0lBQ3JCQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxXQUFXLEdBQUcsRUFBRSxHQUFHO0lBQ2pEQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQzlDQSxjQUFjLENBQUNBLGNBQWMsQ0FBQyxvQkFBb0IsR0FBRyxFQUFFLEdBQUc7SUFDMURBLGNBQWMsQ0FBQ0EsY0FBYyxDQUFDLE9BQU8sR0FBRyxFQUFFLEdBQUc7QUFDakQsR0FBR0EsaUJBQWlCSixRQUFRSSxjQUFjLElBQUtKLENBQUFBLHNCQUFzQixHQUFHLENBQUM7QUFDekU7OztDQUdDLEdBQ0QsTUFBTUc7SUFDRkssWUFBWUMsTUFBTSxDQUFFO1FBQ2hCLElBQUlBLFdBQVdDLFdBQVc7WUFDdEIsSUFBSSxDQUFDRCxNQUFNLEdBQUdBO1FBQ2xCLE9BQ0s7WUFDRCxJQUFJLENBQUNBLE1BQU0sR0FBRztnQkFDVkUsTUFBTUosWUFBWUssTUFBTSxDQUFDQyxXQUFXO2dCQUNwQ0MsU0FBUztnQkFDVEMsVUFBVSxJQUFJVixXQUFXVyxRQUFRO1lBQ3JDO1FBQ0o7SUFDSjtJQUNBQyxLQUFLQyxRQUFRLEVBQUU7UUFDWCxPQUFPO1lBQ0hDLGdCQUFnQmYsZUFBZWdCLGlCQUFpQjtZQUNoREMsWUFBWTtZQUNaWixRQUFRLElBQUksQ0FBQ0EsTUFBTTtZQUNuQmEsc0JBQXNCLEVBQUU7WUFDeEJDLGVBQWU7UUFDbkI7SUFDSjtBQUNKO0FBQ0F2Qix5QkFBeUIsR0FBR0c7QUFDNUI7Ozs7OztDQU1DLEdBQ0QsTUFBTUQ7SUFDRix1RkFBdUY7SUFDdkZNLFlBQVlnQixZQUFZLENBQUU7UUFDdEIsSUFBSSxDQUFDQSxZQUFZLEdBQUdBO1FBQ3BCLElBQUksQ0FBQ0MsY0FBYyxHQUFHO0lBQzFCO0lBQ0FSLEtBQUtDLFFBQVEsRUFBRTtRQUNYLElBQUksQ0FBQyxJQUFJLENBQUNPLGNBQWMsRUFBRTtZQUN0QkMsUUFBUUMsUUFBUSxDQUFDO2dCQUNiLElBQUksQ0FBQ0gsWUFBWSxDQUFDSSxRQUFRO1lBQzlCO1lBQ0EsSUFBSSxDQUFDSCxjQUFjLEdBQUc7UUFDMUI7UUFDQSxPQUFPO1lBQ0hOLGdCQUFnQmYsZUFBZXlCLEtBQUs7WUFDcENSLFlBQVk7WUFDWlosUUFBUTtZQUNSYSxzQkFBc0IsRUFBRTtZQUN4QkMsZUFBZTtRQUNuQjtJQUNKO0FBQ0o7QUFDQXZCLG1CQUFtQixHQUFHRSxhQUN0QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcGlja2VyLmpzPzU3ZTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUXVldWVQaWNrZXIgPSBleHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gZXhwb3J0cy5QaWNrUmVzdWx0VHlwZSA9IHZvaWQgMDtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xudmFyIFBpY2tSZXN1bHRUeXBlO1xuKGZ1bmN0aW9uIChQaWNrUmVzdWx0VHlwZSkge1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiQ09NUExFVEVcIl0gPSAwXSA9IFwiQ09NUExFVEVcIjtcbiAgICBQaWNrUmVzdWx0VHlwZVtQaWNrUmVzdWx0VHlwZVtcIlFVRVVFXCJdID0gMV0gPSBcIlFVRVVFXCI7XG4gICAgUGlja1Jlc3VsdFR5cGVbUGlja1Jlc3VsdFR5cGVbXCJUUkFOU0lFTlRfRkFJTFVSRVwiXSA9IDJdID0gXCJUUkFOU0lFTlRfRkFJTFVSRVwiO1xuICAgIFBpY2tSZXN1bHRUeXBlW1BpY2tSZXN1bHRUeXBlW1wiRFJPUFwiXSA9IDNdID0gXCJEUk9QXCI7XG59KShQaWNrUmVzdWx0VHlwZSA9IGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgfHwgKGV4cG9ydHMuUGlja1Jlc3VsdFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBBIHN0YW5kYXJkIHBpY2tlciByZXByZXNlbnRpbmcgYSBsb2FkIGJhbGFuY2VyIGluIHRoZSBUUkFOU0lFTlRfRkFJTFVSRVxuICogc3RhdGUuIEFsd2F5cyByZXNwb25kcyB0byBldmVyeSBwaWNrIHJlcXVlc3Qgd2l0aCBhbiBVTkFWQUlMQUJMRSBzdGF0dXMuXG4gKi9cbmNsYXNzIFVuYXZhaWxhYmxlUGlja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzdGF0dXMpIHtcbiAgICAgICAgaWYgKHN0YXR1cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICBkZXRhaWxzOiAnTm8gY29ubmVjdGlvbiBlc3RhYmxpc2hlZCcsXG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IG5ldyBtZXRhZGF0YV8xLk1ldGFkYXRhKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBpY2tSZXN1bHRUeXBlOiBQaWNrUmVzdWx0VHlwZS5UUkFOU0lFTlRfRkFJTFVSRSxcbiAgICAgICAgICAgIHN1YmNoYW5uZWw6IG51bGwsXG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZXh0cmFGaWx0ZXJGYWN0b3JpZXM6IFtdLFxuICAgICAgICAgICAgb25DYWxsU3RhcnRlZDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlVuYXZhaWxhYmxlUGlja2VyID0gVW5hdmFpbGFibGVQaWNrZXI7XG4vKipcbiAqIEEgc3RhbmRhcmQgcGlja2VyIHJlcHJlc2VudGluZyBhIGxvYWQgYmFsYW5jZXIgaW4gdGhlIElETEUgb3IgQ09OTkVDVElOR1xuICogc3RhdGUuIEFsd2F5cyByZXNwb25kcyB0byBldmVyeSBwaWNrIHJlcXVlc3Qgd2l0aCBhIFFVRVVFIHBpY2sgcmVzdWx0XG4gKiBpbmRpY2F0aW5nIHRoYXQgdGhlIHBpY2sgc2hvdWxkIGJlIHRyaWVkIGFnYWluIHdpdGggdGhlIG5leHQgYFBpY2tlcmAuIEFsc29cbiAqIHJlcG9ydHMgYmFjayB0byB0aGUgbG9hZCBiYWxhbmNlciB0aGF0IGEgY29ubmVjdGlvbiBzaG91bGQgYmUgZXN0YWJsaXNoZWRcbiAqIG9uY2UgYW55IHBpY2sgaXMgYXR0ZW1wdGVkLlxuICovXG5jbGFzcyBRdWV1ZVBpY2tlciB7XG4gICAgLy8gQ29uc3RydWN0ZWQgd2l0aCBhIGxvYWQgYmFsYW5jZXIuIENhbGxzIGV4aXRJZGxlIG9uIGl0IHRoZSBmaXJzdCB0aW1lIHBpY2sgaXMgY2FsbGVkXG4gICAgY29uc3RydWN0b3IobG9hZEJhbGFuY2VyKSB7XG4gICAgICAgIHRoaXMubG9hZEJhbGFuY2VyID0gbG9hZEJhbGFuY2VyO1xuICAgICAgICB0aGlzLmNhbGxlZEV4aXRJZGxlID0gZmFsc2U7XG4gICAgfVxuICAgIHBpY2socGlja0FyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGxlZEV4aXRJZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRCYWxhbmNlci5leGl0SWRsZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmNhbGxlZEV4aXRJZGxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGlja1Jlc3VsdFR5cGU6IFBpY2tSZXN1bHRUeXBlLlFVRVVFLFxuICAgICAgICAgICAgc3ViY2hhbm5lbDogbnVsbCxcbiAgICAgICAgICAgIHN0YXR1czogbnVsbCxcbiAgICAgICAgICAgIGV4dHJhRmlsdGVyRmFjdG9yaWVzOiBbXSxcbiAgICAgICAgICAgIG9uQ2FsbFN0YXJ0ZWQ6IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5RdWV1ZVBpY2tlciA9IFF1ZXVlUGlja2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGlja2VyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlF1ZXVlUGlja2VyIiwiVW5hdmFpbGFibGVQaWNrZXIiLCJQaWNrUmVzdWx0VHlwZSIsIm1ldGFkYXRhXzEiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJjb25zdHJ1Y3RvciIsInN0YXR1cyIsInVuZGVmaW5lZCIsImNvZGUiLCJTdGF0dXMiLCJVTkFWQUlMQUJMRSIsImRldGFpbHMiLCJtZXRhZGF0YSIsIk1ldGFkYXRhIiwicGljayIsInBpY2tBcmdzIiwicGlja1Jlc3VsdFR5cGUiLCJUUkFOU0lFTlRfRkFJTFVSRSIsInN1YmNoYW5uZWwiLCJleHRyYUZpbHRlckZhY3RvcmllcyIsIm9uQ2FsbFN0YXJ0ZWQiLCJsb2FkQmFsYW5jZXIiLCJjYWxsZWRFeGl0SWRsZSIsInByb2Nlc3MiLCJuZXh0VGljayIsImV4aXRJZGxlIiwiUVVFVUUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-dns.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst dns = __webpack_require__(/*! dns */ \"dns\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst TRACER_NAME = \"dns_resolver\";\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */ const DEFAULT_PORT = 443;\nconst DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 30000;\nconst resolveTxtPromise = util.promisify(dns.resolveTxt);\nconst dnsLookupPromise = util.promisify(dns.lookup);\n/**\n * Merge any number of arrays into a single alternating array\n * @param arrays\n */ function mergeArrays(...arrays) {\n    const result = [];\n    for(let i = 0; i < Math.max.apply(null, arrays.map((array)=>array.length)); i++){\n        for (const array of arrays){\n            if (i < array.length) {\n                result.push(array[i]);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Resolver implementation that handles DNS names and IP addresses.\n */ class DnsResolver {\n    constructor(target, listener, channelOptions){\n        var _a, _b, _c;\n        this.target = target;\n        this.listener = listener;\n        this.pendingLookupPromise = null;\n        this.pendingTxtPromise = null;\n        this.latestLookupResult = null;\n        this.latestServiceConfig = null;\n        this.latestServiceConfigError = null;\n        this.continueResolving = false;\n        this.isNextResolutionTimerRunning = false;\n        trace(\"Resolver constructed for target \" + uri_parser_1.uriToString(target));\n        const hostPort = uri_parser_1.splitHostPort(target.path);\n        if (hostPort === null) {\n            this.ipResult = null;\n            this.dnsHostname = null;\n            this.port = null;\n        } else {\n            if (net_1.isIPv4(hostPort.host) || net_1.isIPv6(hostPort.host)) {\n                this.ipResult = [\n                    {\n                        host: hostPort.host,\n                        port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT\n                    }\n                ];\n                this.dnsHostname = null;\n                this.port = null;\n            } else {\n                this.ipResult = null;\n                this.dnsHostname = hostPort.host;\n                this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;\n            }\n        }\n        this.percentage = Math.random() * 100;\n        this.defaultResolutionError = {\n            code: constants_1.Status.UNAVAILABLE,\n            details: `Name resolution failed for target ${uri_parser_1.uriToString(this.target)}`,\n            metadata: new metadata_1.Metadata()\n        };\n        const backoffOptions = {\n            initialDelay: channelOptions[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: channelOptions[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoff = new backoff_timeout_1.BackoffTimeout(()=>{\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, backoffOptions);\n        this.backoff.unref();\n        this.minTimeBetweenResolutionsMs = (_c = channelOptions[\"grpc.dns_min_time_between_resolutions_ms\"]) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;\n        this.nextResolutionTimer = setTimeout(()=>{}, 0);\n        clearTimeout(this.nextResolutionTimer);\n    }\n    /**\n     * If the target is an IP address, just provide that address as a result.\n     * Otherwise, initiate A, AAAA, and TXT lookups\n     */ startResolution() {\n        if (this.ipResult !== null) {\n            trace(\"Returning IP address for target \" + uri_parser_1.uriToString(this.target));\n            setImmediate(()=>{\n                this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});\n            });\n            this.backoff.stop();\n            this.backoff.reset();\n            return;\n        }\n        if (this.dnsHostname === null) {\n            trace(\"Failed to parse DNS address \" + uri_parser_1.uriToString(this.target));\n            setImmediate(()=>{\n                this.listener.onError({\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse DNS address ${uri_parser_1.uriToString(this.target)}`,\n                    metadata: new metadata_1.Metadata()\n                });\n            });\n            this.stopNextResolutionTimer();\n        } else {\n            if (this.pendingLookupPromise !== null) {\n                return;\n            }\n            trace(\"Looking up DNS hostname \" + this.dnsHostname);\n            /* We clear out latestLookupResult here to ensure that it contains the\n             * latest result since the last time we started resolving. That way, the\n             * TXT resolution handler can use it, but only if it finishes second. We\n             * don't clear out any previous service config results because it's\n             * better to use a service config that's slightly out of date than to\n             * revert to an effectively blank one. */ this.latestLookupResult = null;\n            const hostname = this.dnsHostname;\n            /* We lookup both address families here and then split them up later\n             * because when looking up a single family, dns.lookup outputs an error\n             * if the name exists but there are no records for that family, and that\n             * error is indistinguishable from other kinds of errors */ this.pendingLookupPromise = dnsLookupPromise(hostname, {\n                all: true\n            });\n            this.pendingLookupPromise.then((addressList)=>{\n                this.pendingLookupPromise = null;\n                this.backoff.reset();\n                this.backoff.stop();\n                const ip4Addresses = addressList.filter((addr)=>addr.family === 4);\n                const ip6Addresses = addressList.filter((addr)=>addr.family === 6);\n                this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr)=>({\n                        host: addr.address,\n                        port: +this.port\n                    }));\n                const allAddressesString = \"[\" + this.latestLookupResult.map((addr)=>addr.host + \":\" + addr.port).join(\",\") + \"]\";\n                trace(\"Resolved addresses for target \" + uri_parser_1.uriToString(this.target) + \": \" + allAddressesString);\n                if (this.latestLookupResult.length === 0) {\n                    this.listener.onError(this.defaultResolutionError);\n                    return;\n                }\n                /* If the TXT lookup has not yet finished, both of the last two\n                 * arguments will be null, which is the equivalent of getting an\n                 * empty TXT response. When the TXT lookup does finish, its handler\n                 * can update the service config by using the same address list */ this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n            }, (err)=>{\n                trace(\"Resolution error for target \" + uri_parser_1.uriToString(this.target) + \": \" + err.message);\n                this.pendingLookupPromise = null;\n                this.stopNextResolutionTimer();\n                this.listener.onError(this.defaultResolutionError);\n            });\n            /* If there already is a still-pending TXT resolution, we can just use\n             * that result when it comes in */ if (this.pendingTxtPromise === null) {\n                /* We handle the TXT query promise differently than the others because\n                 * the name resolution attempt as a whole is a success even if the TXT\n                 * lookup fails */ this.pendingTxtPromise = resolveTxtPromise(hostname);\n                this.pendingTxtPromise.then((txtRecord)=>{\n                    this.pendingTxtPromise = null;\n                    try {\n                        this.latestServiceConfig = service_config_1.extractAndSelectServiceConfig(txtRecord, this.percentage);\n                    } catch (err) {\n                        this.latestServiceConfigError = {\n                            code: constants_1.Status.UNAVAILABLE,\n                            details: \"Parsing service config failed\",\n                            metadata: new metadata_1.Metadata()\n                        };\n                    }\n                    if (this.latestLookupResult !== null) {\n                        /* We rely here on the assumption that calling this function with\n                         * identical parameters will be essentialy idempotent, and calling\n                         * it with the same address list and a different service config\n                         * should result in a fast and seamless switchover. */ this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});\n                    }\n                }, (err)=>{\n                /* If TXT lookup fails we should do nothing, which means that we\n                     * continue to use the result of the most recent successful lookup,\n                     * or the default null config object if there has never been a\n                     * successful lookup. We do not set the latestServiceConfigError\n                     * here because that is specifically used for response validation\n                     * errors. We still need to handle this error so that it does not\n                     * bubble up as an unhandled promise rejection. */ });\n            }\n        }\n    }\n    startNextResolutionTimer() {\n        var _a, _b;\n        clearTimeout(this.nextResolutionTimer);\n        this.nextResolutionTimer = (_b = (_a = setTimeout(()=>{\n            this.stopNextResolutionTimer();\n            if (this.continueResolving) {\n                this.startResolutionWithBackoff();\n            }\n        }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        this.isNextResolutionTimerRunning = true;\n    }\n    stopNextResolutionTimer() {\n        clearTimeout(this.nextResolutionTimer);\n        this.isNextResolutionTimerRunning = false;\n    }\n    startResolutionWithBackoff() {\n        if (this.pendingLookupPromise === null) {\n            this.continueResolving = false;\n            this.startResolution();\n            this.backoff.runOnce();\n            this.startNextResolutionTimer();\n        }\n    }\n    updateResolution() {\n        /* If there is a pending lookup, just let it finish. Otherwise, if the\n         * nextResolutionTimer or backoff timer is running, set the\n         * continueResolving flag to resolve when whichever of those timers\n         * fires. Otherwise, start resolving immediately. */ if (this.pendingLookupPromise === null) {\n            if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {\n                this.continueResolving = true;\n            } else {\n                this.startResolutionWithBackoff();\n            }\n        }\n    }\n    destroy() {\n        this.continueResolving = false;\n        this.backoff.stop();\n        this.stopNextResolutionTimer();\n    }\n    /**\n     * Get the default authority for the given target. For IP targets, that is\n     * the IP address. For DNS targets, it is the hostname.\n     * @param target\n     */ static getDefaultAuthority(target) {\n        return target.path;\n    }\n}\n/**\n * Set up the DNS resolver class by registering it as the handler for the\n * \"dns:\" prefix and as the default resolver.\n */ function setup() {\n    resolver_1.registerResolver(\"dns\", DnsResolver);\n    resolver_1.registerDefaultScheme(\"dns\");\n}\nexports.setup = setup; //# sourceMappingURL=resolver-dns.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItZG5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBRyxLQUFLO0FBQ3JCLE1BQU1HLGFBQWFDLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1DLE1BQU1ELG1CQUFPQSxDQUFDLGdCQUFLO0FBQ3pCLE1BQU1FLE9BQU9GLG1CQUFPQSxDQUFDLGtCQUFNO0FBQzNCLE1BQU1HLG1CQUFtQkgsbUJBQU9BLENBQUMsd0ZBQWtCO0FBQ25ELE1BQU1JLGNBQWNKLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1LLGFBQWFMLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1NLFVBQVVOLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1PLGNBQWNQLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1RLGVBQWVSLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1TLFFBQVFULG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLE1BQU1VLG9CQUFvQlYsbUJBQU9BLENBQUMsMEZBQW1CO0FBQ3JELE1BQU1XLGNBQWM7QUFDcEIsU0FBU0MsTUFBTUMsSUFBSTtJQUNmUCxRQUFRTSxLQUFLLENBQUNMLFlBQVlPLFlBQVksQ0FBQ0MsS0FBSyxFQUFFSixhQUFhRTtBQUMvRDtBQUNBOztDQUVDLEdBQ0QsTUFBTUcsZUFBZTtBQUNyQixNQUFNQywwQ0FBMEM7QUFDaEQsTUFBTUMsb0JBQW9CaEIsS0FBS2lCLFNBQVMsQ0FBQ2xCLElBQUltQixVQUFVO0FBQ3ZELE1BQU1DLG1CQUFtQm5CLEtBQUtpQixTQUFTLENBQUNsQixJQUFJcUIsTUFBTTtBQUNsRDs7O0NBR0MsR0FDRCxTQUFTQyxZQUFZLEdBQUdDLE1BQU07SUFDMUIsTUFBTUMsU0FBUyxFQUFF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UUFDekIsSUFBSSxDQUFDd0IsT0FBTyxDQUFDVyxJQUFJO1FBQ2pCLElBQUksQ0FBQ0csdUJBQXVCO0lBQ2hDO0lBQ0E7Ozs7S0FJQyxHQUNELE9BQU91QixvQkFBb0J4RSxNQUFNLEVBQUU7UUFDL0IsT0FBT0EsT0FBT2dCLElBQUk7SUFDdEI7QUFDSjtBQUNBOzs7Q0FHQyxHQUNELFNBQVN0RDtJQUNMQyxXQUFXOEcsZ0JBQWdCLENBQUMsT0FBTzNFO0lBQ25DbkMsV0FBVytHLHFCQUFxQixDQUFDO0FBQ3JDO0FBQ0FsSCxhQUFhLEdBQUdFLE9BQ2hCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci1kbnMuanM/NzFlNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gdm9pZCAwO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgZG5zID0gcmVxdWlyZShcImRuc1wiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IHNlcnZpY2VfY29uZmlnXzEgPSByZXF1aXJlKFwiLi9zZXJ2aWNlLWNvbmZpZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgbWV0YWRhdGFfMSA9IHJlcXVpcmUoXCIuL21ldGFkYXRhXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBjb25zdGFudHNfMiA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcbmNvbnN0IFRSQUNFUl9OQU1FID0gJ2Ruc19yZXNvbHZlcic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMi5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgVENQIHBvcnQgdG8gY29ubmVjdCB0byBpZiBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQgaW4gdGhlIHRhcmdldC5cbiAqL1xuY29uc3QgREVGQVVMVF9QT1JUID0gNDQzO1xuY29uc3QgREVGQVVMVF9NSU5fVElNRV9CRVRXRUVOX1JFU09MVVRJT05TX01TID0gMzAwMDA7XG5jb25zdCByZXNvbHZlVHh0UHJvbWlzZSA9IHV0aWwucHJvbWlzaWZ5KGRucy5yZXNvbHZlVHh0KTtcbmNvbnN0IGRuc0xvb2t1cFByb21pc2UgPSB1dGlsLnByb21pc2lmeShkbnMubG9va3VwKTtcbi8qKlxuICogTWVyZ2UgYW55IG51bWJlciBvZiBhcnJheXMgaW50byBhIHNpbmdsZSBhbHRlcm5hdGluZyBhcnJheVxuICogQHBhcmFtIGFycmF5c1xuICovXG5mdW5jdGlvbiBtZXJnZUFycmF5cyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8XG4gICAgICAgIE1hdGgubWF4LmFwcGx5KG51bGwsIGFycmF5cy5tYXAoKGFycmF5KSA9PiBhcnJheS5sZW5ndGgpKTsgaSsrKSB7XG4gICAgICAgIGZvciAoY29uc3QgYXJyYXkgb2YgYXJyYXlzKSB7XG4gICAgICAgICAgICBpZiAoaSA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFycmF5W2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBSZXNvbHZlciBpbXBsZW1lbnRhdGlvbiB0aGF0IGhhbmRsZXMgRE5TIG5hbWVzIGFuZCBJUCBhZGRyZXNzZXMuXG4gKi9cbmNsYXNzIERuc1Jlc29sdmVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGxpc3RlbmVyLCBjaGFubmVsT3B0aW9ucykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdHJhY2UoJ1Jlc29sdmVyIGNvbnN0cnVjdGVkIGZvciB0YXJnZXQgJyArIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0YXJnZXQpKTtcbiAgICAgICAgY29uc3QgaG9zdFBvcnQgPSB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydCh0YXJnZXQucGF0aCk7XG4gICAgICAgIGlmIChob3N0UG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucG9ydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobmV0XzEuaXNJUHY0KGhvc3RQb3J0Lmhvc3QpIHx8IG5ldF8xLmlzSVB2Nihob3N0UG9ydC5ob3N0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXBSZXN1bHQgPSBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3RQb3J0Lmhvc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3J0OiAoX2EgPSBob3N0UG9ydC5wb3J0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1BPUlQsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB0aGlzLmRuc0hvc3RuYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pcFJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5kbnNIb3N0bmFtZSA9IGhvc3RQb3J0Lmhvc3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3J0ID0gKF9iID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogREVGQVVMVF9QT1JUO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVyY2VudGFnZSA9IE1hdGgucmFuZG9tKCkgKiAxMDA7XG4gICAgICAgIHRoaXMuZGVmYXVsdFJlc29sdXRpb25FcnJvciA9IHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgIGRldGFpbHM6IGBOYW1lIHJlc29sdXRpb24gZmFpbGVkIGZvciB0YXJnZXQgJHt1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpfWAsXG4gICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYmFja29mZk9wdGlvbnMgPSB7XG4gICAgICAgICAgICBpbml0aWFsRGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBjaGFubmVsT3B0aW9uc1snZ3JwYy5tYXhfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5iYWNrb2ZmID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlc29sdXRpb25XaXRoQmFja29mZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFja29mZi51bnJlZigpO1xuICAgICAgICB0aGlzLm1pblRpbWVCZXR3ZWVuUmVzb2x1dGlvbnNNcyA9IChfYyA9IGNoYW5uZWxPcHRpb25zWydncnBjLmRuc19taW5fdGltZV9iZXR3ZWVuX3Jlc29sdXRpb25zX21zJ10pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IERFRkFVTFRfTUlOX1RJTUVfQkVUV0VFTl9SRVNPTFVUSU9OU19NUztcbiAgICAgICAgdGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHRhcmdldCBpcyBhbiBJUCBhZGRyZXNzLCBqdXN0IHByb3ZpZGUgdGhhdCBhZGRyZXNzIGFzIGEgcmVzdWx0LlxuICAgICAqIE90aGVyd2lzZSwgaW5pdGlhdGUgQSwgQUFBQSwgYW5kIFRYVCBsb29rdXBzXG4gICAgICovXG4gICAgc3RhcnRSZXNvbHV0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pcFJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhY2UoJ1JldHVybmluZyBJUCBhZGRyZXNzIGZvciB0YXJnZXQgJyArIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0aGlzLnRhcmdldCkpO1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24odGhpcy5pcFJlc3VsdCwgbnVsbCwgbnVsbCwgbnVsbCwge30pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYuc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZG5zSG9zdG5hbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYWNlKCdGYWlsZWQgdG8gcGFyc2UgRE5TIGFkZHJlc3MgJyArIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0aGlzLnRhcmdldCkpO1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6IGBGYWlsZWQgdG8gcGFyc2UgRE5TIGFkZHJlc3MgJHt1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpfWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNlKCdMb29raW5nIHVwIEROUyBob3N0bmFtZSAnICsgdGhpcy5kbnNIb3N0bmFtZSk7XG4gICAgICAgICAgICAvKiBXZSBjbGVhciBvdXQgbGF0ZXN0TG9va3VwUmVzdWx0IGhlcmUgdG8gZW5zdXJlIHRoYXQgaXQgY29udGFpbnMgdGhlXG4gICAgICAgICAgICAgKiBsYXRlc3QgcmVzdWx0IHNpbmNlIHRoZSBsYXN0IHRpbWUgd2Ugc3RhcnRlZCByZXNvbHZpbmcuIFRoYXQgd2F5LCB0aGVcbiAgICAgICAgICAgICAqIFRYVCByZXNvbHV0aW9uIGhhbmRsZXIgY2FuIHVzZSBpdCwgYnV0IG9ubHkgaWYgaXQgZmluaXNoZXMgc2Vjb25kLiBXZVxuICAgICAgICAgICAgICogZG9uJ3QgY2xlYXIgb3V0IGFueSBwcmV2aW91cyBzZXJ2aWNlIGNvbmZpZyByZXN1bHRzIGJlY2F1c2UgaXQnc1xuICAgICAgICAgICAgICogYmV0dGVyIHRvIHVzZSBhIHNlcnZpY2UgY29uZmlnIHRoYXQncyBzbGlnaHRseSBvdXQgb2YgZGF0ZSB0aGFuIHRvXG4gICAgICAgICAgICAgKiByZXZlcnQgdG8gYW4gZWZmZWN0aXZlbHkgYmxhbmsgb25lLiAqL1xuICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgaG9zdG5hbWUgPSB0aGlzLmRuc0hvc3RuYW1lO1xuICAgICAgICAgICAgLyogV2UgbG9va3VwIGJvdGggYWRkcmVzcyBmYW1pbGllcyBoZXJlIGFuZCB0aGVuIHNwbGl0IHRoZW0gdXAgbGF0ZXJcbiAgICAgICAgICAgICAqIGJlY2F1c2Ugd2hlbiBsb29raW5nIHVwIGEgc2luZ2xlIGZhbWlseSwgZG5zLmxvb2t1cCBvdXRwdXRzIGFuIGVycm9yXG4gICAgICAgICAgICAgKiBpZiB0aGUgbmFtZSBleGlzdHMgYnV0IHRoZXJlIGFyZSBubyByZWNvcmRzIGZvciB0aGF0IGZhbWlseSwgYW5kIHRoYXRcbiAgICAgICAgICAgICAqIGVycm9yIGlzIGluZGlzdGluZ3Vpc2hhYmxlIGZyb20gb3RoZXIga2luZHMgb2YgZXJyb3JzICovXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlID0gZG5zTG9va3VwUHJvbWlzZShob3N0bmFtZSwgeyBhbGw6IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdMb29rdXBQcm9taXNlLnRoZW4oKGFkZHJlc3NMaXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrb2ZmLnN0b3AoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpcDRBZGRyZXNzZXMgPSBhZGRyZXNzTGlzdC5maWx0ZXIoKGFkZHIpID0+IGFkZHIuZmFtaWx5ID09PSA0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBpcDZBZGRyZXNzZXMgPSBhZGRyZXNzTGlzdC5maWx0ZXIoKGFkZHIpID0+IGFkZHIuZmFtaWx5ID09PSA2KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCA9IG1lcmdlQXJyYXlzKGlwNkFkZHJlc3NlcywgaXA0QWRkcmVzc2VzKS5tYXAoKGFkZHIpID0+ICh7IGhvc3Q6IGFkZHIuYWRkcmVzcywgcG9ydDogK3RoaXMucG9ydCB9KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsQWRkcmVzc2VzU3RyaW5nID0gJ1snICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RMb29rdXBSZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKGFkZHIpID0+IGFkZHIuaG9zdCArICc6JyArIGFkZHIucG9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsJykgK1xuICAgICAgICAgICAgICAgICAgICAnXSc7XG4gICAgICAgICAgICAgICAgdHJhY2UoJ1Jlc29sdmVkIGFkZHJlc3NlcyBmb3IgdGFyZ2V0ICcgK1xuICAgICAgICAgICAgICAgICAgICB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGhpcy50YXJnZXQpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIGFsbEFkZHJlc3Nlc1N0cmluZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3IodGhpcy5kZWZhdWx0UmVzb2x1dGlvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgVFhUIGxvb2t1cCBoYXMgbm90IHlldCBmaW5pc2hlZCwgYm90aCBvZiB0aGUgbGFzdCB0d29cbiAgICAgICAgICAgICAgICAgKiBhcmd1bWVudHMgd2lsbCBiZSBudWxsLCB3aGljaCBpcyB0aGUgZXF1aXZhbGVudCBvZiBnZXR0aW5nIGFuXG4gICAgICAgICAgICAgICAgICogZW1wdHkgVFhUIHJlc3BvbnNlLiBXaGVuIHRoZSBUWFQgbG9va3VwIGRvZXMgZmluaXNoLCBpdHMgaGFuZGxlclxuICAgICAgICAgICAgICAgICAqIGNhbiB1cGRhdGUgdGhlIHNlcnZpY2UgY29uZmlnIGJ5IHVzaW5nIHRoZSBzYW1lIGFkZHJlc3MgbGlzdCAqL1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXIub25TdWNjZXNzZnVsUmVzb2x1dGlvbih0aGlzLmxhdGVzdExvb2t1cFJlc3VsdCwgdGhpcy5sYXRlc3RTZXJ2aWNlQ29uZmlnLCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciwgbnVsbCwge30pO1xuICAgICAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHRyYWNlKCdSZXNvbHV0aW9uIGVycm9yIGZvciB0YXJnZXQgJyArXG4gICAgICAgICAgICAgICAgICAgIHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0aGlzLnRhcmdldCkgK1xuICAgICAgICAgICAgICAgICAgICAnOiAnICtcbiAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLm9uRXJyb3IodGhpcy5kZWZhdWx0UmVzb2x1dGlvbkVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyogSWYgdGhlcmUgYWxyZWFkeSBpcyBhIHN0aWxsLXBlbmRpbmcgVFhUIHJlc29sdXRpb24sIHdlIGNhbiBqdXN0IHVzZVxuICAgICAgICAgICAgICogdGhhdCByZXN1bHQgd2hlbiBpdCBjb21lcyBpbiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ1R4dFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvKiBXZSBoYW5kbGUgdGhlIFRYVCBxdWVyeSBwcm9taXNlIGRpZmZlcmVudGx5IHRoYW4gdGhlIG90aGVycyBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICogdGhlIG5hbWUgcmVzb2x1dGlvbiBhdHRlbXB0IGFzIGEgd2hvbGUgaXMgYSBzdWNjZXNzIGV2ZW4gaWYgdGhlIFRYVFxuICAgICAgICAgICAgICAgICAqIGxvb2t1cCBmYWlscyAqL1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1R4dFByb21pc2UgPSByZXNvbHZlVHh0UHJvbWlzZShob3N0bmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZS50aGVuKCh0eHRSZWNvcmQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nVHh0UHJvbWlzZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcgPSBzZXJ2aWNlX2NvbmZpZ18xLmV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnKHR4dFJlY29yZCwgdGhpcy5wZXJjZW50YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWdFcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5BVkFJTEFCTEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogJ1BhcnNpbmcgc2VydmljZSBjb25maWcgZmFpbGVkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBXZSByZWx5IGhlcmUgb24gdGhlIGFzc3VtcHRpb24gdGhhdCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gd2l0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICogaWRlbnRpY2FsIHBhcmFtZXRlcnMgd2lsbCBiZSBlc3NlbnRpYWx5IGlkZW1wb3RlbnQsIGFuZCBjYWxsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBpdCB3aXRoIHRoZSBzYW1lIGFkZHJlc3MgbGlzdCBhbmQgYSBkaWZmZXJlbnQgc2VydmljZSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHNob3VsZCByZXN1bHQgaW4gYSBmYXN0IGFuZCBzZWFtbGVzcyBzd2l0Y2hvdmVyLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMubGF0ZXN0TG9va3VwUmVzdWx0LCB0aGlzLmxhdGVzdFNlcnZpY2VDb25maWcsIHRoaXMubGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yLCBudWxsLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIFRYVCBsb29rdXAgZmFpbHMgd2Ugc2hvdWxkIGRvIG5vdGhpbmcsIHdoaWNoIG1lYW5zIHRoYXQgd2VcbiAgICAgICAgICAgICAgICAgICAgICogY29udGludWUgdG8gdXNlIHRoZSByZXN1bHQgb2YgdGhlIG1vc3QgcmVjZW50IHN1Y2Nlc3NmdWwgbG9va3VwLFxuICAgICAgICAgICAgICAgICAgICAgKiBvciB0aGUgZGVmYXVsdCBudWxsIGNvbmZpZyBvYmplY3QgaWYgdGhlcmUgaGFzIG5ldmVyIGJlZW4gYVxuICAgICAgICAgICAgICAgICAgICAgKiBzdWNjZXNzZnVsIGxvb2t1cC4gV2UgZG8gbm90IHNldCB0aGUgbGF0ZXN0U2VydmljZUNvbmZpZ0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAqIGhlcmUgYmVjYXVzZSB0aGF0IGlzIHNwZWNpZmljYWxseSB1c2VkIGZvciByZXNwb25zZSB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqIGVycm9ycy4gV2Ugc3RpbGwgbmVlZCB0byBoYW5kbGUgdGhpcyBlcnJvciBzbyB0aGF0IGl0IGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAgICAqIGJ1YmJsZSB1cCBhcyBhbiB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24uICovXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnROZXh0UmVzb2x1dGlvblRpbWVyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyKTtcbiAgICAgICAgdGhpcy5uZXh0UmVzb2x1dGlvblRpbWVyID0gKF9iID0gKF9hID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0b3BOZXh0UmVzb2x1dGlvblRpbWVyKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250aW51ZVJlc29sdmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcy5taW5UaW1lQmV0d2VlblJlc29sdXRpb25zTXMpKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB0aGlzLmlzTmV4dFJlc29sdXRpb25UaW1lclJ1bm5pbmcgPSB0cnVlO1xuICAgIH1cbiAgICBzdG9wTmV4dFJlc29sdXRpb25UaW1lcigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubmV4dFJlc29sdXRpb25UaW1lcik7XG4gICAgICAgIHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICBzdGFydFJlc29sdXRpb25XaXRoQmFja29mZigpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0xvb2t1cFByb21pc2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmYucnVuT25jZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFydE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVSZXNvbHV0aW9uKCkge1xuICAgICAgICAvKiBJZiB0aGVyZSBpcyBhIHBlbmRpbmcgbG9va3VwLCBqdXN0IGxldCBpdCBmaW5pc2guIE90aGVyd2lzZSwgaWYgdGhlXG4gICAgICAgICAqIG5leHRSZXNvbHV0aW9uVGltZXIgb3IgYmFja29mZiB0aW1lciBpcyBydW5uaW5nLCBzZXQgdGhlXG4gICAgICAgICAqIGNvbnRpbnVlUmVzb2x2aW5nIGZsYWcgdG8gcmVzb2x2ZSB3aGVuIHdoaWNoZXZlciBvZiB0aG9zZSB0aW1lcnNcbiAgICAgICAgICogZmlyZXMuIE90aGVyd2lzZSwgc3RhcnQgcmVzb2x2aW5nIGltbWVkaWF0ZWx5LiAqL1xuICAgICAgICBpZiAodGhpcy5wZW5kaW5nTG9va3VwUHJvbWlzZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyB8fCB0aGlzLmJhY2tvZmYuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNvbnRpbnVlUmVzb2x2aW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYmFja29mZi5zdG9wKCk7XG4gICAgICAgIHRoaXMuc3RvcE5leHRSZXNvbHV0aW9uVGltZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBkZWZhdWx0IGF1dGhvcml0eSBmb3IgdGhlIGdpdmVuIHRhcmdldC4gRm9yIElQIHRhcmdldHMsIHRoYXQgaXNcbiAgICAgKiB0aGUgSVAgYWRkcmVzcy4gRm9yIEROUyB0YXJnZXRzLCBpdCBpcyB0aGUgaG9zdG5hbWUuXG4gICAgICogQHBhcmFtIHRhcmdldFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LnBhdGg7XG4gICAgfVxufVxuLyoqXG4gKiBTZXQgdXAgdGhlIEROUyByZXNvbHZlciBjbGFzcyBieSByZWdpc3RlcmluZyBpdCBhcyB0aGUgaGFuZGxlciBmb3IgdGhlXG4gKiBcImRuczpcIiBwcmVmaXggYW5kIGFzIHRoZSBkZWZhdWx0IHJlc29sdmVyLlxuICovXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIoJ2RucycsIERuc1Jlc29sdmVyKTtcbiAgICByZXNvbHZlcl8xLnJlZ2lzdGVyRGVmYXVsdFNjaGVtZSgnZG5zJyk7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci1kbnMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2V0dXAiLCJyZXNvbHZlcl8xIiwicmVxdWlyZSIsImRucyIsInV0aWwiLCJzZXJ2aWNlX2NvbmZpZ18xIiwiY29uc3RhbnRzXzEiLCJtZXRhZGF0YV8xIiwibG9nZ2luZyIsImNvbnN0YW50c18yIiwidXJpX3BhcnNlcl8xIiwibmV0XzEiLCJiYWNrb2ZmX3RpbWVvdXRfMSIsIlRSQUNFUl9OQU1FIiwidHJhY2UiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJERUZBVUxUX1BPUlQiLCJERUZBVUxUX01JTl9USU1FX0JFVFdFRU5fUkVTT0xVVElPTlNfTVMiLCJyZXNvbHZlVHh0UHJvbWlzZSIsInByb21pc2lmeSIsInJlc29sdmVUeHQiLCJkbnNMb29rdXBQcm9taXNlIiwibG9va3VwIiwibWVyZ2VBcnJheXMiLCJhcnJheXMiLCJyZXN1bHQiLCJpIiwiTWF0aCIsIm1heCIsImFwcGx5IiwibWFwIiwiYXJyYXkiLCJsZW5ndGgiLCJwdXNoIiwiRG5zUmVzb2x2ZXIiLCJjb25zdHJ1Y3RvciIsInRhcmdldCIsImxpc3RlbmVyIiwiY2hhbm5lbE9wdGlvbnMiLCJfYSIsIl9iIiwiX2MiLCJwZW5kaW5nTG9va3VwUHJvbWlzZSIsInBlbmRpbmdUeHRQcm9taXNlIiwibGF0ZXN0TG9va3VwUmVzdWx0IiwibGF0ZXN0U2VydmljZUNvbmZpZyIsImxhdGVzdFNlcnZpY2VDb25maWdFcnJvciIsImNvbnRpbnVlUmVzb2x2aW5nIiwiaXNOZXh0UmVzb2x1dGlvblRpbWVyUnVubmluZyIsInVyaVRvU3RyaW5nIiwiaG9zdFBvcnQiLCJzcGxpdEhvc3RQb3J0IiwicGF0aCIsImlwUmVzdWx0IiwiZG5zSG9zdG5hbWUiLCJwb3J0IiwiaXNJUHY0IiwiaG9zdCIsImlzSVB2NiIsInBlcmNlbnRhZ2UiLCJyYW5kb20iLCJkZWZhdWx0UmVzb2x1dGlvbkVycm9yIiwiY29kZSIsIlN0YXR1cyIsIlVOQVZBSUxBQkxFIiwiZGV0YWlscyIsIm1ldGFkYXRhIiwiTWV0YWRhdGEiLCJiYWNrb2ZmT3B0aW9ucyIsImluaXRpYWxEZWxheSIsIm1heERlbGF5IiwiYmFja29mZiIsIkJhY2tvZmZUaW1lb3V0Iiwic3RhcnRSZXNvbHV0aW9uV2l0aEJhY2tvZmYiLCJ1bnJlZiIsIm1pblRpbWVCZXR3ZWVuUmVzb2x1dGlvbnNNcyIsIm5leHRSZXNvbHV0aW9uVGltZXIiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic3RhcnRSZXNvbHV0aW9uIiwic2V0SW1tZWRpYXRlIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsInN0b3AiLCJyZXNldCIsIm9uRXJyb3IiLCJzdG9wTmV4dFJlc29sdXRpb25UaW1lciIsImhvc3RuYW1lIiwiYWxsIiwidGhlbiIsImFkZHJlc3NMaXN0IiwiaXA0QWRkcmVzc2VzIiwiZmlsdGVyIiwiYWRkciIsImZhbWlseSIsImlwNkFkZHJlc3NlcyIsImFkZHJlc3MiLCJhbGxBZGRyZXNzZXNTdHJpbmciLCJqb2luIiwiZXJyIiwibWVzc2FnZSIsInR4dFJlY29yZCIsImV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnIiwic3RhcnROZXh0UmVzb2x1dGlvblRpbWVyIiwiY2FsbCIsInJ1bk9uY2UiLCJ1cGRhdGVSZXNvbHV0aW9uIiwiaXNSdW5uaW5nIiwiZGVzdHJveSIsImdldERlZmF1bHRBdXRob3JpdHkiLCJyZWdpc3RlclJlc29sdmVyIiwicmVnaXN0ZXJEZWZhdWx0U2NoZW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-dns.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-ip.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"ip_resolver\";\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst IPV4_SCHEME = \"ipv4\";\nconst IPV6_SCHEME = \"ipv6\";\n/**\n * The default TCP port to connect to if not explicitly specified in the target.\n */ const DEFAULT_PORT = 443;\nclass IpResolver {\n    constructor(target, listener, channelOptions){\n        var _a;\n        this.target = target;\n        this.listener = listener;\n        this.addresses = [];\n        this.error = null;\n        trace(\"Resolver constructed for target \" + uri_parser_1.uriToString(target));\n        const addresses = [];\n        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {\n            this.error = {\n                code: constants_1.Status.UNAVAILABLE,\n                details: `Unrecognized scheme ${target.scheme} in IP resolver`,\n                metadata: new metadata_1.Metadata()\n            };\n            return;\n        }\n        const pathList = target.path.split(\",\");\n        for (const path of pathList){\n            const hostPort = uri_parser_1.splitHostPort(path);\n            if (hostPort === null) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata()\n                };\n                return;\n            }\n            if (target.scheme === IPV4_SCHEME && !net_1.isIPv4(hostPort.host) || target.scheme === IPV6_SCHEME && !net_1.isIPv6(hostPort.host)) {\n                this.error = {\n                    code: constants_1.Status.UNAVAILABLE,\n                    details: `Failed to parse ${target.scheme} address ${path}`,\n                    metadata: new metadata_1.Metadata()\n                };\n                return;\n            }\n            addresses.push({\n                host: hostPort.host,\n                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT\n            });\n        }\n        this.addresses = addresses;\n        trace(\"Parsed \" + target.scheme + \" address list \" + this.addresses);\n    }\n    updateResolution() {\n        process.nextTick(()=>{\n            if (this.error) {\n                this.listener.onError(this.error);\n            } else {\n                this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});\n            }\n        });\n    }\n    destroy() {\n    // This resolver owns no resources, so we do nothing here.\n    }\n    static getDefaultAuthority(target) {\n        return target.path.split(\",\")[0];\n    }\n}\nfunction setup() {\n    resolver_1.registerResolver(IPV4_SCHEME, IpResolver);\n    resolver_1.registerResolver(IPV6_SCHEME, IpResolver);\n}\nexports.setup = setup; //# sourceMappingURL=resolver-ip.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7Q0FjQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsYUFBYSxHQUFHLEtBQUs7QUFDckIsTUFBTUcsUUFBUUMsbUJBQU9BLENBQUMsZ0JBQUs7QUFDM0IsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTUUsYUFBYUYsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUksZUFBZUosbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTUssVUFBVUwsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTU0sY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZILFFBQVFFLEtBQUssQ0FBQ04sWUFBWVEsWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0EsTUFBTUcsY0FBYztBQUNwQixNQUFNQyxjQUFjO0FBQ3BCOztDQUVDLEdBQ0QsTUFBTUMsZUFBZTtBQUNyQixNQUFNQztJQUNGQyxZQUFZQyxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsY0FBYyxDQUFFO1FBQzFDLElBQUlDO1FBQ0osSUFBSSxDQUFDSCxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDQyxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0csU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFDYmQsTUFBTSxxQ0FBcUNILGFBQWFrQixXQUFXLENBQUNOO1FBQ3BFLE1BQU1JLFlBQVksRUFBRTtRQUNwQixJQUFJLENBQUVKLENBQUFBLE9BQU9PLE1BQU0sS0FBS1osZUFBZUssT0FBT08sTUFBTSxLQUFLWCxXQUFVLEdBQUk7WUFDbkUsSUFBSSxDQUFDUyxLQUFLLEdBQUc7Z0JBQ1RHLE1BQU12QixZQUFZd0IsTUFBTSxDQUFDQyxXQUFXO2dCQUNwQ0MsU0FBUyxDQUFDLG9CQUFvQixFQUFFWCxPQUFPTyxNQUFNLENBQUMsZUFBZSxDQUFDO2dCQUM5REssVUFBVSxJQUFJMUIsV0FBVzJCLFFBQVE7WUFDckM7WUFDQTtRQUNKO1FBQ0EsTUFBTUMsV0FBV2QsT0FBT2UsSUFBSSxDQUFDQyxLQUFLLENBQUM7UUFDbkMsS0FBSyxNQUFNRCxRQUFRRCxTQUFVO1lBQ3pCLE1BQU1HLFdBQVc3QixhQUFhOEIsYUFBYSxDQUFDSDtZQUM1QyxJQUFJRSxhQUFhLE1BQU07Z0JBQ25CLElBQUksQ0FBQ1osS0FBSyxHQUFHO29CQUNURyxNQUFNdkIsWUFBWXdCLE1BQU0sQ0FBQ0MsV0FBVztvQkFDcENDLFNBQVMsQ0FBQyxnQkFBZ0IsRUFBRVgsT0FBT08sTUFBTSxDQUFDLFNBQVMsRUFBRVEsS0FBSyxDQUFDO29CQUMzREgsVUFBVSxJQUFJMUIsV0FBVzJCLFFBQVE7Z0JBQ3JDO2dCQUNBO1lBQ0o7WUFDQSxJQUFJLE9BQVFOLE1BQU0sS0FBS1osZUFBZSxDQUFDWixNQUFNb0MsTUFBTSxDQUFDRixTQUFTRyxJQUFJLEtBQzVEcEIsT0FBT08sTUFBTSxLQUFLWCxlQUFlLENBQUNiLE1BQU1zQyxNQUFNLENBQUNKLFNBQVNHLElBQUksR0FBSTtnQkFDakUsSUFBSSxDQUFDZixLQUFLLEdBQUc7b0JBQ1RHLE1BQU12QixZQUFZd0IsTUFBTSxDQUFDQyxXQUFXO29CQUNwQ0MsU0FBUyxDQUFDLGdCQUFnQixFQUFFWCxPQUFPTyxNQUFNLENBQUMsU0FBUyxFQUFFUSxLQUFLLENBQUM7b0JBQzNESCxVQUFVLElBQUkxQixXQUFXMkIsUUFBUTtnQkFDckM7Z0JBQ0E7WUFDSjtZQUNBVCxVQUFVa0IsSUFBSSxDQUFDO2dCQUNYRixNQUFNSCxTQUFTRyxJQUFJO2dCQUNuQkcsTUFBTSxDQUFDcEIsS0FBS2MsU0FBU00sSUFBSSxNQUFNLFFBQVFwQixPQUFPLEtBQUssSUFBSUEsS0FBS047WUFDaEU7UUFDSjtRQUNBLElBQUksQ0FBQ08sU0FBUyxHQUFHQTtRQUNqQmIsTUFBTSxZQUFZUyxPQUFPTyxNQUFNLEdBQUcsbUJBQW1CLElBQUksQ0FBQ0gsU0FBUztJQUN2RTtJQUNBb0IsbUJBQW1CO1FBQ2ZDLFFBQVFDLFFBQVEsQ0FBQztZQUNiLElBQUksSUFBSSxDQUFDckIsS0FBSyxFQUFFO2dCQUNaLElBQUksQ0FBQ0osUUFBUSxDQUFDMEIsT0FBTyxDQUFDLElBQUksQ0FBQ3RCLEtBQUs7WUFDcEMsT0FDSztnQkFDRCxJQUFJLENBQUNKLFFBQVEsQ0FBQzJCLHNCQUFzQixDQUFDLElBQUksQ0FBQ3hCLFNBQVMsRUFBRSxNQUFNLE1BQU0sTUFBTSxDQUFDO1lBQzVFO1FBQ0o7SUFDSjtJQUNBeUIsVUFBVTtJQUNOLDBEQUEwRDtJQUM5RDtJQUNBLE9BQU9DLG9CQUFvQjlCLE1BQU0sRUFBRTtRQUMvQixPQUFPQSxPQUFPZSxJQUFJLENBQUNDLEtBQUssQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUNwQztBQUNKO0FBQ0EsU0FBU2xDO0lBQ0xLLFdBQVc0QyxnQkFBZ0IsQ0FBQ3BDLGFBQWFHO0lBQ3pDWCxXQUFXNEMsZ0JBQWdCLENBQUNuQyxhQUFhRTtBQUM3QztBQUNBbEIsYUFBYSxHQUFHRSxPQUNoQix1Q0FBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItaXAuanM/N2QyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdpcF9yZXNvbHZlcic7XG5mdW5jdGlvbiB0cmFjZSh0ZXh0KSB7XG4gICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsIFRSQUNFUl9OQU1FLCB0ZXh0KTtcbn1cbmNvbnN0IElQVjRfU0NIRU1FID0gJ2lwdjQnO1xuY29uc3QgSVBWNl9TQ0hFTUUgPSAnaXB2Nic7XG4vKipcbiAqIFRoZSBkZWZhdWx0IFRDUCBwb3J0IHRvIGNvbm5lY3QgdG8gaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIGluIHRoZSB0YXJnZXQuXG4gKi9cbmNvbnN0IERFRkFVTFRfUE9SVCA9IDQ0MztcbmNsYXNzIElwUmVzb2x2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgbGlzdGVuZXIsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgIHRyYWNlKCdSZXNvbHZlciBjb25zdHJ1Y3RlZCBmb3IgdGFyZ2V0ICcgKyB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGFyZ2V0KSk7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICBpZiAoISh0YXJnZXQuc2NoZW1lID09PSBJUFY0X1NDSEVNRSB8fCB0YXJnZXQuc2NoZW1lID09PSBJUFY2X1NDSEVNRSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOQVZBSUxBQkxFLFxuICAgICAgICAgICAgICAgIGRldGFpbHM6IGBVbnJlY29nbml6ZWQgc2NoZW1lICR7dGFyZ2V0LnNjaGVtZX0gaW4gSVAgcmVzb2x2ZXJgLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXRoTGlzdCA9IHRhcmdldC5wYXRoLnNwbGl0KCcsJyk7XG4gICAgICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgaG9zdFBvcnQgPSB1cmlfcGFyc2VyXzEuc3BsaXRIb3N0UG9ydChwYXRoKTtcbiAgICAgICAgICAgIGlmIChob3N0UG9ydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYEZhaWxlZCB0byBwYXJzZSAke3RhcmdldC5zY2hlbWV9IGFkZHJlc3MgJHtwYXRofWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0YXJnZXQuc2NoZW1lID09PSBJUFY0X1NDSEVNRSAmJiAhbmV0XzEuaXNJUHY0KGhvc3RQb3J0Lmhvc3QpKSB8fFxuICAgICAgICAgICAgICAgICh0YXJnZXQuc2NoZW1lID09PSBJUFY2X1NDSEVNRSAmJiAhbmV0XzEuaXNJUHY2KGhvc3RQb3J0Lmhvc3QpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYEZhaWxlZCB0byBwYXJzZSAke3RhcmdldC5zY2hlbWV9IGFkZHJlc3MgJHtwYXRofWAsXG4gICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhOiBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWRkcmVzc2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIGhvc3Q6IGhvc3RQb3J0Lmhvc3QsXG4gICAgICAgICAgICAgICAgcG9ydDogKF9hID0gaG9zdFBvcnQucG9ydCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogREVGQVVMVF9QT1JULFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBhZGRyZXNzZXM7XG4gICAgICAgIHRyYWNlKCdQYXJzZWQgJyArIHRhcmdldC5zY2hlbWUgKyAnIGFkZHJlc3MgbGlzdCAnICsgdGhpcy5hZGRyZXNzZXMpO1xuICAgIH1cbiAgICB1cGRhdGVSZXNvbHV0aW9uKCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vbkVycm9yKHRoaXMuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lci5vblN1Y2Nlc3NmdWxSZXNvbHV0aW9uKHRoaXMuYWRkcmVzc2VzLCBudWxsLCBudWxsLCBudWxsLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBUaGlzIHJlc29sdmVyIG93bnMgbm8gcmVzb3VyY2VzLCBzbyB3ZSBkbyBub3RoaW5nIGhlcmUuXG4gICAgfVxuICAgIHN0YXRpYyBnZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LnBhdGguc3BsaXQoJywnKVswXTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIoSVBWNF9TQ0hFTUUsIElwUmVzb2x2ZXIpO1xuICAgIHJlc29sdmVyXzEucmVnaXN0ZXJSZXNvbHZlcihJUFY2X1NDSEVNRSwgSXBSZXNvbHZlcik7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci1pcC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzZXR1cCIsIm5ldF8xIiwicmVxdWlyZSIsImNvbnN0YW50c18xIiwibWV0YWRhdGFfMSIsInJlc29sdmVyXzEiLCJ1cmlfcGFyc2VyXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIklQVjRfU0NIRU1FIiwiSVBWNl9TQ0hFTUUiLCJERUZBVUxUX1BPUlQiLCJJcFJlc29sdmVyIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJsaXN0ZW5lciIsImNoYW5uZWxPcHRpb25zIiwiX2EiLCJhZGRyZXNzZXMiLCJlcnJvciIsInVyaVRvU3RyaW5nIiwic2NoZW1lIiwiY29kZSIsIlN0YXR1cyIsIlVOQVZBSUxBQkxFIiwiZGV0YWlscyIsIm1ldGFkYXRhIiwiTWV0YWRhdGEiLCJwYXRoTGlzdCIsInBhdGgiLCJzcGxpdCIsImhvc3RQb3J0Iiwic3BsaXRIb3N0UG9ydCIsImlzSVB2NCIsImhvc3QiLCJpc0lQdjYiLCJwdXNoIiwicG9ydCIsInVwZGF0ZVJlc29sdXRpb24iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJvbkVycm9yIiwib25TdWNjZXNzZnVsUmVzb2x1dGlvbiIsImRlc3Ryb3kiLCJnZXREZWZhdWx0QXV0aG9yaXR5IiwicmVnaXN0ZXJSZXNvbHZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-ip.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js":
/*!**************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver-uds.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.setup = void 0;\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nclass UdsResolver {\n    constructor(target, listener, channelOptions){\n        this.listener = listener;\n        this.addresses = [];\n        let path;\n        if (target.authority === \"\") {\n            path = \"/\" + target.path;\n        } else {\n            path = target.path;\n        }\n        this.addresses = [\n            {\n                path\n            }\n        ];\n    }\n    updateResolution() {\n        process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});\n    }\n    destroy() {\n    // This resolver owns no resources, so we do nothing here.\n    }\n    static getDefaultAuthority(target) {\n        return \"localhost\";\n    }\n}\nfunction setup() {\n    resolver_1.registerResolver(\"unix\", UdsResolver);\n}\nexports.setup = setup; //# sourceMappingURL=resolver-uds.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXItdWRzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELGFBQWEsR0FBRyxLQUFLO0FBQ3JCLE1BQU1HLGFBQWFDLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1DO0lBQ0ZDLFlBQVlDLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxjQUFjLENBQUU7UUFDMUMsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ0UsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSUM7UUFDSixJQUFJSixPQUFPSyxTQUFTLEtBQUssSUFBSTtZQUN6QkQsT0FBTyxNQUFNSixPQUFPSSxJQUFJO1FBQzVCLE9BQ0s7WUFDREEsT0FBT0osT0FBT0ksSUFBSTtRQUN0QjtRQUNBLElBQUksQ0FBQ0QsU0FBUyxHQUFHO1lBQUM7Z0JBQUVDO1lBQUs7U0FBRTtJQUMvQjtJQUNBRSxtQkFBbUI7UUFDZkMsUUFBUUMsUUFBUSxDQUFDLElBQUksQ0FBQ1AsUUFBUSxDQUFDUSxzQkFBc0IsRUFBRSxJQUFJLENBQUNOLFNBQVMsRUFBRSxNQUFNLE1BQU0sTUFBTSxDQUFDO0lBQzlGO0lBQ0FPLFVBQVU7SUFDTiwwREFBMEQ7SUFDOUQ7SUFDQSxPQUFPQyxvQkFBb0JYLE1BQU0sRUFBRTtRQUMvQixPQUFPO0lBQ1g7QUFDSjtBQUNBLFNBQVNMO0lBQ0xDLFdBQVdnQixnQkFBZ0IsQ0FBQyxRQUFRZDtBQUN4QztBQUNBTCxhQUFhLEdBQUdFLE9BQ2hCLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9yZXNvbHZlci11ZHMuanM/Njk1OSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwID0gdm9pZCAwO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY2xhc3MgVWRzUmVzb2x2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgbGlzdGVuZXIsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5hZGRyZXNzZXMgPSBbXTtcbiAgICAgICAgbGV0IHBhdGg7XG4gICAgICAgIGlmICh0YXJnZXQuYXV0aG9yaXR5ID09PSAnJykge1xuICAgICAgICAgICAgcGF0aCA9ICcvJyArIHRhcmdldC5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IHRhcmdldC5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkcmVzc2VzID0gW3sgcGF0aCB9XTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24sIHRoaXMuYWRkcmVzc2VzLCBudWxsLCBudWxsLCBudWxsLCB7fSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIC8vIFRoaXMgcmVzb2x2ZXIgb3ducyBubyByZXNvdXJjZXMsIHNvIHdlIGRvIG5vdGhpbmcgaGVyZS5cbiAgICB9XG4gICAgc3RhdGljIGdldERlZmF1bHRBdXRob3JpdHkodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiAnbG9jYWxob3N0JztcbiAgICB9XG59XG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgICByZXNvbHZlcl8xLnJlZ2lzdGVyUmVzb2x2ZXIoJ3VuaXgnLCBVZHNSZXNvbHZlcik7XG59XG5leHBvcnRzLnNldHVwID0gc2V0dXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlci11ZHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwic2V0dXAiLCJyZXNvbHZlcl8xIiwicmVxdWlyZSIsIlVkc1Jlc29sdmVyIiwiY29uc3RydWN0b3IiLCJ0YXJnZXQiLCJsaXN0ZW5lciIsImNoYW5uZWxPcHRpb25zIiwiYWRkcmVzc2VzIiwicGF0aCIsImF1dGhvcml0eSIsInVwZGF0ZVJlc29sdXRpb24iLCJwcm9jZXNzIiwibmV4dFRpY2siLCJvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uIiwiZGVzdHJveSIsImdldERlZmF1bHRBdXRob3JpdHkiLCJyZWdpc3RlclJlc29sdmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver-uds.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js":
/*!**********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolver.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */ function registerResolver(scheme, resolverClass) {\n    registeredResolvers[scheme] = resolverClass;\n}\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */ function registerDefaultScheme(scheme) {\n    defaultScheme = scheme;\n}\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */ function createResolver(target, listener, options) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return new registeredResolvers[target.scheme](target, listener, options);\n    } else {\n        throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);\n    }\n}\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */ function getDefaultAuthority(target) {\n    if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n        return registeredResolvers[target.scheme].getDefaultAuthority(target);\n    } else {\n        throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);\n    }\n}\nexports.getDefaultAuthority = getDefaultAuthority;\nfunction mapUriDefaultScheme(target) {\n    if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n        if (defaultScheme !== null) {\n            return {\n                scheme: defaultScheme,\n                authority: undefined,\n                path: uri_parser_1.uriToString(target)\n            };\n        } else {\n            return null;\n        }\n    }\n    return target;\n}\nexports.mapUriDefaultScheme = mapUriDefaultScheme; //# sourceMappingURL=resolver.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSwyQkFBMkIsR0FBR0Esc0JBQXNCLEdBQUdBLDZCQUE2QixHQUFHQSx3QkFBd0IsR0FBRyxLQUFLO0FBQ3JKLE1BQU1PLGVBQWVDLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1DLHNCQUFzQixDQUFDO0FBQzdCLElBQUlDLGdCQUFnQjtBQUNwQjs7Ozs7O0NBTUMsR0FDRCxTQUFTSixpQkFBaUJLLE1BQU0sRUFBRUMsYUFBYTtJQUMzQ0gsbUJBQW1CLENBQUNFLE9BQU8sR0FBR0M7QUFDbEM7QUFDQVosd0JBQXdCLEdBQUdNO0FBQzNCOzs7O0NBSUMsR0FDRCxTQUFTRCxzQkFBc0JNLE1BQU07SUFDakNELGdCQUFnQkM7QUFDcEI7QUFDQVgsNkJBQTZCLEdBQUdLO0FBQ2hDOzs7OztDQUtDLEdBQ0QsU0FBU0QsZUFBZVMsTUFBTSxFQUFFQyxRQUFRLEVBQUVDLE9BQU87SUFDN0MsSUFBSUYsT0FBT0YsTUFBTSxLQUFLSyxhQUFhSCxPQUFPRixNQUFNLElBQUlGLHFCQUFxQjtRQUNyRSxPQUFPLElBQUlBLG1CQUFtQixDQUFDSSxPQUFPRixNQUFNLENBQUMsQ0FBQ0UsUUFBUUMsVUFBVUM7SUFDcEUsT0FDSztRQUNELE1BQU0sSUFBSUUsTUFBTSxDQUFDLHdDQUF3QyxFQUFFVixhQUFhVyxXQUFXLENBQUNMLFFBQVEsQ0FBQztJQUNqRztBQUNKO0FBQ0FiLHNCQUFzQixHQUFHSTtBQUN6Qjs7OztDQUlDLEdBQ0QsU0FBU0Qsb0JBQW9CVSxNQUFNO0lBQy9CLElBQUlBLE9BQU9GLE1BQU0sS0FBS0ssYUFBYUgsT0FBT0YsTUFBTSxJQUFJRixxQkFBcUI7UUFDckUsT0FBT0EsbUJBQW1CLENBQUNJLE9BQU9GLE1BQU0sQ0FBQyxDQUFDUixtQkFBbUIsQ0FBQ1U7SUFDbEUsT0FDSztRQUNELE1BQU0sSUFBSUksTUFBTSxDQUFDLGVBQWUsRUFBRVYsYUFBYVcsV0FBVyxDQUFDTCxRQUFRLENBQUM7SUFDeEU7QUFDSjtBQUNBYiwyQkFBMkIsR0FBR0c7QUFDOUIsU0FBU0Qsb0JBQW9CVyxNQUFNO0lBQy9CLElBQUlBLE9BQU9GLE1BQU0sS0FBS0ssYUFBYSxDQUFFSCxDQUFBQSxPQUFPRixNQUFNLElBQUlGLG1CQUFrQixHQUFJO1FBQ3hFLElBQUlDLGtCQUFrQixNQUFNO1lBQ3hCLE9BQU87Z0JBQ0hDLFFBQVFEO2dCQUNSUyxXQUFXSDtnQkFDWEksTUFBTWIsYUFBYVcsV0FBVyxDQUFDTDtZQUNuQztRQUNKLE9BQ0s7WUFDRCxPQUFPO1FBQ1g7SUFDSjtJQUNBLE9BQU9BO0FBQ1g7QUFDQWIsMkJBQTJCLEdBQUdFLHFCQUM5QixvQ0FBb0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2ZXIuanM/MWQ5NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tYXBVcmlEZWZhdWx0U2NoZW1lID0gZXhwb3J0cy5nZXREZWZhdWx0QXV0aG9yaXR5ID0gZXhwb3J0cy5jcmVhdGVSZXNvbHZlciA9IGV4cG9ydHMucmVnaXN0ZXJEZWZhdWx0U2NoZW1lID0gZXhwb3J0cy5yZWdpc3RlclJlc29sdmVyID0gdm9pZCAwO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IHJlZ2lzdGVyZWRSZXNvbHZlcnMgPSB7fTtcbmxldCBkZWZhdWx0U2NoZW1lID0gbnVsbDtcbi8qKlxuICogUmVnaXN0ZXIgYSByZXNvbHZlciBjbGFzcyB0byBoYW5kbGUgdGFyZ2V0IG5hbWVzIHByZWZpeGVkIHdpdGggdGhlIGBwcmVmaXhgXG4gKiBzdHJpbmcuIFRoaXMgcHJlZml4IHNob3VsZCBjb3JyZXNwb25kIHRvIGEgVVJJIHNjaGVtZSBuYW1lIGxpc3RlZCBpbiB0aGVcbiAqIFtnUlBDIE5hbWUgUmVzb2x1dGlvbiBkb2N1bWVudF0oaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9kb2MvbmFtaW5nLm1kKVxuICogQHBhcmFtIHByZWZpeFxuICogQHBhcmFtIHJlc29sdmVyQ2xhc3NcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJSZXNvbHZlcihzY2hlbWUsIHJlc29sdmVyQ2xhc3MpIHtcbiAgICByZWdpc3RlcmVkUmVzb2x2ZXJzW3NjaGVtZV0gPSByZXNvbHZlckNsYXNzO1xufVxuZXhwb3J0cy5yZWdpc3RlclJlc29sdmVyID0gcmVnaXN0ZXJSZXNvbHZlcjtcbi8qKlxuICogUmVnaXN0ZXIgYSBkZWZhdWx0IHJlc29sdmVyIHRvIGhhbmRsZSB0YXJnZXQgbmFtZXMgdGhhdCBkbyBub3Qgc3RhcnQgd2l0aFxuICogYW55IHJlZ2lzdGVyZWQgcHJlZml4LlxuICogQHBhcmFtIHJlc29sdmVyQ2xhc3NcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0U2NoZW1lKHNjaGVtZSkge1xuICAgIGRlZmF1bHRTY2hlbWUgPSBzY2hlbWU7XG59XG5leHBvcnRzLnJlZ2lzdGVyRGVmYXVsdFNjaGVtZSA9IHJlZ2lzdGVyRGVmYXVsdFNjaGVtZTtcbi8qKlxuICogQ3JlYXRlIGEgbmFtZSByZXNvbHZlciBmb3IgdGhlIHNwZWNpZmllZCB0YXJnZXQsIGlmIHBvc3NpYmxlLiBUaHJvd3MgYW5cbiAqIGVycm9yIGlmIG5vIHN1Y2ggbmFtZSByZXNvbHZlciBjYW4gYmUgY3JlYXRlZC5cbiAqIEBwYXJhbSB0YXJnZXRcbiAqIEBwYXJhbSBsaXN0ZW5lclxuICovXG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZlcih0YXJnZXQsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgIT09IHVuZGVmaW5lZCAmJiB0YXJnZXQuc2NoZW1lIGluIHJlZ2lzdGVyZWRSZXNvbHZlcnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyByZWdpc3RlcmVkUmVzb2x2ZXJzW3RhcmdldC5zY2hlbWVdKHRhcmdldCwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyByZXNvbHZlciBjb3VsZCBiZSBjcmVhdGVkIGZvciB0YXJnZXQgJHt1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcodGFyZ2V0KX1gKTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZVJlc29sdmVyID0gY3JlYXRlUmVzb2x2ZXI7XG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCBhdXRob3JpdHkgZm9yIHRoZSBzcGVjaWZpZWQgdGFyZ2V0LCBpZiBwb3NzaWJsZS4gVGhyb3dzIGFuXG4gKiBlcnJvciBpZiBubyByZWdpc3RlcmVkIG5hbWUgcmVzb2x2ZXIgY2FuIHBhcnNlIHRoYXQgdGFyZ2V0IHN0cmluZy5cbiAqIEBwYXJhbSB0YXJnZXRcbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEF1dGhvcml0eSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0LnNjaGVtZSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykge1xuICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZFJlc29sdmVyc1t0YXJnZXQuc2NoZW1lXS5nZXREZWZhdWx0QXV0aG9yaXR5KHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGFyZ2V0ICR7dXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRhcmdldCl9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5nZXREZWZhdWx0QXV0aG9yaXR5ID0gZ2V0RGVmYXVsdEF1dGhvcml0eTtcbmZ1bmN0aW9uIG1hcFVyaURlZmF1bHRTY2hlbWUodGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldC5zY2hlbWUgPT09IHVuZGVmaW5lZCB8fCAhKHRhcmdldC5zY2hlbWUgaW4gcmVnaXN0ZXJlZFJlc29sdmVycykpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRTY2hlbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2NoZW1lOiBkZWZhdWx0U2NoZW1lLFxuICAgICAgICAgICAgICAgIGF1dGhvcml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHBhdGg6IHVyaV9wYXJzZXJfMS51cmlUb1N0cmluZyh0YXJnZXQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5leHBvcnRzLm1hcFVyaURlZmF1bHRTY2hlbWUgPSBtYXBVcmlEZWZhdWx0U2NoZW1lO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibWFwVXJpRGVmYXVsdFNjaGVtZSIsImdldERlZmF1bHRBdXRob3JpdHkiLCJjcmVhdGVSZXNvbHZlciIsInJlZ2lzdGVyRGVmYXVsdFNjaGVtZSIsInJlZ2lzdGVyUmVzb2x2ZXIiLCJ1cmlfcGFyc2VyXzEiLCJyZXF1aXJlIiwicmVnaXN0ZXJlZFJlc29sdmVycyIsImRlZmF1bHRTY2hlbWUiLCJzY2hlbWUiLCJyZXNvbHZlckNsYXNzIiwidGFyZ2V0IiwibGlzdGVuZXIiLCJvcHRpb25zIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJ1cmlUb1N0cmluZyIsImF1dGhvcml0eSIsInBhdGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\nconst service_config_1 = __webpack_require__(/*! ./service-config */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst picker_1 = __webpack_require__(/*! ./picker */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/picker.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_2 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst load_balancer_child_handler_1 = __webpack_require__(/*! ./load-balancer-child-handler */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js\");\nconst TRACER_NAME = \"resolving_load_balancer\";\nfunction trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst DEFAULT_LOAD_BALANCER_NAME = \"pick_first\";\nfunction getDefaultConfigSelector(serviceConfig) {\n    return function defaultConfigSelector(methodName, metadata) {\n        var _a, _b;\n        const splitName = methodName.split(\"/\").filter((x)=>x.length > 0);\n        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : \"\";\n        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : \"\";\n        if (serviceConfig && serviceConfig.methodConfig) {\n            for (const methodConfig of serviceConfig.methodConfig){\n                for (const name of methodConfig.name){\n                    if (name.service === service && (name.method === undefined || name.method === method)) {\n                        return {\n                            methodConfig: methodConfig,\n                            pickInformation: {},\n                            status: constants_1.Status.OK,\n                            dynamicFilterFactories: []\n                        };\n                    }\n                }\n            }\n        }\n        return {\n            methodConfig: {\n                name: []\n            },\n            pickInformation: {},\n            status: constants_1.Status.OK,\n            dynamicFilterFactories: []\n        };\n    };\n}\nclass ResolvingLoadBalancer {\n    /**\n     * Wrapper class that behaves like a `LoadBalancer` and also handles name\n     * resolution internally.\n     * @param target The address of the backend to connect to.\n     * @param channelControlHelper `ChannelControlHelper` instance provided by\n     *     this load balancer's owner.\n     * @param defaultServiceConfig The default service configuration to be used\n     *     if none is provided by the name resolver. A `null` value indicates\n     *     that the default behavior should be the default unconfigured behavior.\n     *     In practice, that means using the \"pick first\" load balancer\n     *     implmentation\n     */ constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution){\n        this.target = target;\n        this.channelControlHelper = channelControlHelper;\n        this.channelOptions = channelOptions;\n        this.onSuccessfulResolution = onSuccessfulResolution;\n        this.onFailedResolution = onFailedResolution;\n        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n        this.latestChildPicker = new picker_1.QueuePicker(this);\n        /**\n         * This resolving load balancer's current connectivity state.\n         */ this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The service config object from the last successful resolution, if\n         * available. A value of null indicates that we have not yet received a valid\n         * service config from the resolver.\n         */ this.previousServiceConfig = null;\n        /**\n         * Indicates whether we should attempt to resolve again after the backoff\n         * timer runs out.\n         */ this.continueResolving = false;\n        if (channelOptions[\"grpc.service_config\"]) {\n            this.defaultServiceConfig = service_config_1.validateServiceConfig(JSON.parse(channelOptions[\"grpc.service_config\"]));\n        } else {\n            this.defaultServiceConfig = {\n                loadBalancingConfig: [],\n                methodConfig: []\n            };\n        }\n        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n            createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n            requestReresolution: ()=>{\n                /* If the backoffTimeout is running, we're still backing off from\n                 * making resolve requests, so we shouldn't make another one here.\n                 * In that case, the backoff timer callback will call\n                 * updateResolution */ if (this.backoffTimeout.isRunning()) {\n                    this.continueResolving = true;\n                } else {\n                    this.updateResolution();\n                }\n            },\n            updateState: (newState, picker)=>{\n                this.latestChildState = newState;\n                this.latestChildPicker = picker;\n                this.updateState(newState, picker);\n            },\n            addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n            removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)\n        });\n        this.innerResolver = resolver_1.createResolver(target, {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes)=>{\n                var _a;\n                let workingServiceConfig = null;\n                /* This first group of conditionals implements the algorithm described\n                 * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n                 * in the section called \"Behavior on receiving a new gRPC Config\".\n                 */ if (serviceConfig === null) {\n                    // Step 4 and 5\n                    if (serviceConfigError === null) {\n                        // Step 5\n                        this.previousServiceConfig = null;\n                        workingServiceConfig = this.defaultServiceConfig;\n                    } else {\n                        // Step 4\n                        if (this.previousServiceConfig === null) {\n                            // Step 4.ii\n                            this.handleResolutionFailure(serviceConfigError);\n                        } else {\n                            // Step 4.i\n                            workingServiceConfig = this.previousServiceConfig;\n                        }\n                    }\n                } else {\n                    // Step 3\n                    workingServiceConfig = serviceConfig;\n                    this.previousServiceConfig = serviceConfig;\n                }\n                const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n                const loadBalancingConfig = load_balancer_1.getFirstUsableConfig(workingConfigList, true);\n                if (loadBalancingConfig === null) {\n                    // There were load balancing configs but none are supported. This counts as a resolution failure\n                    this.handleResolutionFailure({\n                        code: constants_1.Status.UNAVAILABLE,\n                        details: \"All load balancer options in service config are not compatible\",\n                        metadata: new metadata_1.Metadata()\n                    });\n                    return;\n                }\n                this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n                const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n                this.onSuccessfulResolution(configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n            },\n            onError: (error)=>{\n                this.handleResolutionFailure(error);\n            }\n        }, channelOptions);\n        const backoffOptions = {\n            initialDelay: channelOptions[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: channelOptions[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(()=>{\n            if (this.continueResolving) {\n                this.updateResolution();\n                this.continueResolving = false;\n            } else {\n                this.updateState(this.latestChildState, this.latestChildPicker);\n            }\n        }, backoffOptions);\n        this.backoffTimeout.unref();\n    }\n    updateResolution() {\n        this.innerResolver.updateResolution();\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        this.backoffTimeout.runOnce();\n    }\n    updateState(connectivityState, picker) {\n        trace(uri_parser_1.uriToString(this.target) + \" \" + connectivity_state_1.ConnectivityState[this.currentState] + \" -> \" + connectivity_state_1.ConnectivityState[connectivityState]);\n        // Ensure that this.exitIdle() is called by the picker\n        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n            picker = new picker_1.QueuePicker(this);\n        }\n        this.currentState = connectivityState;\n        this.channelControlHelper.updateState(connectivityState, picker);\n    }\n    handleResolutionFailure(error) {\n        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n            this.onFailedResolution(error);\n        }\n    }\n    exitIdle() {\n        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n            if (this.backoffTimeout.isRunning()) {\n                this.continueResolving = true;\n            } else {\n                this.updateResolution();\n            }\n        }\n        this.childLoadBalancer.exitIdle();\n    }\n    updateAddressList(addressList, lbConfig) {\n        throw new Error(\"updateAddressList not supported on ResolvingLoadBalancer\");\n    }\n    resetBackoff() {\n        this.backoffTimeout.reset();\n        this.childLoadBalancer.resetBackoff();\n    }\n    destroy() {\n        this.childLoadBalancer.destroy();\n        this.innerResolver.destroy();\n        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n    }\n    getTypeName() {\n        return \"resolving_load_balancer\";\n    }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer; //# sourceMappingURL=resolving-load-balancer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUcsa0JBQWtCQyxtQkFBT0EsQ0FBQyxzRkFBaUI7QUFDakQsTUFBTUMsbUJBQW1CRCxtQkFBT0EsQ0FBQyx3RkFBa0I7QUFDbkQsTUFBTUUsdUJBQXVCRixtQkFBT0EsQ0FBQyxnR0FBc0I7QUFDM0QsTUFBTUcsYUFBYUgsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTUksV0FBV0osbUJBQU9BLENBQUMsd0VBQVU7QUFDbkMsTUFBTUssb0JBQW9CTCxtQkFBT0EsQ0FBQywwRkFBbUI7QUFDckQsTUFBTU0sY0FBY04sbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTU8sYUFBYVAsbUJBQU9BLENBQUMsNEVBQVk7QUFDdkMsTUFBTVEsVUFBVVIsbUJBQU9BLENBQUMsMEVBQVc7QUFDbkMsTUFBTVMsY0FBY1QsbUJBQU9BLENBQUMsOEVBQWE7QUFDekMsTUFBTVUsZUFBZVYsbUJBQU9BLENBQUMsZ0ZBQWM7QUFDM0MsTUFBTVcsZ0NBQWdDWCxtQkFBT0EsQ0FBQyxrSEFBK0I7QUFDN0UsTUFBTVksY0FBYztBQUNwQixTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZOLFFBQVFLLEtBQUssQ0FBQ0osWUFBWU0sWUFBWSxDQUFDQyxLQUFLLEVBQUVKLGFBQWFFO0FBQy9EO0FBQ0EsTUFBTUcsNkJBQTZCO0FBQ25DLFNBQVNDLHlCQUF5QkMsYUFBYTtJQUMzQyxPQUFPLFNBQVNDLHNCQUFzQkMsVUFBVSxFQUFFQyxRQUFRO1FBQ3RELElBQUlDLElBQUlDO1FBQ1IsTUFBTUMsWUFBWUosV0FBV0ssS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQyxD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LENBQUNvRCxpQkFBaUIsRUFBRTtZQUNySixJQUFJLElBQUksQ0FBQ2xDLGNBQWMsQ0FBQ0MsU0FBUyxJQUFJO2dCQUNqQyxJQUFJLENBQUNiLGlCQUFpQixHQUFHO1lBQzdCLE9BQ0s7Z0JBQ0QsSUFBSSxDQUFDYyxnQkFBZ0I7WUFDekI7UUFDSjtRQUNBLElBQUksQ0FBQ1AsaUJBQWlCLENBQUN5QyxRQUFRO0lBQ25DO0lBQ0FmLGtCQUFrQlosV0FBVyxFQUFFNEIsUUFBUSxFQUFFO1FBQ3JDLE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBQyxlQUFlO1FBQ1gsSUFBSSxDQUFDdkMsY0FBYyxDQUFDd0MsS0FBSztRQUN6QixJQUFJLENBQUM3QyxpQkFBaUIsQ0FBQzRDLFlBQVk7SUFDdkM7SUFDQUUsVUFBVTtRQUNOLElBQUksQ0FBQzlDLGlCQUFpQixDQUFDOEMsT0FBTztRQUM5QixJQUFJLENBQUNsQyxhQUFhLENBQUNrQyxPQUFPO1FBQzFCLElBQUksQ0FBQy9DLFdBQVcsQ0FBQ3pELHFCQUFxQjZDLGlCQUFpQixDQUFDNEQsUUFBUSxFQUFFLElBQUl2RyxTQUFTZ0csaUJBQWlCO0lBQ3BHO0lBQ0FRLGNBQWM7UUFDVixPQUFPO0lBQ1g7QUFDSjtBQUNBaEgsNkJBQTZCLEdBQUdFLHVCQUNoQyxtREFBbUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvcmVzb2x2aW5nLWxvYWQtYmFsYW5jZXIuanM/NDk3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAxOSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZXNvbHZpbmdMb2FkQmFsYW5jZXIgPSB2b2lkIDA7XG5jb25zdCBsb2FkX2JhbGFuY2VyXzEgPSByZXF1aXJlKFwiLi9sb2FkLWJhbGFuY2VyXCIpO1xuY29uc3Qgc2VydmljZV9jb25maWdfMSA9IHJlcXVpcmUoXCIuL3NlcnZpY2UtY29uZmlnXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCByZXNvbHZlcl8xID0gcmVxdWlyZShcIi4vcmVzb2x2ZXJcIik7XG5jb25zdCBwaWNrZXJfMSA9IHJlcXVpcmUoXCIuL3BpY2tlclwiKTtcbmNvbnN0IGJhY2tvZmZfdGltZW91dF8xID0gcmVxdWlyZShcIi4vYmFja29mZi10aW1lb3V0XCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBtZXRhZGF0YV8xID0gcmVxdWlyZShcIi4vbWV0YWRhdGFcIik7XG5jb25zdCBsb2dnaW5nID0gcmVxdWlyZShcIi4vbG9nZ2luZ1wiKTtcbmNvbnN0IGNvbnN0YW50c18yID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdXJpX3BhcnNlcl8xID0gcmVxdWlyZShcIi4vdXJpLXBhcnNlclwiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vbG9hZC1iYWxhbmNlci1jaGlsZC1oYW5kbGVyXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAncmVzb2x2aW5nX2xvYWRfYmFsYW5jZXInO1xuZnVuY3Rpb24gdHJhY2UodGV4dCkge1xuICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzIuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgdGV4dCk7XG59XG5jb25zdCBERUZBVUxUX0xPQURfQkFMQU5DRVJfTkFNRSA9ICdwaWNrX2ZpcnN0JztcbmZ1bmN0aW9uIGdldERlZmF1bHRDb25maWdTZWxlY3RvcihzZXJ2aWNlQ29uZmlnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlZmF1bHRDb25maWdTZWxlY3RvcihtZXRob2ROYW1lLCBtZXRhZGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBzcGxpdE5hbWUgPSBtZXRob2ROYW1lLnNwbGl0KCcvJykuZmlsdGVyKCh4KSA9PiB4Lmxlbmd0aCA+IDApO1xuICAgICAgICBjb25zdCBzZXJ2aWNlID0gKF9hID0gc3BsaXROYW1lWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgY29uc3QgbWV0aG9kID0gKF9iID0gc3BsaXROYW1lWzFdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgICAgICAgaWYgKHNlcnZpY2VDb25maWcgJiYgc2VydmljZUNvbmZpZy5tZXRob2RDb25maWcpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWV0aG9kQ29uZmlnIG9mIHNlcnZpY2VDb25maWcubWV0aG9kQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1ldGhvZENvbmZpZy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lLnNlcnZpY2UgPT09IHNlcnZpY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChuYW1lLm1ldGhvZCA9PT0gdW5kZWZpbmVkIHx8IG5hbWUubWV0aG9kID09PSBtZXRob2QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZENvbmZpZzogbWV0aG9kQ29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tJbmZvcm1hdGlvbjoge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHluYW1pY0ZpbHRlckZhY3RvcmllczogW11cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1ldGhvZENvbmZpZzogeyBuYW1lOiBbXSB9LFxuICAgICAgICAgICAgcGlja0luZm9ybWF0aW9uOiB7fSxcbiAgICAgICAgICAgIHN0YXR1czogY29uc3RhbnRzXzEuU3RhdHVzLk9LLFxuICAgICAgICAgICAgZHluYW1pY0ZpbHRlckZhY3RvcmllczogW11cbiAgICAgICAgfTtcbiAgICB9O1xufVxuY2xhc3MgUmVzb2x2aW5nTG9hZEJhbGFuY2VyIHtcbiAgICAvKipcbiAgICAgKiBXcmFwcGVyIGNsYXNzIHRoYXQgYmVoYXZlcyBsaWtlIGEgYExvYWRCYWxhbmNlcmAgYW5kIGFsc28gaGFuZGxlcyBuYW1lXG4gICAgICogcmVzb2x1dGlvbiBpbnRlcm5hbGx5LlxuICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIGFkZHJlc3Mgb2YgdGhlIGJhY2tlbmQgdG8gY29ubmVjdCB0by5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbENvbnRyb2xIZWxwZXIgYENoYW5uZWxDb250cm9sSGVscGVyYCBpbnN0YW5jZSBwcm92aWRlZCBieVxuICAgICAqICAgICB0aGlzIGxvYWQgYmFsYW5jZXIncyBvd25lci5cbiAgICAgKiBAcGFyYW0gZGVmYXVsdFNlcnZpY2VDb25maWcgVGhlIGRlZmF1bHQgc2VydmljZSBjb25maWd1cmF0aW9uIHRvIGJlIHVzZWRcbiAgICAgKiAgICAgaWYgbm9uZSBpcyBwcm92aWRlZCBieSB0aGUgbmFtZSByZXNvbHZlci4gQSBgbnVsbGAgdmFsdWUgaW5kaWNhdGVzXG4gICAgICogICAgIHRoYXQgdGhlIGRlZmF1bHQgYmVoYXZpb3Igc2hvdWxkIGJlIHRoZSBkZWZhdWx0IHVuY29uZmlndXJlZCBiZWhhdmlvci5cbiAgICAgKiAgICAgSW4gcHJhY3RpY2UsIHRoYXQgbWVhbnMgdXNpbmcgdGhlIFwicGljayBmaXJzdFwiIGxvYWQgYmFsYW5jZXJcbiAgICAgKiAgICAgaW1wbG1lbnRhdGlvblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgY2hhbm5lbENvbnRyb2xIZWxwZXIsIGNoYW5uZWxPcHRpb25zLCBvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uLCBvbkZhaWxlZFJlc29sdXRpb24pIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuY2hhbm5lbENvbnRyb2xIZWxwZXIgPSBjaGFubmVsQ29udHJvbEhlbHBlcjtcbiAgICAgICAgdGhpcy5jaGFubmVsT3B0aW9ucyA9IGNoYW5uZWxPcHRpb25zO1xuICAgICAgICB0aGlzLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24gPSBvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uO1xuICAgICAgICB0aGlzLm9uRmFpbGVkUmVzb2x1dGlvbiA9IG9uRmFpbGVkUmVzb2x1dGlvbjtcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciA9IG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcmVzb2x2aW5nIGxvYWQgYmFsYW5jZXIncyBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzZXJ2aWNlIGNvbmZpZyBvYmplY3QgZnJvbSB0aGUgbGFzdCBzdWNjZXNzZnVsIHJlc29sdXRpb24sIGlmXG4gICAgICAgICAqIGF2YWlsYWJsZS4gQSB2YWx1ZSBvZiBudWxsIGluZGljYXRlcyB0aGF0IHdlIGhhdmUgbm90IHlldCByZWNlaXZlZCBhIHZhbGlkXG4gICAgICAgICAqIHNlcnZpY2UgY29uZmlnIGZyb20gdGhlIHJlc29sdmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2aW91c1NlcnZpY2VDb25maWcgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgd2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmVzb2x2ZSBhZ2FpbiBhZnRlciB0aGUgYmFja29mZlxuICAgICAgICAgKiB0aW1lciBydW5zIG91dC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udGludWVSZXNvbHZpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNoYW5uZWxPcHRpb25zWydncnBjLnNlcnZpY2VfY29uZmlnJ10pIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWcgPSBzZXJ2aWNlX2NvbmZpZ18xLnZhbGlkYXRlU2VydmljZUNvbmZpZyhKU09OLnBhcnNlKGNoYW5uZWxPcHRpb25zWydncnBjLnNlcnZpY2VfY29uZmlnJ10pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdFNlcnZpY2VDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbG9hZEJhbGFuY2luZ0NvbmZpZzogW10sXG4gICAgICAgICAgICAgICAgbWV0aG9kQ29uZmlnOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFLCBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcykpO1xuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyID0gbmV3IGxvYWRfYmFsYW5jZXJfY2hpbGRfaGFuZGxlcl8xLkNoaWxkTG9hZEJhbGFuY2VySGFuZGxlcih7XG4gICAgICAgICAgICBjcmVhdGVTdWJjaGFubmVsOiBjaGFubmVsQ29udHJvbEhlbHBlci5jcmVhdGVTdWJjaGFubmVsLmJpbmQoY2hhbm5lbENvbnRyb2xIZWxwZXIpLFxuICAgICAgICAgICAgcmVxdWVzdFJlcmVzb2x1dGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8qIElmIHRoZSBiYWNrb2ZmVGltZW91dCBpcyBydW5uaW5nLCB3ZSdyZSBzdGlsbCBiYWNraW5nIG9mZiBmcm9tXG4gICAgICAgICAgICAgICAgICogbWFraW5nIHJlc29sdmUgcmVxdWVzdHMsIHNvIHdlIHNob3VsZG4ndCBtYWtlIGFub3RoZXIgb25lIGhlcmUuXG4gICAgICAgICAgICAgICAgICogSW4gdGhhdCBjYXNlLCB0aGUgYmFja29mZiB0aW1lciBjYWxsYmFjayB3aWxsIGNhbGxcbiAgICAgICAgICAgICAgICAgKiB1cGRhdGVSZXNvbHV0aW9uICovXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmFja29mZlRpbWVvdXQuaXNSdW5uaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlU3RhdGU6IChuZXdTdGF0ZSwgcGlja2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRlc3RDaGlsZFBpY2tlciA9IHBpY2tlcjtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKG5ld1N0YXRlLCBwaWNrZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZENoYW5uZWx6Q2hpbGQ6IGNoYW5uZWxDb250cm9sSGVscGVyLmFkZENoYW5uZWx6Q2hpbGQuYmluZChjaGFubmVsQ29udHJvbEhlbHBlciksXG4gICAgICAgICAgICByZW1vdmVDaGFubmVsekNoaWxkOiBjaGFubmVsQ29udHJvbEhlbHBlci5yZW1vdmVDaGFubmVsekNoaWxkLmJpbmQoY2hhbm5lbENvbnRyb2xIZWxwZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmlubmVyUmVzb2x2ZXIgPSByZXNvbHZlcl8xLmNyZWF0ZVJlc29sdmVyKHRhcmdldCwge1xuICAgICAgICAgICAgb25TdWNjZXNzZnVsUmVzb2x1dGlvbjogKGFkZHJlc3NMaXN0LCBzZXJ2aWNlQ29uZmlnLCBzZXJ2aWNlQ29uZmlnRXJyb3IsIGNvbmZpZ1NlbGVjdG9yLCBhdHRyaWJ1dGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCB3b3JraW5nU2VydmljZUNvbmZpZyA9IG51bGw7XG4gICAgICAgICAgICAgICAgLyogVGhpcyBmaXJzdCBncm91cCBvZiBjb25kaXRpb25hbHMgaW1wbGVtZW50cyB0aGUgYWxnb3JpdGhtIGRlc2NyaWJlZFxuICAgICAgICAgICAgICAgICAqIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9ncnBjL3Byb3Bvc2FsL2Jsb2IvbWFzdGVyL0EyMS1zZXJ2aWNlLWNvbmZpZy1lcnJvci1oYW5kbGluZy5tZFxuICAgICAgICAgICAgICAgICAqIGluIHRoZSBzZWN0aW9uIGNhbGxlZCBcIkJlaGF2aW9yIG9uIHJlY2VpdmluZyBhIG5ldyBnUlBDIENvbmZpZ1wiLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChzZXJ2aWNlQ29uZmlnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNCBhbmQgNVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VydmljZUNvbmZpZ0Vycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdTZXJ2aWNlQ29uZmlnID0gdGhpcy5kZWZhdWx0U2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0ZXAgNFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0LmlpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXNvbHV0aW9uRmFpbHVyZShzZXJ2aWNlQ29uZmlnRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RlcCA0LmlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nU2VydmljZUNvbmZpZyA9IHRoaXMucHJldmlvdXNTZXJ2aWNlQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdGVwIDNcbiAgICAgICAgICAgICAgICAgICAgd29ya2luZ1NlcnZpY2VDb25maWcgPSBzZXJ2aWNlQ29uZmlnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXZpb3VzU2VydmljZUNvbmZpZyA9IHNlcnZpY2VDb25maWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHdvcmtpbmdDb25maWdMaXN0ID0gKF9hID0gd29ya2luZ1NlcnZpY2VDb25maWcgPT09IG51bGwgfHwgd29ya2luZ1NlcnZpY2VDb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdvcmtpbmdTZXJ2aWNlQ29uZmlnLmxvYWRCYWxhbmNpbmdDb25maWcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvYWRCYWxhbmNpbmdDb25maWcgPSBsb2FkX2JhbGFuY2VyXzEuZ2V0Rmlyc3RVc2FibGVDb25maWcod29ya2luZ0NvbmZpZ0xpc3QsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmIChsb2FkQmFsYW5jaW5nQ29uZmlnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIHdlcmUgbG9hZCBiYWxhbmNpbmcgY29uZmlncyBidXQgbm9uZSBhcmUgc3VwcG9ydGVkLiBUaGlzIGNvdW50cyBhcyBhIHJlc29sdXRpb24gZmFpbHVyZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc29sdXRpb25GYWlsdXJlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5VTkFWQUlMQUJMRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdBbGwgbG9hZCBiYWxhbmNlciBvcHRpb25zIGluIHNlcnZpY2UgY29uZmlnIGFyZSBub3QgY29tcGF0aWJsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZExvYWRCYWxhbmNlci51cGRhdGVBZGRyZXNzTGlzdChhZGRyZXNzTGlzdCwgbG9hZEJhbGFuY2luZ0NvbmZpZywgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmluYWxTZXJ2aWNlQ29uZmlnID0gd29ya2luZ1NlcnZpY2VDb25maWcgIT09IG51bGwgJiYgd29ya2luZ1NlcnZpY2VDb25maWcgIT09IHZvaWQgMCA/IHdvcmtpbmdTZXJ2aWNlQ29uZmlnIDogdGhpcy5kZWZhdWx0U2VydmljZUNvbmZpZztcbiAgICAgICAgICAgICAgICB0aGlzLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24oY29uZmlnU2VsZWN0b3IgIT09IG51bGwgJiYgY29uZmlnU2VsZWN0b3IgIT09IHZvaWQgMCA/IGNvbmZpZ1NlbGVjdG9yIDogZ2V0RGVmYXVsdENvbmZpZ1NlbGVjdG9yKGZpbmFsU2VydmljZUNvbmZpZykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzb2x1dGlvbkZhaWx1cmUoZXJyb3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICBjb25zdCBiYWNrb2ZmT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGluaXRpYWxEZWxheTogY2hhbm5lbE9wdGlvbnNbJ2dycGMuaW5pdGlhbF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICAgICAgbWF4RGVsYXk6IGNoYW5uZWxPcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0ID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRpbnVlUmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSh0aGlzLmxhdGVzdENoaWxkU3RhdGUsIHRoaXMubGF0ZXN0Q2hpbGRQaWNrZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBiYWNrb2ZmT3B0aW9ucyk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQudW5yZWYoKTtcbiAgICB9XG4gICAgdXBkYXRlUmVzb2x1dGlvbigpIHtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIG5ldyBwaWNrZXJfMS5RdWV1ZVBpY2tlcih0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5ydW5PbmNlKCk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlKGNvbm5lY3Rpdml0eVN0YXRlLCBwaWNrZXIpIHtcbiAgICAgICAgdHJhY2UodXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMudGFyZ2V0KSArXG4gICAgICAgICAgICAnICcgK1xuICAgICAgICAgICAgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbdGhpcy5jdXJyZW50U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtjb25uZWN0aXZpdHlTdGF0ZV0pO1xuICAgICAgICAvLyBFbnN1cmUgdGhhdCB0aGlzLmV4aXRJZGxlKCkgaXMgY2FsbGVkIGJ5IHRoZSBwaWNrZXJcbiAgICAgICAgaWYgKGNvbm5lY3Rpdml0eVN0YXRlID09PSBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5JRExFKSB7XG4gICAgICAgICAgICBwaWNrZXIgPSBuZXcgcGlja2VyXzEuUXVldWVQaWNrZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBjb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgdGhpcy5jaGFubmVsQ29udHJvbEhlbHBlci51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlTdGF0ZSwgcGlja2VyKTtcbiAgICB9XG4gICAgaGFuZGxlUmVzb2x1dGlvbkZhaWx1cmUoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMubGF0ZXN0Q2hpbGRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKGVycm9yKSk7XG4gICAgICAgICAgICB0aGlzLm9uRmFpbGVkUmVzb2x1dGlvbihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhpdElkbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSB8fCB0aGlzLmN1cnJlbnRTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJhY2tvZmZUaW1lb3V0LmlzUnVubmluZygpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZVJlc29sdmluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVJlc29sdXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLmV4aXRJZGxlKCk7XG4gICAgfVxuICAgIHVwZGF0ZUFkZHJlc3NMaXN0KGFkZHJlc3NMaXN0LCBsYkNvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VwZGF0ZUFkZHJlc3NMaXN0IG5vdCBzdXBwb3J0ZWQgb24gUmVzb2x2aW5nTG9hZEJhbGFuY2VyJyk7XG4gICAgfVxuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLnJlc2V0QmFja29mZigpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmNoaWxkTG9hZEJhbGFuY2VyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5pbm5lclJlc29sdmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZShjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5TSFVURE9XTiwgbmV3IHBpY2tlcl8xLlVuYXZhaWxhYmxlUGlja2VyKCkpO1xuICAgIH1cbiAgICBnZXRUeXBlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdyZXNvbHZpbmdfbG9hZF9iYWxhbmNlcic7XG4gICAgfVxufVxuZXhwb3J0cy5SZXNvbHZpbmdMb2FkQmFsYW5jZXIgPSBSZXNvbHZpbmdMb2FkQmFsYW5jZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZpbmctbG9hZC1iYWxhbmNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZXNvbHZpbmdMb2FkQmFsYW5jZXIiLCJsb2FkX2JhbGFuY2VyXzEiLCJyZXF1aXJlIiwic2VydmljZV9jb25maWdfMSIsImNvbm5lY3Rpdml0eV9zdGF0ZV8xIiwicmVzb2x2ZXJfMSIsInBpY2tlcl8xIiwiYmFja29mZl90aW1lb3V0XzEiLCJjb25zdGFudHNfMSIsIm1ldGFkYXRhXzEiLCJsb2dnaW5nIiwiY29uc3RhbnRzXzIiLCJ1cmlfcGFyc2VyXzEiLCJsb2FkX2JhbGFuY2VyX2NoaWxkX2hhbmRsZXJfMSIsIlRSQUNFUl9OQU1FIiwidHJhY2UiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJERUZBVUxUX0xPQURfQkFMQU5DRVJfTkFNRSIsImdldERlZmF1bHRDb25maWdTZWxlY3RvciIsInNlcnZpY2VDb25maWciLCJkZWZhdWx0Q29uZmlnU2VsZWN0b3IiLCJtZXRob2ROYW1lIiwibWV0YWRhdGEiLCJfYSIsIl9iIiwic3BsaXROYW1lIiwic3BsaXQiLCJmaWx0ZXIiLCJ4IiwibGVuZ3RoIiwic2VydmljZSIsIm1ldGhvZCIsIm1ldGhvZENvbmZpZyIsIm5hbWUiLCJ1bmRlZmluZWQiLCJwaWNrSW5mb3JtYXRpb24iLCJzdGF0dXMiLCJTdGF0dXMiLCJPSyIsImR5bmFtaWNGaWx0ZXJGYWN0b3JpZXMiLCJjb25zdHJ1Y3RvciIsInRhcmdldCIsImNoYW5uZWxDb250cm9sSGVscGVyIiwiY2hhbm5lbE9wdGlvbnMiLCJvblN1Y2Nlc3NmdWxSZXNvbHV0aW9uIiwib25GYWlsZWRSZXNvbHV0aW9uIiwibGF0ZXN0Q2hpbGRTdGF0ZSIsIkNvbm5lY3Rpdml0eVN0YXRlIiwiSURMRSIsImxhdGVzdENoaWxkUGlja2VyIiwiUXVldWVQaWNrZXIiLCJjdXJyZW50U3RhdGUiLCJwcmV2aW91c1NlcnZpY2VDb25maWciLCJjb250aW51ZVJlc29sdmluZyIsImRlZmF1bHRTZXJ2aWNlQ29uZmlnIiwidmFsaWRhdGVTZXJ2aWNlQ29uZmlnIiwiSlNPTiIsInBhcnNlIiwibG9hZEJhbGFuY2luZ0NvbmZpZyIsInVwZGF0ZVN0YXRlIiwiY2hpbGRMb2FkQmFsYW5jZXIiLCJDaGlsZExvYWRCYWxhbmNlckhhbmRsZXIiLCJjcmVhdGVTdWJjaGFubmVsIiwiYmluZCIsInJlcXVlc3RSZXJlc29sdXRpb24iLCJiYWNrb2ZmVGltZW91dCIsImlzUnVubmluZyIsInVwZGF0ZVJlc29sdXRpb24iLCJuZXdTdGF0ZSIsInBpY2tlciIsImFkZENoYW5uZWx6Q2hpbGQiLCJyZW1vdmVDaGFubmVsekNoaWxkIiwiaW5uZXJSZXNvbHZlciIsImNyZWF0ZVJlc29sdmVyIiwiYWRkcmVzc0xpc3QiLCJzZXJ2aWNlQ29uZmlnRXJyb3IiLCJjb25maWdTZWxlY3RvciIsImF0dHJpYnV0ZXMiLCJ3b3JraW5nU2VydmljZUNvbmZpZyIsImhhbmRsZVJlc29sdXRpb25GYWlsdXJlIiwid29ya2luZ0NvbmZpZ0xpc3QiLCJnZXRGaXJzdFVzYWJsZUNvbmZpZyIsImNvZGUiLCJVTkFWQUlMQUJMRSIsImRldGFpbHMiLCJNZXRhZGF0YSIsInVwZGF0ZUFkZHJlc3NMaXN0IiwiZmluYWxTZXJ2aWNlQ29uZmlnIiwib25FcnJvciIsImVycm9yIiwiYmFja29mZk9wdGlvbnMiLCJpbml0aWFsRGVsYXkiLCJtYXhEZWxheSIsIkJhY2tvZmZUaW1lb3V0IiwidW5yZWYiLCJDT05ORUNUSU5HIiwicnVuT25jZSIsImNvbm5lY3Rpdml0eVN0YXRlIiwidXJpVG9TdHJpbmciLCJUUkFOU0lFTlRfRkFJTFVSRSIsIlVuYXZhaWxhYmxlUGlja2VyIiwiZXhpdElkbGUiLCJsYkNvbmZpZyIsIkVycm9yIiwicmVzZXRCYWNrb2ZmIiwicmVzZXQiLCJkZXN0cm95IiwiU0hVVERPV04iLCJnZXRUeXBlTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-call.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst metadata_1 = __webpack_require__(/*! ./metadata */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/metadata.js\");\nconst stream_decoder_1 = __webpack_require__(/*! ./stream-decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst TRACER_NAME = \"server_call\";\nconst unzip = util_1.promisify(zlib.unzip);\nconst inflate = util_1.promisify(zlib.inflate);\nfunction trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = \"grpc-accept-encoding\";\nconst GRPC_ENCODING_HEADER = \"grpc-encoding\";\nconst GRPC_MESSAGE_HEADER = \"grpc-message\";\nconst GRPC_STATUS_HEADER = \"grpc-status\";\nconst GRPC_TIMEOUT_HEADER = \"grpc-timeout\";\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n    H: 3600000,\n    M: 60000,\n    S: 1000,\n    m: 1,\n    u: 0.001,\n    n: 0.000001\n};\nconst defaultResponseHeaders = {\n    // TODO(cjihrig): Remove these encoding headers from the default response\n    // once compression is integrated.\n    [GRPC_ACCEPT_ENCODING_HEADER]: \"identity,deflate,gzip\",\n    [GRPC_ENCODING_HEADER]: \"identity\",\n    [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n    [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: \"application/grpc+proto\"\n};\nconst defaultResponseOptions = {\n    waitForTrailers: true\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n    constructor(call, metadata, request){\n        super();\n        this.call = call;\n        this.metadata = metadata;\n        this.request = request;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n    constructor(call, metadata, deserialize, encoding){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n    }\n    _read(size) {\n        if (!this.call.consumeUnpushedMessages(this)) {\n            return;\n        }\n        this.call.resume();\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n    constructor(call, metadata, serialize, request){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.request = request;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.on(\"error\", (err)=>{\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    _write(chunk, encoding, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback) {\n        try {\n            const response = this.call.serializeMessage(chunk);\n            if (!this.call.write(response)) {\n                this.call.once(\"drain\", callback);\n                return;\n            }\n        } catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.emit(\"error\", err);\n        }\n        callback();\n    }\n    _final(callback) {\n        this.call.sendStatus({\n            code: constants_1.Status.OK,\n            details: \"OK\",\n            metadata: this.trailingMetadata\n        });\n        callback(null);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n    constructor(call, metadata, serialize, deserialize, encoding){\n        super({\n            objectMode: true\n        });\n        this.call = call;\n        this.metadata = metadata;\n        this.serialize = serialize;\n        this.deserialize = deserialize;\n        this.cancelled = false;\n        this.trailingMetadata = new metadata_1.Metadata();\n        this.call.setupSurfaceCall(this);\n        this.call.setupReadable(this, encoding);\n        this.on(\"error\", (err)=>{\n            this.call.sendError(err);\n            this.end();\n        });\n    }\n    getPeer() {\n        return this.call.getPeer();\n    }\n    sendMetadata(responseMetadata) {\n        this.call.sendMetadata(responseMetadata);\n    }\n    getDeadline() {\n        return this.call.getDeadline();\n    }\n    getPath() {\n        return this.call.getPath();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    end(metadata) {\n        if (metadata) {\n            this.trailingMetadata = metadata;\n        }\n        return super.end();\n    }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n    constructor(stream, handler, options){\n        super();\n        this.stream = stream;\n        this.handler = handler;\n        this.options = options;\n        this.cancelled = false;\n        this.deadlineTimer = null;\n        this.statusSent = false;\n        this.deadline = Infinity;\n        this.wantTrailers = false;\n        this.metadataSent = false;\n        this.canPush = false;\n        this.isPushPending = false;\n        this.bufferedMessages = [];\n        this.messagesToPush = [];\n        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n        this.stream.once(\"error\", (err)=>{\n        /* We need an error handler to avoid uncaught error event exceptions, but\n             * there is nothing we can reasonably do here. Any error event should\n             * have a corresponding close event, which handles emitting the cancelled\n             * event. And the stream is now in a bad state, so we can't reasonably\n             * expect to be able to send an error over it. */ });\n        this.stream.once(\"close\", ()=>{\n            var _a;\n            trace(\"Request to method \" + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + \" stream closed with rstCode \" + this.stream.rstCode);\n            if (!this.statusSent) {\n                this.cancelled = true;\n                this.emit(\"cancelled\", \"cancelled\");\n                this.emit(\"streamEnd\", false);\n                this.sendStatus({\n                    code: constants_1.Status.CANCELLED,\n                    details: \"Cancelled by client\",\n                    metadata: null\n                });\n            }\n        });\n        this.stream.on(\"drain\", ()=>{\n            this.emit(\"drain\");\n        });\n        if (\"grpc.max_send_message_length\" in options) {\n            this.maxSendMessageSize = options[\"grpc.max_send_message_length\"];\n        }\n        if (\"grpc.max_receive_message_length\" in options) {\n            this.maxReceiveMessageSize = options[\"grpc.max_receive_message_length\"];\n        }\n    }\n    checkCancelled() {\n        /* In some cases the stream can become destroyed before the close event\n         * fires. That creates a race condition that this check works around */ if (this.stream.destroyed || this.stream.closed) {\n            this.cancelled = true;\n        }\n        return this.cancelled;\n    }\n    getDecompressedMessage(message, encoding) {\n        if (encoding === \"deflate\") {\n            return inflate(message.subarray(5));\n        } else if (encoding === \"gzip\") {\n            return unzip(message.subarray(5));\n        } else if (encoding === \"identity\") {\n            return message.subarray(5);\n        }\n        return Promise.reject({\n            code: constants_1.Status.UNIMPLEMENTED,\n            details: `Received message compressed with unsupported encoding \"${encoding}\"`\n        });\n    }\n    sendMetadata(customMetadata) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.metadataSent) {\n            return;\n        }\n        this.metadataSent = true;\n        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n        // TODO(cjihrig): Include compression headers.\n        const headers = Object.assign(Object.assign({}, defaultResponseHeaders), custom);\n        this.stream.respond(headers, defaultResponseOptions);\n    }\n    receiveMetadata(headers) {\n        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            trace(\"Request to \" + this.handler.path + \" received headers \" + JSON.stringify(metadata.toJSON()));\n        }\n        // TODO(cjihrig): Receive compression metadata.\n        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n        if (timeoutHeader.length > 0) {\n            const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n            if (match === null) {\n                const err = new Error(\"Invalid deadline\");\n                err.code = constants_1.Status.OUT_OF_RANGE;\n                this.sendError(err);\n                return metadata;\n            }\n            const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n            const now = new Date();\n            this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n            this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n            metadata.remove(GRPC_TIMEOUT_HEADER);\n        }\n        // Remove several headers that should not be propagated to the application\n        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n        metadata.remove(http2.constants.HTTP2_HEADER_TE);\n        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n        metadata.remove(\"grpc-accept-encoding\");\n        return metadata;\n    }\n    receiveUnaryMessage(encoding, next) {\n        const { stream } = this;\n        let receivedLength = 0;\n        const call = this;\n        const body = [];\n        const limit = this.maxReceiveMessageSize;\n        stream.on(\"data\", onData);\n        stream.on(\"end\", onEnd);\n        stream.on(\"error\", onEnd);\n        function onData(chunk) {\n            receivedLength += chunk.byteLength;\n            if (limit !== -1 && receivedLength > limit) {\n                stream.removeListener(\"data\", onData);\n                stream.removeListener(\"end\", onEnd);\n                stream.removeListener(\"error\", onEnd);\n                next({\n                    code: constants_1.Status.RESOURCE_EXHAUSTED,\n                    details: `Received message larger than max (${receivedLength} vs. ${limit})`\n                });\n                return;\n            }\n            body.push(chunk);\n        }\n        function onEnd(err) {\n            stream.removeListener(\"data\", onData);\n            stream.removeListener(\"end\", onEnd);\n            stream.removeListener(\"error\", onEnd);\n            if (err !== undefined) {\n                next({\n                    code: constants_1.Status.INTERNAL,\n                    details: err.message\n                });\n                return;\n            }\n            if (receivedLength === 0) {\n                next({\n                    code: constants_1.Status.INTERNAL,\n                    details: \"received empty unary message\"\n                });\n                return;\n            }\n            call.emit(\"receiveMessage\");\n            const requestBytes = Buffer.concat(body, receivedLength);\n            const compressed = requestBytes.readUInt8(0) === 1;\n            const compressedMessageEncoding = compressed ? encoding : \"identity\";\n            const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n            if (Buffer.isBuffer(decompressedMessage)) {\n                call.safeDeserializeMessage(decompressedMessage, next);\n                return;\n            }\n            decompressedMessage.then((decompressed)=>call.safeDeserializeMessage(decompressed, next), (err)=>next(err.code ? err : {\n                    code: constants_1.Status.INTERNAL,\n                    details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`\n                }));\n        }\n    }\n    safeDeserializeMessage(buffer, next) {\n        try {\n            next(null, this.deserializeMessage(buffer));\n        } catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            next(err);\n        }\n    }\n    serializeMessage(value) {\n        const messageBuffer = this.handler.serialize(value);\n        // TODO(cjihrig): Call compression aware serializeMessage().\n        const byteLength = messageBuffer.byteLength;\n        const output = Buffer.allocUnsafe(byteLength + 5);\n        output.writeUInt8(0, 0);\n        output.writeUInt32BE(byteLength, 1);\n        messageBuffer.copy(output, 5);\n        return output;\n    }\n    deserializeMessage(bytes) {\n        return this.handler.deserialize(bytes);\n    }\n    async sendUnaryMessage(err, value, metadata, flags) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (metadata === undefined) {\n            metadata = null;\n        }\n        if (err) {\n            if (!Object.prototype.hasOwnProperty.call(err, \"metadata\") && metadata) {\n                err.metadata = metadata;\n            }\n            this.sendError(err);\n            return;\n        }\n        try {\n            const response = this.serializeMessage(value);\n            this.write(response);\n            this.sendStatus({\n                code: constants_1.Status.OK,\n                details: \"OK\",\n                metadata\n            });\n        } catch (err) {\n            err.code = constants_1.Status.INTERNAL;\n            this.sendError(err);\n        }\n    }\n    sendStatus(statusObj) {\n        var _a;\n        this.emit(\"callEnd\", statusObj.code);\n        this.emit(\"streamEnd\", statusObj.code === constants_1.Status.OK);\n        if (this.checkCancelled()) {\n            return;\n        }\n        trace(\"Request to method \" + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + \" ended with status code: \" + constants_1.Status[statusObj.code] + \" details: \" + statusObj.details);\n        if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n        if (!this.wantTrailers) {\n            this.wantTrailers = true;\n            this.stream.once(\"wantTrailers\", ()=>{\n                var _a;\n                const trailersToSend = Object.assign({\n                    [GRPC_STATUS_HEADER]: statusObj.code,\n                    [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n                }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n                this.stream.sendTrailers(trailersToSend);\n                this.statusSent = true;\n            });\n            this.sendMetadata();\n            this.stream.end();\n        }\n    }\n    sendError(error) {\n        const status = {\n            code: constants_1.Status.UNKNOWN,\n            details: \"message\" in error ? error.message : \"Unknown Error\",\n            metadata: \"metadata\" in error && error.metadata !== undefined ? error.metadata : null\n        };\n        if (\"code\" in error && typeof error.code === \"number\" && Number.isInteger(error.code)) {\n            status.code = error.code;\n            if (\"details\" in error && typeof error.details === \"string\") {\n                status.details = error.details;\n            }\n        }\n        this.sendStatus(status);\n    }\n    write(chunk) {\n        if (this.checkCancelled()) {\n            return;\n        }\n        if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n            this.sendError({\n                code: constants_1.Status.RESOURCE_EXHAUSTED,\n                details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n            });\n            return;\n        }\n        this.sendMetadata();\n        this.emit(\"sendMessage\");\n        return this.stream.write(chunk);\n    }\n    resume() {\n        this.stream.resume();\n    }\n    setupSurfaceCall(call) {\n        this.once(\"cancelled\", (reason)=>{\n            call.cancelled = true;\n            call.emit(\"cancelled\", reason);\n        });\n        this.once(\"callEnd\", (status)=>call.emit(\"callEnd\", status));\n    }\n    setupReadable(readable, encoding) {\n        const decoder = new stream_decoder_1.StreamDecoder();\n        let readsDone = false;\n        let pendingMessageProcessing = false;\n        let pushedEnd = false;\n        const maybePushEnd = ()=>{\n            if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n                pushedEnd = true;\n                this.pushOrBufferMessage(readable, null);\n            }\n        };\n        this.stream.on(\"data\", async (data)=>{\n            const messages = decoder.write(data);\n            pendingMessageProcessing = true;\n            this.stream.pause();\n            for (const message of messages){\n                if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {\n                    this.sendError({\n                        code: constants_1.Status.RESOURCE_EXHAUSTED,\n                        details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`\n                    });\n                    return;\n                }\n                this.emit(\"receiveMessage\");\n                const compressed = message.readUInt8(0) === 1;\n                const compressedMessageEncoding = compressed ? encoding : \"identity\";\n                const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n                // Encountered an error with decompression; it'll already have been propogated back\n                // Just return early\n                if (!decompressedMessage) return;\n                this.pushOrBufferMessage(readable, decompressedMessage);\n            }\n            pendingMessageProcessing = false;\n            this.stream.resume();\n            maybePushEnd();\n        });\n        this.stream.once(\"end\", ()=>{\n            readsDone = true;\n            maybePushEnd();\n        });\n    }\n    consumeUnpushedMessages(readable) {\n        this.canPush = true;\n        while(this.messagesToPush.length > 0){\n            const nextMessage = this.messagesToPush.shift();\n            const canPush = readable.push(nextMessage);\n            if (nextMessage === null || canPush === false) {\n                this.canPush = false;\n                break;\n            }\n        }\n        return this.canPush;\n    }\n    pushOrBufferMessage(readable, messageBytes) {\n        if (this.isPushPending) {\n            this.bufferedMessages.push(messageBytes);\n        } else {\n            this.pushMessage(readable, messageBytes);\n        }\n    }\n    async pushMessage(readable, messageBytes) {\n        if (messageBytes === null) {\n            trace(\"Received end of stream\");\n            if (this.canPush) {\n                readable.push(null);\n            } else {\n                this.messagesToPush.push(null);\n            }\n            return;\n        }\n        trace(\"Received message of length \" + messageBytes.length);\n        this.isPushPending = true;\n        try {\n            const deserialized = await this.deserializeMessage(messageBytes);\n            if (this.canPush) {\n                if (!readable.push(deserialized)) {\n                    this.canPush = false;\n                    this.stream.pause();\n                }\n            } else {\n                this.messagesToPush.push(deserialized);\n            }\n        } catch (error) {\n            // Ignore any remaining messages when errors occur.\n            this.bufferedMessages.length = 0;\n            if (!(\"code\" in error && typeof error.code === \"number\" && Number.isInteger(error.code) && error.code >= constants_1.Status.OK && error.code <= constants_1.Status.UNAUTHENTICATED)) {\n                // The error code is not a valid gRPC code so its being overwritten.\n                error.code = constants_1.Status.INTERNAL;\n            }\n            readable.emit(\"error\", error);\n        }\n        this.isPushPending = false;\n        if (this.bufferedMessages.length > 0) {\n            this.pushMessage(readable, this.bufferedMessages.shift());\n        }\n    }\n    getPeer() {\n        const socket = this.stream.session.socket;\n        if (socket.remoteAddress) {\n            if (socket.remotePort) {\n                return `${socket.remoteAddress}:${socket.remotePort}`;\n            } else {\n                return socket.remoteAddress;\n            }\n        } else {\n            return \"unknown\";\n        }\n    }\n    getDeadline() {\n        return this.deadline;\n    }\n    getPath() {\n        return this.handler.path;\n    }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n    const err = new Error(\"Deadline exceeded\");\n    err.code = constants_1.Status.DEADLINE_EXCEEDED;\n    call.sendError(err);\n    call.cancelled = true;\n    call.emit(\"cancelled\", \"deadline\");\n} //# sourceMappingURL=server-call.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNhbGwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHQSw4QkFBOEIsR0FBR0EsZ0NBQWdDLEdBQUdBLGdDQUFnQyxHQUFHQSwyQkFBMkIsR0FBRyxLQUFLO0FBQzFLLE1BQU1PLFdBQVdDLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1DLFFBQVFELG1CQUFPQSxDQUFDLG9CQUFPO0FBQzdCLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHNCQUFRO0FBQ2pDLE1BQU1HLE9BQU9ILG1CQUFPQSxDQUFDLGtCQUFNO0FBQzNCLE1BQU1JLFNBQVNKLG1CQUFPQSxDQUFDLGtCQUFNO0FBQzdCLE1BQU1LLGNBQWNMLG1CQUFPQSxDQUFDLDhFQUFhO0FBQ3pDLE1BQU1NLGFBQWFOLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1PLG1CQUFtQlAsbUJBQU9BLENBQUMsd0ZBQWtCO0FBQ25ELE1BQU1RLFVBQVVSLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1TLGNBQWM7QUFDcEIsTUFBTUMsUUFBUU4sT0FBT08sU0FBUyxDQUFDUixLQUFLTyxLQUFLO0FBQ3pDLE1BQU1FLFVBQVVSLE9BQU9PLFNBQVMsQ0FBQ1IsS0FBS1MsT0FBTztBQUM3QyxTQUFTQyxNQUFNQyxJQUFJO0lBQ2ZOLFFBQVFLLEtBQUssQ0FBQ1IsWUFBWVUsWUFBWSxDQUFDQyxLQUFLLEVBQUVQLGFBQWFLO0FBQy9EO0FBQ0EsTUFBTUcsOEJBQThCO0FBQ3BDLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsb0JBQW9CO0lBQ3RCQyxH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LENBQUMxSCxNQUFNLENBQUMySCxPQUFPLENBQUNELE1BQU07UUFDekMsSUFBSUEsT0FBT0UsYUFBYSxFQUFFO1lBQ3RCLElBQUlGLE9BQU9HLFVBQVUsRUFBRTtnQkFDbkIsT0FBTyxDQUFDLEVBQUVILE9BQU9FLGFBQWEsQ0FBQyxDQUFDLEVBQUVGLE9BQU9HLFVBQVUsQ0FBQyxDQUFDO1lBQ3pELE9BQ0s7Z0JBQ0QsT0FBT0gsT0FBT0UsYUFBYTtZQUMvQjtRQUNKLE9BQ0s7WUFDRCxPQUFPO1FBQ1g7SUFDSjtJQUNBaEssY0FBYztRQUNWLE9BQU8sSUFBSSxDQUFDeUMsUUFBUTtJQUN4QjtJQUNBeEMsVUFBVTtRQUNOLE9BQU8sSUFBSSxDQUFDb0MsT0FBTyxDQUFDaUIsSUFBSTtJQUM1QjtBQUNKO0FBQ0E3Ryw2QkFBNkIsR0FBR0U7QUFDaEMsU0FBU2dKLHNCQUFzQm5HLElBQUk7SUFDL0IsTUFBTXdCLE1BQU0sSUFBSW1FLE1BQU07SUFDdEJuRSxJQUFJVSxJQUFJLEdBQUdwRSxZQUFZcUUsTUFBTSxDQUFDdUksaUJBQWlCO0lBQy9DMUssS0FBS3lCLFNBQVMsQ0FBQ0Q7SUFDZnhCLEtBQUtHLFNBQVMsR0FBRztJQUNqQkgsS0FBS3FDLElBQUksQ0FBQyxhQUFhO0FBQzNCLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZlci1jYWxsLmpzPzcyM2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtID0gZXhwb3J0cy5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsID0gZXhwb3J0cy5TZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwgPSBleHBvcnRzLlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCA9IGV4cG9ydHMuU2VydmVyVW5hcnlDYWxsSW1wbCA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IG1ldGFkYXRhXzEgPSByZXF1aXJlKFwiLi9tZXRhZGF0YVwiKTtcbmNvbnN0IHN0cmVhbV9kZWNvZGVyXzEgPSByZXF1aXJlKFwiLi9zdHJlYW0tZGVjb2RlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc2VydmVyX2NhbGwnO1xuY29uc3QgdW56aXAgPSB1dGlsXzEucHJvbWlzaWZ5KHpsaWIudW56aXApO1xuY29uc3QgaW5mbGF0ZSA9IHV0aWxfMS5wcm9taXNpZnkoemxpYi5pbmZsYXRlKTtcbmZ1bmN0aW9uIHRyYWNlKHRleHQpIHtcbiAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsIHRleHQpO1xufVxuY29uc3QgR1JQQ19BQ0NFUFRfRU5DT0RJTkdfSEVBREVSID0gJ2dycGMtYWNjZXB0LWVuY29kaW5nJztcbmNvbnN0IEdSUENfRU5DT0RJTkdfSEVBREVSID0gJ2dycGMtZW5jb2RpbmcnO1xuY29uc3QgR1JQQ19NRVNTQUdFX0hFQURFUiA9ICdncnBjLW1lc3NhZ2UnO1xuY29uc3QgR1JQQ19TVEFUVVNfSEVBREVSID0gJ2dycGMtc3RhdHVzJztcbmNvbnN0IEdSUENfVElNRU9VVF9IRUFERVIgPSAnZ3JwYy10aW1lb3V0JztcbmNvbnN0IERFQURMSU5FX1JFR0VYID0gLyhcXGR7MSw4fSlcXHMqKFtITVNtdW5dKS87XG5jb25zdCBkZWFkbGluZVVuaXRzVG9NcyA9IHtcbiAgICBIOiAzNjAwMDAwLFxuICAgIE06IDYwMDAwLFxuICAgIFM6IDEwMDAsXG4gICAgbTogMSxcbiAgICB1OiAwLjAwMSxcbiAgICBuOiAwLjAwMDAwMSxcbn07XG5jb25zdCBkZWZhdWx0UmVzcG9uc2VIZWFkZXJzID0ge1xuICAgIC8vIFRPRE8oY2ppaHJpZyk6IFJlbW92ZSB0aGVzZSBlbmNvZGluZyBoZWFkZXJzIGZyb20gdGhlIGRlZmF1bHQgcmVzcG9uc2VcbiAgICAvLyBvbmNlIGNvbXByZXNzaW9uIGlzIGludGVncmF0ZWQuXG4gICAgW0dSUENfQUNDRVBUX0VOQ09ESU5HX0hFQURFUl06ICdpZGVudGl0eSxkZWZsYXRlLGd6aXAnLFxuICAgIFtHUlBDX0VOQ09ESU5HX0hFQURFUl06ICdpZGVudGl0eScsXG4gICAgW2h0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfU1RBVFVTXTogaHR0cDIuY29uc3RhbnRzLkhUVFBfU1RBVFVTX09LLFxuICAgIFtodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRV06ICdhcHBsaWNhdGlvbi9ncnBjK3Byb3RvJyxcbn07XG5jb25zdCBkZWZhdWx0UmVzcG9uc2VPcHRpb25zID0ge1xuICAgIHdhaXRGb3JUcmFpbGVyczogdHJ1ZSxcbn07XG5jbGFzcyBTZXJ2ZXJVbmFyeUNhbGxJbXBsIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBtZXRhZGF0YSwgcmVxdWVzdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhbGwgPSBjYWxsO1xuICAgICAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FsbC5zZXR1cFN1cmZhY2VDYWxsKHRoaXMpO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQYXRoKCk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXJVbmFyeUNhbGxJbXBsID0gU2VydmVyVW5hcnlDYWxsSW1wbDtcbmNsYXNzIFNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLlJlYWRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBtZXRhZGF0YSwgZGVzZXJpYWxpemUsIGVuY29kaW5nKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2FsbC5zZXR1cFN1cmZhY2VDYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBSZWFkYWJsZSh0aGlzLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIF9yZWFkKHNpemUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhbGwuY29uc3VtZVVucHVzaGVkTWVzc2FnZXModGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGwucmVzdW1lKCk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBhdGgoKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCA9IFNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbDtcbmNsYXNzIFNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLldyaXRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihjYWxsLCBtZXRhZGF0YSwgc2VyaWFsaXplLCByZXF1ZXN0KSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbmV3IG1ldGFkYXRhXzEuTWV0YWRhdGEoKTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwU3VyZmFjZUNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMub24oJ2Vycm9yJywgKGVycikgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBlZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0UGVlcigpO1xuICAgIH1cbiAgICBzZW5kTWV0YWRhdGEocmVzcG9uc2VNZXRhZGF0YSkge1xuICAgICAgICB0aGlzLmNhbGwuc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpO1xuICAgIH1cbiAgICBnZXREZWFkbGluZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXREZWFkbGluZSgpO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBhdGgoKTtcbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjYWxsYmFjaykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLmNhbGwuc2VyaWFsaXplTWVzc2FnZShjaHVuayk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FsbC53cml0ZShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGwub25jZSgnZHJhaW4nLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVyci5jb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgX2ZpbmFsKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuY2FsbC5zZW5kU3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5PSyxcbiAgICAgICAgICAgIGRldGFpbHM6ICdPSycsXG4gICAgICAgICAgICBtZXRhZGF0YTogdGhpcy50cmFpbGluZ01ldGFkYXRhLFxuICAgICAgICB9KTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZW5kKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsID0gU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsO1xuY2xhc3MgU2VydmVyRHVwbGV4U3RyZWFtSW1wbCBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3IoY2FsbCwgbWV0YWRhdGEsIHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGVuY29kaW5nKSB7XG4gICAgICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5jYWxsID0gY2FsbDtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYWlsaW5nTWV0YWRhdGEgPSBuZXcgbWV0YWRhdGFfMS5NZXRhZGF0YSgpO1xuICAgICAgICB0aGlzLmNhbGwuc2V0dXBTdXJmYWNlQ2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYWxsLnNldHVwUmVhZGFibGUodGhpcywgZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2FsbC5zZW5kRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxsLmdldFBlZXIoKTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKHJlc3BvbnNlTWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5jYWxsLnNlbmRNZXRhZGF0YShyZXNwb25zZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGwuZ2V0RGVhZGxpbmUoKTtcbiAgICB9XG4gICAgZ2V0UGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsbC5nZXRQYXRoKCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZW5kKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmIChtZXRhZGF0YSkge1xuICAgICAgICAgICAgdGhpcy50cmFpbGluZ01ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuZCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyRHVwbGV4U3RyZWFtSW1wbCA9IFNlcnZlckR1cGxleFN0cmVhbUltcGw7XG5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsLnByb3RvdHlwZS5fcmVhZCA9XG4gICAgU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsLnByb3RvdHlwZS5fcmVhZDtcblNlcnZlckR1cGxleFN0cmVhbUltcGwucHJvdG90eXBlLl93cml0ZSA9XG4gICAgU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsLnByb3RvdHlwZS5fd3JpdGU7XG5TZXJ2ZXJEdXBsZXhTdHJlYW1JbXBsLnByb3RvdHlwZS5fZmluYWwgPVxuICAgIFNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbC5wcm90b3R5cGUuX2ZpbmFsO1xuLy8gSW50ZXJuYWwgY2xhc3MgdGhhdCB3cmFwcyB0aGUgSFRUUDIgcmVxdWVzdC5cbmNsYXNzIEh0dHAyU2VydmVyQ2FsbFN0cmVhbSBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Ioc3RyZWFtLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlYWRsaW5lVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1c1NlbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWFkbGluZSA9IEluZmluaXR5O1xuICAgICAgICB0aGlzLndhbnRUcmFpbGVycyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1ldGFkYXRhU2VudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyZWRNZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLm1lc3NhZ2VzVG9QdXNoID0gW107XG4gICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gY29uc3RhbnRzXzEuREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSDtcbiAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPSBjb25zdGFudHNfMS5ERUZBVUxUX01BWF9SRUNFSVZFX01FU1NBR0VfTEVOR1RIO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAgICAgICAgIC8qIFdlIG5lZWQgYW4gZXJyb3IgaGFuZGxlciB0byBhdm9pZCB1bmNhdWdodCBlcnJvciBldmVudCBleGNlcHRpb25zLCBidXRcbiAgICAgICAgICAgICAqIHRoZXJlIGlzIG5vdGhpbmcgd2UgY2FuIHJlYXNvbmFibHkgZG8gaGVyZS4gQW55IGVycm9yIGV2ZW50IHNob3VsZFxuICAgICAgICAgICAgICogaGF2ZSBhIGNvcnJlc3BvbmRpbmcgY2xvc2UgZXZlbnQsIHdoaWNoIGhhbmRsZXMgZW1pdHRpbmcgdGhlIGNhbmNlbGxlZFxuICAgICAgICAgICAgICogZXZlbnQuIEFuZCB0aGUgc3RyZWFtIGlzIG5vdyBpbiBhIGJhZCBzdGF0ZSwgc28gd2UgY2FuJ3QgcmVhc29uYWJseVxuICAgICAgICAgICAgICogZXhwZWN0IHRvIGJlIGFibGUgdG8gc2VuZCBhbiBlcnJvciBvdmVyIGl0LiAqL1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byBtZXRob2QgJyArICgoX2EgPSB0aGlzLmhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSArXG4gICAgICAgICAgICAgICAgJyBzdHJlYW0gY2xvc2VkIHdpdGggcnN0Q29kZSAnICtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5yc3RDb2RlKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGF0dXNTZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnY2FuY2VsbGVkJywgJ2NhbmNlbGxlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RyZWFtRW5kJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFN0YXR1cyh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5DQU5DRUxMRUQsXG4gICAgICAgICAgICAgICAgICAgIGRldGFpbHM6ICdDYW5jZWxsZWQgYnkgY2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnN0cmVhbS5vbignZHJhaW4nLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoJ2dycGMubWF4X3NlbmRfbWVzc2FnZV9sZW5ndGgnIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMubWF4U2VuZE1lc3NhZ2VTaXplID0gb3B0aW9uc1snZ3JwYy5tYXhfc2VuZF9tZXNzYWdlX2xlbmd0aCddO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnZ3JwYy5tYXhfcmVjZWl2ZV9tZXNzYWdlX2xlbmd0aCcgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5tYXhSZWNlaXZlTWVzc2FnZVNpemUgPSBvcHRpb25zWydncnBjLm1heF9yZWNlaXZlX21lc3NhZ2VfbGVuZ3RoJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tDYW5jZWxsZWQoKSB7XG4gICAgICAgIC8qIEluIHNvbWUgY2FzZXMgdGhlIHN0cmVhbSBjYW4gYmVjb21lIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNsb3NlIGV2ZW50XG4gICAgICAgICAqIGZpcmVzLiBUaGF0IGNyZWF0ZXMgYSByYWNlIGNvbmRpdGlvbiB0aGF0IHRoaXMgY2hlY2sgd29ya3MgYXJvdW5kICovXG4gICAgICAgIGlmICh0aGlzLnN0cmVhbS5kZXN0cm95ZWQgfHwgdGhpcy5zdHJlYW0uY2xvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY2FuY2VsbGVkO1xuICAgIH1cbiAgICBnZXREZWNvbXByZXNzZWRNZXNzYWdlKG1lc3NhZ2UsIGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2RlZmxhdGUnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5mbGF0ZShtZXNzYWdlLnN1YmFycmF5KDUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbmNvZGluZyA9PT0gJ2d6aXAnKSB7XG4gICAgICAgICAgICByZXR1cm4gdW56aXAobWVzc2FnZS5zdWJhcnJheSg1KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW5jb2RpbmcgPT09ICdpZGVudGl0eScpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlLnN1YmFycmF5KDUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh7XG4gICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgIGRldGFpbHM6IGBSZWNlaXZlZCBtZXNzYWdlIGNvbXByZXNzZWQgd2l0aCB1bnN1cHBvcnRlZCBlbmNvZGluZyBcIiR7ZW5jb2Rpbmd9XCJgLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZE1ldGFkYXRhKGN1c3RvbU1ldGFkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YVNlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1ldGFkYXRhU2VudCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGN1c3RvbSA9IGN1c3RvbU1ldGFkYXRhID8gY3VzdG9tTWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKSA6IG51bGw7XG4gICAgICAgIC8vIFRPRE8oY2ppaHJpZyk6IEluY2x1ZGUgY29tcHJlc3Npb24gaGVhZGVycy5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFJlc3BvbnNlSGVhZGVycyksIGN1c3RvbSk7XG4gICAgICAgIHRoaXMuc3RyZWFtLnJlc3BvbmQoaGVhZGVycywgZGVmYXVsdFJlc3BvbnNlT3B0aW9ucyk7XG4gICAgfVxuICAgIHJlY2VpdmVNZXRhZGF0YShoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gbWV0YWRhdGFfMS5NZXRhZGF0YS5mcm9tSHR0cDJIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICBpZiAobG9nZ2luZy5pc1RyYWNlckVuYWJsZWQoVFJBQ0VSX05BTUUpKSB7XG4gICAgICAgICAgICB0cmFjZSgnUmVxdWVzdCB0byAnICtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXIucGF0aCArXG4gICAgICAgICAgICAgICAgJyByZWNlaXZlZCBoZWFkZXJzICcgK1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhLnRvSlNPTigpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhjamlocmlnKTogUmVjZWl2ZSBjb21wcmVzc2lvbiBtZXRhZGF0YS5cbiAgICAgICAgY29uc3QgdGltZW91dEhlYWRlciA9IG1ldGFkYXRhLmdldChHUlBDX1RJTUVPVVRfSEVBREVSKTtcbiAgICAgICAgaWYgKHRpbWVvdXRIZWFkZXIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB0aW1lb3V0SGVhZGVyWzBdLnRvU3RyaW5nKCkubWF0Y2goREVBRExJTkVfUkVHRVgpO1xuICAgICAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJbnZhbGlkIGRlYWRsaW5lJyk7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuT1VUX09GX1JBTkdFO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZEVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9ICgrbWF0Y2hbMV0gKiBkZWFkbGluZVVuaXRzVG9Nc1ttYXRjaFsyXV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB0aGlzLmRlYWRsaW5lID0gbm93LnNldE1pbGxpc2Vjb25kcyhub3cuZ2V0TWlsbGlzZWNvbmRzKCkgKyB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuZGVhZGxpbmVUaW1lciA9IHNldFRpbWVvdXQoaGFuZGxlRXhwaXJlZERlYWRsaW5lLCB0aW1lb3V0LCB0aGlzKTtcbiAgICAgICAgICAgIG1ldGFkYXRhLnJlbW92ZShHUlBDX1RJTUVPVVRfSEVBREVSKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgc2V2ZXJhbCBoZWFkZXJzIHRoYXQgc2hvdWxkIG5vdCBiZSBwcm9wYWdhdGVkIHRvIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9BQ0NFUFRfRU5DT0RJTkcpO1xuICAgICAgICBtZXRhZGF0YS5yZW1vdmUoaHR0cDIuY29uc3RhbnRzLkhUVFAyX0hFQURFUl9URSk7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZShodHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRSk7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1hY2NlcHQtZW5jb2RpbmcnKTtcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhO1xuICAgIH1cbiAgICByZWNlaXZlVW5hcnlNZXNzYWdlKGVuY29kaW5nLCBuZXh0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtIH0gPSB0aGlzO1xuICAgICAgICBsZXQgcmVjZWl2ZWRMZW5ndGggPSAwO1xuICAgICAgICBjb25zdCBjYWxsID0gdGhpcztcbiAgICAgICAgY29uc3QgYm9keSA9IFtdO1xuICAgICAgICBjb25zdCBsaW1pdCA9IHRoaXMubWF4UmVjZWl2ZU1lc3NhZ2VTaXplO1xuICAgICAgICBzdHJlYW0ub24oJ2RhdGEnLCBvbkRhdGEpO1xuICAgICAgICBzdHJlYW0ub24oJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIG9uRW5kKTtcbiAgICAgICAgZnVuY3Rpb24gb25EYXRhKGNodW5rKSB7XG4gICAgICAgICAgICByZWNlaXZlZExlbmd0aCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxpbWl0ICE9PSAtMSAmJiByZWNlaXZlZExlbmd0aCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25EYXRhKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FbmQpO1xuICAgICAgICAgICAgICAgIG5leHQoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7cmVjZWl2ZWRMZW5ndGh9IHZzLiAke2xpbWl0fSlgLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJvZHkucHVzaChjaHVuayk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25FbmQoZXJyKSB7XG4gICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbkRhdGEpO1xuICAgICAgICAgICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbkVuZCk7XG4gICAgICAgICAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FbmQpO1xuICAgICAgICAgICAgaWYgKGVyciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbmV4dCh7IGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgZGV0YWlsczogZXJyLm1lc3NhZ2UgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlY2VpdmVkTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbmV4dCh7IGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTCwgZGV0YWlsczogJ3JlY2VpdmVkIGVtcHR5IHVuYXJ5IG1lc3NhZ2UnIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGwuZW1pdCgncmVjZWl2ZU1lc3NhZ2UnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RCeXRlcyA9IEJ1ZmZlci5jb25jYXQoYm9keSwgcmVjZWl2ZWRMZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgY29tcHJlc3NlZCA9IHJlcXVlc3RCeXRlcy5yZWFkVUludDgoMCkgPT09IDE7XG4gICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nID0gY29tcHJlc3NlZCA/IGVuY29kaW5nIDogJ2lkZW50aXR5JztcbiAgICAgICAgICAgIGNvbnN0IGRlY29tcHJlc3NlZE1lc3NhZ2UgPSBjYWxsLmdldERlY29tcHJlc3NlZE1lc3NhZ2UocmVxdWVzdEJ5dGVzLCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nKTtcbiAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZGVjb21wcmVzc2VkTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsLnNhZmVEZXNlcmlhbGl6ZU1lc3NhZ2UoZGVjb21wcmVzc2VkTWVzc2FnZSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVjb21wcmVzc2VkTWVzc2FnZS50aGVuKChkZWNvbXByZXNzZWQpID0+IGNhbGwuc2FmZURlc2VyaWFsaXplTWVzc2FnZShkZWNvbXByZXNzZWQsIG5leHQpLCAoZXJyKSA9PiBuZXh0KGVyci5jb2RlXG4gICAgICAgICAgICAgICAgPyBlcnJcbiAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMLFxuICAgICAgICAgICAgICAgICAgICBkZXRhaWxzOiBgUmVjZWl2ZWQgXCJncnBjLWVuY29kaW5nXCIgaGVhZGVyIFwiJHtlbmNvZGluZ31cIiBidXQgJHtlbmNvZGluZ30gZGVjb21wcmVzc2lvbiBmYWlsZWRgLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzYWZlRGVzZXJpYWxpemVNZXNzYWdlKGJ1ZmZlciwgbmV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV4dChudWxsLCB0aGlzLmRlc2VyaWFsaXplTWVzc2FnZShidWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnIuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgIG5leHQoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXJpYWxpemVNZXNzYWdlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VCdWZmZXIgPSB0aGlzLmhhbmRsZXIuc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgLy8gVE9ETyhjamlocmlnKTogQ2FsbCBjb21wcmVzc2lvbiBhd2FyZSBzZXJpYWxpemVNZXNzYWdlKCkuXG4gICAgICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBtZXNzYWdlQnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlTGVuZ3RoICsgNSk7XG4gICAgICAgIG91dHB1dC53cml0ZVVJbnQ4KDAsIDApO1xuICAgICAgICBvdXRwdXQud3JpdGVVSW50MzJCRShieXRlTGVuZ3RoLCAxKTtcbiAgICAgICAgbWVzc2FnZUJ1ZmZlci5jb3B5KG91dHB1dCwgNSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIGRlc2VyaWFsaXplTWVzc2FnZShieXRlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmRlc2VyaWFsaXplKGJ5dGVzKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZFVuYXJ5TWVzc2FnZShlcnIsIHZhbHVlLCBtZXRhZGF0YSwgZmxhZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCAnbWV0YWRhdGEnKSAmJiBtZXRhZGF0YSkge1xuICAgICAgICAgICAgICAgIGVyci5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UodmFsdWUpO1xuICAgICAgICAgICAgdGhpcy53cml0ZShyZXNwb25zZSk7XG4gICAgICAgICAgICB0aGlzLnNlbmRTdGF0dXMoeyBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuT0ssIGRldGFpbHM6ICdPSycsIG1ldGFkYXRhIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVyci5jb2RlID0gY29uc3RhbnRzXzEuU3RhdHVzLklOVEVSTkFMO1xuICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kU3RhdHVzKHN0YXR1c09iaikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZW1pdCgnY2FsbEVuZCcsIHN0YXR1c09iai5jb2RlKTtcbiAgICAgICAgdGhpcy5lbWl0KCdzdHJlYW1FbmQnLCBzdGF0dXNPYmouY29kZSA9PT0gY29uc3RhbnRzXzEuU3RhdHVzLk9LKTtcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tDYW5jZWxsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlKCdSZXF1ZXN0IHRvIG1ldGhvZCAnICsgKChfYSA9IHRoaXMuaGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGgpICtcbiAgICAgICAgICAgICcgZW5kZWQgd2l0aCBzdGF0dXMgY29kZTogJyArXG4gICAgICAgICAgICBjb25zdGFudHNfMS5TdGF0dXNbc3RhdHVzT2JqLmNvZGVdICtcbiAgICAgICAgICAgICcgZGV0YWlsczogJyArXG4gICAgICAgICAgICBzdGF0dXNPYmouZGV0YWlscyk7XG4gICAgICAgIGlmICh0aGlzLmRlYWRsaW5lVGltZXIpXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWFkbGluZVRpbWVyKTtcbiAgICAgICAgaWYgKCF0aGlzLndhbnRUcmFpbGVycykge1xuICAgICAgICAgICAgdGhpcy53YW50VHJhaWxlcnMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ub25jZSgnd2FudFRyYWlsZXJzJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFpbGVyc1RvU2VuZCA9IE9iamVjdC5hc3NpZ24oeyBbR1JQQ19TVEFUVVNfSEVBREVSXTogc3RhdHVzT2JqLmNvZGUsIFtHUlBDX01FU1NBR0VfSEVBREVSXTogZW5jb2RlVVJJKHN0YXR1c09iai5kZXRhaWxzKSB9LCAoX2EgPSBzdGF0dXNPYmoubWV0YWRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0h0dHAySGVhZGVycygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5zZW5kVHJhaWxlcnModHJhaWxlcnNUb1NlbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzU2VudCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc2VuZE1ldGFkYXRhKCk7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZW5kRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge1xuICAgICAgICAgICAgY29kZTogY29uc3RhbnRzXzEuU3RhdHVzLlVOS05PV04sXG4gICAgICAgICAgICBkZXRhaWxzOiAnbWVzc2FnZScgaW4gZXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gRXJyb3InLFxuICAgICAgICAgICAgbWV0YWRhdGE6ICdtZXRhZGF0YScgaW4gZXJyb3IgJiYgZXJyb3IubWV0YWRhdGEgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gZXJyb3IubWV0YWRhdGFcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIGlmICgnY29kZScgaW4gZXJyb3IgJiZcbiAgICAgICAgICAgIHR5cGVvZiBlcnJvci5jb2RlID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihlcnJvci5jb2RlKSkge1xuICAgICAgICAgICAgc3RhdHVzLmNvZGUgPSBlcnJvci5jb2RlO1xuICAgICAgICAgICAgaWYgKCdkZXRhaWxzJyBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IuZGV0YWlscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGV0YWlscyA9IGVycm9yLmRldGFpbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW5kU3RhdHVzKHN0YXR1cyk7XG4gICAgfVxuICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ2FuY2VsbGVkKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXhTZW5kTWVzc2FnZVNpemUgIT09IC0xICYmXG4gICAgICAgICAgICBjaHVuay5sZW5ndGggPiB0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5zZW5kRXJyb3Ioe1xuICAgICAgICAgICAgICAgIGNvZGU6IGNvbnN0YW50c18xLlN0YXR1cy5SRVNPVVJDRV9FWEhBVVNURUQsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFNlbnQgbWVzc2FnZSBsYXJnZXIgdGhhbiBtYXggKCR7Y2h1bmsubGVuZ3RofSB2cy4gJHt0aGlzLm1heFNlbmRNZXNzYWdlU2l6ZX0pYCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VuZE1ldGFkYXRhKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnc2VuZE1lc3NhZ2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtLndyaXRlKGNodW5rKTtcbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICB0aGlzLnN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gICAgc2V0dXBTdXJmYWNlQ2FsbChjYWxsKSB7XG4gICAgICAgIHRoaXMub25jZSgnY2FuY2VsbGVkJywgKHJlYXNvbikgPT4ge1xuICAgICAgICAgICAgY2FsbC5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2FsbC5lbWl0KCdjYW5jZWxsZWQnLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmNlKCdjYWxsRW5kJywgKHN0YXR1cykgPT4gY2FsbC5lbWl0KCdjYWxsRW5kJywgc3RhdHVzKSk7XG4gICAgfVxuICAgIHNldHVwUmVhZGFibGUocmVhZGFibGUsIGVuY29kaW5nKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgc3RyZWFtX2RlY29kZXJfMS5TdHJlYW1EZWNvZGVyKCk7XG4gICAgICAgIGxldCByZWFkc0RvbmUgPSBmYWxzZTtcbiAgICAgICAgbGV0IHBlbmRpbmdNZXNzYWdlUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICBsZXQgcHVzaGVkRW5kID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1heWJlUHVzaEVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghcHVzaGVkRW5kICYmIHJlYWRzRG9uZSAmJiAhcGVuZGluZ01lc3NhZ2VQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgcHVzaGVkRW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hPckJ1ZmZlck1lc3NhZ2UocmVhZGFibGUsIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0cmVhbS5vbignZGF0YScsIGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGRlY29kZXIud3JpdGUoZGF0YSk7XG4gICAgICAgICAgICBwZW5kaW5nTWVzc2FnZVByb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucGF1c2UoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWVzc2FnZSBvZiBtZXNzYWdlcykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5sZW5ndGggPiB0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuUkVTT1VSQ0VfRVhIQVVTVEVELFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsczogYFJlY2VpdmVkIG1lc3NhZ2UgbGFyZ2VyIHRoYW4gbWF4ICgke21lc3NhZ2UubGVuZ3RofSB2cy4gJHt0aGlzLm1heFJlY2VpdmVNZXNzYWdlU2l6ZX0pYCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWNlaXZlTWVzc2FnZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzZWQgPSBtZXNzYWdlLnJlYWRVSW50OCgwKSA9PT0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nID0gY29tcHJlc3NlZCA/IGVuY29kaW5nIDogJ2lkZW50aXR5JztcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNvbXByZXNzZWRNZXNzYWdlID0gYXdhaXQgdGhpcy5nZXREZWNvbXByZXNzZWRNZXNzYWdlKG1lc3NhZ2UsIGNvbXByZXNzZWRNZXNzYWdlRW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIC8vIEVuY291bnRlcmVkIGFuIGVycm9yIHdpdGggZGVjb21wcmVzc2lvbjsgaXQnbGwgYWxyZWFkeSBoYXZlIGJlZW4gcHJvcG9nYXRlZCBiYWNrXG4gICAgICAgICAgICAgICAgLy8gSnVzdCByZXR1cm4gZWFybHlcbiAgICAgICAgICAgICAgICBpZiAoIWRlY29tcHJlc3NlZE1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hPckJ1ZmZlck1lc3NhZ2UocmVhZGFibGUsIGRlY29tcHJlc3NlZE1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVuZGluZ01lc3NhZ2VQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbS5yZXN1bWUoKTtcbiAgICAgICAgICAgIG1heWJlUHVzaEVuZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdHJlYW0ub25jZSgnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgcmVhZHNEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIG1heWJlUHVzaEVuZCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3VtZVVucHVzaGVkTWVzc2FnZXMocmVhZGFibGUpIHtcbiAgICAgICAgdGhpcy5jYW5QdXNoID0gdHJ1ZTtcbiAgICAgICAgd2hpbGUgKHRoaXMubWVzc2FnZXNUb1B1c2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dE1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzVG9QdXNoLnNoaWZ0KCk7XG4gICAgICAgICAgICBjb25zdCBjYW5QdXNoID0gcmVhZGFibGUucHVzaChuZXh0TWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAobmV4dE1lc3NhZ2UgPT09IG51bGwgfHwgY2FuUHVzaCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhblB1c2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYW5QdXNoO1xuICAgIH1cbiAgICBwdXNoT3JCdWZmZXJNZXNzYWdlKHJlYWRhYmxlLCBtZXNzYWdlQnl0ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQdXNoUGVuZGluZykge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJlZE1lc3NhZ2VzLnB1c2gobWVzc2FnZUJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHVzaE1lc3NhZ2UocmVhZGFibGUsIG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcHVzaE1lc3NhZ2UocmVhZGFibGUsIG1lc3NhZ2VCeXRlcykge1xuICAgICAgICBpZiAobWVzc2FnZUJ5dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFjZSgnUmVjZWl2ZWQgZW5kIG9mIHN0cmVhbScpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuUHVzaCkge1xuICAgICAgICAgICAgICAgIHJlYWRhYmxlLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VzVG9QdXNoLnB1c2gobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2UoJ1JlY2VpdmVkIG1lc3NhZ2Ugb2YgbGVuZ3RoICcgKyBtZXNzYWdlQnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5pc1B1c2hQZW5kaW5nID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZCA9IGF3YWl0IHRoaXMuZGVzZXJpYWxpemVNZXNzYWdlKG1lc3NhZ2VCeXRlcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5QdXNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWFkYWJsZS5wdXNoKGRlc2VyaWFsaXplZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW5QdXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1RvUHVzaC5wdXNoKGRlc2VyaWFsaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgYW55IHJlbWFpbmluZyBtZXNzYWdlcyB3aGVuIGVycm9ycyBvY2N1ci5cbiAgICAgICAgICAgIHRoaXMuYnVmZmVyZWRNZXNzYWdlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgaWYgKCEoJ2NvZGUnIGluIGVycm9yICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGVycm9yLmNvZGUgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzSW50ZWdlcihlcnJvci5jb2RlKSAmJlxuICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPj0gY29uc3RhbnRzXzEuU3RhdHVzLk9LICYmXG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA8PSBjb25zdGFudHNfMS5TdGF0dXMuVU5BVVRIRU5USUNBVEVEKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBlcnJvciBjb2RlIGlzIG5vdCBhIHZhbGlkIGdSUEMgY29kZSBzbyBpdHMgYmVpbmcgb3ZlcndyaXR0ZW4uXG4gICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5JTlRFUk5BTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWRhYmxlLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNQdXNoUGVuZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5idWZmZXJlZE1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMucHVzaE1lc3NhZ2UocmVhZGFibGUsIHRoaXMuYnVmZmVyZWRNZXNzYWdlcy5zaGlmdCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRQZWVyKCkge1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLnN0cmVhbS5zZXNzaW9uLnNvY2tldDtcbiAgICAgICAgaWYgKHNvY2tldC5yZW1vdGVBZGRyZXNzKSB7XG4gICAgICAgICAgICBpZiAoc29ja2V0LnJlbW90ZVBvcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCR7c29ja2V0LnJlbW90ZUFkZHJlc3N9OiR7c29ja2V0LnJlbW90ZVBvcnR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVhZGxpbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlYWRsaW5lO1xuICAgIH1cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLnBhdGg7XG4gICAgfVxufVxuZXhwb3J0cy5IdHRwMlNlcnZlckNhbGxTdHJlYW0gPSBIdHRwMlNlcnZlckNhbGxTdHJlYW07XG5mdW5jdGlvbiBoYW5kbGVFeHBpcmVkRGVhZGxpbmUoY2FsbCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignRGVhZGxpbmUgZXhjZWVkZWQnKTtcbiAgICBlcnIuY29kZSA9IGNvbnN0YW50c18xLlN0YXR1cy5ERUFETElORV9FWENFRURFRDtcbiAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgIGNhbGwuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBjYWxsLmVtaXQoJ2NhbmNlbGxlZCcsICdkZWFkbGluZScpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWNhbGwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiSHR0cDJTZXJ2ZXJDYWxsU3RyZWFtIiwiU2VydmVyRHVwbGV4U3RyZWFtSW1wbCIsIlNlcnZlcldyaXRhYmxlU3RyZWFtSW1wbCIsIlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbCIsIlNlcnZlclVuYXJ5Q2FsbEltcGwiLCJldmVudHNfMSIsInJlcXVpcmUiLCJodHRwMiIsInN0cmVhbV8xIiwiemxpYiIsInV0aWxfMSIsImNvbnN0YW50c18xIiwibWV0YWRhdGFfMSIsInN0cmVhbV9kZWNvZGVyXzEiLCJsb2dnaW5nIiwiVFJBQ0VSX05BTUUiLCJ1bnppcCIsInByb21pc2lmeSIsImluZmxhdGUiLCJ0cmFjZSIsInRleHQiLCJMb2dWZXJib3NpdHkiLCJERUJVRyIsIkdSUENfQUNDRVBUX0VOQ09ESU5HX0hFQURFUiIsIkdSUENfRU5DT0RJTkdfSEVBREVSIiwiR1JQQ19NRVNTQUdFX0hFQURFUiIsIkdSUENfU1RBVFVTX0hFQURFUiIsIkdSUENfVElNRU9VVF9IRUFERVIiLCJERUFETElORV9SRUdFWCIsImRlYWRsaW5lVW5pdHNUb01zIiwiSCIsIk0iLCJTIiwibSIsInUiLCJuIiwiZGVmYXVsdFJlc3BvbnNlSGVhZGVycyIsImNvbnN0YW50cyIsIkhUVFAyX0hFQURFUl9TVEFUVVMiLCJIVFRQX1NUQVRVU19PSyIsIkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUiLCJkZWZhdWx0UmVzcG9uc2VPcHRpb25zIiwid2FpdEZvclRyYWlsZXJzIiwiRXZlbnRFbWl0dGVyIiwiY29uc3RydWN0b3IiLCJjYWxsIiwibWV0YWRhdGEiLCJyZXF1ZXN0IiwiY2FuY2VsbGVkIiwic2V0dXBTdXJmYWNlQ2FsbCIsImdldFBlZXIiLCJzZW5kTWV0YWRhdGEiLCJyZXNwb25zZU1ldGFkYXRhIiwiZ2V0RGVhZGxpbmUiLCJnZXRQYXRoIiwiUmVhZGFibGUiLCJkZXNlcmlhbGl6ZSIsImVuY29kaW5nIiwib2JqZWN0TW9kZSIsInNldHVwUmVhZGFibGUiLCJfcmVhZCIsInNpemUiLCJjb25zdW1lVW5wdXNoZWRNZXNzYWdlcyIsInJlc3VtZSIsIldyaXRhYmxlIiwic2VyaWFsaXplIiwidHJhaWxpbmdNZXRhZGF0YSIsIk1ldGFkYXRhIiwib24iLCJlcnIiLCJzZW5kRXJyb3IiLCJlbmQiLCJfd3JpdGUiLCJjaHVuayIsImNhbGxiYWNrIiwicmVzcG9uc2UiLCJzZXJpYWxpemVNZXNzYWdlIiwid3JpdGUiLCJvbmNlIiwiY29kZSIsIlN0YXR1cyIsIklOVEVSTkFMIiwiZW1pdCIsIl9maW5hbCIsInNlbmRTdGF0dXMiLCJPSyIsImRldGFpbHMiLCJEdXBsZXgiLCJwcm90b3R5cGUiLCJzdHJlYW0iLCJoYW5kbGVyIiwib3B0aW9ucyIsImRlYWRsaW5lVGltZXIiLCJzdGF0dXNTZW50IiwiZGVhZGxpbmUiLCJJbmZpbml0eSIsIndhbnRUcmFpbGVycyIsIm1ldGFkYXRhU2VudCIsImNhblB1c2giLCJpc1B1c2hQZW5kaW5nIiwiYnVmZmVyZWRNZXNzYWdlcyIsIm1lc3NhZ2VzVG9QdXNoIiwibWF4U2VuZE1lc3NhZ2VTaXplIiwiREVGQVVMVF9NQVhfU0VORF9NRVNTQUdFX0xFTkdUSCIsIm1heFJlY2VpdmVNZXNzYWdlU2l6ZSIsIkRFRkFVTFRfTUFYX1JFQ0VJVkVfTUVTU0FHRV9MRU5HVEgiLCJfYSIsInBhdGgiLCJyc3RDb2RlIiwiQ0FOQ0VMTEVEIiwiY2hlY2tDYW5jZWxsZWQiLCJkZXN0cm95ZWQiLCJjbG9zZWQiLCJnZXREZWNvbXByZXNzZWRNZXNzYWdlIiwibWVzc2FnZSIsInN1YmFycmF5IiwiUHJvbWlzZSIsInJlamVjdCIsIlVOSU1QTEVNRU5URUQiLCJjdXN0b21NZXRhZGF0YSIsImN1c3RvbSIsInRvSHR0cDJIZWFkZXJzIiwiaGVhZGVycyIsImFzc2lnbiIsInJlc3BvbmQiLCJyZWNlaXZlTWV0YWRhdGEiLCJmcm9tSHR0cDJIZWFkZXJzIiwiaXNUcmFjZXJFbmFibGVkIiwiSlNPTiIsInN0cmluZ2lmeSIsInRvSlNPTiIsInRpbWVvdXRIZWFkZXIiLCJnZXQiLCJsZW5ndGgiLCJtYXRjaCIsInRvU3RyaW5nIiwiRXJyb3IiLCJPVVRfT0ZfUkFOR0UiLCJ0aW1lb3V0Iiwibm93IiwiRGF0ZSIsInNldE1pbGxpc2Vjb25kcyIsImdldE1pbGxpc2Vjb25kcyIsInNldFRpbWVvdXQiLCJoYW5kbGVFeHBpcmVkRGVhZGxpbmUiLCJyZW1vdmUiLCJIVFRQMl9IRUFERVJfQUNDRVBUX0VOQ09ESU5HIiwiSFRUUDJfSEVBREVSX1RFIiwicmVjZWl2ZVVuYXJ5TWVzc2FnZSIsIm5leHQiLCJyZWNlaXZlZExlbmd0aCIsImJvZHkiLCJsaW1pdCIsIm9uRGF0YSIsIm9uRW5kIiwiYnl0ZUxlbmd0aCIsInJlbW92ZUxpc3RlbmVyIiwiUkVTT1VSQ0VfRVhIQVVTVEVEIiwicHVzaCIsInVuZGVmaW5lZCIsInJlcXVlc3RCeXRlcyIsIkJ1ZmZlciIsImNvbmNhdCIsImNvbXByZXNzZWQiLCJyZWFkVUludDgiLCJjb21wcmVzc2VkTWVzc2FnZUVuY29kaW5nIiwiZGVjb21wcmVzc2VkTWVzc2FnZSIsImlzQnVmZmVyIiwic2FmZURlc2VyaWFsaXplTWVzc2FnZSIsInRoZW4iLCJkZWNvbXByZXNzZWQiLCJidWZmZXIiLCJkZXNlcmlhbGl6ZU1lc3NhZ2UiLCJtZXNzYWdlQnVmZmVyIiwib3V0cHV0IiwiYWxsb2NVbnNhZmUiLCJ3cml0ZVVJbnQ4Iiwid3JpdGVVSW50MzJCRSIsImNvcHkiLCJieXRlcyIsInNlbmRVbmFyeU1lc3NhZ2UiLCJmbGFncyIsImhhc093blByb3BlcnR5Iiwic3RhdHVzT2JqIiwiY2xlYXJUaW1lb3V0IiwidHJhaWxlcnNUb1NlbmQiLCJlbmNvZGVVUkkiLCJzZW5kVHJhaWxlcnMiLCJlcnJvciIsInN0YXR1cyIsIlVOS05PV04iLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJyZWFzb24iLCJyZWFkYWJsZSIsImRlY29kZXIiLCJTdHJlYW1EZWNvZGVyIiwicmVhZHNEb25lIiwicGVuZGluZ01lc3NhZ2VQcm9jZXNzaW5nIiwicHVzaGVkRW5kIiwibWF5YmVQdXNoRW5kIiwicHVzaE9yQnVmZmVyTWVzc2FnZSIsImRhdGEiLCJtZXNzYWdlcyIsInBhdXNlIiwibmV4dE1lc3NhZ2UiLCJzaGlmdCIsIm1lc3NhZ2VCeXRlcyIsInB1c2hNZXNzYWdlIiwiZGVzZXJpYWxpemVkIiwiVU5BVVRIRU5USUNBVEVEIiwic29ja2V0Iiwic2Vzc2lvbiIsInJlbW90ZUFkZHJlc3MiLCJyZW1vdGVQb3J0IiwiREVBRExJTkVfRVhDRUVERUQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server-credentials.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.ServerCredentials = void 0;\nconst tls_helpers_1 = __webpack_require__(/*! ./tls-helpers */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\");\nclass ServerCredentials {\n    static createInsecure() {\n        return new InsecureServerCredentials();\n    }\n    static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {\n        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {\n            throw new TypeError(\"rootCerts must be null or a Buffer\");\n        }\n        if (!Array.isArray(keyCertPairs)) {\n            throw new TypeError(\"keyCertPairs must be an array\");\n        }\n        if (typeof checkClientCertificate !== \"boolean\") {\n            throw new TypeError(\"checkClientCertificate must be a boolean\");\n        }\n        const cert = [];\n        const key = [];\n        for(let i = 0; i < keyCertPairs.length; i++){\n            const pair = keyCertPairs[i];\n            if (pair === null || typeof pair !== \"object\") {\n                throw new TypeError(`keyCertPair[${i}] must be an object`);\n            }\n            if (!Buffer.isBuffer(pair.private_key)) {\n                throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);\n            }\n            if (!Buffer.isBuffer(pair.cert_chain)) {\n                throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);\n            }\n            cert.push(pair.cert_chain);\n            key.push(pair.private_key);\n        }\n        return new SecureServerCredentials({\n            ca: rootCerts || tls_helpers_1.getDefaultRootsData() || undefined,\n            cert,\n            key,\n            requestCert: checkClientCertificate,\n            ciphers: tls_helpers_1.CIPHER_SUITES\n        });\n    }\n}\nexports.ServerCredentials = ServerCredentials;\nclass InsecureServerCredentials extends ServerCredentials {\n    _isSecure() {\n        return false;\n    }\n    _getSettings() {\n        return null;\n    }\n}\nclass SecureServerCredentials extends ServerCredentials {\n    constructor(options){\n        super();\n        this.options = options;\n    }\n    _isSecure() {\n        return true;\n    }\n    _getSettings() {\n        return this.options;\n    }\n} //# sourceMappingURL=server-credentials.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLWNyZWRlbnRpYWxzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBRyxLQUFLO0FBQ2pDLE1BQU1HLGdCQUFnQkMsbUJBQU9BLENBQUMsa0ZBQWU7QUFDN0MsTUFBTUY7SUFDRixPQUFPRyxpQkFBaUI7UUFDcEIsT0FBTyxJQUFJQztJQUNmO0lBQ0EsT0FBT0MsVUFBVUMsU0FBUyxFQUFFQyxZQUFZLEVBQUVDLHlCQUF5QixLQUFLLEVBQUU7UUFDdEUsSUFBSUYsY0FBYyxRQUFRLENBQUNHLE9BQU9DLFFBQVEsQ0FBQ0osWUFBWTtZQUNuRCxNQUFNLElBQUlLLFVBQVU7UUFDeEI7UUFDQSxJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ04sZUFBZTtZQUM5QixNQUFNLElBQUlJLFVBQVU7UUFDeEI7UUFDQSxJQUFJLE9BQU9ILDJCQUEyQixXQUFXO1lBQzdDLE1BQU0sSUFBSUcsVUFBVTtRQUN4QjtRQUNBLE1BQU1HLE9BQU8sRUFBRTtRQUNmLE1BQU1DLE1BQU0sRUFBRTtRQUNkLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJVCxhQUFhVSxNQUFNLEVBQUVELElBQUs7WUFDMUMsTUFBTUUsT0FBT1gsWUFBWSxDQUFDUyxFQUFFO1lBQzVCLElBQUlFLFNBQVMsUUFBUSxPQUFPQSxTQUFTLFVBQVU7Z0JBQzNDLE1BQU0sSUFBSVAsVUFBVSxDQUFDLFlBQVksRUFBRUssRUFBRSxtQkFBbUIsQ0FBQztZQUM3RDtZQUNBLElBQUksQ0FBQ1AsT0FBT0MsUUFBUSxDQUFDUSxLQUFLQyxXQUFXLEdBQUc7Z0JBQ3BDLE1BQU0sSUFBSVIsVUFBVSxDQUFDLFlBQVksRUFBRUssRUFBRSw4QkFBOEIsQ0FBQztZQUN4RTtZQUNBLElBQUksQ0FBQ1AsT0FBT0MsUUFBUSxDQUFDUSxLQUFLRSxVQUFVLEdBQUc7Z0JBQ25DLE1BQU0sSUFBSVQsVUFBVSxDQUFDLFlBQVksRUFBRUssRUFBRSw2QkFBNkIsQ0FBQztZQUN2RTtZQUNBRixLQUFLTyxJQUFJLENBQUNILEtBQUtFLFVBQVU7WUFDekJMLElBQUlNLElBQUksQ0FBQ0gsS0FBS0MsV0FBVztRQUM3QjtRQUNBLE9BQU8sSUFBSUcsd0JBQXdCO1lBQy9CQyxJQUFJakIsYUFBYUwsY0FBY3VCLG1CQUFtQixNQUFNQztZQUN4RFg7WUFDQUM7WUFDQVcsYUFBYWxCO1lBQ2JtQixTQUFTMUIsY0FBYzJCLGFBQWE7UUFDeEM7SUFDSjtBQUNKO0FBQ0E5Qix5QkFBeUIsR0FBR0U7QUFDNUIsTUFBTUksa0NBQWtDSjtJQUNwQzZCLFlBQVk7UUFDUixPQUFPO0lBQ1g7SUFDQUMsZUFBZTtRQUNYLE9BQU87SUFDWDtBQUNKO0FBQ0EsTUFBTVIsZ0NBQWdDdEI7SUFDbEMrQixZQUFZQyxPQUFPLENBQUU7UUFDakIsS0FBSztRQUNMLElBQUksQ0FBQ0EsT0FBTyxHQUFHQTtJQUNuQjtJQUNBSCxZQUFZO1FBQ1IsT0FBTztJQUNYO0lBQ0FDLGVBQWU7UUFDWCxPQUFPLElBQUksQ0FBQ0UsT0FBTztJQUN2QjtBQUNKLEVBQ0EsOENBQThDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZlci1jcmVkZW50aWFscy5qcz9kYzcyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlckNyZWRlbnRpYWxzID0gdm9pZCAwO1xuY29uc3QgdGxzX2hlbHBlcnNfMSA9IHJlcXVpcmUoXCIuL3Rscy1oZWxwZXJzXCIpO1xuY2xhc3MgU2VydmVyQ3JlZGVudGlhbHMge1xuICAgIHN0YXRpYyBjcmVhdGVJbnNlY3VyZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJbnNlY3VyZVNlcnZlckNyZWRlbnRpYWxzKCk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVTc2wocm9vdENlcnRzLCBrZXlDZXJ0UGFpcnMsIGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUgPSBmYWxzZSkge1xuICAgICAgICBpZiAocm9vdENlcnRzICE9PSBudWxsICYmICFCdWZmZXIuaXNCdWZmZXIocm9vdENlcnRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncm9vdENlcnRzIG11c3QgYmUgbnVsbCBvciBhIEJ1ZmZlcicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShrZXlDZXJ0UGFpcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdrZXlDZXJ0UGFpcnMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tDbGllbnRDZXJ0aWZpY2F0ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjaGVja0NsaWVudENlcnRpZmljYXRlIG11c3QgYmUgYSBib29sZWFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VydCA9IFtdO1xuICAgICAgICBjb25zdCBrZXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlDZXJ0UGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBrZXlDZXJ0UGFpcnNbaV07XG4gICAgICAgICAgICBpZiAocGFpciA9PT0gbnVsbCB8fCB0eXBlb2YgcGFpciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBrZXlDZXJ0UGFpclske2l9XSBtdXN0IGJlIGFuIG9iamVjdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIocGFpci5wcml2YXRlX2tleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBrZXlDZXJ0UGFpclske2l9XS5wcml2YXRlX2tleSBtdXN0IGJlIGEgQnVmZmVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihwYWlyLmNlcnRfY2hhaW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihga2V5Q2VydFBhaXJbJHtpfV0uY2VydF9jaGFpbiBtdXN0IGJlIGEgQnVmZmVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZXJ0LnB1c2gocGFpci5jZXJ0X2NoYWluKTtcbiAgICAgICAgICAgIGtleS5wdXNoKHBhaXIucHJpdmF0ZV9rZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMoe1xuICAgICAgICAgICAgY2E6IHJvb3RDZXJ0cyB8fCB0bHNfaGVscGVyc18xLmdldERlZmF1bHRSb290c0RhdGEoKSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBjZXJ0LFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgcmVxdWVzdENlcnQ6IGNoZWNrQ2xpZW50Q2VydGlmaWNhdGUsXG4gICAgICAgICAgICBjaXBoZXJzOiB0bHNfaGVscGVyc18xLkNJUEhFUl9TVUlURVMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyQ3JlZGVudGlhbHMgPSBTZXJ2ZXJDcmVkZW50aWFscztcbmNsYXNzIEluc2VjdXJlU2VydmVyQ3JlZGVudGlhbHMgZXh0ZW5kcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgX2lzU2VjdXJlKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIF9nZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMgZXh0ZW5kcyBTZXJ2ZXJDcmVkZW50aWFscyB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBfaXNTZWN1cmUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBfZ2V0U2V0dGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWNyZWRlbnRpYWxzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlNlcnZlckNyZWRlbnRpYWxzIiwidGxzX2hlbHBlcnNfMSIsInJlcXVpcmUiLCJjcmVhdGVJbnNlY3VyZSIsIkluc2VjdXJlU2VydmVyQ3JlZGVudGlhbHMiLCJjcmVhdGVTc2wiLCJyb290Q2VydHMiLCJrZXlDZXJ0UGFpcnMiLCJjaGVja0NsaWVudENlcnRpZmljYXRlIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJUeXBlRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJjZXJ0Iiwia2V5IiwiaSIsImxlbmd0aCIsInBhaXIiLCJwcml2YXRlX2tleSIsImNlcnRfY2hhaW4iLCJwdXNoIiwiU2VjdXJlU2VydmVyQ3JlZGVudGlhbHMiLCJjYSIsImdldERlZmF1bHRSb290c0RhdGEiLCJ1bmRlZmluZWQiLCJyZXF1ZXN0Q2VydCIsImNpcGhlcnMiLCJDSVBIRVJfU1VJVEVTIiwiX2lzU2VjdXJlIiwiX2dldFNldHRpbmdzIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js":
/*!********************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/server.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Server = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst server_call_1 = __webpack_require__(/*! ./server-call */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-call.js\");\nconst server_credentials_1 = __webpack_require__(/*! ./server-credentials */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/server-credentials.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst { HTTP2_HEADER_PATH } = http2.constants;\nconst TRACER_NAME = \"server\";\nfunction noop() {}\nfunction getUnimplementedStatusResponse(methodName) {\n    return {\n        code: constants_1.Status.UNIMPLEMENTED,\n        details: `The server does not implement the method ${methodName}`\n    };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n    const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n    switch(handlerType){\n        case \"unary\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"clientStream\":\n            return (call, callback)=>{\n                callback(unimplementedStatusResponse, null);\n            };\n        case \"serverStream\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        case \"bidi\":\n            return (call)=>{\n                call.emit(\"error\", unimplementedStatusResponse);\n            };\n        default:\n            throw new Error(`Invalid handlerType ${handlerType}`);\n    }\n}\nclass Server {\n    constructor(options){\n        this.http2ServerList = [];\n        this.handlers = new Map();\n        this.sessions = new Map();\n        this.started = false;\n        this.serverAddressString = \"null\";\n        // Channelz Info\n        this.channelzEnabled = true;\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n        this.options = options !== null && options !== void 0 ? options : {};\n        if (this.options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzRef = channelz_1.registerChannelzServer(()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Server created\");\n        }\n        this.trace(\"Server constructed\");\n    }\n    getChannelzInfo() {\n        return {\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            listenerChildren: this.listenerChildrenTracker.getChildLists(),\n            sessionChildren: this.sessionChildrenTracker.getChildLists()\n        };\n    }\n    getChannelzSessionInfoGetter(session) {\n        return ()=>{\n            var _a, _b, _c;\n            const sessionInfo = this.sessions.get(session);\n            const sessionSocket = session.socket;\n            const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n            const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n            let tlsInfo;\n            if (session.encrypted) {\n                const tlsSocket = sessionSocket;\n                const cipherInfo = tlsSocket.getCipher();\n                const certificate = tlsSocket.getCertificate();\n                const peerCertificate = tlsSocket.getPeerCertificate();\n                tlsInfo = {\n                    cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                    cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                    localCertificate: certificate && \"raw\" in certificate ? certificate.raw : null,\n                    remoteCertificate: peerCertificate && \"raw\" in peerCertificate ? peerCertificate.raw : null\n                };\n            } else {\n                tlsInfo = null;\n            }\n            const socketInfo = {\n                remoteAddress: remoteAddress,\n                localAddress: localAddress,\n                security: tlsInfo,\n                remoteName: null,\n                streamsStarted: sessionInfo.streamTracker.callsStarted,\n                streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n                streamsFailed: sessionInfo.streamTracker.callsFailed,\n                messagesSent: sessionInfo.messagesSent,\n                messagesReceived: sessionInfo.messagesReceived,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n                lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n                lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n                localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n                remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n            };\n            return socketInfo;\n        };\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + text);\n    }\n    addProtoService() {\n        throw new Error(\"Not implemented. Use addService() instead\");\n    }\n    addService(service, implementation) {\n        if (service === null || typeof service !== \"object\" || implementation === null || typeof implementation !== \"object\") {\n            throw new Error(\"addService() requires two objects as arguments\");\n        }\n        const serviceKeys = Object.keys(service);\n        if (serviceKeys.length === 0) {\n            throw new Error(\"Cannot add an empty service to a server\");\n        }\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            let methodType;\n            if (attrs.requestStream) {\n                if (attrs.responseStream) {\n                    methodType = \"bidi\";\n                } else {\n                    methodType = \"clientStream\";\n                }\n            } else {\n                if (attrs.responseStream) {\n                    methodType = \"serverStream\";\n                } else {\n                    methodType = \"unary\";\n                }\n            }\n            let implFn = implementation[name];\n            let impl;\n            if (implFn === undefined && typeof attrs.originalName === \"string\") {\n                implFn = implementation[attrs.originalName];\n            }\n            if (implFn !== undefined) {\n                impl = implFn.bind(implementation);\n            } else {\n                impl = getDefaultHandler(methodType, name);\n            }\n            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n            if (success === false) {\n                throw new Error(`Method handler for ${attrs.path} already provided.`);\n            }\n        });\n    }\n    removeService(service) {\n        if (service === null || typeof service !== \"object\") {\n            throw new Error(\"removeService() requires object as argument\");\n        }\n        const serviceKeys = Object.keys(service);\n        serviceKeys.forEach((name)=>{\n            const attrs = service[name];\n            this.unregister(attrs.path);\n        });\n    }\n    bind(port, creds) {\n        throw new Error(\"Not implemented. Use bindAsync() instead\");\n    }\n    bindAsync(port, creds, callback) {\n        if (this.started === true) {\n            throw new Error(\"server is already started\");\n        }\n        if (typeof port !== \"string\") {\n            throw new TypeError(\"port must be a string\");\n        }\n        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n            throw new TypeError(\"creds must be a ServerCredentials object\");\n        }\n        if (typeof callback !== \"function\") {\n            throw new TypeError(\"callback must be a function\");\n        }\n        const initialPortUri = uri_parser_1.parseUri(port);\n        if (initialPortUri === null) {\n            throw new Error(`Could not parse port \"${port}\"`);\n        }\n        const portUri = resolver_1.mapUriDefaultScheme(initialPortUri);\n        if (portUri === null) {\n            throw new Error(`Could not get a default scheme for port \"${port}\"`);\n        }\n        const serverOptions = {\n            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n        };\n        if (\"grpc-node.max_session_memory\" in this.options) {\n            serverOptions.maxSessionMemory = this.options[\"grpc-node.max_session_memory\"];\n        } else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */ serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        if (\"grpc.max_concurrent_streams\" in this.options) {\n            serverOptions.settings = {\n                maxConcurrentStreams: this.options[\"grpc.max_concurrent_streams\"]\n            };\n        }\n        const deferredCallback = (error, port)=>{\n            process.nextTick(()=>callback(error, port));\n        };\n        const setupServer = ()=>{\n            let http2Server;\n            if (creds._isSecure()) {\n                const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n                http2Server = http2.createSecureServer(secureServerOptions);\n                http2Server.on(\"secureConnection\", (socket)=>{\n                    /* These errors need to be handled by the user of Http2SecureServer,\n                     * according to https://github.com/nodejs/node/issues/35824 */ socket.on(\"error\", (e)=>{\n                        this.trace(\"An incoming TLS connection closed with error: \" + e.message);\n                    });\n                });\n            } else {\n                http2Server = http2.createServer(serverOptions);\n            }\n            http2Server.setTimeout(0, noop);\n            this._setupHandlers(http2Server);\n            return http2Server;\n        };\n        const bindSpecificPort = (addressList, portNum, previousCount)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: portNum,\n                    count: previousCount\n                });\n            }\n            return Promise.all(addressList.map((address)=>{\n                this.trace(\"Attempting to bind \" + subchannel_address_1.subchannelAddressToString(address));\n                let addr;\n                if (subchannel_address_1.isTcpSubchannelAddress(address)) {\n                    addr = {\n                        host: address.host,\n                        port: portNum\n                    };\n                } else {\n                    addr = address;\n                }\n                const http2Server = setupServer();\n                return new Promise((resolve, reject)=>{\n                    const onError = (err)=>{\n                        this.trace(\"Failed to bind \" + subchannel_address_1.subchannelAddressToString(address) + \" with error \" + err.message);\n                        resolve(err);\n                    };\n                    http2Server.once(\"error\", onError);\n                    http2Server.listen(addr, ()=>{\n                        const boundAddress = http2Server.address();\n                        let boundSubchannelAddress;\n                        if (typeof boundAddress === \"string\") {\n                            boundSubchannelAddress = {\n                                path: boundAddress\n                            };\n                        } else {\n                            boundSubchannelAddress = {\n                                host: boundAddress.address,\n                                port: boundAddress.port\n                            };\n                        }\n                        let channelzRef;\n                        channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), ()=>{\n                            return {\n                                localAddress: boundSubchannelAddress,\n                                remoteAddress: null,\n                                security: null,\n                                remoteName: null,\n                                streamsStarted: 0,\n                                streamsSucceeded: 0,\n                                streamsFailed: 0,\n                                messagesSent: 0,\n                                messagesReceived: 0,\n                                keepAlivesSent: 0,\n                                lastLocalStreamCreatedTimestamp: null,\n                                lastRemoteStreamCreatedTimestamp: null,\n                                lastMessageSentTimestamp: null,\n                                lastMessageReceivedTimestamp: null,\n                                localFlowControlWindow: null,\n                                remoteFlowControlWindow: null\n                            };\n                        }, this.channelzEnabled);\n                        if (this.channelzEnabled) {\n                            this.listenerChildrenTracker.refChild(channelzRef);\n                        }\n                        this.http2ServerList.push({\n                            server: http2Server,\n                            channelzRef: channelzRef\n                        });\n                        this.trace(\"Successfully bound \" + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n                        resolve(\"port\" in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n                        http2Server.removeListener(\"error\", onError);\n                    });\n                });\n            })).then((results)=>{\n                let count = 0;\n                for (const result of results){\n                    if (typeof result === \"number\") {\n                        count += 1;\n                        if (result !== portNum) {\n                            throw new Error(\"Invalid state: multiple port numbers added from single address\");\n                        }\n                    }\n                }\n                return {\n                    port: portNum,\n                    count: count + previousCount\n                };\n            });\n        };\n        const bindWildcardPort = (addressList)=>{\n            if (addressList.length === 0) {\n                return Promise.resolve({\n                    port: 0,\n                    count: 0\n                });\n            }\n            const address = addressList[0];\n            const http2Server = setupServer();\n            return new Promise((resolve, reject)=>{\n                const onError = (err)=>{\n                    this.trace(\"Failed to bind \" + subchannel_address_1.subchannelAddressToString(address) + \" with error \" + err.message);\n                    resolve(bindWildcardPort(addressList.slice(1)));\n                };\n                http2Server.once(\"error\", onError);\n                http2Server.listen(address, ()=>{\n                    const boundAddress = http2Server.address();\n                    const boundSubchannelAddress = {\n                        host: boundAddress.address,\n                        port: boundAddress.port\n                    };\n                    let channelzRef;\n                    channelzRef = channelz_1.registerChannelzSocket(subchannel_address_1.subchannelAddressToString(boundSubchannelAddress), ()=>{\n                        return {\n                            localAddress: boundSubchannelAddress,\n                            remoteAddress: null,\n                            security: null,\n                            remoteName: null,\n                            streamsStarted: 0,\n                            streamsSucceeded: 0,\n                            streamsFailed: 0,\n                            messagesSent: 0,\n                            messagesReceived: 0,\n                            keepAlivesSent: 0,\n                            lastLocalStreamCreatedTimestamp: null,\n                            lastRemoteStreamCreatedTimestamp: null,\n                            lastMessageSentTimestamp: null,\n                            lastMessageReceivedTimestamp: null,\n                            localFlowControlWindow: null,\n                            remoteFlowControlWindow: null\n                        };\n                    }, this.channelzEnabled);\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.refChild(channelzRef);\n                    }\n                    this.http2ServerList.push({\n                        server: http2Server,\n                        channelzRef: channelzRef\n                    });\n                    this.trace(\"Successfully bound \" + subchannel_address_1.subchannelAddressToString(boundSubchannelAddress));\n                    resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n                    http2Server.removeListener(\"error\", onError);\n                });\n            });\n        };\n        const resolverListener = {\n            onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError)=>{\n                // We only want one resolution result. Discard all future results\n                resolverListener.onSuccessfulResolution = ()=>{};\n                if (addressList.length === 0) {\n                    deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n                    return;\n                }\n                let bindResultPromise;\n                if (subchannel_address_1.isTcpSubchannelAddress(addressList[0])) {\n                    if (addressList[0].port === 0) {\n                        bindResultPromise = bindWildcardPort(addressList);\n                    } else {\n                        bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n                    }\n                } else {\n                    // Use an arbitrary non-zero port for non-TCP addresses\n                    bindResultPromise = bindSpecificPort(addressList, 1, 0);\n                }\n                bindResultPromise.then((bindResult)=>{\n                    if (bindResult.count === 0) {\n                        const errorString = `No address added out of total ${addressList.length} resolved`;\n                        logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                        deferredCallback(new Error(errorString), 0);\n                    } else {\n                        if (bindResult.count < addressList.length) {\n                            logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n                        }\n                        deferredCallback(null, bindResult.port);\n                    }\n                }, (error)=>{\n                    const errorString = `No address added out of total ${addressList.length} resolved`;\n                    logging.log(constants_1.LogVerbosity.ERROR, errorString);\n                    deferredCallback(new Error(errorString), 0);\n                });\n            },\n            onError: (error)=>{\n                deferredCallback(new Error(error.details), 0);\n            }\n        };\n        const resolver = resolver_1.createResolver(portUri, resolverListener, this.options);\n        resolver.updateResolution();\n    }\n    forceShutdown() {\n        // Close the server if it is still running.\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        channelz_1.unregisterChannelzRef(ref);\n                    }\n                });\n            }\n        }\n        this.started = false;\n        // Always destroy any available sessions. It's possible that one or more\n        // tryShutdown() calls are in progress. Don't wait on them to finish.\n        this.sessions.forEach((channelzInfo, session)=>{\n            // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n            // recognize destroy(code) as a valid signature.\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            session.destroy(http2.constants.NGHTTP2_CANCEL);\n        });\n        this.sessions.clear();\n        if (this.channelzEnabled) {\n            channelz_1.unregisterChannelzRef(this.channelzRef);\n        }\n    }\n    register(name, handler, serialize, deserialize, type) {\n        if (this.handlers.has(name)) {\n            return false;\n        }\n        this.handlers.set(name, {\n            func: handler,\n            serialize,\n            deserialize,\n            type,\n            path: name\n        });\n        return true;\n    }\n    unregister(name) {\n        return this.handlers.delete(name);\n    }\n    start() {\n        if (this.http2ServerList.length === 0 || this.http2ServerList.every(({ server: http2Server })=>http2Server.listening !== true)) {\n            throw new Error(\"server must be bound in order to start\");\n        }\n        if (this.started === true) {\n            throw new Error(\"server is already started\");\n        }\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Starting\");\n        }\n        this.started = true;\n    }\n    tryShutdown(callback) {\n        const wrappedCallback = (error)=>{\n            if (this.channelzEnabled) {\n                channelz_1.unregisterChannelzRef(this.channelzRef);\n            }\n            callback(error);\n        };\n        let pendingChecks = 0;\n        function maybeCallback() {\n            pendingChecks--;\n            if (pendingChecks === 0) {\n                wrappedCallback();\n            }\n        }\n        // Close the server if necessary.\n        this.started = false;\n        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList){\n            if (http2Server.listening) {\n                pendingChecks++;\n                http2Server.close(()=>{\n                    if (this.channelzEnabled) {\n                        this.listenerChildrenTracker.unrefChild(ref);\n                        channelz_1.unregisterChannelzRef(ref);\n                    }\n                    maybeCallback();\n                });\n            }\n        }\n        this.sessions.forEach((channelzInfo, session)=>{\n            if (!session.closed) {\n                pendingChecks += 1;\n                session.close(maybeCallback);\n            }\n        });\n        if (pendingChecks === 0) {\n            wrappedCallback();\n        }\n    }\n    addHttp2Port() {\n        throw new Error(\"Not yet implemented\");\n    }\n    /**\n     * Get the channelz reference object for this server. The returned value is\n     * garbage if channelz is disabled for this server.\n     * @returns\n     */ getChannelzRef() {\n        return this.channelzRef;\n    }\n    _verifyContentType(stream, headers) {\n        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n        if (typeof contentType !== \"string\" || !contentType.startsWith(\"application/grpc\")) {\n            stream.respond({\n                [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n            }, {\n                endStream: true\n            });\n            return false;\n        }\n        return true;\n    }\n    _retrieveHandler(headers) {\n        const path = headers[HTTP2_HEADER_PATH];\n        this.trace(\"Received call to method \" + path + \" at address \" + this.serverAddressString);\n        const handler = this.handlers.get(path);\n        if (handler === undefined) {\n            this.trace(\"No handler registered for method \" + path + \". Sending UNIMPLEMENTED status.\");\n            throw getUnimplementedStatusResponse(path);\n        }\n        return handler;\n    }\n    _respondWithError(err, stream, channelzSessionInfo = null) {\n        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n        if (err.code === undefined) {\n            err.code = constants_1.Status.INTERNAL;\n        }\n        if (this.channelzEnabled) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n        }\n        call.sendError(err);\n    }\n    _channelzHandler(stream, headers) {\n        const channelzSessionInfo = this.sessions.get(stream.session);\n        this.callTracker.addCallStarted();\n        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n        if (!this._verifyContentType(stream, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            return;\n        }\n        let handler;\n        try {\n            handler = this._retrieveHandler(headers);\n        } catch (err) {\n            this._respondWithError(err, stream, channelzSessionInfo);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        call.once(\"callEnd\", (code)=>{\n            if (code === constants_1.Status.OK) {\n                this.callTracker.addCallSucceeded();\n            } else {\n                this.callTracker.addCallFailed();\n            }\n        });\n        if (channelzSessionInfo) {\n            call.once(\"streamEnd\", (success)=>{\n                if (success) {\n                    channelzSessionInfo.streamTracker.addCallSucceeded();\n                } else {\n                    channelzSessionInfo.streamTracker.addCallFailed();\n                }\n            });\n            call.on(\"sendMessage\", ()=>{\n                channelzSessionInfo.messagesSent += 1;\n                channelzSessionInfo.lastMessageSentTimestamp = new Date();\n            });\n            call.on(\"receiveMessage\", ()=>{\n                channelzSessionInfo.messagesReceived += 1;\n                channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n            });\n        }\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            this.callTracker.addCallFailed();\n            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _streamHandler(stream, headers) {\n        if (this._verifyContentType(stream, headers) !== true) {\n            return;\n        }\n        let handler;\n        try {\n            handler = this._retrieveHandler(headers);\n        } catch (err) {\n            this._respondWithError(err, stream, null);\n            return;\n        }\n        const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n        if (!this._runHandlerForCall(call, handler, headers)) {\n            call.sendError({\n                code: constants_1.Status.INTERNAL,\n                details: `Unknown handler type: ${handler.type}`\n            });\n        }\n    }\n    _runHandlerForCall(call, handler, headers) {\n        var _a;\n        const metadata = call.receiveMetadata(headers);\n        const encoding = (_a = metadata.get(\"grpc-encoding\")[0]) !== null && _a !== void 0 ? _a : \"identity\";\n        metadata.remove(\"grpc-encoding\");\n        const { type } = handler;\n        if (type === \"unary\") {\n            handleUnary(call, handler, metadata, encoding);\n        } else if (type === \"clientStream\") {\n            handleClientStreaming(call, handler, metadata, encoding);\n        } else if (type === \"serverStream\") {\n            handleServerStreaming(call, handler, metadata, encoding);\n        } else if (type === \"bidi\") {\n            handleBidiStreaming(call, handler, metadata, encoding);\n        } else {\n            return false;\n        }\n        return true;\n    }\n    _setupHandlers(http2Server) {\n        if (http2Server === null) {\n            return;\n        }\n        const serverAddress = http2Server.address();\n        let serverAddressString = \"null\";\n        if (serverAddress) {\n            if (typeof serverAddress === \"string\") {\n                serverAddressString = serverAddress;\n            } else {\n                serverAddressString = serverAddress.address + \":\" + serverAddress.port;\n            }\n        }\n        this.serverAddressString = serverAddressString;\n        const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n        http2Server.on(\"stream\", handler.bind(this));\n        http2Server.on(\"session\", (session)=>{\n            var _a;\n            if (!this.started) {\n                session.destroy();\n                return;\n            }\n            let channelzRef;\n            channelzRef = channelz_1.registerChannelzSocket((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : \"unknown\", this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n            const channelzSessionInfo = {\n                ref: channelzRef,\n                streamTracker: new channelz_1.ChannelzCallTracker(),\n                messagesSent: 0,\n                messagesReceived: 0,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null\n            };\n            this.sessions.set(session, channelzSessionInfo);\n            const clientAddress = session.socket.remoteAddress;\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Connection established by client \" + clientAddress);\n                this.sessionChildrenTracker.refChild(channelzRef);\n            }\n            session.on(\"close\", ()=>{\n                if (this.channelzEnabled) {\n                    this.channelzTrace.addTrace(\"CT_INFO\", \"Connection dropped by client \" + clientAddress);\n                    this.sessionChildrenTracker.unrefChild(channelzRef);\n                    channelz_1.unregisterChannelzRef(channelzRef);\n                }\n                this.sessions.delete(session);\n            });\n        });\n    }\n}\nexports.Server = Server;\nfunction handleUnary(call, handler, metadata, encoding) {\n    call.receiveUnaryMessage(encoding, (err, request)=>{\n        if (err) {\n            call.sendError(err);\n            return;\n        }\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n        handler.func(emitter, (err, value, trailer, flags)=>{\n            call.sendUnaryMessage(err, value, trailer, flags);\n        });\n    });\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n    function respond(err, value, trailer, flags) {\n        stream.destroy();\n        call.sendUnaryMessage(err, value, trailer, flags);\n    }\n    if (call.cancelled) {\n        return;\n    }\n    stream.on(\"error\", respond);\n    handler.func(stream, respond);\n}\nfunction handleServerStreaming(call, handler, metadata, encoding) {\n    call.receiveUnaryMessage(encoding, (err, request)=>{\n        if (err) {\n            call.sendError(err);\n            return;\n        }\n        if (request === undefined || call.cancelled) {\n            return;\n        }\n        const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n        handler.func(stream);\n    });\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n    const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n    if (call.cancelled) {\n        return;\n    }\n    handler.func(stream);\n} //# sourceMappingURL=server.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxjQUFjLEdBQUcsS0FBSztBQUN0QixNQUFNRyxRQUFRQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNQyxjQUFjRCxtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNRSxnQkFBZ0JGLG1CQUFPQSxDQUFDLGtGQUFlO0FBQzdDLE1BQU1HLHVCQUF1QkgsbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1JLGFBQWFKLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU1LLFVBQVVMLG1CQUFPQSxDQUFDLDBFQUFXO0FBQ25DLE1BQU1NLHVCQUF1Qk4sbUJBQU9BLENBQUMsZ0dBQXNCO0FBQzNELE1BQU1PLGVBQWVQLG1CQUFPQSxDQUFDLGdGQUFjO0FBQzNDLE1BQU1RLGFBQWFSLG1CQUFPQSxDQUFDLDRFQUFZO0FBQ3ZDLE1BQU0sRUFBRVMsaUJBQWlCLEVBQUUsR0FBR1YsTUFBTVcsU0FBUztBQUM3QyxNQUFNQyxjQUFjO0FBQ3BCLFNBQVNDLFFBQVM7QUFDbEIsU0FBU0MsK0JBQStCQyxVQUFVO0lBQzlDLE9BQU87UUFDSEMsTUFBTWQsWUFBWWUsTUFBTSxDQUFDQyxhQUFhO1FBQ3RDQyxTQUFTLENBQUMseUNBQXlDLEVBQUVKLFdBQVcsQ0FBQztJQUNyRTtBQUNKO0FBQ0EsU0FBU0ssa0JBQWtCQyxXQUFXLEVBQUVOLFVBQVU7SUFDOUMsTUFBTU8sOEJBQThCUiwrQkFBK0JDO0lBQ25FLE9BQVFNO1FBQ0osS0FBSztZQUNELE9BQU8sQ0FBQ0UsTUFBTUM7Z0JBQ1ZBLFNBQVNGLDZCQUE2QjtZQUMxQztRQUNKLEtBQUs7WUFDRCxPQUFPLENBQUNDLE1BQU1DO2dCQUNWQSxTQUFTRiw2QkFBNkI7WUFD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LFFBQVE3RCxHQUFHLEVBQUV2TCxLQUFLLEVBQUVxUixPQUFPLEVBQUVDLEtBQUs7UUFDdkN2QyxPQUFPckIsT0FBTztRQUNkak0sS0FBSzhQLGdCQUFnQixDQUFDaEcsS0FBS3ZMLE9BQU9xUixTQUFTQztJQUMvQztJQUNBLElBQUk3UCxLQUFLeVAsU0FBUyxFQUFFO1FBQ2hCO0lBQ0o7SUFDQW5DLE9BQU85RSxFQUFFLENBQUMsU0FBU21GO0lBQ25CdkIsUUFBUU0sSUFBSSxDQUFDWSxRQUFRSztBQUN6QjtBQUNBLFNBQVN3QixzQkFBc0JuUCxJQUFJLEVBQUVvTSxPQUFPLEVBQUV5QyxRQUFRLEVBQUVFLFFBQVE7SUFDNUQvTyxLQUFLdVAsbUJBQW1CLENBQUNSLFVBQVUsQ0FBQ2pGLEtBQUswRjtRQUNyQyxJQUFJMUYsS0FBSztZQUNMOUosS0FBS3FPLFNBQVMsQ0FBQ3ZFO1lBQ2Y7UUFDSjtRQUNBLElBQUkwRixZQUFZckosYUFBYW5HLEtBQUt5UCxTQUFTLEVBQUU7WUFDekM7UUFDSjtRQUNBLE1BQU1uQyxTQUFTLElBQUkxTyxjQUFjb1Isd0JBQXdCLENBQUNoUSxNQUFNNk8sVUFBVXpDLFFBQVFDLFNBQVMsRUFBRW1EO1FBQzdGcEQsUUFBUU0sSUFBSSxDQUFDWTtJQUNqQjtBQUNKO0FBQ0EsU0FBUzhCLG9CQUFvQnBQLElBQUksRUFBRW9NLE9BQU8sRUFBRXlDLFFBQVEsRUFBRUUsUUFBUTtJQUMxRCxNQUFNekIsU0FBUyxJQUFJMU8sY0FBY3FSLHNCQUFzQixDQUFDalEsTUFBTTZPLFVBQVV6QyxRQUFRQyxTQUFTLEVBQUVELFFBQVFFLFdBQVcsRUFBRXlDO0lBQ2hILElBQUkvTyxLQUFLeVAsU0FBUyxFQUFFO1FBQ2hCO0lBQ0o7SUFDQXJELFFBQVFNLElBQUksQ0FBQ1k7QUFDakIsRUFDQSxrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmVyLmpzP2E4ODIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VydmVyID0gdm9pZCAwO1xuY29uc3QgaHR0cDIgPSByZXF1aXJlKFwiaHR0cDJcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHNlcnZlcl9jYWxsXzEgPSByZXF1aXJlKFwiLi9zZXJ2ZXItY2FsbFwiKTtcbmNvbnN0IHNlcnZlcl9jcmVkZW50aWFsc18xID0gcmVxdWlyZShcIi4vc2VydmVyLWNyZWRlbnRpYWxzXCIpO1xuY29uc3QgcmVzb2x2ZXJfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmVyXCIpO1xuY29uc3QgbG9nZ2luZyA9IHJlcXVpcmUoXCIuL2xvZ2dpbmdcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBjaGFubmVsel8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHpcIik7XG5jb25zdCB7IEhUVFAyX0hFQURFUl9QQVRIIH0gPSBodHRwMi5jb25zdGFudHM7XG5jb25zdCBUUkFDRVJfTkFNRSA9ICdzZXJ2ZXInO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZnVuY3Rpb24gZ2V0VW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuVU5JTVBMRU1FTlRFRCxcbiAgICAgICAgZGV0YWlsczogYFRoZSBzZXJ2ZXIgZG9lcyBub3QgaW1wbGVtZW50IHRoZSBtZXRob2QgJHttZXRob2ROYW1lfWAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRIYW5kbGVyKGhhbmRsZXJUeXBlLCBtZXRob2ROYW1lKSB7XG4gICAgY29uc3QgdW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlID0gZ2V0VW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlKG1ldGhvZE5hbWUpO1xuICAgIHN3aXRjaCAoaGFuZGxlclR5cGUpIHtcbiAgICAgICAgY2FzZSAndW5hcnknOlxuICAgICAgICAgICAgcmV0dXJuIChjYWxsLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSwgbnVsbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdjbGllbnRTdHJlYW0nOlxuICAgICAgICAgICAgcmV0dXJuIChjYWxsLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSwgbnVsbCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdzZXJ2ZXJTdHJlYW0nOlxuICAgICAgICAgICAgcmV0dXJuIChjYWxsKSA9PiB7XG4gICAgICAgICAgICAgICAgY2FsbC5lbWl0KCdlcnJvcicsIHVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdiaWRpJzpcbiAgICAgICAgICAgIHJldHVybiAoY2FsbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNhbGwuZW1pdCgnZXJyb3InLCB1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBoYW5kbGVyVHlwZSAke2hhbmRsZXJUeXBlfWApO1xuICAgIH1cbn1cbmNsYXNzIFNlcnZlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLmh0dHAyU2VydmVyTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNlc3Npb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXJ2ZXJBZGRyZXNzU3RyaW5nID0gJ251bGwnO1xuICAgICAgICAvLyBDaGFubmVseiBJbmZvXG4gICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jaGFubmVselRyYWNlID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpUcmFjZSgpO1xuICAgICAgICB0aGlzLmNhbGxUcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uQ2hpbGRyZW5UcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge307XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbJ2dycGMuZW5hYmxlX2NoYW5uZWx6J10gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFubmVselJlZiA9IGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNlcnZlcigoKSA9PiB0aGlzLmdldENoYW5uZWx6SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ1NlcnZlciBjcmVhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnU2VydmVyIGNvbnN0cnVjdGVkJyk7XG4gICAgfVxuICAgIGdldENoYW5uZWx6SW5mbygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXG4gICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcbiAgICAgICAgICAgIGxpc3RlbmVyQ2hpbGRyZW46IHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpLFxuICAgICAgICAgICAgc2Vzc2lvbkNoaWxkcmVuOiB0aGlzLnNlc3Npb25DaGlsZHJlblRyYWNrZXIuZ2V0Q2hpbGRMaXN0cygpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldENoYW5uZWx6U2Vzc2lvbkluZm9HZXR0ZXIoc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSW5mbyA9IHRoaXMuc2Vzc2lvbnMuZ2V0KHNlc3Npb24pO1xuICAgICAgICAgICAgY29uc3Qgc2Vzc2lvblNvY2tldCA9IHNlc3Npb24uc29ja2V0O1xuICAgICAgICAgICAgY29uc3QgcmVtb3RlQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzcyA/IHN1YmNoYW5uZWxfYWRkcmVzc18xLnN0cmluZ1RvU3ViY2hhbm5lbEFkZHJlc3Moc2Vzc2lvblNvY2tldC5yZW1vdGVBZGRyZXNzLCBzZXNzaW9uU29ja2V0LnJlbW90ZVBvcnQpIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzID8gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyhzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzcywgc2Vzc2lvblNvY2tldC5sb2NhbFBvcnQpIDogbnVsbDtcbiAgICAgICAgICAgIGxldCB0bHNJbmZvO1xuICAgICAgICAgICAgaWYgKHNlc3Npb24uZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGxzU29ja2V0ID0gc2Vzc2lvblNvY2tldDtcbiAgICAgICAgICAgICAgICBjb25zdCBjaXBoZXJJbmZvID0gdGxzU29ja2V0LmdldENpcGhlcigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldENlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVlckNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldFBlZXJDZXJ0aWZpY2F0ZSgpO1xuICAgICAgICAgICAgICAgIHRsc0luZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlU3RhbmRhcmROYW1lOiAoX2EgPSBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgY2lwaGVyU3VpdGVPdGhlck5hbWU6IGNpcGhlckluZm8uc3RhbmRhcmROYW1lID8gbnVsbCA6IGNpcGhlckluZm8ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxDZXJ0aWZpY2F0ZTogKGNlcnRpZmljYXRlICYmICdyYXcnIGluIGNlcnRpZmljYXRlKSA/IGNlcnRpZmljYXRlLnJhdyA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHJlbW90ZUNlcnRpZmljYXRlOiAocGVlckNlcnRpZmljYXRlICYmICdyYXcnIGluIHBlZXJDZXJ0aWZpY2F0ZSkgPyBwZWVyQ2VydGlmaWNhdGUucmF3IDogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0bHNJbmZvID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvY2tldEluZm8gPSB7XG4gICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogcmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBsb2NhbEFkZHJlc3M6IGxvY2FsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICBzZWN1cml0eTogdGxzSW5mbyxcbiAgICAgICAgICAgICAgICByZW1vdGVOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmNhbGxzU3RhcnRlZCxcbiAgICAgICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgICAgIHN0cmVhbXNGYWlsZWQ6IHNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuY2FsbHNGYWlsZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNTZW50OiBzZXNzaW9uSW5mby5tZXNzYWdlc1NlbnQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNSZWNlaXZlZDogc2Vzc2lvbkluZm8ubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgICAgICBrZWVwQWxpdmVzU2VudDogMCxcbiAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXA6IHNlc3Npb25JbmZvLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBzZXNzaW9uSW5mby5sYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IChfYiA9IHNlc3Npb24uc3RhdGUubG9jYWxXaW5kb3dTaXplKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbW90ZUZsb3dDb250cm9sV2luZG93OiAoX2MgPSBzZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gc29ja2V0SW5mbztcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgVFJBQ0VSX05BTUUsICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICsgdGV4dCk7XG4gICAgfVxuICAgIGFkZFByb3RvU2VydmljZSgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuIFVzZSBhZGRTZXJ2aWNlKCkgaW5zdGVhZCcpO1xuICAgIH1cbiAgICBhZGRTZXJ2aWNlKHNlcnZpY2UsIGltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgIGlmIChzZXJ2aWNlID09PSBudWxsIHx8XG4gICAgICAgICAgICB0eXBlb2Ygc2VydmljZSAhPT0gJ29iamVjdCcgfHxcbiAgICAgICAgICAgIGltcGxlbWVudGF0aW9uID09PSBudWxsIHx8XG4gICAgICAgICAgICB0eXBlb2YgaW1wbGVtZW50YXRpb24gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkZFNlcnZpY2UoKSByZXF1aXJlcyB0d28gb2JqZWN0cyBhcyBhcmd1bWVudHMnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJ2aWNlS2V5cyA9IE9iamVjdC5rZXlzKHNlcnZpY2UpO1xuICAgICAgICBpZiAoc2VydmljZUtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBhZGQgYW4gZW1wdHkgc2VydmljZSB0byBhIHNlcnZlcicpO1xuICAgICAgICB9XG4gICAgICAgIHNlcnZpY2VLZXlzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gc2VydmljZVtuYW1lXTtcbiAgICAgICAgICAgIGxldCBtZXRob2RUeXBlO1xuICAgICAgICAgICAgaWYgKGF0dHJzLnJlcXVlc3RTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnMucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdiaWRpJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZFR5cGUgPSAnY2xpZW50U3RyZWFtJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cnMucmVzcG9uc2VTdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICdzZXJ2ZXJTdHJlYW0nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kVHlwZSA9ICd1bmFyeSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGltcGxGbiA9IGltcGxlbWVudGF0aW9uW25hbWVdO1xuICAgICAgICAgICAgbGV0IGltcGw7XG4gICAgICAgICAgICBpZiAoaW1wbEZuID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIGF0dHJzLm9yaWdpbmFsTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbXBsRm4gPSBpbXBsZW1lbnRhdGlvblthdHRycy5vcmlnaW5hbE5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltcGxGbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaW1wbCA9IGltcGxGbi5iaW5kKGltcGxlbWVudGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGltcGwgPSBnZXREZWZhdWx0SGFuZGxlcihtZXRob2RUeXBlLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSB0aGlzLnJlZ2lzdGVyKGF0dHJzLnBhdGgsIGltcGwsIGF0dHJzLnJlc3BvbnNlU2VyaWFsaXplLCBhdHRycy5yZXF1ZXN0RGVzZXJpYWxpemUsIG1ldGhvZFR5cGUpO1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXRob2QgaGFuZGxlciBmb3IgJHthdHRycy5wYXRofSBhbHJlYWR5IHByb3ZpZGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlU2VydmljZShzZXJ2aWNlKSB7XG4gICAgICAgIGlmIChzZXJ2aWNlID09PSBudWxsIHx8IHR5cGVvZiBzZXJ2aWNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdmVTZXJ2aWNlKCkgcmVxdWlyZXMgb2JqZWN0IGFzIGFyZ3VtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VydmljZUtleXMgPSBPYmplY3Qua2V5cyhzZXJ2aWNlKTtcbiAgICAgICAgc2VydmljZUtleXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cnMgPSBzZXJ2aWNlW25hbWVdO1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKGF0dHJzLnBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYmluZChwb3J0LCBjcmVkcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZC4gVXNlIGJpbmRBc3luYygpIGluc3RlYWQnKTtcbiAgICB9XG4gICAgYmluZEFzeW5jKHBvcnQsIGNyZWRzLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcnZlciBpcyBhbHJlYWR5IHN0YXJ0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBvcnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwb3J0IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3JlZHMgPT09IG51bGwgfHwgIShjcmVkcyBpbnN0YW5jZW9mIHNlcnZlcl9jcmVkZW50aWFsc18xLlNlcnZlckNyZWRlbnRpYWxzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY3JlZHMgbXVzdCBiZSBhIFNlcnZlckNyZWRlbnRpYWxzIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXRpYWxQb3J0VXJpID0gdXJpX3BhcnNlcl8xLnBhcnNlVXJpKHBvcnQpO1xuICAgICAgICBpZiAoaW5pdGlhbFBvcnRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHBhcnNlIHBvcnQgXCIke3BvcnR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwb3J0VXJpID0gcmVzb2x2ZXJfMS5tYXBVcmlEZWZhdWx0U2NoZW1lKGluaXRpYWxQb3J0VXJpKTtcbiAgICAgICAgaWYgKHBvcnRVcmkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGdldCBhIGRlZmF1bHQgc2NoZW1lIGZvciBwb3J0IFwiJHtwb3J0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VydmVyT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1heFNlbmRIZWFkZXJCbG9ja0xlbmd0aDogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgIH07XG4gICAgICAgIGlmICgnZ3JwYy1ub2RlLm1heF9zZXNzaW9uX21lbW9yeScgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICBzZXJ2ZXJPcHRpb25zLm1heFNlc3Npb25NZW1vcnkgPSB0aGlzLm9wdGlvbnNbJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIEJ5IGRlZmF1bHQsIHNldCBhIHZlcnkgbGFyZ2UgbWF4IHNlc3Npb24gbWVtb3J5IGxpbWl0LCB0byBlZmZlY3RpdmVseVxuICAgICAgICAgICAgICogZGlzYWJsZSBlbmZvcmNlbWVudCBvZiB0aGUgbGltaXQuIFNvbWUgdGVzdGluZyBpbmRpY2F0ZXMgdGhhdCBOb2RlJ3NcbiAgICAgICAgICAgICAqIGJlaGF2aW9yIGRlZ3JhZGVzIGJhZGx5IHdoZW4gdGhpcyBsaW1pdCBpcyByZWFjaGVkLCBzbyB3ZSBzb2x2ZSB0aGF0XG4gICAgICAgICAgICAgKiBieSBkaXNhYmxpbmcgdGhlIGNoZWNrIGVudGlyZWx5LiAqL1xuICAgICAgICAgICAgc2VydmVyT3B0aW9ucy5tYXhTZXNzaW9uTWVtb3J5ID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnIGluIHRoaXMub3B0aW9ucykge1xuICAgICAgICAgICAgc2VydmVyT3B0aW9ucy5zZXR0aW5ncyA9IHtcbiAgICAgICAgICAgICAgICBtYXhDb25jdXJyZW50U3RyZWFtczogdGhpcy5vcHRpb25zWydncnBjLm1heF9jb25jdXJyZW50X3N0cmVhbXMnXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmZXJyZWRDYWxsYmFjayA9IChlcnJvciwgcG9ydCkgPT4ge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiBjYWxsYmFjayhlcnJvciwgcG9ydCkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXR1cFNlcnZlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBodHRwMlNlcnZlcjtcbiAgICAgICAgICAgIGlmIChjcmVkcy5faXNTZWN1cmUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlY3VyZVNlcnZlck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHNlcnZlck9wdGlvbnMsIGNyZWRzLl9nZXRTZXR0aW5ncygpKTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlciA9IGh0dHAyLmNyZWF0ZVNlY3VyZVNlcnZlcihzZWN1cmVTZXJ2ZXJPcHRpb25zKTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbignc2VjdXJlQ29ubmVjdGlvbicsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogVGhlc2UgZXJyb3JzIG5lZWQgdG8gYmUgaGFuZGxlZCBieSB0aGUgdXNlciBvZiBIdHRwMlNlY3VyZVNlcnZlcixcbiAgICAgICAgICAgICAgICAgICAgICogYWNjb3JkaW5nIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzU4MjQgKi9cbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Lm9uKCdlcnJvcicsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdBbiBpbmNvbWluZyBUTFMgY29ubmVjdGlvbiBjbG9zZWQgd2l0aCBlcnJvcjogJyArIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIgPSBodHRwMi5jcmVhdGVTZXJ2ZXIoc2VydmVyT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBodHRwMlNlcnZlci5zZXRUaW1lb3V0KDAsIG5vb3ApO1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBIYW5kbGVycyhodHRwMlNlcnZlcik7XG4gICAgICAgICAgICByZXR1cm4gaHR0cDJTZXJ2ZXI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGJpbmRTcGVjaWZpY1BvcnQgPSAoYWRkcmVzc0xpc3QsIHBvcnROdW0sIHByZXZpb3VzQ291bnQpID0+IHtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzTGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgcG9ydDogcG9ydE51bSwgY291bnQ6IHByZXZpb3VzQ291bnQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYWRkcmVzc0xpc3QubWFwKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnQXR0ZW1wdGluZyB0byBiaW5kICcgKyBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpKTtcbiAgICAgICAgICAgICAgICBsZXQgYWRkcjtcbiAgICAgICAgICAgICAgICBpZiAoc3ViY2hhbm5lbF9hZGRyZXNzXzEuaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgICAgICBhZGRyID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaG9zdDogYWRkcmVzcy5ob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogcG9ydE51bSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZHIgPSBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBodHRwMlNlcnZlciA9IHNldHVwU2VydmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ0ZhaWxlZCB0byBiaW5kICcgKyBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpICsgJyB3aXRoIGVycm9yICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLm9uY2UoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmxpc3RlbihhZGRyLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZEFkZHJlc3MgPSBodHRwMlNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYm91bmRTdWJjaGFubmVsQWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYm91bmRBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGJvdW5kQWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZFN1YmNoYW5uZWxBZGRyZXNzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBib3VuZEFkZHJlc3MuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogYm91bmRBZGRyZXNzLnBvcnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoYW5uZWx6UmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpSZWYgPSBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQoc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhib3VuZFN1YmNoYW5uZWxBZGRyZXNzKSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogYm91bmRTdWJjaGFubmVsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VjdXJpdHk6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZU5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zU3VjY2VlZGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zRmFpbGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1NlbnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbEZsb3dDb250cm9sV2luZG93OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJMaXN0LnB1c2goeyBzZXJ2ZXI6IGh0dHAyU2VydmVyLCBjaGFubmVselJlZjogY2hhbm5lbHpSZWYgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCdTdWNjZXNzZnVsbHkgYm91bmQgJyArIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoYm91bmRTdWJjaGFubmVsQWRkcmVzcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgncG9ydCcgaW4gYm91bmRTdWJjaGFubmVsQWRkcmVzcyA/IGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MucG9ydCA6IHBvcnROdW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gcG9ydE51bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdGF0ZTogbXVsdGlwbGUgcG9ydCBudW1iZXJzIGFkZGVkIGZyb20gc2luZ2xlIGFkZHJlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwb3J0OiBwb3J0TnVtLFxuICAgICAgICAgICAgICAgICAgICBjb3VudDogY291bnQgKyBwcmV2aW91c0NvdW50LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYmluZFdpbGRjYXJkUG9ydCA9IChhZGRyZXNzTGlzdCkgPT4ge1xuICAgICAgICAgICAgaWYgKGFkZHJlc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBwb3J0OiAwLCBjb3VudDogMCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhZGRyZXNzTGlzdFswXTtcbiAgICAgICAgICAgIGNvbnN0IGh0dHAyU2VydmVyID0gc2V0dXBTZXJ2ZXIoKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnRmFpbGVkIHRvIGJpbmQgJyArIHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoYWRkcmVzcykgKyAnIHdpdGggZXJyb3IgJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShiaW5kV2lsZGNhcmRQb3J0KGFkZHJlc3NMaXN0LnNsaWNlKDEpKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5vbmNlKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmxpc3RlbihhZGRyZXNzLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kQWRkcmVzcyA9IGh0dHAyU2VydmVyLmFkZHJlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRTdWJjaGFubmVsQWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IGJvdW5kQWRkcmVzcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogYm91bmRBZGRyZXNzLnBvcnRcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoYW5uZWx6UmVmO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVselJlZiA9IGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldChzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGJvdW5kU3ViY2hhbm5lbEFkZHJlc3MpLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsQWRkcmVzczogYm91bmRTdWJjaGFubmVsQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVBZGRyZXNzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3VyaXR5OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZU5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N0YXJ0ZWQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtc1N1Y2NlZWRlZDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1zRmFpbGVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxGbG93Q29udHJvbFdpbmRvdzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy5jaGFubmVsekVuYWJsZWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJDaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaHR0cDJTZXJ2ZXJMaXN0LnB1c2goeyBzZXJ2ZXI6IGh0dHAyU2VydmVyLCBjaGFubmVselJlZjogY2hhbm5lbHpSZWYgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ1N1Y2Nlc3NmdWxseSBib3VuZCAnICsgc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyhib3VuZFN1YmNoYW5uZWxBZGRyZXNzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYmluZFNwZWNpZmljUG9ydChhZGRyZXNzTGlzdC5zbGljZSgxKSwgYm91bmRBZGRyZXNzLnBvcnQsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgaHR0cDJTZXJ2ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXJMaXN0ZW5lciA9IHtcbiAgICAgICAgICAgIG9uU3VjY2Vzc2Z1bFJlc29sdXRpb246IChhZGRyZXNzTGlzdCwgc2VydmljZUNvbmZpZywgc2VydmljZUNvbmZpZ0Vycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugb25seSB3YW50IG9uZSByZXNvbHV0aW9uIHJlc3VsdC4gRGlzY2FyZCBhbGwgZnV0dXJlIHJlc3VsdHNcbiAgICAgICAgICAgICAgICByZXNvbHZlckxpc3RlbmVyLm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24gPSAoKSA9PiB7IH07XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3NMaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENhbGxiYWNrKG5ldyBFcnJvcihgTm8gYWRkcmVzc2VzIHJlc29sdmVkIGZvciBwb3J0ICR7cG9ydH1gKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJpbmRSZXN1bHRQcm9taXNlO1xuICAgICAgICAgICAgICAgIGlmIChzdWJjaGFubmVsX2FkZHJlc3NfMS5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3NMaXN0WzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzc0xpc3RbMF0ucG9ydCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UgPSBiaW5kV2lsZGNhcmRQb3J0KGFkZHJlc3NMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpbmRSZXN1bHRQcm9taXNlID0gYmluZFNwZWNpZmljUG9ydChhZGRyZXNzTGlzdCwgYWRkcmVzc0xpc3RbMF0ucG9ydCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhbiBhcmJpdHJhcnkgbm9uLXplcm8gcG9ydCBmb3Igbm9uLVRDUCBhZGRyZXNzZXNcbiAgICAgICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UgPSBiaW5kU3BlY2lmaWNQb3J0KGFkZHJlc3NMaXN0LCAxLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZFJlc3VsdFByb21pc2UudGhlbigoYmluZFJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluZFJlc3VsdC5jb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JTdHJpbmcgPSBgTm8gYWRkcmVzcyBhZGRlZCBvdXQgb2YgdG90YWwgJHthZGRyZXNzTGlzdC5sZW5ndGh9IHJlc29sdmVkYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgZXJyb3JTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDYWxsYmFjayhuZXcgRXJyb3IoZXJyb3JTdHJpbmcpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaW5kUmVzdWx0LmNvdW50IDwgYWRkcmVzc0xpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2luZy5sb2coY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LklORk8sIGBXQVJOSU5HIE9ubHkgJHtiaW5kUmVzdWx0LmNvdW50fSBhZGRyZXNzZXMgYWRkZWQgb3V0IG9mIHRvdGFsICR7YWRkcmVzc0xpc3QubGVuZ3RofSByZXNvbHZlZGApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWRDYWxsYmFjayhudWxsLCBiaW5kUmVzdWx0LnBvcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yU3RyaW5nID0gYE5vIGFkZHJlc3MgYWRkZWQgb3V0IG9mIHRvdGFsICR7YWRkcmVzc0xpc3QubGVuZ3RofSByZXNvbHZlZGA7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dpbmcubG9nKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5FUlJPUiwgZXJyb3JTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICBkZWZlcnJlZENhbGxiYWNrKG5ldyBFcnJvcihlcnJvclN0cmluZyksIDApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRXJyb3I6IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkQ2FsbGJhY2sobmV3IEVycm9yKGVycm9yLmRldGFpbHMpLCAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gcmVzb2x2ZXJfMS5jcmVhdGVSZXNvbHZlcihwb3J0VXJpLCByZXNvbHZlckxpc3RlbmVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICByZXNvbHZlci51cGRhdGVSZXNvbHV0aW9uKCk7XG4gICAgfVxuICAgIGZvcmNlU2h1dGRvd24oKSB7XG4gICAgICAgIC8vIENsb3NlIHRoZSBzZXJ2ZXIgaWYgaXQgaXMgc3RpbGwgcnVubmluZy5cbiAgICAgICAgZm9yIChjb25zdCB7IHNlcnZlcjogaHR0cDJTZXJ2ZXIsIGNoYW5uZWx6UmVmOiByZWYgfSBvZiB0aGlzLmh0dHAyU2VydmVyTGlzdCkge1xuICAgICAgICAgICAgaWYgKGh0dHAyU2VydmVyLmxpc3RlbmluZykge1xuICAgICAgICAgICAgICAgIGh0dHAyU2VydmVyLmNsb3NlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyLnVucmVmQ2hpbGQocmVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKHJlZik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gQWx3YXlzIGRlc3Ryb3kgYW55IGF2YWlsYWJsZSBzZXNzaW9ucy4gSXQncyBwb3NzaWJsZSB0aGF0IG9uZSBvciBtb3JlXG4gICAgICAgIC8vIHRyeVNodXRkb3duKCkgY2FsbHMgYXJlIGluIHByb2dyZXNzLiBEb24ndCB3YWl0IG9uIHRoZW0gdG8gZmluaXNoLlxuICAgICAgICB0aGlzLnNlc3Npb25zLmZvckVhY2goKGNoYW5uZWx6SW5mbywgc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgLy8gQ2FzdCBOR0hUVFAyX0NBTkNFTCB0byBhbnkgYmVjYXVzZSBUeXBlU2NyaXB0IGRvZXNuJ3Qgc2VlbSB0b1xuICAgICAgICAgICAgLy8gcmVjb2duaXplIGRlc3Ryb3koY29kZSkgYXMgYSB2YWxpZCBzaWduYXR1cmUuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgc2Vzc2lvbi5kZXN0cm95KGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0NBTkNFTCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNlc3Npb25zLmNsZWFyKCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYodGhpcy5jaGFubmVselJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXIobmFtZSwgaGFuZGxlciwgc2VyaWFsaXplLCBkZXNlcmlhbGl6ZSwgdHlwZSkge1xuICAgICAgICBpZiAodGhpcy5oYW5kbGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRsZXJzLnNldChuYW1lLCB7XG4gICAgICAgICAgICBmdW5jOiBoYW5kbGVyLFxuICAgICAgICAgICAgc2VyaWFsaXplLFxuICAgICAgICAgICAgZGVzZXJpYWxpemUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgcGF0aDogbmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB1bnJlZ2lzdGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlcnMuZGVsZXRlKG5hbWUpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaHR0cDJTZXJ2ZXJMaXN0Lmxlbmd0aCA9PT0gMCB8fFxuICAgICAgICAgICAgdGhpcy5odHRwMlNlcnZlckxpc3QuZXZlcnkoKHsgc2VydmVyOiBodHRwMlNlcnZlciB9KSA9PiBodHRwMlNlcnZlci5saXN0ZW5pbmcgIT09IHRydWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlcnZlciBtdXN0IGJlIGJvdW5kIGluIG9yZGVyIHRvIHN0YXJ0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXJ2ZXIgaXMgYWxyZWFkeSBzdGFydGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU3RhcnRpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0cnlTaHV0ZG93bihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCB3cmFwcGVkQ2FsbGJhY2sgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKHRoaXMuY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICBsZXQgcGVuZGluZ0NoZWNrcyA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIG1heWJlQ2FsbGJhY2soKSB7XG4gICAgICAgICAgICBwZW5kaW5nQ2hlY2tzLS07XG4gICAgICAgICAgICBpZiAocGVuZGluZ0NoZWNrcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIENsb3NlIHRoZSBzZXJ2ZXIgaWYgbmVjZXNzYXJ5LlxuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCB7IHNlcnZlcjogaHR0cDJTZXJ2ZXIsIGNoYW5uZWx6UmVmOiByZWYgfSBvZiB0aGlzLmh0dHAyU2VydmVyTGlzdCkge1xuICAgICAgICAgICAgaWYgKGh0dHAyU2VydmVyLmxpc3RlbmluZykge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdDaGVja3MrKztcbiAgICAgICAgICAgICAgICBodHRwMlNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lckNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKHJlZik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZihyZWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1heWJlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb25zLmZvckVhY2goKGNoYW5uZWx6SW5mbywgc2Vzc2lvbikgPT4ge1xuICAgICAgICAgICAgaWYgKCFzZXNzaW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdDaGVja3MgKz0gMTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uLmNsb3NlKG1heWJlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHBlbmRpbmdDaGVja3MgPT09IDApIHtcbiAgICAgICAgICAgIHdyYXBwZWRDYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEh0dHAyUG9ydCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgeWV0IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY2hhbm5lbHogcmVmZXJlbmNlIG9iamVjdCBmb3IgdGhpcyBzZXJ2ZXIuIFRoZSByZXR1cm5lZCB2YWx1ZSBpc1xuICAgICAqIGdhcmJhZ2UgaWYgY2hhbm5lbHogaXMgZGlzYWJsZWQgZm9yIHRoaXMgc2VydmVyLlxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBfdmVyaWZ5Q29udGVudFR5cGUoc3RyZWFtLCBoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gaGVhZGVyc1todHRwMi5jb25zdGFudHMuSFRUUDJfSEVBREVSX0NPTlRFTlRfVFlQRV07XG4gICAgICAgIGlmICh0eXBlb2YgY29udGVudFR5cGUgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICAgICAhY29udGVudFR5cGUuc3RhcnRzV2l0aCgnYXBwbGljYXRpb24vZ3JwYycpKSB7XG4gICAgICAgICAgICBzdHJlYW0ucmVzcG9uZCh7XG4gICAgICAgICAgICAgICAgW2h0dHAyLmNvbnN0YW50cy5IVFRQMl9IRUFERVJfU1RBVFVTXTogaHR0cDIuY29uc3RhbnRzLkhUVFBfU1RBVFVTX1VOU1VQUE9SVEVEX01FRElBX1RZUEUsXG4gICAgICAgICAgICB9LCB7IGVuZFN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgX3JldHJpZXZlSGFuZGxlcihoZWFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXTtcbiAgICAgICAgdGhpcy50cmFjZSgnUmVjZWl2ZWQgY2FsbCB0byBtZXRob2QgJyArXG4gICAgICAgICAgICBwYXRoICtcbiAgICAgICAgICAgICcgYXQgYWRkcmVzcyAnICtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyQWRkcmVzc1N0cmluZyk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzLmdldChwYXRoKTtcbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnTm8gaGFuZGxlciByZWdpc3RlcmVkIGZvciBtZXRob2QgJyArXG4gICAgICAgICAgICAgICAgcGF0aCArXG4gICAgICAgICAgICAgICAgJy4gU2VuZGluZyBVTklNUExFTUVOVEVEIHN0YXR1cy4nKTtcbiAgICAgICAgICAgIHRocm93IGdldFVuaW1wbGVtZW50ZWRTdGF0dXNSZXNwb25zZShwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG4gICAgX3Jlc3BvbmRXaXRoRXJyb3IoZXJyLCBzdHJlYW0sIGNoYW5uZWx6U2Vzc2lvbkluZm8gPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNhbGwgPSBuZXcgc2VydmVyX2NhbGxfMS5IdHRwMlNlcnZlckNhbGxTdHJlYW0oc3RyZWFtLCBudWxsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAoZXJyLmNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZXJyLmNvZGUgPSBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IG51bGwgfHwgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgIH1cbiAgICBfY2hhbm5lbHpIYW5kbGVyKHN0cmVhbSwgaGVhZGVycykge1xuICAgICAgICBjb25zdCBjaGFubmVselNlc3Npb25JbmZvID0gdGhpcy5zZXNzaW9ucy5nZXQoc3RyZWFtLnNlc3Npb24pO1xuICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IG51bGwgfHwgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxTdGFydGVkKCk7XG4gICAgICAgIGlmICghdGhpcy5fdmVyaWZ5Q29udGVudFR5cGUoc3RyZWFtLCBoZWFkZXJzKSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvID09PSBudWxsIHx8IGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhbmRsZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5fcmV0cmlldmVIYW5kbGVyKGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbmRXaXRoRXJyb3IoZXJyLCBzdHJlYW0sIGNoYW5uZWx6U2Vzc2lvbkluZm8pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGwgPSBuZXcgc2VydmVyX2NhbGxfMS5IdHRwMlNlcnZlckNhbGxTdHJlYW0oc3RyZWFtLCBoYW5kbGVyLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBjYWxsLm9uY2UoJ2NhbGxFbmQnLCAoY29kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZGUgPT09IGNvbnN0YW50c18xLlN0YXR1cy5PSykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbFRyYWNrZXIuYWRkQ2FsbFN1Y2NlZWRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsRmFpbGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY2hhbm5lbHpTZXNzaW9uSW5mbykge1xuICAgICAgICAgICAgY2FsbC5vbmNlKCdzdHJlYW1FbmQnLCAoc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8uc3RyZWFtVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FsbC5vbignc2VuZE1lc3NhZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbHpTZXNzaW9uSW5mby5tZXNzYWdlc1NlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICBjaGFubmVselNlc3Npb25JbmZvLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhbGwub24oJ3JlY2VpdmVNZXNzYWdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubWVzc2FnZXNSZWNlaXZlZCArPSAxO1xuICAgICAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8ubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3J1bkhhbmRsZXJGb3JDYWxsKGNhbGwsIGhhbmRsZXIsIGhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgIGNoYW5uZWx6U2Vzc2lvbkluZm8gPT09IG51bGwgfHwgY2hhbm5lbHpTZXNzaW9uSW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhbm5lbHpTZXNzaW9uSW5mby5zdHJlYW1UcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgIGNhbGwuc2VuZEVycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFVua25vd24gaGFuZGxlciB0eXBlOiAke2hhbmRsZXIudHlwZX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3RyZWFtSGFuZGxlcihzdHJlYW0sIGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZlcmlmeUNvbnRlbnRUeXBlKHN0cmVhbSwgaGVhZGVycykgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFuZGxlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzLl9yZXRyaWV2ZUhhbmRsZXIoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uZFdpdGhFcnJvcihlcnIsIHN0cmVhbSwgbnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbCA9IG5ldyBzZXJ2ZXJfY2FsbF8xLkh0dHAyU2VydmVyQ2FsbFN0cmVhbShzdHJlYW0sIGhhbmRsZXIsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGlmICghdGhpcy5fcnVuSGFuZGxlckZvckNhbGwoY2FsbCwgaGFuZGxlciwgaGVhZGVycykpIHtcbiAgICAgICAgICAgIGNhbGwuc2VuZEVycm9yKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBjb25zdGFudHNfMS5TdGF0dXMuSU5URVJOQUwsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogYFVua25vd24gaGFuZGxlciB0eXBlOiAke2hhbmRsZXIudHlwZX1gXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcnVuSGFuZGxlckZvckNhbGwoY2FsbCwgaGFuZGxlciwgaGVhZGVycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gY2FsbC5yZWNlaXZlTWV0YWRhdGEoaGVhZGVycyk7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gKF9hID0gbWV0YWRhdGEuZ2V0KCdncnBjLWVuY29kaW5nJylbMF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdpZGVudGl0eSc7XG4gICAgICAgIG1ldGFkYXRhLnJlbW92ZSgnZ3JwYy1lbmNvZGluZycpO1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IGhhbmRsZXI7XG4gICAgICAgIGlmICh0eXBlID09PSAndW5hcnknKSB7XG4gICAgICAgICAgICBoYW5kbGVVbmFyeShjYWxsLCBoYW5kbGVyLCBtZXRhZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdjbGllbnRTdHJlYW0nKSB7XG4gICAgICAgICAgICBoYW5kbGVDbGllbnRTdHJlYW1pbmcoY2FsbCwgaGFuZGxlciwgbWV0YWRhdGEsIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnc2VydmVyU3RyZWFtJykge1xuICAgICAgICAgICAgaGFuZGxlU2VydmVyU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2JpZGknKSB7XG4gICAgICAgICAgICBoYW5kbGVCaWRpU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIF9zZXR1cEhhbmRsZXJzKGh0dHAyU2VydmVyKSB7XG4gICAgICAgIGlmIChodHRwMlNlcnZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcnZlckFkZHJlc3MgPSBodHRwMlNlcnZlci5hZGRyZXNzKCk7XG4gICAgICAgIGxldCBzZXJ2ZXJBZGRyZXNzU3RyaW5nID0gJ251bGwnO1xuICAgICAgICBpZiAoc2VydmVyQWRkcmVzcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJ2ZXJBZGRyZXNzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VydmVyQWRkcmVzc1N0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckFkZHJlc3MuYWRkcmVzcyArICc6JyArIHNlcnZlckFkZHJlc3MucG9ydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlckFkZHJlc3NTdHJpbmcgPSBzZXJ2ZXJBZGRyZXNzU3RyaW5nO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5jaGFubmVsekVuYWJsZWRcbiAgICAgICAgICAgID8gdGhpcy5fY2hhbm5lbHpIYW5kbGVyXG4gICAgICAgICAgICA6IHRoaXMuX3N0cmVhbUhhbmRsZXI7XG4gICAgICAgIGh0dHAyU2VydmVyLm9uKCdzdHJlYW0nLCBoYW5kbGVyLmJpbmQodGhpcykpO1xuICAgICAgICBodHRwMlNlcnZlci5vbignc2Vzc2lvbicsIChzZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIHNlc3Npb24uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjaGFubmVselJlZjtcbiAgICAgICAgICAgIGNoYW5uZWx6UmVmID0gY2hhbm5lbHpfMS5yZWdpc3RlckNoYW5uZWx6U29ja2V0KChfYSA9IHNlc3Npb24uc29ja2V0LnJlbW90ZUFkZHJlc3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd1bmtub3duJywgdGhpcy5nZXRDaGFubmVselNlc3Npb25JbmZvR2V0dGVyKHNlc3Npb24pLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVselNlc3Npb25JbmZvID0ge1xuICAgICAgICAgICAgICAgIHJlZjogY2hhbm5lbHpSZWYsXG4gICAgICAgICAgICAgICAgc3RyZWFtVHJhY2tlcjogbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzU2VudDogMCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlc1JlY2VpdmVkOiAwLFxuICAgICAgICAgICAgICAgIGxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcDogbnVsbCxcbiAgICAgICAgICAgICAgICBsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9ucy5zZXQoc2Vzc2lvbiwgY2hhbm5lbHpTZXNzaW9uSW5mbyk7XG4gICAgICAgICAgICBjb25zdCBjbGllbnRBZGRyZXNzID0gc2Vzc2lvbi5zb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsICdDb25uZWN0aW9uIGVzdGFibGlzaGVkIGJ5IGNsaWVudCAnICsgY2xpZW50QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uQ2hpbGRyZW5UcmFja2VyLnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlc3Npb24ub24oJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnQ29ubmVjdGlvbiBkcm9wcGVkIGJ5IGNsaWVudCAnICsgY2xpZW50QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbkNoaWxkcmVuVHJhY2tlci51bnJlZkNoaWxkKGNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHpfMS51bnJlZ2lzdGVyQ2hhbm5lbHpSZWYoY2hhbm5lbHpSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb25zLmRlbGV0ZShzZXNzaW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlciA9IFNlcnZlcjtcbmZ1bmN0aW9uIGhhbmRsZVVuYXJ5KGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZykge1xuICAgIGNhbGwucmVjZWl2ZVVuYXJ5TWVzc2FnZShlbmNvZGluZywgKGVyciwgcmVxdWVzdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQgfHwgY2FsbC5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gbmV3IHNlcnZlcl9jYWxsXzEuU2VydmVyVW5hcnlDYWxsSW1wbChjYWxsLCBtZXRhZGF0YSwgcmVxdWVzdCk7XG4gICAgICAgIGhhbmRsZXIuZnVuYyhlbWl0dGVyLCAoZXJyLCB2YWx1ZSwgdHJhaWxlciwgZmxhZ3MpID0+IHtcbiAgICAgICAgICAgIGNhbGwuc2VuZFVuYXJ5TWVzc2FnZShlcnIsIHZhbHVlLCB0cmFpbGVyLCBmbGFncyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaGFuZGxlQ2xpZW50U3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZykge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlclJlYWRhYmxlU3RyZWFtSW1wbChjYWxsLCBtZXRhZGF0YSwgaGFuZGxlci5kZXNlcmlhbGl6ZSwgZW5jb2RpbmcpO1xuICAgIGZ1bmN0aW9uIHJlc3BvbmQoZXJyLCB2YWx1ZSwgdHJhaWxlciwgZmxhZ3MpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgY2FsbC5zZW5kVW5hcnlNZXNzYWdlKGVyciwgdmFsdWUsIHRyYWlsZXIsIGZsYWdzKTtcbiAgICB9XG4gICAgaWYgKGNhbGwuY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlc3BvbmQpO1xuICAgIGhhbmRsZXIuZnVuYyhzdHJlYW0sIHJlc3BvbmQpO1xufVxuZnVuY3Rpb24gaGFuZGxlU2VydmVyU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZykge1xuICAgIGNhbGwucmVjZWl2ZVVuYXJ5TWVzc2FnZShlbmNvZGluZywgKGVyciwgcmVxdWVzdCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBjYWxsLnNlbmRFcnJvcihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1ZXN0ID09PSB1bmRlZmluZWQgfHwgY2FsbC5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgc2VydmVyX2NhbGxfMS5TZXJ2ZXJXcml0YWJsZVN0cmVhbUltcGwoY2FsbCwgbWV0YWRhdGEsIGhhbmRsZXIuc2VyaWFsaXplLCByZXF1ZXN0KTtcbiAgICAgICAgaGFuZGxlci5mdW5jKHN0cmVhbSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBoYW5kbGVCaWRpU3RyZWFtaW5nKGNhbGwsIGhhbmRsZXIsIG1ldGFkYXRhLCBlbmNvZGluZykge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBzZXJ2ZXJfY2FsbF8xLlNlcnZlckR1cGxleFN0cmVhbUltcGwoY2FsbCwgbWV0YWRhdGEsIGhhbmRsZXIuc2VyaWFsaXplLCBoYW5kbGVyLmRlc2VyaWFsaXplLCBlbmNvZGluZyk7XG4gICAgaWYgKGNhbGwuY2FuY2VsbGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlci5mdW5jKHN0cmVhbSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJ2ZXIuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU2VydmVyIiwiaHR0cDIiLCJyZXF1aXJlIiwiY29uc3RhbnRzXzEiLCJzZXJ2ZXJfY2FsbF8xIiwic2VydmVyX2NyZWRlbnRpYWxzXzEiLCJyZXNvbHZlcl8xIiwibG9nZ2luZyIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwidXJpX3BhcnNlcl8xIiwiY2hhbm5lbHpfMSIsIkhUVFAyX0hFQURFUl9QQVRIIiwiY29uc3RhbnRzIiwiVFJBQ0VSX05BTUUiLCJub29wIiwiZ2V0VW5pbXBsZW1lbnRlZFN0YXR1c1Jlc3BvbnNlIiwibWV0aG9kTmFtZSIsImNvZGUiLCJTdGF0dXMiLCJVTklNUExFTUVOVEVEIiwiZGV0YWlscyIsImdldERlZmF1bHRIYW5kbGVyIiwiaGFuZGxlclR5cGUiLCJ1bmltcGxlbWVudGVkU3RhdHVzUmVzcG9uc2UiLCJjYWxsIiwiY2FsbGJhY2siLCJlbWl0IiwiRXJyb3IiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJodHRwMlNlcnZlckxpc3QiLCJoYW5kbGVycyIsIk1hcCIsInNlc3Npb25zIiwic3RhcnRlZCIsInNlcnZlckFkZHJlc3NTdHJpbmciLCJjaGFubmVsekVuYWJsZWQiLCJjaGFubmVselRyYWNlIiwiQ2hhbm5lbHpUcmFjZSIsImNhbGxUcmFja2VyIiwiQ2hhbm5lbHpDYWxsVHJhY2tlciIsImxpc3RlbmVyQ2hpbGRyZW5UcmFja2VyIiwiQ2hhbm5lbHpDaGlsZHJlblRyYWNrZXIiLCJzZXNzaW9uQ2hpbGRyZW5UcmFja2VyIiwiY2hhbm5lbHpSZWYiLCJyZWdpc3RlckNoYW5uZWx6U2VydmVyIiwiZ2V0Q2hhbm5lbHpJbmZvIiwiYWRkVHJhY2UiLCJ0cmFjZSIsImxpc3RlbmVyQ2hpbGRyZW4iLCJnZXRDaGlsZExpc3RzIiwic2Vzc2lvbkNoaWxkcmVuIiwiZ2V0Q2hhbm5lbHpTZXNzaW9uSW5mb0dldHRlciIsInNlc3Npb24iLCJfYSIsIl9iIiwiX2MiLCJzZXNzaW9uSW5mbyIsImdldCIsInNlc3Npb25Tb2NrZXQiLCJzb2NrZXQiLCJyZW1vdGVBZGRyZXNzIiwic3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyIsInJlbW90ZVBvcnQiLCJsb2NhbEFkZHJlc3MiLCJsb2NhbFBvcnQiLCJ0bHNJbmZvIiwiZW5jcnlwdGVkIiwidGxzU29ja2V0IiwiY2lwaGVySW5mbyIsImdldENpcGhlciIsImNlcnRpZmljYXRlIiwiZ2V0Q2VydGlmaWNhdGUiLCJwZWVyQ2VydGlmaWNhdGUiLCJnZXRQZWVyQ2VydGlmaWNhdGUiLCJjaXBoZXJTdWl0ZVN0YW5kYXJkTmFtZSIsInN0YW5kYXJkTmFtZSIsImNpcGhlclN1aXRlT3RoZXJOYW1lIiwibmFtZSIsImxvY2FsQ2VydGlmaWNhdGUiLCJyYXciLCJyZW1vdGVDZXJ0aWZpY2F0ZSIsInNvY2tldEluZm8iLCJzZWN1cml0eSIsInJlbW90ZU5hbWUiLCJzdHJlYW1zU3RhcnRlZCIsInN0cmVhbVRyYWNrZXIiLCJjYWxsc1N0YXJ0ZWQiLCJzdHJlYW1zU3VjY2VlZGVkIiwiY2FsbHNTdWNjZWVkZWQiLCJzdHJlYW1zRmFpbGVkIiwiY2FsbHNGYWlsZWQiLCJtZXNzYWdlc1NlbnQiLCJtZXNzYWdlc1JlY2VpdmVkIiwia2VlcEFsaXZlc1NlbnQiLCJsYXN0TG9jYWxTdHJlYW1DcmVhdGVkVGltZXN0YW1wIiwibGFzdFJlbW90ZVN0cmVhbUNyZWF0ZWRUaW1lc3RhbXAiLCJsYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAiLCJsYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAiLCJsYXN0TWVzc2FnZVJlY2VpdmVkVGltZXN0YW1wIiwibG9jYWxGbG93Q29udHJvbFdpbmRvdyIsInN0YXRlIiwibG9jYWxXaW5kb3dTaXplIiwicmVtb3RlRmxvd0NvbnRyb2xXaW5kb3ciLCJyZW1vdGVXaW5kb3dTaXplIiwidGV4dCIsIkxvZ1ZlcmJvc2l0eSIsIkRFQlVHIiwiaWQiLCJhZGRQcm90b1NlcnZpY2UiLCJhZGRTZXJ2aWNlIiwic2VydmljZSIsImltcGxlbWVudGF0aW9uIiwic2VydmljZUtleXMiLCJrZXlzIiwibGVuZ3RoIiwiZm9yRWFjaCIsImF0dHJzIiwibWV0aG9kVHlwZSIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsImltcGxGbiIsImltcGwiLCJ1bmRlZmluZWQiLCJvcmlnaW5hbE5hbWUiLCJiaW5kIiwic3VjY2VzcyIsInJlZ2lzdGVyIiwicGF0aCIsInJlc3BvbnNlU2VyaWFsaXplIiwicmVxdWVzdERlc2VyaWFsaXplIiwicmVtb3ZlU2VydmljZSIsInVucmVnaXN0ZXIiLCJwb3J0IiwiY3JlZHMiLCJiaW5kQXN5bmMiLCJUeXBlRXJyb3IiLCJTZXJ2ZXJDcmVkZW50aWFscyIsImluaXRpYWxQb3J0VXJpIiwicGFyc2VVcmkiLCJwb3J0VXJpIiwibWFwVXJpRGVmYXVsdFNjaGVtZSIsInNlcnZlck9wdGlvbnMiLCJtYXhTZW5kSGVhZGVyQmxvY2tMZW5ndGgiLCJOdW1iZXIiLCJNQVhfU0FGRV9JTlRFR0VSIiwibWF4U2Vzc2lvbk1lbW9yeSIsInNldHRpbmdzIiwibWF4Q29uY3VycmVudFN0cmVhbXMiLCJkZWZlcnJlZENhbGxiYWNrIiwiZXJyb3IiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJzZXR1cFNlcnZlciIsImh0dHAyU2VydmVyIiwiX2lzU2VjdXJlIiwic2VjdXJlU2VydmVyT3B0aW9ucyIsImFzc2lnbiIsIl9nZXRTZXR0aW5ncyIsImNyZWF0ZVNlY3VyZVNlcnZlciIsIm9uIiwiZSIsIm1lc3NhZ2UiLCJjcmVhdGVTZXJ2ZXIiLCJzZXRUaW1lb3V0IiwiX3NldHVwSGFuZGxlcnMiLCJiaW5kU3BlY2lmaWNQb3J0IiwiYWRkcmVzc0xpc3QiLCJwb3J0TnVtIiwicHJldmlvdXNDb3VudCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY291bnQiLCJhbGwiLCJtYXAiLCJhZGRyZXNzIiwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyIsImFkZHIiLCJpc1RjcFN1YmNoYW5uZWxBZGRyZXNzIiwiaG9zdCIsInJlamVjdCIsIm9uRXJyb3IiLCJlcnIiLCJvbmNlIiwibGlzdGVuIiwiYm91bmRBZGRyZXNzIiwiYm91bmRTdWJjaGFubmVsQWRkcmVzcyIsInJlZ2lzdGVyQ2hhbm5lbHpTb2NrZXQiLCJyZWZDaGlsZCIsInB1c2giLCJzZXJ2ZXIiLCJyZW1vdmVMaXN0ZW5lciIsInRoZW4iLCJyZXN1bHRzIiwicmVzdWx0IiwiYmluZFdpbGRjYXJkUG9ydCIsInNsaWNlIiwicmVzb2x2ZXJMaXN0ZW5lciIsIm9uU3VjY2Vzc2Z1bFJlc29sdXRpb24iLCJzZXJ2aWNlQ29uZmlnIiwic2VydmljZUNvbmZpZ0Vycm9yIiwiYmluZFJlc3VsdFByb21pc2UiLCJiaW5kUmVzdWx0IiwiZXJyb3JTdHJpbmciLCJsb2ciLCJFUlJPUiIsIklORk8iLCJyZXNvbHZlciIsImNyZWF0ZVJlc29sdmVyIiwidXBkYXRlUmVzb2x1dGlvbiIsImZvcmNlU2h1dGRvd24iLCJyZWYiLCJsaXN0ZW5pbmciLCJjbG9zZSIsInVucmVmQ2hpbGQiLCJ1bnJlZ2lzdGVyQ2hhbm5lbHpSZWYiLCJjaGFubmVsekluZm8iLCJkZXN0cm95IiwiTkdIVFRQMl9DQU5DRUwiLCJjbGVhciIsImhhbmRsZXIiLCJzZXJpYWxpemUiLCJkZXNlcmlhbGl6ZSIsInR5cGUiLCJoYXMiLCJzZXQiLCJmdW5jIiwiZGVsZXRlIiwic3RhcnQiLCJldmVyeSIsInRyeVNodXRkb3duIiwid3JhcHBlZENhbGxiYWNrIiwicGVuZGluZ0NoZWNrcyIsIm1heWJlQ2FsbGJhY2siLCJjbG9zZWQiLCJhZGRIdHRwMlBvcnQiLCJnZXRDaGFubmVselJlZiIsIl92ZXJpZnlDb250ZW50VHlwZSIsInN0cmVhbSIsImhlYWRlcnMiLCJjb250ZW50VHlwZSIsIkhUVFAyX0hFQURFUl9DT05URU5UX1RZUEUiLCJzdGFydHNXaXRoIiwicmVzcG9uZCIsIkhUVFAyX0hFQURFUl9TVEFUVVMiLCJIVFRQX1NUQVRVU19VTlNVUFBPUlRFRF9NRURJQV9UWVBFIiwiZW5kU3RyZWFtIiwiX3JldHJpZXZlSGFuZGxlciIsIl9yZXNwb25kV2l0aEVycm9yIiwiY2hhbm5lbHpTZXNzaW9uSW5mbyIsIkh0dHAyU2VydmVyQ2FsbFN0cmVhbSIsIklOVEVSTkFMIiwiYWRkQ2FsbEZhaWxlZCIsInNlbmRFcnJvciIsIl9jaGFubmVsekhhbmRsZXIiLCJhZGRDYWxsU3RhcnRlZCIsIk9LIiwiYWRkQ2FsbFN1Y2NlZWRlZCIsIkRhdGUiLCJfcnVuSGFuZGxlckZvckNhbGwiLCJfc3RyZWFtSGFuZGxlciIsIm1ldGFkYXRhIiwicmVjZWl2ZU1ldGFkYXRhIiwiZW5jb2RpbmciLCJyZW1vdmUiLCJoYW5kbGVVbmFyeSIsImhhbmRsZUNsaWVudFN0cmVhbWluZyIsImhhbmRsZVNlcnZlclN0cmVhbWluZyIsImhhbmRsZUJpZGlTdHJlYW1pbmciLCJzZXJ2ZXJBZGRyZXNzIiwiY2xpZW50QWRkcmVzcyIsInJlY2VpdmVVbmFyeU1lc3NhZ2UiLCJyZXF1ZXN0IiwiY2FuY2VsbGVkIiwiZW1pdHRlciIsIlNlcnZlclVuYXJ5Q2FsbEltcGwiLCJ0cmFpbGVyIiwiZmxhZ3MiLCJzZW5kVW5hcnlNZXNzYWdlIiwiU2VydmVyUmVhZGFibGVTdHJlYW1JbXBsIiwiU2VydmVyV3JpdGFibGVTdHJlYW1JbXBsIiwiU2VydmVyRHVwbGV4U3RyZWFtSW1wbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/server.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/service-config.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.extractAndSelectServiceConfig = exports.validateServiceConfig = void 0;\n/* This file implements gRFC A2 and the service config spec:\n * https://github.com/grpc/proposal/blob/master/A2-service-configs-in-dns.md\n * https://github.com/grpc/grpc/blob/master/doc/service_config.md. Each\n * function here takes an object with unknown structure and returns its\n * specific object type if the input has the right structure, and throws an\n * error otherwise. */ /* The any type is purposely used here. All functions validate their input at\n * runtime */ /* eslint-disable @typescript-eslint/no-explicit-any */ const os = __webpack_require__(/*! os */ \"os\");\nconst load_balancer_1 = __webpack_require__(/*! ./load-balancer */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/load-balancer.js\");\n/**\n * Recognizes a number with up to 9 digits after the decimal point, followed by\n * an \"s\", representing a number of seconds.\n */ const TIMEOUT_REGEX = /^\\d+(\\.\\d{1,9})?s$/;\n/**\n * Client language name used for determining whether this client matches a\n * `ServiceConfigCanaryConfig`'s `clientLanguage` list.\n */ const CLIENT_LANGUAGE_STRING = \"node\";\nfunction validateName(obj) {\n    if (!(\"service\" in obj) || typeof obj.service !== \"string\") {\n        throw new Error(\"Invalid method config name: invalid service\");\n    }\n    const result = {\n        service: obj.service\n    };\n    if (\"method\" in obj) {\n        if (typeof obj.method === \"string\") {\n            result.method = obj.method;\n        } else {\n            throw new Error(\"Invalid method config name: invalid method\");\n        }\n    }\n    return result;\n}\nfunction validateMethodConfig(obj) {\n    var _a;\n    const result = {\n        name: []\n    };\n    if (!(\"name\" in obj) || !Array.isArray(obj.name)) {\n        throw new Error(\"Invalid method config: invalid name array\");\n    }\n    for (const name of obj.name){\n        result.name.push(validateName(name));\n    }\n    if (\"waitForReady\" in obj) {\n        if (typeof obj.waitForReady !== \"boolean\") {\n            throw new Error(\"Invalid method config: invalid waitForReady\");\n        }\n        result.waitForReady = obj.waitForReady;\n    }\n    if (\"timeout\" in obj) {\n        if (typeof obj.timeout === \"object\") {\n            if (!(\"seconds\" in obj.timeout) || !(typeof obj.timeout.seconds === \"number\")) {\n                throw new Error(\"Invalid method config: invalid timeout.seconds\");\n            }\n            if (!(\"nanos\" in obj.timeout) || !(typeof obj.timeout.nanos === \"number\")) {\n                throw new Error(\"Invalid method config: invalid timeout.nanos\");\n            }\n            result.timeout = obj.timeout;\n        } else if (typeof obj.timeout === \"string\" && TIMEOUT_REGEX.test(obj.timeout)) {\n            const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split(\".\");\n            result.timeout = {\n                seconds: timeoutParts[0] | 0,\n                nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0\n            };\n        } else {\n            throw new Error(\"Invalid method config: invalid timeout\");\n        }\n    }\n    if (\"maxRequestBytes\" in obj) {\n        if (typeof obj.maxRequestBytes !== \"number\") {\n            throw new Error(\"Invalid method config: invalid maxRequestBytes\");\n        }\n        result.maxRequestBytes = obj.maxRequestBytes;\n    }\n    if (\"maxResponseBytes\" in obj) {\n        if (typeof obj.maxResponseBytes !== \"number\") {\n            throw new Error(\"Invalid method config: invalid maxRequestBytes\");\n        }\n        result.maxResponseBytes = obj.maxResponseBytes;\n    }\n    return result;\n}\nfunction validateServiceConfig(obj) {\n    const result = {\n        loadBalancingConfig: [],\n        methodConfig: []\n    };\n    if (\"loadBalancingPolicy\" in obj) {\n        if (typeof obj.loadBalancingPolicy === \"string\") {\n            result.loadBalancingPolicy = obj.loadBalancingPolicy;\n        } else {\n            throw new Error(\"Invalid service config: invalid loadBalancingPolicy\");\n        }\n    }\n    if (\"loadBalancingConfig\" in obj) {\n        if (Array.isArray(obj.loadBalancingConfig)) {\n            for (const config of obj.loadBalancingConfig){\n                result.loadBalancingConfig.push(load_balancer_1.validateLoadBalancingConfig(config));\n            }\n        } else {\n            throw new Error(\"Invalid service config: invalid loadBalancingConfig\");\n        }\n    }\n    if (\"methodConfig\" in obj) {\n        if (Array.isArray(obj.methodConfig)) {\n            for (const methodConfig of obj.methodConfig){\n                result.methodConfig.push(validateMethodConfig(methodConfig));\n            }\n        }\n    }\n    // Validate method name uniqueness\n    const seenMethodNames = [];\n    for (const methodConfig of result.methodConfig){\n        for (const name of methodConfig.name){\n            for (const seenName of seenMethodNames){\n                if (name.service === seenName.service && name.method === seenName.method) {\n                    throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);\n                }\n            }\n            seenMethodNames.push(name);\n        }\n    }\n    return result;\n}\nexports.validateServiceConfig = validateServiceConfig;\nfunction validateCanaryConfig(obj) {\n    if (!(\"serviceConfig\" in obj)) {\n        throw new Error(\"Invalid service config choice: missing service config\");\n    }\n    const result = {\n        serviceConfig: validateServiceConfig(obj.serviceConfig)\n    };\n    if (\"clientLanguage\" in obj) {\n        if (Array.isArray(obj.clientLanguage)) {\n            result.clientLanguage = [];\n            for (const lang of obj.clientLanguage){\n                if (typeof lang === \"string\") {\n                    result.clientLanguage.push(lang);\n                } else {\n                    throw new Error(\"Invalid service config choice: invalid clientLanguage\");\n                }\n            }\n        } else {\n            throw new Error(\"Invalid service config choice: invalid clientLanguage\");\n        }\n    }\n    if (\"clientHostname\" in obj) {\n        if (Array.isArray(obj.clientHostname)) {\n            result.clientHostname = [];\n            for (const lang of obj.clientHostname){\n                if (typeof lang === \"string\") {\n                    result.clientHostname.push(lang);\n                } else {\n                    throw new Error(\"Invalid service config choice: invalid clientHostname\");\n                }\n            }\n        } else {\n            throw new Error(\"Invalid service config choice: invalid clientHostname\");\n        }\n    }\n    if (\"percentage\" in obj) {\n        if (typeof obj.percentage === \"number\" && 0 <= obj.percentage && obj.percentage <= 100) {\n            result.percentage = obj.percentage;\n        } else {\n            throw new Error(\"Invalid service config choice: invalid percentage\");\n        }\n    }\n    // Validate that no unexpected fields are present\n    const allowedFields = [\n        \"clientLanguage\",\n        \"percentage\",\n        \"clientHostname\",\n        \"serviceConfig\"\n    ];\n    for(const field in obj){\n        if (!allowedFields.includes(field)) {\n            throw new Error(`Invalid service config choice: unexpected field ${field}`);\n        }\n    }\n    return result;\n}\nfunction validateAndSelectCanaryConfig(obj, percentage) {\n    if (!Array.isArray(obj)) {\n        throw new Error(\"Invalid service config list\");\n    }\n    for (const config of obj){\n        const validatedConfig = validateCanaryConfig(config);\n        /* For each field, we check if it is present, then only discard the\n         * config if the field value does not match the current client */ if (typeof validatedConfig.percentage === \"number\" && percentage > validatedConfig.percentage) {\n            continue;\n        }\n        if (Array.isArray(validatedConfig.clientHostname)) {\n            let hostnameMatched = false;\n            for (const hostname of validatedConfig.clientHostname){\n                if (hostname === os.hostname()) {\n                    hostnameMatched = true;\n                }\n            }\n            if (!hostnameMatched) {\n                continue;\n            }\n        }\n        if (Array.isArray(validatedConfig.clientLanguage)) {\n            let languageMatched = false;\n            for (const language of validatedConfig.clientLanguage){\n                if (language === CLIENT_LANGUAGE_STRING) {\n                    languageMatched = true;\n                }\n            }\n            if (!languageMatched) {\n                continue;\n            }\n        }\n        return validatedConfig.serviceConfig;\n    }\n    throw new Error(\"No matching service config found\");\n}\n/**\n * Find the \"grpc_config\" record among the TXT records, parse its value as JSON, validate its contents,\n * and select a service config with selection fields that all match this client. Most of these steps\n * can fail with an error; the caller must handle any errors thrown this way.\n * @param txtRecord The TXT record array that is output from a successful call to dns.resolveTxt\n * @param percentage A number chosen from the range [0, 100) that is used to select which config to use\n * @return The service configuration to use, given the percentage value, or null if the service config\n *     data has a valid format but none of the options match the current client.\n */ function extractAndSelectServiceConfig(txtRecord, percentage) {\n    for (const record of txtRecord){\n        if (record.length > 0 && record[0].startsWith(\"grpc_config=\")) {\n            /* Treat the list of strings in this record as a single string and remove\n             * \"grpc_config=\" from the beginning. The rest should be a JSON string */ const recordString = record.join(\"\").substring(\"grpc_config=\".length);\n            const recordJson = JSON.parse(recordString);\n            return validateAndSelectCanaryConfig(recordJson, percentage);\n        }\n    }\n    return null;\n}\nexports.extractAndSelectServiceConfig = extractAndSelectServiceConfig; //# sourceMappingURL=service-config.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc2VydmljZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFDQUFxQyxHQUFHQSw2QkFBNkIsR0FBRyxLQUFLO0FBQzdFOzs7OztvQkFLb0IsR0FDcEI7V0FDVyxHQUNYLHFEQUFxRCxHQUNyRCxNQUFNSSxLQUFLQyxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCLE1BQU1DLGtCQUFrQkQsbUJBQU9BLENBQUMsc0ZBQWlCO0FBQ2pEOzs7Q0FHQyxHQUNELE1BQU1FLGdCQUFnQjtBQUN0Qjs7O0NBR0MsR0FDRCxNQUFNQyx5QkFBeUI7QUFDL0IsU0FBU0MsYUFBYUMsR0FBRztJQUNyQixJQUFJLENBQUUsY0FBYUEsR0FBRSxLQUFNLE9BQU9BLElBQUlDLE9BQU8sS0FBSyxVQUFVO1FBQ3hELE1BQU0sSUFBSUMsTUFBTTtJQUNwQjtJQUNBLE1BQU1DLFNBQVM7UUFDWEYsU0FBU0QsSUFBSUMsT0FBTztJQUN4QjtJQUNBLElBQUksWUFBWUQsS0FBSztRQUNqQixJQUFJLE9BQU9BLElBQUlJLE1BQU0sS0FBSyxVQUFVO1lBQ2hDRCxPQUFPQyxNQUFNLEdBQUdKLElBQUlJLE1BQU07UUFDOUIsT0FDSztZQUNELE1BQU0sSUFBSUYsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsT0FBT0M7QUFDWDtBQUNBLFNBQVNFLHFCQUFxQkwsR0FBRztJQUM3QixJQUFJTTtJQUNKLE1BQU1ILFNBQVM7UUFDWEksTUFBTSxFQUFFO0lBQ1o7SUFDQSxJQUFJLENBQUUsV0FBVVAsR0FBRSxLQUFNLENBQUNRLE1BQU1DLE9BQU8sQ0FBQ1QsSUFBSU8sSUFBSSxHQUFHO1FBQzlDLE1BQU0sSUFBSUwsTUFBTTtJQUNwQjtJQUNBLEtBQUssTUFBTUssUUFBUVAsSUFBSU8sSUFBSSxDQUFFO1FBQ3pC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STFCLE1BQU1DLE9BQU8sQ0FBQzhCLGdCQUFnQk4sY0FBYyxHQUFHO1lBQy9DLElBQUlPLGtCQUFrQjtZQUN0QixLQUFLLE1BQU1DLFlBQVlGLGdCQUFnQk4sY0FBYyxDQUFFO2dCQUNuRCxJQUFJUSxhQUFhL0MsR0FBRytDLFFBQVEsSUFBSTtvQkFDNUJELGtCQUFrQjtnQkFDdEI7WUFDSjtZQUNBLElBQUksQ0FBQ0EsaUJBQWlCO2dCQUNsQjtZQUNKO1FBQ0o7UUFDQSxJQUFJaEMsTUFBTUMsT0FBTyxDQUFDOEIsZ0JBQWdCUixjQUFjLEdBQUc7WUFDL0MsSUFBSVcsa0JBQWtCO1lBQ3RCLEtBQUssTUFBTUMsWUFBWUosZ0JBQWdCUixjQUFjLENBQUU7Z0JBQ25ELElBQUlZLGFBQWE3Qyx3QkFBd0I7b0JBQ3JDNEMsa0JBQWtCO2dCQUN0QjtZQUNKO1lBQ0EsSUFBSSxDQUFDQSxpQkFBaUI7Z0JBQ2xCO1lBQ0o7UUFDSjtRQUNBLE9BQU9ILGdCQUFnQlQsYUFBYTtJQUN4QztJQUNBLE1BQU0sSUFBSTVCLE1BQU07QUFDcEI7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNWLDhCQUE4Qm9ELFNBQVMsRUFBRVYsVUFBVTtJQUN4RCxLQUFLLE1BQU1XLFVBQVVELFVBQVc7UUFDNUIsSUFBSUMsT0FBTzNCLE1BQU0sR0FBRyxLQUFLMkIsTUFBTSxDQUFDLEVBQUUsQ0FBQ0MsVUFBVSxDQUFDLGlCQUFpQjtZQUMzRDttRkFDdUUsR0FDdkUsTUFBTUMsZUFBZUYsT0FBT0csSUFBSSxDQUFDLElBQUkvQixTQUFTLENBQUMsZUFBZUMsTUFBTTtZQUNwRSxNQUFNK0IsYUFBYUMsS0FBS0MsS0FBSyxDQUFDSjtZQUM5QixPQUFPVCw4QkFBOEJXLFlBQVlmO1FBQ3JEO0lBQ0o7SUFDQSxPQUFPO0FBQ1g7QUFDQTVDLHFDQUFxQyxHQUFHRSwrQkFDeEMsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3NlcnZpY2UtY29uZmlnLmpzPzZjNDgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWcgPSBleHBvcnRzLnZhbGlkYXRlU2VydmljZUNvbmZpZyA9IHZvaWQgMDtcbi8qIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGdSRkMgQTIgYW5kIHRoZSBzZXJ2aWNlIGNvbmZpZyBzcGVjOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvcHJvcG9zYWwvYmxvYi9tYXN0ZXIvQTItc2VydmljZS1jb25maWdzLWluLWRucy5tZFxuICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy9ibG9iL21hc3Rlci9kb2Mvc2VydmljZV9jb25maWcubWQuIEVhY2hcbiAqIGZ1bmN0aW9uIGhlcmUgdGFrZXMgYW4gb2JqZWN0IHdpdGggdW5rbm93biBzdHJ1Y3R1cmUgYW5kIHJldHVybnMgaXRzXG4gKiBzcGVjaWZpYyBvYmplY3QgdHlwZSBpZiB0aGUgaW5wdXQgaGFzIHRoZSByaWdodCBzdHJ1Y3R1cmUsIGFuZCB0aHJvd3MgYW5cbiAqIGVycm9yIG90aGVyd2lzZS4gKi9cbi8qIFRoZSBhbnkgdHlwZSBpcyBwdXJwb3NlbHkgdXNlZCBoZXJlLiBBbGwgZnVuY3Rpb25zIHZhbGlkYXRlIHRoZWlyIGlucHV0IGF0XG4gKiBydW50aW1lICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IGxvYWRfYmFsYW5jZXJfMSA9IHJlcXVpcmUoXCIuL2xvYWQtYmFsYW5jZXJcIik7XG4vKipcbiAqIFJlY29nbml6ZXMgYSBudW1iZXIgd2l0aCB1cCB0byA5IGRpZ2l0cyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCwgZm9sbG93ZWQgYnlcbiAqIGFuIFwic1wiLCByZXByZXNlbnRpbmcgYSBudW1iZXIgb2Ygc2Vjb25kcy5cbiAqL1xuY29uc3QgVElNRU9VVF9SRUdFWCA9IC9eXFxkKyhcXC5cXGR7MSw5fSk/cyQvO1xuLyoqXG4gKiBDbGllbnQgbGFuZ3VhZ2UgbmFtZSB1c2VkIGZvciBkZXRlcm1pbmluZyB3aGV0aGVyIHRoaXMgY2xpZW50IG1hdGNoZXMgYVxuICogYFNlcnZpY2VDb25maWdDYW5hcnlDb25maWdgJ3MgYGNsaWVudExhbmd1YWdlYCBsaXN0LlxuICovXG5jb25zdCBDTElFTlRfTEFOR1VBR0VfU1RSSU5HID0gJ25vZGUnO1xuZnVuY3Rpb24gdmFsaWRhdGVOYW1lKG9iaikge1xuICAgIGlmICghKCdzZXJ2aWNlJyBpbiBvYmopIHx8IHR5cGVvZiBvYmouc2VydmljZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgbmFtZTogaW52YWxpZCBzZXJ2aWNlJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgc2VydmljZTogb2JqLnNlcnZpY2UsXG4gICAgfTtcbiAgICBpZiAoJ21ldGhvZCcgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLm1ldGhvZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlc3VsdC5tZXRob2QgPSBvYmoubWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWcgbmFtZTogaW52YWxpZCBtZXRob2QnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVNZXRob2RDb25maWcob2JqKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogW10sXG4gICAgfTtcbiAgICBpZiAoISgnbmFtZScgaW4gb2JqKSB8fCAhQXJyYXkuaXNBcnJheShvYmoubmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgbmFtZSBhcnJheScpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgb2Ygb2JqLm5hbWUpIHtcbiAgICAgICAgcmVzdWx0Lm5hbWUucHVzaCh2YWxpZGF0ZU5hbWUobmFtZSkpO1xuICAgIH1cbiAgICBpZiAoJ3dhaXRGb3JSZWFkeScgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLndhaXRGb3JSZWFkeSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB3YWl0Rm9yUmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQud2FpdEZvclJlYWR5ID0gb2JqLndhaXRGb3JSZWFkeTtcbiAgICB9XG4gICAgaWYgKCd0aW1lb3V0JyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoudGltZW91dCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmICghKCdzZWNvbmRzJyBpbiBvYmoudGltZW91dCkgfHxcbiAgICAgICAgICAgICAgICAhKHR5cGVvZiBvYmoudGltZW91dC5zZWNvbmRzID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCB0aW1lb3V0LnNlY29uZHMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKCduYW5vcycgaW4gb2JqLnRpbWVvdXQpIHx8XG4gICAgICAgICAgICAgICAgISh0eXBlb2Ygb2JqLnRpbWVvdXQubmFub3MgPT09ICdudW1iZXInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZXRob2QgY29uZmlnOiBpbnZhbGlkIHRpbWVvdXQubmFub3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC50aW1lb3V0ID0gb2JqLnRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9iai50aW1lb3V0ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgVElNRU9VVF9SRUdFWC50ZXN0KG9iai50aW1lb3V0KSkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dFBhcnRzID0gb2JqLnRpbWVvdXRcbiAgICAgICAgICAgICAgICAuc3Vic3RyaW5nKDAsIG9iai50aW1lb3V0Lmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICByZXN1bHQudGltZW91dCA9IHtcbiAgICAgICAgICAgICAgICBzZWNvbmRzOiB0aW1lb3V0UGFydHNbMF0gfCAwLFxuICAgICAgICAgICAgICAgIG5hbm9zOiAoKF9hID0gdGltZW91dFBhcnRzWzFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSB8IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgdGltZW91dCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgnbWF4UmVxdWVzdEJ5dGVzJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmoubWF4UmVxdWVzdEJ5dGVzICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1ldGhvZCBjb25maWc6IGludmFsaWQgbWF4UmVxdWVzdEJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Lm1heFJlcXVlc3RCeXRlcyA9IG9iai5tYXhSZXF1ZXN0Qnl0ZXM7XG4gICAgfVxuICAgIGlmICgnbWF4UmVzcG9uc2VCeXRlcycgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLm1heFJlc3BvbnNlQnl0ZXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWV0aG9kIGNvbmZpZzogaW52YWxpZCBtYXhSZXF1ZXN0Qnl0ZXMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQubWF4UmVzcG9uc2VCeXRlcyA9IG9iai5tYXhSZXNwb25zZUJ5dGVzO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVTZXJ2aWNlQ29uZmlnKG9iaikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbG9hZEJhbGFuY2luZ0NvbmZpZzogW10sXG4gICAgICAgIG1ldGhvZENvbmZpZzogW10sXG4gICAgfTtcbiAgICBpZiAoJ2xvYWRCYWxhbmNpbmdQb2xpY3knIGluIG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iai5sb2FkQmFsYW5jaW5nUG9saWN5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzdWx0LmxvYWRCYWxhbmNpbmdQb2xpY3kgPSBvYmoubG9hZEJhbGFuY2luZ1BvbGljeTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogaW52YWxpZCBsb2FkQmFsYW5jaW5nUG9saWN5Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdsb2FkQmFsYW5jaW5nQ29uZmlnJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmxvYWRCYWxhbmNpbmdDb25maWcpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbmZpZyBvZiBvYmoubG9hZEJhbGFuY2luZ0NvbmZpZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5sb2FkQmFsYW5jaW5nQ29uZmlnLnB1c2gobG9hZF9iYWxhbmNlcl8xLnZhbGlkYXRlTG9hZEJhbGFuY2luZ0NvbmZpZyhjb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogaW52YWxpZCBsb2FkQmFsYW5jaW5nQ29uZmlnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdtZXRob2RDb25maWcnIGluIG9iaikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmoubWV0aG9kQ29uZmlnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZXRob2RDb25maWcgb2Ygb2JqLm1ldGhvZENvbmZpZykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5tZXRob2RDb25maWcucHVzaCh2YWxpZGF0ZU1ldGhvZENvbmZpZyhtZXRob2RDb25maWcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSBtZXRob2QgbmFtZSB1bmlxdWVuZXNzXG4gICAgY29uc3Qgc2Vlbk1ldGhvZE5hbWVzID0gW107XG4gICAgZm9yIChjb25zdCBtZXRob2RDb25maWcgb2YgcmVzdWx0Lm1ldGhvZENvbmZpZykge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbWV0aG9kQ29uZmlnLm5hbWUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc2Vlbk5hbWUgb2Ygc2Vlbk1ldGhvZE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUuc2VydmljZSA9PT0gc2Vlbk5hbWUuc2VydmljZSAmJlxuICAgICAgICAgICAgICAgICAgICBuYW1lLm1ldGhvZCA9PT0gc2Vlbk5hbWUubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzZXJ2aWNlIGNvbmZpZzogZHVwbGljYXRlIG5hbWUgJHtuYW1lLnNlcnZpY2V9LyR7bmFtZS5tZXRob2R9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vlbk1ldGhvZE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudmFsaWRhdGVTZXJ2aWNlQ29uZmlnID0gdmFsaWRhdGVTZXJ2aWNlQ29uZmlnO1xuZnVuY3Rpb24gdmFsaWRhdGVDYW5hcnlDb25maWcob2JqKSB7XG4gICAgaWYgKCEoJ3NlcnZpY2VDb25maWcnIGluIG9iaikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogbWlzc2luZyBzZXJ2aWNlIGNvbmZpZycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHNlcnZpY2VDb25maWc6IHZhbGlkYXRlU2VydmljZUNvbmZpZyhvYmouc2VydmljZUNvbmZpZyksXG4gICAgfTtcbiAgICBpZiAoJ2NsaWVudExhbmd1YWdlJyBpbiBvYmopIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqLmNsaWVudExhbmd1YWdlKSkge1xuICAgICAgICAgICAgcmVzdWx0LmNsaWVudExhbmd1YWdlID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxhbmcgb2Ygb2JqLmNsaWVudExhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBsYW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY2xpZW50TGFuZ3VhZ2UucHVzaChsYW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBjaG9pY2U6IGludmFsaWQgY2xpZW50TGFuZ3VhZ2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudExhbmd1YWdlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCdjbGllbnRIb3N0bmFtZScgaW4gb2JqKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iai5jbGllbnRIb3N0bmFtZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jbGllbnRIb3N0bmFtZSA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsYW5nIG9mIG9iai5jbGllbnRIb3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFuZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNsaWVudEhvc3RuYW1lLnB1c2gobGFuZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIGNsaWVudEhvc3RuYW1lJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlcnZpY2UgY29uZmlnIGNob2ljZTogaW52YWxpZCBjbGllbnRIb3N0bmFtZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgncGVyY2VudGFnZScgaW4gb2JqKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqLnBlcmNlbnRhZ2UgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAwIDw9IG9iai5wZXJjZW50YWdlICYmXG4gICAgICAgICAgICBvYmoucGVyY2VudGFnZSA8PSAxMDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wZXJjZW50YWdlID0gb2JqLnBlcmNlbnRhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiBpbnZhbGlkIHBlcmNlbnRhZ2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB0aGF0IG5vIHVuZXhwZWN0ZWQgZmllbGRzIGFyZSBwcmVzZW50XG4gICAgY29uc3QgYWxsb3dlZEZpZWxkcyA9IFtcbiAgICAgICAgJ2NsaWVudExhbmd1YWdlJyxcbiAgICAgICAgJ3BlcmNlbnRhZ2UnLFxuICAgICAgICAnY2xpZW50SG9zdG5hbWUnLFxuICAgICAgICAnc2VydmljZUNvbmZpZycsXG4gICAgXTtcbiAgICBmb3IgKGNvbnN0IGZpZWxkIGluIG9iaikge1xuICAgICAgICBpZiAoIWFsbG93ZWRGaWVsZHMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VydmljZSBjb25maWcgY2hvaWNlOiB1bmV4cGVjdGVkIGZpZWxkICR7ZmllbGR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlQW5kU2VsZWN0Q2FuYXJ5Q29uZmlnKG9iaiwgcGVyY2VudGFnZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZXJ2aWNlIGNvbmZpZyBsaXN0Jyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29uZmlnIG9mIG9iaikge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRDb25maWcgPSB2YWxpZGF0ZUNhbmFyeUNvbmZpZyhjb25maWcpO1xuICAgICAgICAvKiBGb3IgZWFjaCBmaWVsZCwgd2UgY2hlY2sgaWYgaXQgaXMgcHJlc2VudCwgdGhlbiBvbmx5IGRpc2NhcmQgdGhlXG4gICAgICAgICAqIGNvbmZpZyBpZiB0aGUgZmllbGQgdmFsdWUgZG9lcyBub3QgbWF0Y2ggdGhlIGN1cnJlbnQgY2xpZW50ICovXG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRhdGVkQ29uZmlnLnBlcmNlbnRhZ2UgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICBwZXJjZW50YWdlID4gdmFsaWRhdGVkQ29uZmlnLnBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbGlkYXRlZENvbmZpZy5jbGllbnRIb3N0bmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBob3N0bmFtZU1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaG9zdG5hbWUgb2YgdmFsaWRhdGVkQ29uZmlnLmNsaWVudEhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RuYW1lID09PSBvcy5ob3N0bmFtZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhvc3RuYW1lTWF0Y2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFob3N0bmFtZU1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWxpZGF0ZWRDb25maWcuY2xpZW50TGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICBsZXQgbGFuZ3VhZ2VNYXRjaGVkID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxhbmd1YWdlIG9mIHZhbGlkYXRlZENvbmZpZy5jbGllbnRMYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZSA9PT0gQ0xJRU5UX0xBTkdVQUdFX1NUUklORykge1xuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZU1hdGNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbGFuZ3VhZ2VNYXRjaGVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZENvbmZpZy5zZXJ2aWNlQ29uZmlnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG1hdGNoaW5nIHNlcnZpY2UgY29uZmlnIGZvdW5kJyk7XG59XG4vKipcbiAqIEZpbmQgdGhlIFwiZ3JwY19jb25maWdcIiByZWNvcmQgYW1vbmcgdGhlIFRYVCByZWNvcmRzLCBwYXJzZSBpdHMgdmFsdWUgYXMgSlNPTiwgdmFsaWRhdGUgaXRzIGNvbnRlbnRzLFxuICogYW5kIHNlbGVjdCBhIHNlcnZpY2UgY29uZmlnIHdpdGggc2VsZWN0aW9uIGZpZWxkcyB0aGF0IGFsbCBtYXRjaCB0aGlzIGNsaWVudC4gTW9zdCBvZiB0aGVzZSBzdGVwc1xuICogY2FuIGZhaWwgd2l0aCBhbiBlcnJvcjsgdGhlIGNhbGxlciBtdXN0IGhhbmRsZSBhbnkgZXJyb3JzIHRocm93biB0aGlzIHdheS5cbiAqIEBwYXJhbSB0eHRSZWNvcmQgVGhlIFRYVCByZWNvcmQgYXJyYXkgdGhhdCBpcyBvdXRwdXQgZnJvbSBhIHN1Y2Nlc3NmdWwgY2FsbCB0byBkbnMucmVzb2x2ZVR4dFxuICogQHBhcmFtIHBlcmNlbnRhZ2UgQSBudW1iZXIgY2hvc2VuIGZyb20gdGhlIHJhbmdlIFswLCAxMDApIHRoYXQgaXMgdXNlZCB0byBzZWxlY3Qgd2hpY2ggY29uZmlnIHRvIHVzZVxuICogQHJldHVybiBUaGUgc2VydmljZSBjb25maWd1cmF0aW9uIHRvIHVzZSwgZ2l2ZW4gdGhlIHBlcmNlbnRhZ2UgdmFsdWUsIG9yIG51bGwgaWYgdGhlIHNlcnZpY2UgY29uZmlnXG4gKiAgICAgZGF0YSBoYXMgYSB2YWxpZCBmb3JtYXQgYnV0IG5vbmUgb2YgdGhlIG9wdGlvbnMgbWF0Y2ggdGhlIGN1cnJlbnQgY2xpZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyh0eHRSZWNvcmQsIHBlcmNlbnRhZ2UpIHtcbiAgICBmb3IgKGNvbnN0IHJlY29yZCBvZiB0eHRSZWNvcmQpIHtcbiAgICAgICAgaWYgKHJlY29yZC5sZW5ndGggPiAwICYmIHJlY29yZFswXS5zdGFydHNXaXRoKCdncnBjX2NvbmZpZz0nKSkge1xuICAgICAgICAgICAgLyogVHJlYXQgdGhlIGxpc3Qgb2Ygc3RyaW5ncyBpbiB0aGlzIHJlY29yZCBhcyBhIHNpbmdsZSBzdHJpbmcgYW5kIHJlbW92ZVxuICAgICAgICAgICAgICogXCJncnBjX2NvbmZpZz1cIiBmcm9tIHRoZSBiZWdpbm5pbmcuIFRoZSByZXN0IHNob3VsZCBiZSBhIEpTT04gc3RyaW5nICovXG4gICAgICAgICAgICBjb25zdCByZWNvcmRTdHJpbmcgPSByZWNvcmQuam9pbignJykuc3Vic3RyaW5nKCdncnBjX2NvbmZpZz0nLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCByZWNvcmRKc29uID0gSlNPTi5wYXJzZShyZWNvcmRTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlQW5kU2VsZWN0Q2FuYXJ5Q29uZmlnKHJlY29yZEpzb24sIHBlcmNlbnRhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5leHRyYWN0QW5kU2VsZWN0U2VydmljZUNvbmZpZyA9IGV4dHJhY3RBbmRTZWxlY3RTZXJ2aWNlQ29uZmlnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZS1jb25maWcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZXh0cmFjdEFuZFNlbGVjdFNlcnZpY2VDb25maWciLCJ2YWxpZGF0ZVNlcnZpY2VDb25maWciLCJvcyIsInJlcXVpcmUiLCJsb2FkX2JhbGFuY2VyXzEiLCJUSU1FT1VUX1JFR0VYIiwiQ0xJRU5UX0xBTkdVQUdFX1NUUklORyIsInZhbGlkYXRlTmFtZSIsIm9iaiIsInNlcnZpY2UiLCJFcnJvciIsInJlc3VsdCIsIm1ldGhvZCIsInZhbGlkYXRlTWV0aG9kQ29uZmlnIiwiX2EiLCJuYW1lIiwiQXJyYXkiLCJpc0FycmF5IiwicHVzaCIsIndhaXRGb3JSZWFkeSIsInRpbWVvdXQiLCJzZWNvbmRzIiwibmFub3MiLCJ0ZXN0IiwidGltZW91dFBhcnRzIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwic3BsaXQiLCJtYXhSZXF1ZXN0Qnl0ZXMiLCJtYXhSZXNwb25zZUJ5dGVzIiwibG9hZEJhbGFuY2luZ0NvbmZpZyIsIm1ldGhvZENvbmZpZyIsImxvYWRCYWxhbmNpbmdQb2xpY3kiLCJjb25maWciLCJ2YWxpZGF0ZUxvYWRCYWxhbmNpbmdDb25maWciLCJzZWVuTWV0aG9kTmFtZXMiLCJzZWVuTmFtZSIsInZhbGlkYXRlQ2FuYXJ5Q29uZmlnIiwic2VydmljZUNvbmZpZyIsImNsaWVudExhbmd1YWdlIiwibGFuZyIsImNsaWVudEhvc3RuYW1lIiwicGVyY2VudGFnZSIsImFsbG93ZWRGaWVsZHMiLCJmaWVsZCIsImluY2x1ZGVzIiwidmFsaWRhdGVBbmRTZWxlY3RDYW5hcnlDb25maWciLCJ2YWxpZGF0ZWRDb25maWciLCJob3N0bmFtZU1hdGNoZWQiLCJob3N0bmFtZSIsImxhbmd1YWdlTWF0Y2hlZCIsImxhbmd1YWdlIiwidHh0UmVjb3JkIiwicmVjb3JkIiwic3RhcnRzV2l0aCIsInJlY29yZFN0cmluZyIsImpvaW4iLCJyZWNvcmRKc29uIiwiSlNPTiIsInBhcnNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/service-config.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/status-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StatusBuilder = void 0;\n/**\n * A builder for gRPC status objects.\n */ class StatusBuilder {\n    constructor(){\n        this.code = null;\n        this.details = null;\n        this.metadata = null;\n    }\n    /**\n     * Adds a status code to the builder.\n     */ withCode(code) {\n        this.code = code;\n        return this;\n    }\n    /**\n     * Adds details to the builder.\n     */ withDetails(details) {\n        this.details = details;\n        return this;\n    }\n    /**\n     * Adds metadata to the builder.\n     */ withMetadata(metadata) {\n        this.metadata = metadata;\n        return this;\n    }\n    /**\n     * Builds the status object.\n     */ build() {\n        const status = {};\n        if (this.code !== null) {\n            status.code = this.code;\n        }\n        if (this.details !== null) {\n            status.details = this.details;\n        }\n        if (this.metadata !== null) {\n            status.metadata = this.metadata;\n        }\n        return status;\n    }\n}\nexports.StatusBuilder = StatusBuilder; //# sourceMappingURL=status-builder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RhdHVzLWJ1aWxkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0I7O0NBRUMsR0FDRCxNQUFNRTtJQUNGQyxhQUFjO1FBQ1YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsUUFBUSxHQUFHO0lBQ3BCO0lBQ0E7O0tBRUMsR0FDREMsU0FBU0gsSUFBSSxFQUFFO1FBQ1gsSUFBSSxDQUFDQSxJQUFJLEdBQUdBO1FBQ1osT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNESSxZQUFZSCxPQUFPLEVBQUU7UUFDakIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsT0FBTyxJQUFJO0lBQ2Y7SUFDQTs7S0FFQyxHQUNESSxhQUFhSCxRQUFRLEVBQUU7UUFDbkIsSUFBSSxDQUFDQSxRQUFRLEdBQUdBO1FBQ2hCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7O0tBRUMsR0FDREksUUFBUTtRQUNKLE1BQU1DLFNBQVMsQ0FBQztRQUNoQixJQUFJLElBQUksQ0FBQ1AsSUFBSSxLQUFLLE1BQU07WUFDcEJPLE9BQU9QLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7UUFDM0I7UUFDQSxJQUFJLElBQUksQ0FBQ0MsT0FBTyxLQUFLLE1BQU07WUFDdkJNLE9BQU9OLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU87UUFDakM7UUFDQSxJQUFJLElBQUksQ0FBQ0MsUUFBUSxLQUFLLE1BQU07WUFDeEJLLE9BQU9MLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7UUFDbkM7UUFDQSxPQUFPSztJQUNYO0FBQ0o7QUFDQVgscUJBQXFCLEdBQUdFLGVBQ3hCLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdGF0dXMtYnVpbGRlci5qcz9kMjkyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlN0YXR1c0J1aWxkZXIgPSB2b2lkIDA7XG4vKipcbiAqIEEgYnVpbGRlciBmb3IgZ1JQQyBzdGF0dXMgb2JqZWN0cy5cbiAqL1xuY2xhc3MgU3RhdHVzQnVpbGRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY29kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IG51bGw7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3RhdHVzIGNvZGUgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgd2l0aENvZGUoY29kZSkge1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBkZXRhaWxzIHRvIHRoZSBidWlsZGVyLlxuICAgICAqL1xuICAgIHdpdGhEZXRhaWxzKGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbWV0YWRhdGEgdG8gdGhlIGJ1aWxkZXIuXG4gICAgICovXG4gICAgd2l0aE1ldGFkYXRhKG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBtZXRhZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgc3RhdHVzIG9iamVjdC5cbiAgICAgKi9cbiAgICBidWlsZCgpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0ge307XG4gICAgICAgIGlmICh0aGlzLmNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXR1cy5jb2RlID0gdGhpcy5jb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRldGFpbHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN0YXR1cy5kZXRhaWxzID0gdGhpcy5kZXRhaWxzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1ldGFkYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0dXMubWV0YWRhdGEgPSB0aGlzLm1ldGFkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0dXM7XG4gICAgfVxufVxuZXhwb3J0cy5TdGF0dXNCdWlsZGVyID0gU3RhdHVzQnVpbGRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXR1cy1idWlsZGVyLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIlN0YXR1c0J1aWxkZXIiLCJjb25zdHJ1Y3RvciIsImNvZGUiLCJkZXRhaWxzIiwibWV0YWRhdGEiLCJ3aXRoQ29kZSIsIndpdGhEZXRhaWxzIiwid2l0aE1ldGFkYXRhIiwiYnVpbGQiLCJzdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/status-builder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/stream-decoder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.StreamDecoder = void 0;\nvar ReadState;\n(function(ReadState) {\n    ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n    ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n    ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\nclass StreamDecoder {\n    constructor(){\n        this.readState = ReadState.NO_DATA;\n        this.readCompressFlag = Buffer.alloc(1);\n        this.readPartialSize = Buffer.alloc(4);\n        this.readSizeRemaining = 4;\n        this.readMessageSize = 0;\n        this.readPartialMessage = [];\n        this.readMessageRemaining = 0;\n    }\n    write(data) {\n        let readHead = 0;\n        let toRead;\n        const result = [];\n        while(readHead < data.length){\n            switch(this.readState){\n                case ReadState.NO_DATA:\n                    this.readCompressFlag = data.slice(readHead, readHead + 1);\n                    readHead += 1;\n                    this.readState = ReadState.READING_SIZE;\n                    this.readPartialSize.fill(0);\n                    this.readSizeRemaining = 4;\n                    this.readMessageSize = 0;\n                    this.readMessageRemaining = 0;\n                    this.readPartialMessage = [];\n                    break;\n                case ReadState.READING_SIZE:\n                    toRead = Math.min(data.length - readHead, this.readSizeRemaining);\n                    data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);\n                    this.readSizeRemaining -= toRead;\n                    readHead += toRead;\n                    // readSizeRemaining >=0 here\n                    if (this.readSizeRemaining === 0) {\n                        this.readMessageSize = this.readPartialSize.readUInt32BE(0);\n                        this.readMessageRemaining = this.readMessageSize;\n                        if (this.readMessageRemaining > 0) {\n                            this.readState = ReadState.READING_MESSAGE;\n                        } else {\n                            const message = Buffer.concat([\n                                this.readCompressFlag,\n                                this.readPartialSize\n                            ], 5);\n                            this.readState = ReadState.NO_DATA;\n                            result.push(message);\n                        }\n                    }\n                    break;\n                case ReadState.READING_MESSAGE:\n                    toRead = Math.min(data.length - readHead, this.readMessageRemaining);\n                    this.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n                    this.readMessageRemaining -= toRead;\n                    readHead += toRead;\n                    // readMessageRemaining >=0 here\n                    if (this.readMessageRemaining === 0) {\n                        // At this point, we have read a full message\n                        const framedMessageBuffers = [\n                            this.readCompressFlag,\n                            this.readPartialSize\n                        ].concat(this.readPartialMessage);\n                        const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);\n                        this.readState = ReadState.NO_DATA;\n                        result.push(framedMessage);\n                    }\n                    break;\n                default:\n                    throw new Error(\"Unexpected read state\");\n            }\n        }\n        return result;\n    }\n}\nexports.StreamDecoder = StreamDecoder; //# sourceMappingURL=stream-decoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3RyZWFtLWRlY29kZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHFCQUFxQixHQUFHLEtBQUs7QUFDN0IsSUFBSUc7QUFDSCxVQUFVQSxTQUFTO0lBQ2hCQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ3RDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQzNDQSxTQUFTLENBQUNBLFNBQVMsQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLEdBQUc7QUFDbEQsR0FBR0EsYUFBY0EsQ0FBQUEsWUFBWSxDQUFDO0FBQzlCLE1BQU1EO0lBQ0ZFLGFBQWM7UUFDVixJQUFJLENBQUNDLFNBQVMsR0FBR0YsVUFBVUcsT0FBTztRQUNsQyxJQUFJLENBQUNDLGdCQUFnQixHQUFHQyxPQUFPQyxLQUFLLENBQUM7UUFDckMsSUFBSSxDQUFDQyxlQUFlLEdBQUdGLE9BQU9DLEtBQUssQ0FBQztRQUNwQyxJQUFJLENBQUNFLGlCQUFpQixHQUFHO1FBQ3pCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0Msa0JBQWtCLEdBQUcsRUFBRTtRQUM1QixJQUFJLENBQUNDLG9CQUFvQixHQUFHO0lBQ2hDO0lBQ0FDLE1BQU1DLElBQUksRUFBRTtRQUNSLElBQUlDLFdBQVc7UUFDZixJQUFJQztRQUNKLE1BQU1DLFNBQVMsRUFBRTtRQUNqQixNQUFPRixXQUFXRCxLQUFLSSxNQUFNLENBQUU7WUFDM0IsT0FBUSxJQUFJLENBQUNmLFNBQVM7Z0JBQ2xCLEtBQUtGLFVBQVVHLE9BQU87b0JBQ2xCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUdTLEtBQUtLLEtBQUssQ0FBQ0osVUFBVUEsV0FBVztvQkFDeERBLFlBQVk7b0JBQ1osSUFBSSxDQUFDWixTQUFTLEdBQUdGLFVBQVVtQixZQUFZO29CQUN2QyxJQUFJLENBQUNaLGVBQWUsQ0FBQ2EsSUFBSSxDQUFDO29CQUMxQixJQUFJLENBQUNaLGlCQUFpQixHQUFHO29CQUN6QixJQUFJLENBQUNDLGVBQWUsR0FBRztvQkFDdkIsSUFBSSxDQUFDRSxvQkFBb0IsR0FBRztvQkFDNUIsSUFBSSxDQUFDRCxrQkFBa0IsR0FBRyxFQUFFO29CQUM1QjtnQkFDSixLQUFLVixVQUFVbUIsWUFBWTtvQkFDdkJKLFNBQVNNLEtBQUtDLEdBQUcsQ0FBQ1QsS0FBS0ksTUFBTSxHQUFHSCxVQUFVLElBQUksQ0FBQ04saUJBQWlCO29CQUNoRUssS0FBS1UsSUFBSSxDQUFDLElBQUksQ0FBQ2hCLGVBQWUsRUFBRSxJQUFJLElBQUksQ0FBQ0MsaUJBQWlCLEVBQUVNLFVBQVVBLFdBQVdDO29CQUNqRixJQUFJLENBQUNQLGlCQUFpQixJQUFJTztvQkFDMUJELFlBQVlDO29CQUNaLDZCQUE2QjtvQkFDN0IsSUFBSSxJQUFJLENBQUNQLGlCQUFpQixLQUFLLEdBQUc7d0JBQzlCLElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUksQ0FBQ0YsZUFBZSxDQUFDaUIsWUFBWSxDQUFDO3dCQUN6RCxJQUFJLENBQUNiLG9CQUFvQixHQUFHLElBQUksQ0FBQ0YsZUFBZTt3QkFDaEQsSUFBSSxJQUFJLENBQUNFLG9CQUFvQixHQUFHLEdBQUc7NEJBQy9CLElBQUksQ0FBQ1QsU0FBUyxHQUFHRixVQUFVeUIsZUFBZTt3QkFDOUMsT0FDSzs0QkFDRCxNQUFNQyxVQUFVckIsT0FBT3NCLE1BQU0sQ0FBQztnQ0FBQyxJQUFJLENBQUN2QixnQkFBZ0I7Z0NBQUUsSUFBSSxDQUFDRyxlQUFlOzZCQUFDLEVBQUU7NEJBQzdFLElBQUksQ0FBQ0wsU0FBUyxHQUFHRixVQUFVRyxPQUFPOzRCQUNsQ2EsT0FBT1ksSUFBSSxDQUFDRjt3QkFDaEI7b0JBQ0o7b0JBQ0E7Z0JBQ0osS0FBSzFCLFVBQVV5QixlQUFlO29CQUMxQlYsU0FBU00sS0FBS0MsR0FBRyxDQUFDVCxLQUFLSSxNQUFNLEdBQUdILFVBQVUsSUFBSSxDQUFDSCxvQkFBb0I7b0JBQ25FLElBQUksQ0FBQ0Qsa0JBQWtCLENBQUNrQixJQUFJLENBQUNmLEtBQUtLLEtBQUssQ0FBQ0osVUFBVUEsV0FBV0M7b0JBQzdELElBQUksQ0FBQ0osb0JBQW9CLElBQUlJO29CQUM3QkQsWUFBWUM7b0JBQ1osZ0NBQWdDO29CQUNoQyxJQUFJLElBQUksQ0FBQ0osb0JBQW9CLEtBQUssR0FBRzt3QkFDakMsNkNBQTZDO3dCQUM3QyxNQUFNa0IsdUJBQXVCOzRCQUN6QixJQUFJLENBQUN6QixnQkFBZ0I7NEJBQ3JCLElBQUksQ0FBQ0csZUFBZTt5QkFDdkIsQ0FBQ29CLE1BQU0sQ0FBQyxJQUFJLENBQUNqQixrQkFBa0I7d0JBQ2hDLE1BQU1vQixnQkFBZ0J6QixPQUFPc0IsTUFBTSxDQUFDRSxzQkFBc0IsSUFBSSxDQUFDcEIsZUFBZSxHQUFHO3dCQUNqRixJQUFJLENBQUNQLFNBQVMsR0FBR0YsVUFBVUcsT0FBTzt3QkFDbENhLE9BQU9ZLElBQUksQ0FBQ0U7b0JBQ2hCO29CQUNBO2dCQUNKO29CQUNJLE1BQU0sSUFBSUMsTUFBTTtZQUN4QjtRQUNKO1FBQ0EsT0FBT2Y7SUFDWDtBQUNKO0FBQ0FuQixxQkFBcUIsR0FBR0UsZUFDeEIsMENBQTBDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3N0cmVhbS1kZWNvZGVyLmpzPzZjYjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RyZWFtRGVjb2RlciA9IHZvaWQgMDtcbnZhciBSZWFkU3RhdGU7XG4oZnVuY3Rpb24gKFJlYWRTdGF0ZSkge1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJOT19EQVRBXCJdID0gMF0gPSBcIk5PX0RBVEFcIjtcbiAgICBSZWFkU3RhdGVbUmVhZFN0YXRlW1wiUkVBRElOR19TSVpFXCJdID0gMV0gPSBcIlJFQURJTkdfU0laRVwiO1xuICAgIFJlYWRTdGF0ZVtSZWFkU3RhdGVbXCJSRUFESU5HX01FU1NBR0VcIl0gPSAyXSA9IFwiUkVBRElOR19NRVNTQUdFXCI7XG59KShSZWFkU3RhdGUgfHwgKFJlYWRTdGF0ZSA9IHt9KSk7XG5jbGFzcyBTdHJlYW1EZWNvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuTk9fREFUQTtcbiAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gQnVmZmVyLmFsbG9jKDEpO1xuICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZSA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyA9IDQ7XG4gICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gMDtcbiAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UgPSBbXTtcbiAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IDA7XG4gICAgfVxuICAgIHdyaXRlKGRhdGEpIHtcbiAgICAgICAgbGV0IHJlYWRIZWFkID0gMDtcbiAgICAgICAgbGV0IHRvUmVhZDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlIChyZWFkSGVhZCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucmVhZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuTk9fREFUQTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnID0gZGF0YS5zbGljZShyZWFkSGVhZCwgcmVhZEhlYWQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmVhZEhlYWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuUkVBRElOR19TSVpFO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRQYXJ0aWFsU2l6ZS5maWxsKDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTaXplUmVtYWluaW5nID0gNDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVNpemUgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRNZXNzYWdlUmVtYWluaW5nID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBSZWFkU3RhdGUuUkVBRElOR19TSVpFOlxuICAgICAgICAgICAgICAgICAgICB0b1JlYWQgPSBNYXRoLm1pbihkYXRhLmxlbmd0aCAtIHJlYWRIZWFkLCB0aGlzLnJlYWRTaXplUmVtYWluaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5jb3B5KHRoaXMucmVhZFBhcnRpYWxTaXplLCA0IC0gdGhpcy5yZWFkU2l6ZVJlbWFpbmluZywgcmVhZEhlYWQsIHJlYWRIZWFkICsgdG9SZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU2l6ZVJlbWFpbmluZyAtPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZFNpemVSZW1haW5pbmcgPj0wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZFNpemVSZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZE1lc3NhZ2VTaXplID0gdGhpcy5yZWFkUGFydGlhbFNpemUucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyA9IHRoaXMucmVhZE1lc3NhZ2VTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkU3RhdGUgPSBSZWFkU3RhdGUuUkVBRElOR19NRVNTQUdFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMucmVhZENvbXByZXNzRmxhZywgdGhpcy5yZWFkUGFydGlhbFNpemVdLCA1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5OT19EQVRBO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUmVhZFN0YXRlLlJFQURJTkdfTUVTU0FHRTpcbiAgICAgICAgICAgICAgICAgICAgdG9SZWFkID0gTWF0aC5taW4oZGF0YS5sZW5ndGggLSByZWFkSGVhZCwgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxNZXNzYWdlLnB1c2goZGF0YS5zbGljZShyZWFkSGVhZCwgcmVhZEhlYWQgKyB0b1JlYWQpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkTWVzc2FnZVJlbWFpbmluZyAtPSB0b1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRIZWFkICs9IHRvUmVhZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVhZE1lc3NhZ2VSZW1haW5pbmcgPj0wIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVhZE1lc3NhZ2VSZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgcmVhZCBhIGZ1bGwgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJhbWVkTWVzc2FnZUJ1ZmZlcnMgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFkQ29tcHJlc3NGbGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhZFBhcnRpYWxTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgXS5jb25jYXQodGhpcy5yZWFkUGFydGlhbE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJhbWVkTWVzc2FnZSA9IEJ1ZmZlci5jb25jYXQoZnJhbWVkTWVzc2FnZUJ1ZmZlcnMsIHRoaXMucmVhZE1lc3NhZ2VTaXplICsgNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWRTdGF0ZSA9IFJlYWRTdGF0ZS5OT19EQVRBO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWVkTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHJlYWQgc3RhdGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyZWFtRGVjb2RlciA9IFN0cmVhbURlY29kZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJlYW0tZGVjb2Rlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJTdHJlYW1EZWNvZGVyIiwiUmVhZFN0YXRlIiwiY29uc3RydWN0b3IiLCJyZWFkU3RhdGUiLCJOT19EQVRBIiwicmVhZENvbXByZXNzRmxhZyIsIkJ1ZmZlciIsImFsbG9jIiwicmVhZFBhcnRpYWxTaXplIiwicmVhZFNpemVSZW1haW5pbmciLCJyZWFkTWVzc2FnZVNpemUiLCJyZWFkUGFydGlhbE1lc3NhZ2UiLCJyZWFkTWVzc2FnZVJlbWFpbmluZyIsIndyaXRlIiwiZGF0YSIsInJlYWRIZWFkIiwidG9SZWFkIiwicmVzdWx0IiwibGVuZ3RoIiwic2xpY2UiLCJSRUFESU5HX1NJWkUiLCJmaWxsIiwiTWF0aCIsIm1pbiIsImNvcHkiLCJyZWFkVUludDMyQkUiLCJSRUFESU5HX01FU1NBR0UiLCJtZXNzYWdlIiwiY29uY2F0IiwicHVzaCIsImZyYW1lZE1lc3NhZ2VCdWZmZXJzIiwiZnJhbWVkTWVzc2FnZSIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/stream-decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js":
/*!********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-address.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.stringToSubchannelAddress = exports.subchannelAddressToString = exports.subchannelAddressEqual = exports.isTcpSubchannelAddress = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction isTcpSubchannelAddress(address) {\n    return \"port\" in address;\n}\nexports.isTcpSubchannelAddress = isTcpSubchannelAddress;\nfunction subchannelAddressEqual(address1, address2) {\n    if (isTcpSubchannelAddress(address1)) {\n        return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;\n    } else {\n        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;\n    }\n}\nexports.subchannelAddressEqual = subchannelAddressEqual;\nfunction subchannelAddressToString(address) {\n    if (isTcpSubchannelAddress(address)) {\n        return address.host + \":\" + address.port;\n    } else {\n        return address.path;\n    }\n}\nexports.subchannelAddressToString = subchannelAddressToString;\nconst DEFAULT_PORT = 443;\nfunction stringToSubchannelAddress(addressString, port) {\n    if (net_1.isIP(addressString)) {\n        return {\n            host: addressString,\n            port: port !== null && port !== void 0 ? port : DEFAULT_PORT\n        };\n    } else {\n        return {\n            path: addressString\n        };\n    }\n}\nexports.stringToSubchannelAddress = stringToSubchannelAddress; //# sourceMappingURL=subchannel-address.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1hZGRyZXNzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQ0FBaUMsR0FBR0EsaUNBQWlDLEdBQUdBLDhCQUE4QixHQUFHQSw4QkFBOEIsR0FBRyxLQUFLO0FBQy9JLE1BQU1NLFFBQVFDLG1CQUFPQSxDQUFDLGdCQUFLO0FBQzNCLFNBQVNGLHVCQUF1QkcsT0FBTztJQUNuQyxPQUFPLFVBQVVBO0FBQ3JCO0FBQ0FSLDhCQUE4QixHQUFHSztBQUNqQyxTQUFTRCx1QkFBdUJLLFFBQVEsRUFBRUMsUUFBUTtJQUM5QyxJQUFJTCx1QkFBdUJJLFdBQVc7UUFDbEMsT0FBUUosdUJBQXVCSyxhQUMzQkQsU0FBU0UsSUFBSSxLQUFLRCxTQUFTQyxJQUFJLElBQy9CRixTQUFTRyxJQUFJLEtBQUtGLFNBQVNFLElBQUk7SUFDdkMsT0FDSztRQUNELE9BQU8sQ0FBQ1AsdUJBQXVCSyxhQUFhRCxTQUFTSSxJQUFJLEtBQUtILFNBQVNHLElBQUk7SUFDL0U7QUFDSjtBQUNBYiw4QkFBOEIsR0FBR0k7QUFDakMsU0FBU0QsMEJBQTBCSyxPQUFPO0lBQ3RDLElBQUlILHVCQUF1QkcsVUFBVTtRQUNqQyxPQUFPQSxRQUFRRyxJQUFJLEdBQUcsTUFBTUgsUUFBUUksSUFBSTtJQUM1QyxPQUNLO1FBQ0QsT0FBT0osUUFBUUssSUFBSTtJQUN2QjtBQUNKO0FBQ0FiLGlDQUFpQyxHQUFHRztBQUNwQyxNQUFNVyxlQUFlO0FBQ3JCLFNBQVNaLDBCQUEwQmEsYUFBYSxFQUFFSCxJQUFJO0lBQ2xELElBQUlOLE1BQU1VLElBQUksQ0FBQ0QsZ0JBQWdCO1FBQzNCLE9BQU87WUFDSEosTUFBTUk7WUFDTkgsTUFBTUEsU0FBUyxRQUFRQSxTQUFTLEtBQUssSUFBSUEsT0FBT0U7UUFDcEQ7SUFDSixPQUNLO1FBQ0QsT0FBTztZQUNIRCxNQUFNRTtRQUNWO0lBQ0o7QUFDSjtBQUNBZixpQ0FBaUMsR0FBR0UsMkJBQ3BDLDhDQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLWFkZHJlc3MuanM/YmEzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMSBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nID0gZXhwb3J0cy5zdWJjaGFubmVsQWRkcmVzc0VxdWFsID0gZXhwb3J0cy5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzID0gdm9pZCAwO1xuY29uc3QgbmV0XzEgPSByZXF1aXJlKFwibmV0XCIpO1xuZnVuY3Rpb24gaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgcmV0dXJuICdwb3J0JyBpbiBhZGRyZXNzO1xufVxuZXhwb3J0cy5pc1RjcFN1YmNoYW5uZWxBZGRyZXNzID0gaXNUY3BTdWJjaGFubmVsQWRkcmVzcztcbmZ1bmN0aW9uIHN1YmNoYW5uZWxBZGRyZXNzRXF1YWwoYWRkcmVzczEsIGFkZHJlc3MyKSB7XG4gICAgaWYgKGlzVGNwU3ViY2hhbm5lbEFkZHJlc3MoYWRkcmVzczEpKSB7XG4gICAgICAgIHJldHVybiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzMikgJiZcbiAgICAgICAgICAgIGFkZHJlc3MxLmhvc3QgPT09IGFkZHJlc3MyLmhvc3QgJiZcbiAgICAgICAgICAgIGFkZHJlc3MxLnBvcnQgPT09IGFkZHJlc3MyLnBvcnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuICFpc1RjcFN1YmNoYW5uZWxBZGRyZXNzKGFkZHJlc3MyKSAmJiBhZGRyZXNzMS5wYXRoID09PSBhZGRyZXNzMi5wYXRoO1xuICAgIH1cbn1cbmV4cG9ydHMuc3ViY2hhbm5lbEFkZHJlc3NFcXVhbCA9IHN1YmNoYW5uZWxBZGRyZXNzRXF1YWw7XG5mdW5jdGlvbiBzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nKGFkZHJlc3MpIHtcbiAgICBpZiAoaXNUY3BTdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzKSkge1xuICAgICAgICByZXR1cm4gYWRkcmVzcy5ob3N0ICsgJzonICsgYWRkcmVzcy5wb3J0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3MucGF0aDtcbiAgICB9XG59XG5leHBvcnRzLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcgPSBzdWJjaGFubmVsQWRkcmVzc1RvU3RyaW5nO1xuY29uc3QgREVGQVVMVF9QT1JUID0gNDQzO1xuZnVuY3Rpb24gc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyhhZGRyZXNzU3RyaW5nLCBwb3J0KSB7XG4gICAgaWYgKG5ldF8xLmlzSVAoYWRkcmVzc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhvc3Q6IGFkZHJlc3NTdHJpbmcsXG4gICAgICAgICAgICBwb3J0OiBwb3J0ICE9PSBudWxsICYmIHBvcnQgIT09IHZvaWQgMCA/IHBvcnQgOiBERUZBVUxUX1BPUlRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoOiBhZGRyZXNzU3RyaW5nXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzID0gc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwtYWRkcmVzcy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJzdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzIiwic3ViY2hhbm5lbEFkZHJlc3NUb1N0cmluZyIsInN1YmNoYW5uZWxBZGRyZXNzRXF1YWwiLCJpc1RjcFN1YmNoYW5uZWxBZGRyZXNzIiwibmV0XzEiLCJyZXF1aXJlIiwiYWRkcmVzcyIsImFkZHJlc3MxIiwiYWRkcmVzczIiLCJob3N0IiwicG9ydCIsInBhdGgiLCJERUZBVUxUX1BPUlQiLCJhZGRyZXNzU3RyaW5nIiwiaXNJUCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.BaseSubchannelWrapper = void 0;\nclass BaseSubchannelWrapper {\n    constructor(child){\n        this.child = child;\n    }\n    getConnectivityState() {\n        return this.child.getConnectivityState();\n    }\n    addConnectivityStateListener(listener) {\n        this.child.addConnectivityStateListener(listener);\n    }\n    removeConnectivityStateListener(listener) {\n        this.child.removeConnectivityStateListener(listener);\n    }\n    startConnecting() {\n        this.child.startConnecting();\n    }\n    getAddress() {\n        return this.child.getAddress();\n    }\n    ref() {\n        this.child.ref();\n    }\n    unref() {\n        this.child.unref();\n    }\n    getChannelzRef() {\n        return this.child.getChannelzRef();\n    }\n    getRealSubchannel() {\n        return this.child.getRealSubchannel();\n    }\n}\nexports.BaseSubchannelWrapper = BaseSubchannelWrapper; //# sourceMappingURL=subchannel-interface.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDZCQUE2QixHQUFHLEtBQUs7QUFDckMsTUFBTUU7SUFDRkMsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0FDLHVCQUF1QjtRQUNuQixPQUFPLElBQUksQ0FBQ0QsS0FBSyxDQUFDQyxvQkFBb0I7SUFDMUM7SUFDQUMsNkJBQTZCQyxRQUFRLEVBQUU7UUFDbkMsSUFBSSxDQUFDSCxLQUFLLENBQUNFLDRCQUE0QixDQUFDQztJQUM1QztJQUNBQyxnQ0FBZ0NELFFBQVEsRUFBRTtRQUN0QyxJQUFJLENBQUNILEtBQUssQ0FBQ0ksK0JBQStCLENBQUNEO0lBQy9DO0lBQ0FFLGtCQUFrQjtRQUNkLElBQUksQ0FBQ0wsS0FBSyxDQUFDSyxlQUFlO0lBQzlCO0lBQ0FDLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ04sS0FBSyxDQUFDTSxVQUFVO0lBQ2hDO0lBQ0FDLE1BQU07UUFDRixJQUFJLENBQUNQLEtBQUssQ0FBQ08sR0FBRztJQUNsQjtJQUNBQyxRQUFRO1FBQ0osSUFBSSxDQUFDUixLQUFLLENBQUNRLEtBQUs7SUFDcEI7SUFDQUMsaUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUNULEtBQUssQ0FBQ1MsY0FBYztJQUNwQztJQUNBQyxvQkFBb0I7UUFDaEIsT0FBTyxJQUFJLENBQUNWLEtBQUssQ0FBQ1UsaUJBQWlCO0lBQ3ZDO0FBQ0o7QUFDQWQsNkJBQTZCLEdBQUdFLHVCQUNoQyxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1pbnRlcmZhY2UuanM/MjhjZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMiBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlU3ViY2hhbm5lbFdyYXBwZXIgPSB2b2lkIDA7XG5jbGFzcyBCYXNlU3ViY2hhbm5lbFdyYXBwZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkKSB7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBjaGlsZDtcbiAgICB9XG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldENvbm5lY3Rpdml0eVN0YXRlKCk7XG4gICAgfVxuICAgIGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5jaGlsZC5hZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmNoaWxkLnJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIHRoaXMuY2hpbGQuc3RhcnRDb25uZWN0aW5nKCk7XG4gICAgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldEFkZHJlc3MoKTtcbiAgICB9XG4gICAgcmVmKCkge1xuICAgICAgICB0aGlzLmNoaWxkLnJlZigpO1xuICAgIH1cbiAgICB1bnJlZigpIHtcbiAgICAgICAgdGhpcy5jaGlsZC51bnJlZigpO1xuICAgIH1cbiAgICBnZXRDaGFubmVselJlZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQuZ2V0Q2hhbm5lbHpSZWYoKTtcbiAgICB9XG4gICAgZ2V0UmVhbFN1YmNoYW5uZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkLmdldFJlYWxTdWJjaGFubmVsKCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlU3ViY2hhbm5lbFdyYXBwZXIgPSBCYXNlU3ViY2hhbm5lbFdyYXBwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLWludGVyZmFjZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJCYXNlU3ViY2hhbm5lbFdyYXBwZXIiLCJjb25zdHJ1Y3RvciIsImNoaWxkIiwiZ2V0Q29ubmVjdGl2aXR5U3RhdGUiLCJhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwibGlzdGVuZXIiLCJyZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyIiwic3RhcnRDb25uZWN0aW5nIiwiZ2V0QWRkcmVzcyIsInJlZiIsInVucmVmIiwiZ2V0Q2hhbm5lbHpSZWYiLCJnZXRSZWFsU3ViY2hhbm5lbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-interface.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getSubchannelPool = exports.SubchannelPool = void 0;\nconst channel_options_1 = __webpack_require__(/*! ./channel-options */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channel-options.js\");\nconst subchannel_1 = __webpack_require__(/*! ./subchannel */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\n// 10 seconds in milliseconds. This value is arbitrary.\n/**\n * The amount of time in between checks for dropping subchannels that have no\n * other references\n */ const REF_CHECK_INTERVAL = 10000;\nclass SubchannelPool {\n    /**\n     * A pool of subchannels use for making connections. Subchannels with the\n     * exact same parameters will be reused.\n     */ constructor(){\n        this.pool = Object.create(null);\n        /**\n         * A timer of a task performing a periodic subchannel cleanup.\n         */ this.cleanupTimer = null;\n    }\n    /**\n     * Unrefs all unused subchannels and cancels the cleanup task if all\n     * subchannels have been unrefed.\n     */ unrefUnusedSubchannels() {\n        let allSubchannelsUnrefed = true;\n        /* These objects are created with Object.create(null), so they do not\n         * have a prototype, which means that for (... in ...) loops over them\n         * do not need to be filtered */ // eslint-disable-disable-next-line:forin\n        for(const channelTarget in this.pool){\n            const subchannelObjArray = this.pool[channelTarget];\n            const refedSubchannels = subchannelObjArray.filter((value)=>!value.subchannel.unrefIfOneRef());\n            if (refedSubchannels.length > 0) {\n                allSubchannelsUnrefed = false;\n            }\n            /* For each subchannel in the pool, try to unref it if it has\n             * exactly one ref (which is the ref from the pool itself). If that\n             * does happen, remove the subchannel from the pool */ this.pool[channelTarget] = refedSubchannels;\n        }\n        /* Currently we do not delete keys with empty values. If that results\n         * in significant memory usage we should change it. */ // Cancel the cleanup task if all subchannels have been unrefed.\n        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {\n            clearInterval(this.cleanupTimer);\n            this.cleanupTimer = null;\n        }\n    }\n    /**\n     * Ensures that the cleanup task is spawned.\n     */ ensureCleanupTask() {\n        var _a, _b;\n        if (this.cleanupTimer === null) {\n            this.cleanupTimer = setInterval(()=>{\n                this.unrefUnusedSubchannels();\n            }, REF_CHECK_INTERVAL);\n            // Unref because this timer should not keep the event loop running.\n            // Call unref only if it exists to address electron/electron#21162\n            (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n    }\n    /**\n     * Get a subchannel if one already exists with exactly matching parameters.\n     * Otherwise, create and save a subchannel with those parameters.\n     * @param channelTarget\n     * @param subchannelTarget\n     * @param channelArguments\n     * @param channelCredentials\n     */ getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {\n        this.ensureCleanupTask();\n        const channelTarget = uri_parser_1.uriToString(channelTargetUri);\n        if (channelTarget in this.pool) {\n            const subchannelObjArray = this.pool[channelTarget];\n            for (const subchannelObj of subchannelObjArray){\n                if (subchannel_address_1.subchannelAddressEqual(subchannelTarget, subchannelObj.subchannelAddress) && channel_options_1.channelOptionsEqual(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {\n                    return subchannelObj.subchannel;\n                }\n            }\n        }\n        // If we get here, no matching subchannel was found\n        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials);\n        if (!(channelTarget in this.pool)) {\n            this.pool[channelTarget] = [];\n        }\n        this.pool[channelTarget].push({\n            subchannelAddress: subchannelTarget,\n            channelArguments,\n            channelCredentials,\n            subchannel\n        });\n        subchannel.ref();\n        return subchannel;\n    }\n}\nexports.SubchannelPool = SubchannelPool;\nconst globalSubchannelPool = new SubchannelPool();\n/**\n * Get either the global subchannel pool, or a new subchannel pool.\n * @param global\n */ function getSubchannelPool(global) {\n    if (global) {\n        return globalSubchannelPool;\n    } else {\n        return new SubchannelPool();\n    }\n}\nexports.getSubchannelPool = getSubchannelPool; //# sourceMappingURL=subchannel-pool.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx5QkFBeUIsR0FBR0Esc0JBQXNCLEdBQUcsS0FBSztBQUMxRCxNQUFNSSxvQkFBb0JDLG1CQUFPQSxDQUFDLDBGQUFtQjtBQUNyRCxNQUFNQyxlQUFlRCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyx1REFBdUQ7QUFDdkQ7OztDQUdDLEdBQ0QsTUFBTUkscUJBQXFCO0FBQzNCLE1BQU1OO0lBQ0Y7OztLQUdDLEdBQ0RPLGFBQWM7UUFDVixJQUFJLENBQUNDLElBQUksR0FBR2IsT0FBT2MsTUFBTSxDQUFDO1FBQzFCOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxZQUFZLEdBQUc7SUFDeEI7SUFDQTs7O0tBR0MsR0FDREMseUJBQXlCO1FBQ3JCLElBQUlDLHdCQUF3QjtRQUM1Qjs7c0NBRThCLEdBQzlCLHlDQUF5QztRQUN6QyxJQUFLLE1BQU1DLGlCQUFpQixJQUFJLENBQUNMLElBQUksQ0FBRTtZQUNuQyxNQUFNTSxxQkFBcUIsSUFBSSxDQUFDTixJQUFJLENBQUNLLGNBQWM7WUFDbkQsTUFBTUUsbUJBQW1CRCxtQkFBbUJFLE1BQU0sQ0FBQyxDQUFDbEIsUUFBVSxDQUFDQSxNQUFNbUIsVUFBVSxDQUFDQyxhQUFhO1lBQzdGLElBQUlILGlCQUFpQkksTUFBTSxHQUFHLEdBQUc7Z0JBQzdCUCx3QkFBd0I7WUFDNUI7WUFDQTs7Z0VBRW9ELEdBQ3BELElBQUksQ0FBQ0osSUFBSSxDQUFDSyxjQUFjLEdBQUdFO1FBQy9CO1FBQ0E7NERBQ29ELEdBQ3BELGdFQUFnRTtRQUNoRSxJQUFJSCx5QkFBeUIsSUFBSSxDQUFDRixZQUFZLEtBQUssTUFBTTtZQUNyRFUsY0FBYyxJQUFJLENBQUNWLFlBQVk7WUFDL0IsSUFBSSxDQUFDQSxZQUFZLEdBQUc7UUFDeEI7SUFDSjtJQUNBOztLQUVDLEdBQ0RXLG9CQUFvQjtRQUNoQixJQUFJQyxJQUFJQztRQUNSLElBQUksSUFBSSxDQUFDYixZQUFZLEtBQUssTUFBTTtZQUM1QixJQUFJLENBQUNBLFlBQVksR0FBR2MsWUFBWTtnQkFDNUIsSUFBSSxDQUFDYixzQkFBc0I7WUFDL0IsR0FBR0w7WUFDSCxtRUFBbUU7WUFDbkUsa0VBQWtFO1lBQ2pFaUIsQ0FBQUEsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ1osWUFBWSxFQUFFZSxLQUFLLE1BQU0sUUFBUUYsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHRyxJQUFJLENBQUNKO1FBQ3ZGO0lBQ0o7SUFDQTs7Ozs7OztLQU9DLEdBQ0RLLHNCQUFzQkMsZ0JBQWdCLEVBQUVDLGdCQUFnQixFQUFFQyxnQkFBZ0IsRUFBRUMsa0JBQWtCLEVBQUU7UUFDNUYsSUFBSSxDQUFDVixpQkFBaUI7UUFDdEIsTUFBTVIsZ0JBQWdCUixhQUFhMkIsV0FBVyxDQUFDSjtRQUMvQyxJQUFJZixpQkFBaUIsSUFBSSxDQUFDTCxJQUFJLEVBQUU7WUFDNUIsTUFBTU0scUJBQXFCLElBQUksQ0FBQ04sSUFBSSxDQUFDSyxjQUFjO1lBQ25ELEtBQUssTUFBTW9CLGlCQUFpQm5CLG1CQUFvQjtnQkFDNUMsSUFBSVYscUJBQXFCOEIsc0JBQXNCLENBQUNMLGtCQUFrQkksY0FBY0UsaUJBQWlCLEtBQzdGbEMsa0JBQWtCbUMsbUJBQW1CLENBQUNOLGtCQUFrQkcsY0FBY0gsZ0JBQWdCLEtBQ3RGQyxtQkFBbUJNLE9BQU8sQ0FBQ0osY0FBY0Ysa0JBQWtCLEdBQUc7b0JBQzlELE9BQU9FLGNBQWNoQixVQUFVO2dCQUNuQztZQUNKO1FBQ0o7UUFDQSxtREFBbUQ7UUFDbkQsTUFBTUEsYUFBYSxJQUFJZCxhQUFhbUMsVUFBVSxDQUFDVixrQkFBa0JDLGtCQUFrQkMsa0JBQWtCQztRQUNyRyxJQUFJLENBQUVsQixDQUFBQSxpQkFBaUIsSUFBSSxDQUFDTCxJQUFJLEdBQUc7WUFDL0IsSUFBSSxDQUFDQSxJQUFJLENBQUNLLGNBQWMsR0FBRyxFQUFFO1FBQ2pDO1FBQ0EsSUFBSSxDQUFDTCxJQUFJLENBQUNLLGNBQWMsQ0FBQzBCLElBQUksQ0FBQztZQUMxQkosbUJBQW1CTjtZQUNuQkM7WUFDQUM7WUFDQWQ7UUFDSjtRQUNBQSxXQUFXdUIsR0FBRztRQUNkLE9BQU92QjtJQUNYO0FBQ0o7QUFDQXBCLHNCQUFzQixHQUFHRztBQUN6QixNQUFNeUMsdUJBQXVCLElBQUl6QztBQUNqQzs7O0NBR0MsR0FDRCxTQUFTRCxrQkFBa0IyQyxNQUFNO0lBQzdCLElBQUlBLFFBQVE7UUFDUixPQUFPRDtJQUNYLE9BQ0s7UUFDRCxPQUFPLElBQUl6QztJQUNmO0FBQ0o7QUFDQUgseUJBQXlCLEdBQUdFLG1CQUM1QiwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC1wb29sLmpzP2M1NjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0U3ViY2hhbm5lbFBvb2wgPSBleHBvcnRzLlN1YmNoYW5uZWxQb29sID0gdm9pZCAwO1xuY29uc3QgY2hhbm5lbF9vcHRpb25zXzEgPSByZXF1aXJlKFwiLi9jaGFubmVsLW9wdGlvbnNcIik7XG5jb25zdCBzdWJjaGFubmVsXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsXCIpO1xuY29uc3Qgc3ViY2hhbm5lbF9hZGRyZXNzXzEgPSByZXF1aXJlKFwiLi9zdWJjaGFubmVsLWFkZHJlc3NcIik7XG5jb25zdCB1cmlfcGFyc2VyXzEgPSByZXF1aXJlKFwiLi91cmktcGFyc2VyXCIpO1xuLy8gMTAgc2Vjb25kcyBpbiBtaWxsaXNlY29uZHMuIFRoaXMgdmFsdWUgaXMgYXJiaXRyYXJ5LlxuLyoqXG4gKiBUaGUgYW1vdW50IG9mIHRpbWUgaW4gYmV0d2VlbiBjaGVja3MgZm9yIGRyb3BwaW5nIHN1YmNoYW5uZWxzIHRoYXQgaGF2ZSBub1xuICogb3RoZXIgcmVmZXJlbmNlc1xuICovXG5jb25zdCBSRUZfQ0hFQ0tfSU5URVJWQUwgPSAxMDAwMDtcbmNsYXNzIFN1YmNoYW5uZWxQb29sIHtcbiAgICAvKipcbiAgICAgKiBBIHBvb2wgb2Ygc3ViY2hhbm5lbHMgdXNlIGZvciBtYWtpbmcgY29ubmVjdGlvbnMuIFN1YmNoYW5uZWxzIHdpdGggdGhlXG4gICAgICogZXhhY3Qgc2FtZSBwYXJhbWV0ZXJzIHdpbGwgYmUgcmV1c2VkLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBvb2wgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSB0aW1lciBvZiBhIHRhc2sgcGVyZm9ybWluZyBhIHBlcmlvZGljIHN1YmNoYW5uZWwgY2xlYW51cC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWZzIGFsbCB1bnVzZWQgc3ViY2hhbm5lbHMgYW5kIGNhbmNlbHMgdGhlIGNsZWFudXAgdGFzayBpZiBhbGxcbiAgICAgKiBzdWJjaGFubmVscyBoYXZlIGJlZW4gdW5yZWZlZC5cbiAgICAgKi9cbiAgICB1bnJlZlVudXNlZFN1YmNoYW5uZWxzKCkge1xuICAgICAgICBsZXQgYWxsU3ViY2hhbm5lbHNVbnJlZmVkID0gdHJ1ZTtcbiAgICAgICAgLyogVGhlc2Ugb2JqZWN0cyBhcmUgY3JlYXRlZCB3aXRoIE9iamVjdC5jcmVhdGUobnVsbCksIHNvIHRoZXkgZG8gbm90XG4gICAgICAgICAqIGhhdmUgYSBwcm90b3R5cGUsIHdoaWNoIG1lYW5zIHRoYXQgZm9yICguLi4gaW4gLi4uKSBsb29wcyBvdmVyIHRoZW1cbiAgICAgICAgICogZG8gbm90IG5lZWQgdG8gYmUgZmlsdGVyZWQgKi9cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtZGlzYWJsZS1uZXh0LWxpbmU6Zm9yaW5cbiAgICAgICAgZm9yIChjb25zdCBjaGFubmVsVGFyZ2V0IGluIHRoaXMucG9vbCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbE9iakFycmF5ID0gdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdO1xuICAgICAgICAgICAgY29uc3QgcmVmZWRTdWJjaGFubmVscyA9IHN1YmNoYW5uZWxPYmpBcnJheS5maWx0ZXIoKHZhbHVlKSA9PiAhdmFsdWUuc3ViY2hhbm5lbC51bnJlZklmT25lUmVmKCkpO1xuICAgICAgICAgICAgaWYgKHJlZmVkU3ViY2hhbm5lbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGFsbFN1YmNoYW5uZWxzVW5yZWZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogRm9yIGVhY2ggc3ViY2hhbm5lbCBpbiB0aGUgcG9vbCwgdHJ5IHRvIHVucmVmIGl0IGlmIGl0IGhhc1xuICAgICAgICAgICAgICogZXhhY3RseSBvbmUgcmVmICh3aGljaCBpcyB0aGUgcmVmIGZyb20gdGhlIHBvb2wgaXRzZWxmKS4gSWYgdGhhdFxuICAgICAgICAgICAgICogZG9lcyBoYXBwZW4sIHJlbW92ZSB0aGUgc3ViY2hhbm5lbCBmcm9tIHRoZSBwb29sICovXG4gICAgICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0gPSByZWZlZFN1YmNoYW5uZWxzO1xuICAgICAgICB9XG4gICAgICAgIC8qIEN1cnJlbnRseSB3ZSBkbyBub3QgZGVsZXRlIGtleXMgd2l0aCBlbXB0eSB2YWx1ZXMuIElmIHRoYXQgcmVzdWx0c1xuICAgICAgICAgKiBpbiBzaWduaWZpY2FudCBtZW1vcnkgdXNhZ2Ugd2Ugc2hvdWxkIGNoYW5nZSBpdC4gKi9cbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBjbGVhbnVwIHRhc2sgaWYgYWxsIHN1YmNoYW5uZWxzIGhhdmUgYmVlbiB1bnJlZmVkLlxuICAgICAgICBpZiAoYWxsU3ViY2hhbm5lbHNVbnJlZmVkICYmIHRoaXMuY2xlYW51cFRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2xlYW51cFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoYXQgdGhlIGNsZWFudXAgdGFzayBpcyBzcGF3bmVkLlxuICAgICAqL1xuICAgIGVuc3VyZUNsZWFudXBUYXNrKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5jbGVhbnVwVGltZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cFRpbWVyID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudW5yZWZVbnVzZWRTdWJjaGFubmVscygpO1xuICAgICAgICAgICAgfSwgUkVGX0NIRUNLX0lOVEVSVkFMKTtcbiAgICAgICAgICAgIC8vIFVucmVmIGJlY2F1c2UgdGhpcyB0aW1lciBzaG91bGQgbm90IGtlZXAgdGhlIGV2ZW50IGxvb3AgcnVubmluZy5cbiAgICAgICAgICAgIC8vIENhbGwgdW5yZWYgb25seSBpZiBpdCBleGlzdHMgdG8gYWRkcmVzcyBlbGVjdHJvbi9lbGVjdHJvbiMyMTE2MlxuICAgICAgICAgICAgKF9iID0gKF9hID0gdGhpcy5jbGVhbnVwVGltZXIpLnVucmVmKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGEgc3ViY2hhbm5lbCBpZiBvbmUgYWxyZWFkeSBleGlzdHMgd2l0aCBleGFjdGx5IG1hdGNoaW5nIHBhcmFtZXRlcnMuXG4gICAgICogT3RoZXJ3aXNlLCBjcmVhdGUgYW5kIHNhdmUgYSBzdWJjaGFubmVsIHdpdGggdGhvc2UgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbFRhcmdldFxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsVGFyZ2V0XG4gICAgICogQHBhcmFtIGNoYW5uZWxBcmd1bWVudHNcbiAgICAgKiBAcGFyYW0gY2hhbm5lbENyZWRlbnRpYWxzXG4gICAgICovXG4gICAgZ2V0T3JDcmVhdGVTdWJjaGFubmVsKGNoYW5uZWxUYXJnZXRVcmksIHN1YmNoYW5uZWxUYXJnZXQsIGNoYW5uZWxBcmd1bWVudHMsIGNoYW5uZWxDcmVkZW50aWFscykge1xuICAgICAgICB0aGlzLmVuc3VyZUNsZWFudXBUYXNrKCk7XG4gICAgICAgIGNvbnN0IGNoYW5uZWxUYXJnZXQgPSB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcoY2hhbm5lbFRhcmdldFVyaSk7XG4gICAgICAgIGlmIChjaGFubmVsVGFyZ2V0IGluIHRoaXMucG9vbCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViY2hhbm5lbE9iakFycmF5ID0gdGhpcy5wb29sW2NoYW5uZWxUYXJnZXRdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdWJjaGFubmVsT2JqIG9mIHN1YmNoYW5uZWxPYmpBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJjaGFubmVsX2FkZHJlc3NfMS5zdWJjaGFubmVsQWRkcmVzc0VxdWFsKHN1YmNoYW5uZWxUYXJnZXQsIHN1YmNoYW5uZWxPYmouc3ViY2hhbm5lbEFkZHJlc3MpICYmXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxfb3B0aW9uc18xLmNoYW5uZWxPcHRpb25zRXF1YWwoY2hhbm5lbEFyZ3VtZW50cywgc3ViY2hhbm5lbE9iai5jaGFubmVsQXJndW1lbnRzKSAmJlxuICAgICAgICAgICAgICAgICAgICBjaGFubmVsQ3JlZGVudGlhbHMuX2VxdWFscyhzdWJjaGFubmVsT2JqLmNoYW5uZWxDcmVkZW50aWFscykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWxPYmouc3ViY2hhbm5lbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIG5vIG1hdGNoaW5nIHN1YmNoYW5uZWwgd2FzIGZvdW5kXG4gICAgICAgIGNvbnN0IHN1YmNoYW5uZWwgPSBuZXcgc3ViY2hhbm5lbF8xLlN1YmNoYW5uZWwoY2hhbm5lbFRhcmdldFVyaSwgc3ViY2hhbm5lbFRhcmdldCwgY2hhbm5lbEFyZ3VtZW50cywgY2hhbm5lbENyZWRlbnRpYWxzKTtcbiAgICAgICAgaWYgKCEoY2hhbm5lbFRhcmdldCBpbiB0aGlzLnBvb2wpKSB7XG4gICAgICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvb2xbY2hhbm5lbFRhcmdldF0ucHVzaCh7XG4gICAgICAgICAgICBzdWJjaGFubmVsQWRkcmVzczogc3ViY2hhbm5lbFRhcmdldCxcbiAgICAgICAgICAgIGNoYW5uZWxBcmd1bWVudHMsXG4gICAgICAgICAgICBjaGFubmVsQ3JlZGVudGlhbHMsXG4gICAgICAgICAgICBzdWJjaGFubmVsLFxuICAgICAgICB9KTtcbiAgICAgICAgc3ViY2hhbm5lbC5yZWYoKTtcbiAgICAgICAgcmV0dXJuIHN1YmNoYW5uZWw7XG4gICAgfVxufVxuZXhwb3J0cy5TdWJjaGFubmVsUG9vbCA9IFN1YmNoYW5uZWxQb29sO1xuY29uc3QgZ2xvYmFsU3ViY2hhbm5lbFBvb2wgPSBuZXcgU3ViY2hhbm5lbFBvb2woKTtcbi8qKlxuICogR2V0IGVpdGhlciB0aGUgZ2xvYmFsIHN1YmNoYW5uZWwgcG9vbCwgb3IgYSBuZXcgc3ViY2hhbm5lbCBwb29sLlxuICogQHBhcmFtIGdsb2JhbFxuICovXG5mdW5jdGlvbiBnZXRTdWJjaGFubmVsUG9vbChnbG9iYWwpIHtcbiAgICBpZiAoZ2xvYmFsKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxTdWJjaGFubmVsUG9vbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ViY2hhbm5lbFBvb2woKTtcbiAgICB9XG59XG5leHBvcnRzLmdldFN1YmNoYW5uZWxQb29sID0gZ2V0U3ViY2hhbm5lbFBvb2w7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdWJjaGFubmVsLXBvb2wuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZ2V0U3ViY2hhbm5lbFBvb2wiLCJTdWJjaGFubmVsUG9vbCIsImNoYW5uZWxfb3B0aW9uc18xIiwicmVxdWlyZSIsInN1YmNoYW5uZWxfMSIsInN1YmNoYW5uZWxfYWRkcmVzc18xIiwidXJpX3BhcnNlcl8xIiwiUkVGX0NIRUNLX0lOVEVSVkFMIiwiY29uc3RydWN0b3IiLCJwb29sIiwiY3JlYXRlIiwiY2xlYW51cFRpbWVyIiwidW5yZWZVbnVzZWRTdWJjaGFubmVscyIsImFsbFN1YmNoYW5uZWxzVW5yZWZlZCIsImNoYW5uZWxUYXJnZXQiLCJzdWJjaGFubmVsT2JqQXJyYXkiLCJyZWZlZFN1YmNoYW5uZWxzIiwiZmlsdGVyIiwic3ViY2hhbm5lbCIsInVucmVmSWZPbmVSZWYiLCJsZW5ndGgiLCJjbGVhckludGVydmFsIiwiZW5zdXJlQ2xlYW51cFRhc2siLCJfYSIsIl9iIiwic2V0SW50ZXJ2YWwiLCJ1bnJlZiIsImNhbGwiLCJnZXRPckNyZWF0ZVN1YmNoYW5uZWwiLCJjaGFubmVsVGFyZ2V0VXJpIiwic3ViY2hhbm5lbFRhcmdldCIsImNoYW5uZWxBcmd1bWVudHMiLCJjaGFubmVsQ3JlZGVudGlhbHMiLCJ1cmlUb1N0cmluZyIsInN1YmNoYW5uZWxPYmoiLCJzdWJjaGFubmVsQWRkcmVzc0VxdWFsIiwic3ViY2hhbm5lbEFkZHJlc3MiLCJjaGFubmVsT3B0aW9uc0VxdWFsIiwiX2VxdWFscyIsIlN1YmNoYW5uZWwiLCJwdXNoIiwicmVmIiwiZ2xvYmFsU3ViY2hhbm5lbFBvb2wiLCJnbG9iYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-pool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/subchannel.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.Subchannel = void 0;\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst connectivity_state_1 = __webpack_require__(/*! ./connectivity-state */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/connectivity-state.js\");\nconst backoff_timeout_1 = __webpack_require__(/*! ./backoff-timeout */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/backoff-timeout.js\");\nconst resolver_1 = __webpack_require__(/*! ./resolver */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/resolver.js\");\nconst logging = __webpack_require__(/*! ./logging */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/logging.js\");\nconst constants_1 = __webpack_require__(/*! ./constants */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/constants.js\");\nconst http_proxy_1 = __webpack_require__(/*! ./http_proxy */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/http_proxy.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst uri_parser_1 = __webpack_require__(/*! ./uri-parser */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\");\nconst subchannel_address_1 = __webpack_require__(/*! ./subchannel-address */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel-address.js\");\nconst channelz_1 = __webpack_require__(/*! ./channelz */ \"(ssr)/./node_modules/@grpc/grpc-js/build/src/channelz.js\");\nconst clientVersion = (__webpack_require__(/*! ../../package.json */ \"(ssr)/./node_modules/@grpc/grpc-js/package.json\").version);\nconst TRACER_NAME = \"subchannel\";\nconst FLOW_CONTROL_TRACER_NAME = \"subchannel_flowctrl\";\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */ const KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */ function uniformRandom(min, max) {\n    return Math.random() * (max - min) + min;\n}\nconst tooManyPingsData = Buffer.from(\"too_many_pings\", \"ascii\");\nclass Subchannel {\n    /**\n     * A class representing a connection to a single backend.\n     * @param channelTarget The target string for the channel as a whole\n     * @param subchannelAddress The address for the backend that this subchannel\n     *     will connect to\n     * @param options The channel options, plus any specific subchannel options\n     *     for this subchannel\n     * @param credentials The channel credentials used to establish this\n     *     connection\n     */ constructor(channelTarget, subchannelAddress, options, credentials){\n        this.channelTarget = channelTarget;\n        this.subchannelAddress = subchannelAddress;\n        this.options = options;\n        this.credentials = credentials;\n        /**\n         * The subchannel's current connectivity state. Invariant: `session` === `null`\n         * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n         */ this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n        /**\n         * The underlying http2 session used to make requests.\n         */ this.session = null;\n        /**\n         * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n         * CONNECTING instead of IDLE when the backoff timeout ends.\n         */ this.continueConnecting = false;\n        /**\n         * A list of listener functions that will be called whenever the connectivity\n         * state changes. Will be modified by `addConnectivityStateListener` and\n         * `removeConnectivityStateListener`\n         */ this.stateListeners = [];\n        /**\n         * A list of listener functions that will be called when the underlying\n         * socket disconnects. Used for ending active calls with an UNAVAILABLE\n         * status.\n         */ this.disconnectListeners = new Set();\n        /**\n         * The amount of time in between sending pings\n         */ this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n        /**\n         * The amount of time to wait for an acknowledgement after sending a ping\n         */ this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n        /**\n         * Indicates whether keepalive pings should be sent without any active calls\n         */ this.keepaliveWithoutCalls = false;\n        /**\n         * Tracks calls with references to this subchannel\n         */ this.callRefcount = 0;\n        /**\n         * Tracks channels and subchannel pools with references to this subchannel\n         */ this.refcount = 0;\n        // Channelz info\n        this.channelzEnabled = true;\n        this.callTracker = new channelz_1.ChannelzCallTracker();\n        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n        // Channelz socket info\n        this.channelzSocketRef = null;\n        /**\n         * Name of the remote server, if it is not the same as the subchannel\n         * address, i.e. if connecting through an HTTP CONNECT proxy.\n         */ this.remoteName = null;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n        // Build user-agent string.\n        this.userAgent = [\n            options[\"grpc.primary_user_agent\"],\n            `grpc-node-js/${clientVersion}`,\n            options[\"grpc.secondary_user_agent\"]\n        ].filter((e)=>e).join(\" \"); // remove falsey values first\n        if (\"grpc.keepalive_time_ms\" in options) {\n            this.keepaliveTimeMs = options[\"grpc.keepalive_time_ms\"];\n        }\n        if (\"grpc.keepalive_timeout_ms\" in options) {\n            this.keepaliveTimeoutMs = options[\"grpc.keepalive_timeout_ms\"];\n        }\n        if (\"grpc.keepalive_permit_without_calls\" in options) {\n            this.keepaliveWithoutCalls = options[\"grpc.keepalive_permit_without_calls\"] === 1;\n        } else {\n            this.keepaliveWithoutCalls = false;\n        }\n        this.keepaliveIntervalId = setTimeout(()=>{}, 0);\n        clearTimeout(this.keepaliveIntervalId);\n        this.keepaliveTimeoutId = setTimeout(()=>{}, 0);\n        clearTimeout(this.keepaliveTimeoutId);\n        const backoffOptions = {\n            initialDelay: options[\"grpc.initial_reconnect_backoff_ms\"],\n            maxDelay: options[\"grpc.max_reconnect_backoff_ms\"]\n        };\n        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(()=>{\n            this.handleBackoffTimer();\n        }, backoffOptions);\n        this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);\n        if (options[\"grpc.enable_channelz\"] === 0) {\n            this.channelzEnabled = false;\n        }\n        this.channelzTrace = new channelz_1.ChannelzTrace();\n        this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, ()=>this.getChannelzInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", \"Subchannel created\");\n        }\n        this.trace(\"Subchannel constructed with options \" + JSON.stringify(options, undefined, 2));\n    }\n    getChannelzInfo() {\n        return {\n            state: this.connectivityState,\n            trace: this.channelzTrace,\n            callTracker: this.callTracker,\n            children: this.childrenTracker.getChildLists(),\n            target: this.subchannelAddressString\n        };\n    }\n    getChannelzSocketInfo() {\n        var _a, _b, _c;\n        if (this.session === null) {\n            return null;\n        }\n        const sessionSocket = this.session.socket;\n        const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n        const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n        let tlsInfo;\n        if (this.session.encrypted) {\n            const tlsSocket = sessionSocket;\n            const cipherInfo = tlsSocket.getCipher();\n            const certificate = tlsSocket.getCertificate();\n            const peerCertificate = tlsSocket.getPeerCertificate();\n            tlsInfo = {\n                cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n                cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n                localCertificate: certificate && \"raw\" in certificate ? certificate.raw : null,\n                remoteCertificate: peerCertificate && \"raw\" in peerCertificate ? peerCertificate.raw : null\n            };\n        } else {\n            tlsInfo = null;\n        }\n        const socketInfo = {\n            remoteAddress: remoteAddress,\n            localAddress: localAddress,\n            security: tlsInfo,\n            remoteName: this.remoteName,\n            streamsStarted: this.streamTracker.callsStarted,\n            streamsSucceeded: this.streamTracker.callsSucceeded,\n            streamsFailed: this.streamTracker.callsFailed,\n            messagesSent: this.messagesSent,\n            messagesReceived: this.messagesReceived,\n            keepAlivesSent: this.keepalivesSent,\n            lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n            lastRemoteStreamCreatedTimestamp: null,\n            lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n            lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n            localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n            remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n        };\n        return socketInfo;\n    }\n    resetChannelzSocketInfo() {\n        if (!this.channelzEnabled) {\n            return;\n        }\n        if (this.channelzSocketRef) {\n            channelz_1.unregisterChannelzRef(this.channelzSocketRef);\n            this.childrenTracker.unrefChild(this.channelzSocketRef);\n            this.channelzSocketRef = null;\n        }\n        this.remoteName = null;\n        this.streamTracker = new channelz_1.ChannelzCallTracker();\n        this.keepalivesSent = 0;\n        this.messagesSent = 0;\n        this.messagesReceived = 0;\n        this.lastMessageSentTimestamp = null;\n        this.lastMessageReceivedTimestamp = null;\n    }\n    trace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    refTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"subchannel_refcount\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    flowControlTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    internalsTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"subchannel_internals\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    keepaliveTrace(text) {\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"keepalive\", \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" \" + text);\n    }\n    handleBackoffTimer() {\n        if (this.continueConnecting) {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.CONNECTING);\n        } else {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n            ], connectivity_state_1.ConnectivityState.IDLE);\n        }\n    }\n    /**\n     * Start a backoff timer with the current nextBackoff timeout\n     */ startBackoff() {\n        this.backoffTimeout.runOnce();\n    }\n    stopBackoff() {\n        this.backoffTimeout.stop();\n        this.backoffTimeout.reset();\n    }\n    sendPing() {\n        var _a, _b;\n        if (this.channelzEnabled) {\n            this.keepalivesSent += 1;\n        }\n        this.keepaliveTrace(\"Sending ping with timeout \" + this.keepaliveTimeoutMs + \"ms\");\n        this.keepaliveTimeoutId = setTimeout(()=>{\n            this.keepaliveTrace(\"Ping timeout passed without response\");\n            this.handleDisconnect();\n        }, this.keepaliveTimeoutMs);\n        (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        try {\n            this.session.ping((err, duration, payload)=>{\n                this.keepaliveTrace(\"Received ping response\");\n                clearTimeout(this.keepaliveTimeoutId);\n            });\n        } catch (e) {\n            /* If we fail to send a ping, the connection is no longer functional, so\n             * we should discard it. */ this.transitionToState([\n                connectivity_state_1.ConnectivityState.READY\n            ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        }\n    }\n    startKeepalivePings() {\n        var _a, _b;\n        this.keepaliveIntervalId = setInterval(()=>{\n            this.sendPing();\n        }, this.keepaliveTimeMs);\n        (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    /* Don't send a ping immediately because whatever caused us to start\n         * sending pings should also involve some network activity. */ }\n    /**\n     * Stop keepalive pings when terminating a connection. This discards the\n     * outstanding ping timeout, so it should not be called if the same\n     * connection will still be used.\n     */ stopKeepalivePings() {\n        clearInterval(this.keepaliveIntervalId);\n        clearTimeout(this.keepaliveTimeoutId);\n    }\n    createSession(proxyConnectionResult) {\n        var _a, _b, _c;\n        if (proxyConnectionResult.realTarget) {\n            this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);\n            this.trace(\"creating HTTP/2 session through proxy to \" + proxyConnectionResult.realTarget);\n        } else {\n            this.remoteName = null;\n            this.trace(\"creating HTTP/2 session\");\n        }\n        const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n        let connectionOptions = this.credentials._getConnectionOptions() || {};\n        connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n        if (\"grpc-node.max_session_memory\" in this.options) {\n            connectionOptions.maxSessionMemory = this.options[\"grpc-node.max_session_memory\"];\n        } else {\n            /* By default, set a very large max session memory limit, to effectively\n             * disable enforcement of the limit. Some testing indicates that Node's\n             * behavior degrades badly when this limit is reached, so we solve that\n             * by disabling the check entirely. */ connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n        }\n        let addressScheme = \"http://\";\n        if (\"secureContext\" in connectionOptions) {\n            addressScheme = \"https://\";\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (this.options[\"grpc.ssl_target_name_override\"]) {\n                const sslTargetNameOverride = this.options[\"grpc.ssl_target_name_override\"];\n                connectionOptions.checkServerIdentity = (host, cert)=>{\n                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            } else {\n                const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : \"localhost\";\n                // We want to always set servername to support SNI\n                connectionOptions.servername = authorityHostname;\n            }\n            if (proxyConnectionResult.socket) {\n                /* This is part of the workaround for\n                 * https://github.com/nodejs/node/issues/32922. Without that bug,\n                 * proxyConnectionResult.socket would always be a plaintext socket and\n                 * this would say\n                 * connectionOptions.socket = proxyConnectionResult.socket; */ connectionOptions.createConnection = (authority, option)=>{\n                    return proxyConnectionResult.socket;\n                };\n            }\n        } else {\n            /* In all but the most recent versions of Node, http2.connect does not use\n             * the options when establishing plaintext connections, so we need to\n             * establish that connection explicitly. */ connectionOptions.createConnection = (authority, option)=>{\n                if (proxyConnectionResult.socket) {\n                    return proxyConnectionResult.socket;\n                } else {\n                    /* net.NetConnectOpts is declared in a way that is more restrictive\n                     * than what net.connect will actually accept, so we use the type\n                     * assertion to work around that. */ return net.connect(this.subchannelAddress);\n                }\n            };\n        }\n        connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);\n        /* http2.connect uses the options here:\n         * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n         * The spread operator overides earlier values with later ones, so any port\n         * or host values in the options will be used rather than any values extracted\n         * from the first argument. In addition, the path overrides the host and port,\n         * as documented for plaintext connections here:\n         * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n         * and for TLS connections here:\n         * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n         * earlier versions of Node, http2.connect passes these options to\n         * tls.connect but not net.connect, so in the insecure case we still need\n         * to set the createConnection option above to create the connection\n         * explicitly. We cannot do that in the TLS case because http2.connect\n         * passes necessary additional options to tls.connect.\n         * The first argument just needs to be parseable as a URL and the scheme\n         * determines whether the connection will be established over TLS or not.\n         */ const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n        this.session = session;\n        this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, ()=>this.getChannelzSocketInfo(), this.channelzEnabled);\n        if (this.channelzEnabled) {\n            this.childrenTracker.refChild(this.channelzSocketRef);\n        }\n        session.unref();\n        /* For all of these events, check if the session at the time of the event\n         * is the same one currently attached to this subchannel, to ensure that\n         * old events from previous connection attempts cannot cause invalid state\n         * transitions. */ session.once(\"connect\", ()=>{\n            if (this.session === session) {\n                this.transitionToState([\n                    connectivity_state_1.ConnectivityState.CONNECTING\n                ], connectivity_state_1.ConnectivityState.READY);\n            }\n        });\n        session.once(\"close\", ()=>{\n            if (this.session === session) {\n                this.trace(\"connection closed\");\n                this.transitionToState([\n                    connectivity_state_1.ConnectivityState.CONNECTING\n                ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n                /* Transitioning directly to IDLE here should be OK because we are not\n                 * doing any backoff, because a connection was established at some\n                 * point */ this.transitionToState([\n                    connectivity_state_1.ConnectivityState.READY\n                ], connectivity_state_1.ConnectivityState.IDLE);\n            }\n        });\n        session.once(\"goaway\", (errorCode, lastStreamID, opaqueData)=>{\n            if (this.session === session) {\n                /* See the last paragraph of\n                 * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */ if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n                    this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n                    logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);\n                }\n                this.trace(\"connection closed by GOAWAY with code \" + errorCode);\n                this.transitionToState([\n                    connectivity_state_1.ConnectivityState.CONNECTING,\n                    connectivity_state_1.ConnectivityState.READY\n                ], connectivity_state_1.ConnectivityState.IDLE);\n            }\n        });\n        session.once(\"error\", (error)=>{\n            /* Do nothing here. Any error should also trigger a close event, which is\n             * where we want to handle that.  */ this.trace(\"connection closed with error \" + error.message);\n        });\n        if (logging.isTracerEnabled(TRACER_NAME)) {\n            session.on(\"remoteSettings\", (settings)=>{\n                this.trace(\"new settings received\" + (this.session !== session ? \" on the old connection\" : \"\") + \": \" + JSON.stringify(settings));\n            });\n            session.on(\"localSettings\", (settings)=>{\n                this.trace(\"local settings acknowledged by remote\" + (this.session !== session ? \" on the old connection\" : \"\") + \": \" + JSON.stringify(settings));\n            });\n        }\n    }\n    startConnectingInternal() {\n        var _a, _b;\n        /* Pass connection options through to the proxy so that it's able to\n         * upgrade it's connection to support tls if needed.\n         * This is a workaround for https://github.com/nodejs/node/issues/32922\n         * See https://github.com/grpc/grpc-node/pull/1369 for more info. */ const connectionOptions = this.credentials._getConnectionOptions() || {};\n        if (\"secureContext\" in connectionOptions) {\n            connectionOptions.ALPNProtocols = [\n                \"h2\"\n            ];\n            // If provided, the value of grpc.ssl_target_name_override should be used\n            // to override the target hostname when checking server identity.\n            // This option is used for testing only.\n            if (this.options[\"grpc.ssl_target_name_override\"]) {\n                const sslTargetNameOverride = this.options[\"grpc.ssl_target_name_override\"];\n                connectionOptions.checkServerIdentity = (host, cert)=>{\n                    return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n                };\n                connectionOptions.servername = sslTargetNameOverride;\n            } else {\n                if (\"grpc.http_connect_target\" in this.options) {\n                    /* This is more or less how servername will be set in createSession\n                     * if a connection is successfully established through the proxy.\n                     * If the proxy is not used, these connectionOptions are discarded\n                     * anyway */ const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options[\"grpc.http_connect_target\"])) !== null && _a !== void 0 ? _a : {\n                        path: \"localhost\"\n                    });\n                    const hostPort = uri_parser_1.splitHostPort(targetPath);\n                    connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n                }\n            }\n        }\n        http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then((result)=>{\n            this.createSession(result);\n        }, (reason)=>{\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.CONNECTING\n            ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        });\n    }\n    handleDisconnect() {\n        this.transitionToState([\n            connectivity_state_1.ConnectivityState.READY\n        ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        for (const listener of this.disconnectListeners.values()){\n            listener();\n        }\n    }\n    /**\n     * Initiate a state transition from any element of oldStates to the new\n     * state. If the current connectivityState is not in oldStates, do nothing.\n     * @param oldStates The set of states to transition from\n     * @param newState The state to transition to\n     * @returns True if the state changed, false otherwise\n     */ transitionToState(oldStates, newState) {\n        if (oldStates.indexOf(this.connectivityState) === -1) {\n            return false;\n        }\n        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        if (this.channelzEnabled) {\n            this.channelzTrace.addTrace(\"CT_INFO\", connectivity_state_1.ConnectivityState[this.connectivityState] + \" -> \" + connectivity_state_1.ConnectivityState[newState]);\n        }\n        const previousState = this.connectivityState;\n        this.connectivityState = newState;\n        switch(newState){\n            case connectivity_state_1.ConnectivityState.READY:\n                this.stopBackoff();\n                const session = this.session;\n                session.socket.once(\"close\", ()=>{\n                    if (this.session === session) {\n                        this.handleDisconnect();\n                    }\n                });\n                if (this.keepaliveWithoutCalls) {\n                    this.startKeepalivePings();\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.CONNECTING:\n                this.startBackoff();\n                this.startConnectingInternal();\n                this.continueConnecting = false;\n                break;\n            case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n                if (this.session) {\n                    this.session.close();\n                }\n                this.session = null;\n                this.resetChannelzSocketInfo();\n                this.stopKeepalivePings();\n                /* If the backoff timer has already ended by the time we get to the\n                 * TRANSIENT_FAILURE state, we want to immediately transition out of\n                 * TRANSIENT_FAILURE as though the backoff timer is ending right now */ if (!this.backoffTimeout.isRunning()) {\n                    process.nextTick(()=>{\n                        this.handleBackoffTimer();\n                    });\n                }\n                break;\n            case connectivity_state_1.ConnectivityState.IDLE:\n                if (this.session) {\n                    this.session.close();\n                }\n                this.session = null;\n                this.resetChannelzSocketInfo();\n                this.stopKeepalivePings();\n                break;\n            default:\n                throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n        }\n        /* We use a shallow copy of the stateListeners array in case a listener\n         * is removed during this iteration */ for (const listener of [\n            ...this.stateListeners\n        ]){\n            listener(this, previousState, newState);\n        }\n        return true;\n    }\n    /**\n     * Check if the subchannel associated with zero calls and with zero channels.\n     * If so, shut it down.\n     */ checkBothRefcounts() {\n        /* If no calls, channels, or subchannel pools have any more references to\n         * this subchannel, we can be sure it will never be used again. */ if (this.callRefcount === 0 && this.refcount === 0) {\n            if (this.channelzEnabled) {\n                this.channelzTrace.addTrace(\"CT_INFO\", \"Shutting down\");\n            }\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.CONNECTING,\n                connectivity_state_1.ConnectivityState.READY\n            ], connectivity_state_1.ConnectivityState.IDLE);\n            if (this.channelzEnabled) {\n                channelz_1.unregisterChannelzRef(this.channelzRef);\n            }\n        }\n    }\n    callRef() {\n        this.refTrace(\"callRefcount \" + this.callRefcount + \" -> \" + (this.callRefcount + 1));\n        if (this.callRefcount === 0) {\n            if (this.session) {\n                this.session.ref();\n            }\n            this.backoffTimeout.ref();\n            if (!this.keepaliveWithoutCalls) {\n                this.startKeepalivePings();\n            }\n        }\n        this.callRefcount += 1;\n    }\n    callUnref() {\n        this.refTrace(\"callRefcount \" + this.callRefcount + \" -> \" + (this.callRefcount - 1));\n        this.callRefcount -= 1;\n        if (this.callRefcount === 0) {\n            if (this.session) {\n                this.session.unref();\n            }\n            this.backoffTimeout.unref();\n            if (!this.keepaliveWithoutCalls) {\n                clearInterval(this.keepaliveIntervalId);\n            }\n            this.checkBothRefcounts();\n        }\n    }\n    ref() {\n        this.refTrace(\"refcount \" + this.refcount + \" -> \" + (this.refcount + 1));\n        this.refcount += 1;\n    }\n    unref() {\n        this.refTrace(\"refcount \" + this.refcount + \" -> \" + (this.refcount - 1));\n        this.refcount -= 1;\n        this.checkBothRefcounts();\n    }\n    unrefIfOneRef() {\n        if (this.refcount === 1) {\n            this.unref();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Start a stream on the current session with the given `metadata` as headers\n     * and then attach it to the `callStream`. Must only be called if the\n     * subchannel's current connectivity state is READY.\n     * @param metadata\n     * @param callStream\n     */ startCallStream(metadata, callStream, extraFilters) {\n        const headers = metadata.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = \"application/grpc\";\n        headers[HTTP2_HEADER_METHOD] = \"POST\";\n        headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n        headers[HTTP2_HEADER_TE] = \"trailers\";\n        let http2Stream;\n        /* In theory, if an error is thrown by session.request because session has\n         * become unusable (e.g. because it has received a goaway), this subchannel\n         * should soon see the corresponding close or goaway event anyway and leave\n         * READY. But we have seen reports that this does not happen\n         * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n         * so for defense in depth, we just discard the session when we see an\n         * error here.\n         */ try {\n            http2Stream = this.session.request(headers);\n        } catch (e) {\n            this.transitionToState([\n                connectivity_state_1.ConnectivityState.READY\n            ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n            throw e;\n        }\n        let headersString = \"\";\n        for (const header of Object.keys(headers)){\n            headersString += \"\t\t\" + header + \": \" + headers[header] + \"\\n\";\n        }\n        logging.trace(constants_1.LogVerbosity.DEBUG, \"call_stream\", \"Starting stream [\" + callStream.getCallNumber() + \"] on subchannel \" + \"(\" + this.channelzRef.id + \") \" + this.subchannelAddressString + \" with headers\\n\" + headersString);\n        this.flowControlTrace(\"local window size: \" + this.session.state.localWindowSize + \" remote window size: \" + this.session.state.remoteWindowSize);\n        const streamSession = this.session;\n        this.internalsTrace(\"session.closed=\" + streamSession.closed + \" session.destroyed=\" + streamSession.destroyed + \" session.socket.destroyed=\" + streamSession.socket.destroyed);\n        let statsTracker;\n        if (this.channelzEnabled) {\n            this.callTracker.addCallStarted();\n            callStream.addStatusWatcher((status)=>{\n                if (status.code === constants_1.Status.OK) {\n                    this.callTracker.addCallSucceeded();\n                } else {\n                    this.callTracker.addCallFailed();\n                }\n            });\n            this.streamTracker.addCallStarted();\n            callStream.addStreamEndWatcher((success)=>{\n                if (streamSession === this.session) {\n                    if (success) {\n                        this.streamTracker.addCallSucceeded();\n                    } else {\n                        this.streamTracker.addCallFailed();\n                    }\n                }\n            });\n            statsTracker = {\n                addMessageSent: ()=>{\n                    this.messagesSent += 1;\n                    this.lastMessageSentTimestamp = new Date();\n                },\n                addMessageReceived: ()=>{\n                    this.messagesReceived += 1;\n                }\n            };\n        } else {\n            statsTracker = {\n                addMessageSent: ()=>{},\n                addMessageReceived: ()=>{}\n            };\n        }\n        callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n    }\n    /**\n     * If the subchannel is currently IDLE, start connecting and switch to the\n     * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n     * the next time it would transition to IDLE, start connecting again instead.\n     * Otherwise, do nothing.\n     */ startConnecting() {\n        /* First, try to transition from IDLE to connecting. If that doesn't happen\n         * because the state is not currently IDLE, check if it is\n         * TRANSIENT_FAILURE, and if so indicate that it should go back to\n         * connecting after the backoff timer ends. Otherwise do nothing */ if (!this.transitionToState([\n            connectivity_state_1.ConnectivityState.IDLE\n        ], connectivity_state_1.ConnectivityState.CONNECTING)) {\n            if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.continueConnecting = true;\n            }\n        }\n    }\n    /**\n     * Get the subchannel's current connectivity state.\n     */ getConnectivityState() {\n        return this.connectivityState;\n    }\n    /**\n     * Add a listener function to be called whenever the subchannel's\n     * connectivity state changes.\n     * @param listener\n     */ addConnectivityStateListener(listener) {\n        this.stateListeners.push(listener);\n    }\n    /**\n     * Remove a listener previously added with `addConnectivityStateListener`\n     * @param listener A reference to a function previously passed to\n     *     `addConnectivityStateListener`\n     */ removeConnectivityStateListener(listener) {\n        const listenerIndex = this.stateListeners.indexOf(listener);\n        if (listenerIndex > -1) {\n            this.stateListeners.splice(listenerIndex, 1);\n        }\n    }\n    addDisconnectListener(listener) {\n        this.disconnectListeners.add(listener);\n    }\n    removeDisconnectListener(listener) {\n        this.disconnectListeners.delete(listener);\n    }\n    /**\n     * Reset the backoff timeout, and immediately start connecting if in backoff.\n     */ resetBackoff() {\n        this.backoffTimeout.reset();\n        this.transitionToState([\n            connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE\n        ], connectivity_state_1.ConnectivityState.CONNECTING);\n    }\n    getAddress() {\n        return this.subchannelAddressString;\n    }\n    getChannelzRef() {\n        return this.channelzRef;\n    }\n    getRealSubchannel() {\n        return this;\n    }\n}\nexports.Subchannel = Subchannel; //# sourceMappingURL=subchannel.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvc3ViY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsa0JBQWtCLEdBQUcsS0FBSztBQUMxQixNQUFNRyxRQUFRQyxtQkFBT0EsQ0FBQyxvQkFBTztBQUM3QixNQUFNQyxRQUFRRCxtQkFBT0EsQ0FBQyxnQkFBSztBQUMzQixNQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNRyxvQkFBb0JILG1CQUFPQSxDQUFDLDBGQUFtQjtBQUNyRCxNQUFNSSxhQUFhSixtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNSyxVQUFVTCxtQkFBT0EsQ0FBQywwRUFBVztBQUNuQyxNQUFNTSxjQUFjTixtQkFBT0EsQ0FBQyw4RUFBYTtBQUN6QyxNQUFNTyxlQUFlUCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNUSxNQUFNUixtQkFBT0EsQ0FBQyxnQkFBSztBQUN6QixNQUFNUyxlQUFlVCxtQkFBT0EsQ0FBQyxnRkFBYztBQUMzQyxNQUFNVSx1QkFBdUJWLG1CQUFPQSxDQUFDLGdHQUFzQjtBQUMzRCxNQUFNVyxhQUFhWCxtQkFBT0EsQ0FBQyw0RUFBWTtBQUN2QyxNQUFNWSxnQkFBZ0JaLDBHQUFxQztBQUMzRCxNQUFNYyxjQUFjO0FBQ3BCLE1BQU1DLDJCQUEyQjtBQUNqQyxNQUFNQyx5QkFBeUI7QUFDL0IsTUFBTUMscUJBQXFCO0FBQzNCLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxpQkFBaUI7QUFDdkIsTUFBTUMsaUJBQWlCO0FBQ3ZCOzttQkFFbUIsR0FDbkIsTUFBTUMsd0JBQXdCLENBQUUsTUFBSyxFQUFDO0FBQ3RDLE1BQU1DLHVCQUF1QjtBQUM3QixNQUFNLEVBQUVDLHNCQUFzQixFQUFFQyx5QkFBeUIsRUFBRUMsbUJBQW1CLEVBQUVDLGlCQUFpQixFQUFFQyxlQUFlLEVBQUVDLHVCQUF1QixFQUFHLEdBQUc3QixNQUFNOEIsU0FBUztBQUNoSzs7OztDQUlDLEdBQ0QsU0FBU0MsY0FBY0MsR0FBRyxFQUFFQyxHQUFHO0lBQzNCLE9BQU9DLEtBQUtDLE1BQU0sS0FBTUYsQ0FBQUEsTUFBTUQsR0FBRSxJQUFLQTtBQUN6QztBQUNBLE1BQU1JLG1CQUFtQkMsT0FBT0MsSUFBSSxDQUFDLGtCQUFrQjtBQUN2RCxNQUFNdkM7SUFDRjs7Ozs7Ozs7O0tBU0MsR0FDRHdDLFlBQVlDLGFBQWEsRUFBRUMsaUJBQWlCLEVBQUVDLE9BQU8sRUFBRUMsV0FBVyxDQUFFO1FBQ2hFLElBQUksQ0FBQ0gsYUFBYSxHQUFHQTtRQUNyQixJQUFJLENBQUNDLGlCQUFpQixHQUFHQTtRQUN6QixJQUFJLENBQUNDLE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLFdBQVcsR0FBR0E7UUFDbkI7OztTQUdDLEdBQ0QsSUFBSSxDQUFDQyxpQkFBaUIsR0FBR3pDLHFCQUFxQjBDLGlCQUFpQixDQUFDQyxJQUFJO1FBQ3BFOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZjs7O1NBR0MsR0FDRCxJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNDLGNBQWMsR0FBRyxFQUFFO1FBQ3hCOzs7O1NBSUMsR0FDRCxJQUFJLENBQUNDLG1CQUFtQixHQUFHLElBQUlDO1FBQy9COztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxlQUFlLEdBQUc5QjtRQUN2Qjs7U0FFQyxHQUNELElBQUksQ0FBQytCLGtCQUFrQixHQUFHOUI7UUFDMUI7O1NBRUMsR0FDRCxJQUFJLENBQUMrQixxQkFBcUIsR0FBRztRQUM3Qjs7U0FFQyxHQUNELElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCOztTQUVDLEdBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUc7UUFDaEIsZ0JBQWdCO1FBQ2hCLElBQUksQ0FBQ0MsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0MsV0FBVyxHQUFHLElBQUk5QyxXQUFXK0MsbUJBQW1CO1FBQ3JELElBQUksQ0FBQ0MsZUFBZSxHQUFHLElBQUloRCxXQUFXaUQsdUJBQXVCO1FBQzdELHVCQUF1QjtRQUN2QixJQUFJLENBQUNDLGlCQUFpQixHQUFHO1FBQ3pCOzs7U0FHQyxHQUNELElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUlwRCxXQUFXK0MsbUJBQW1CO1FBQ3ZELElBQUksQ0FBQ00sY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyx3QkFBd0IsR0FBRztRQUNoQyxJQUFJLENBQUNDLDRCQUE0QixHQUFHO1FBQ3BDLDJCQUEyQjtRQUMzQixJQUFJLENBQUNDLFNBQVMsR0FBRztZQUNiNUIsT0FBTyxDQUFDLDBCQUEwQjtZQUNsQyxDQUFDLGFBQWEsRUFBRTdCLGNBQWMsQ0FBQztZQUMvQjZCLE9BQU8sQ0FBQyw0QkFBNEI7U0FDdkMsQ0FDSTZCLE1BQU0sQ0FBQyxDQUFDQyxJQUFNQSxHQUNkQyxJQUFJLENBQUMsTUFBTSw2QkFBNkI7UUFDN0MsSUFBSSw0QkFBNEIvQixTQUFTO1lBQ3JDLElBQUksQ0FBQ1UsZUFBZSxHQUFHVixPQUFPLENBQUMseUJBQXlCO1FBQzVEO1FBQ0EsSUFBSSwrQkFBK0JBLFNBQVM7WUFDeEMsSUFBSSxDQUFDVyxrQkFBa0IsR0FBR1gsT0FBTyxDQUFDLDRCQUE0QjtRQUNsRTtRQUNBLElBQUkseUNBQXlDQSxTQUFTO1lBQ2xELElBQUksQ0FBQ1kscUJBQXFCLEdBQ3RCWixPQUFPLENBQUMsc0NBQXNDLEtBQUs7UUFDM0QsT0FDSztZQUNELElBQUksQ0FBQ1kscUJBQXFCLEdBQUc7UUFDakM7UUFDQSxJQUFJLENBQUNvQixtQkFBbUIsR0FBR0MsV0FBVyxLQUFRLEdBQUc7UUFDakRDLGFBQWEsSUFBSSxDQUFDRixtQkFBbUI7UUFDckMsSUFBSSxDQUFDRyxrQkFBa0IsR0FBR0YsV0FBVyxLQUFRLEdBQUc7UUFDaERDLGFBQWEsSUFBSSxDQUFDQyxrQkFBa0I7UUFDcEMsTUFBTUMsaUJBQWlCO1lBQ25CQyxjQUFjckMsT0FBTyxDQUFDLG9DQUFvQztZQUMxRHNDLFVBQVV0QyxPQUFPLENBQUMsZ0NBQWdDO1FBQ3REO1FBQ0EsSUFBSSxDQUFDdUMsY0FBYyxHQUFHLElBQUk3RSxrQkFBa0I4RSxjQUFjLENBQUM7WUFDdkQsSUFBSSxDQUFDQyxrQkFBa0I7UUFDM0IsR0FBR0w7UUFDSCxJQUFJLENBQUNNLHVCQUF1QixHQUFHekUscUJBQXFCMEUseUJBQXlCLENBQUM1QztRQUM5RSxJQUFJQyxPQUFPLENBQUMsdUJBQXVCLEtBQUssR0FBRztZQUN2QyxJQUFJLENBQUNlLGVBQWUsR0FBRztRQUMzQjtRQUNBLElBQUksQ0FBQzZCLGFBQWEsR0FBRyxJQUFJMUUsV0FBVzJFLGFBQWE7UUFDakQsSUFBSSxDQUFDQyxXQUFXLEdBQUc1RSxXQUFXNkUsMEJBQTBCLENBQUMsSUFBSSxDQUFDTCx1QkFBdUIsRUFBRSxJQUFNLElBQUksQ0FBQ00sZUFBZSxJQUFJLElBQUksQ0FBQ2pDLGVBQWU7UUFDekksSUFBSSxJQUFJLENBQUNBLGVBQWUsRUFBRTtZQUN0QixJQUFJLENBQUM2QixhQUFhLENBQUNLLFFBQVEsQ0FBQyxXQUFXO1FBQzNDO1FBQ0EsSUFBSSxDQUFDQyxLQUFLLENBQUMseUNBQXlDQyxLQUFLQyxTQUFTLENBQUNwRCxTQUFTcUQsV0FBVztJQUMzRjtJQUNBTCxrQkFBa0I7UUFDZCxPQUFPO1lBQ0hNLE9BQU8sSUFBSSxDQUFDcEQsaUJBQWlCO1lBQzdCZ0QsT0FBTyxJQUFJLENBQUNOLGFBQWE7WUFDekI1QixhQUFhLElBQUksQ0FBQ0EsV0FBVztZQUM3QnVDLFVBQVUsSUFBSSxDQUFDckMsZUFBZSxDQUFDc0MsYUFBYTtZQUM1Q0MsUUFBUSxJQUFJLENBQUNmLHVCQUF1QjtRQUN4QztJQUNKO0lBQ0FnQix3QkFBd0I7UUFDcEIsSUFBSUMsSUFBSUMsSUFBSUM7UUFDWixJQUFJLElBQUksQ0FBQ3hELE9BQU8sS0FBSyxNQUFNO1lBQ3ZCLE9BQU87UUFDWDtRQUNBLE1BQU15RCxnQkFBZ0IsSUFBSSxDQUFDekQsT0FBTyxDQUFDMEQsTUFBTTtRQUN6QyxNQUFNQyxnQkFBZ0JGLGNBQWNFLGFBQWEsR0FBRy9GLHFCQUFxQmdHLHlCQUF5QixDQUFDSCxjQUFjRSxhQUFhLEVBQUVGLGNBQWNJLFVBQVUsSUFBSTtRQUM1SixNQUFNQyxlQUFlTCxjQUFjSyxZQUFZLEdBQUdsRyxxQkFBcUJnRyx5QkFBeUIsQ0FBQ0gsY0FBY0ssWUFBWSxFQUFFTCxjQUFjTSxTQUFTLElBQUk7UUFDeEosSUFBSUM7UUFDSixJQUFJLElBQUksQ0FBQ2hFLE9BQU8sQ0FBQ2lFLFNBQVMsRUFBRTtZQUN4QixNQUFNQyxZQUFZVDtZQUNsQixNQUFNVSxhQUFhRCxVQUFVRSxTQUFTO1lBQ3RDLE1BQU1DLGNBQWNILFVBQVVJLGNBQWM7WUFDNUMsTUFBTUMsa0JBQWtCTCxVQUFVTSxrQkFBa0I7WUFDcERSLFVBQVU7Z0JBQ05TLHlCQUF5QixDQUFDbkIsS0FBS2EsV0FBV08sWUFBWSxNQUFNLFFBQVFwQixPQUFPLEtBQUssSUFBSUEsS0FBSztnQkFDekZxQixzQkFBc0JSLFdBQVdPLFlBQVksR0FBRyxPQUFPUCxXQUFXUyxJQUFJO2dCQUN0RUMsa0JBQWtCLGVBQWdCLFNBQVNSLGNBQWVBLFlBQVlTLEdBQUcsR0FBRztnQkFDNUVDLG1CQUFtQixtQkFBb0IsU0FBU1Isa0JBQW1CQSxnQkFBZ0JPLEdBQUcsR0FBRztZQUM3RjtRQUNKLE9BQ0s7WUFDRGQsVUFBVTtRQUNkO1FBQ0EsTUFBTWdCLGFBQWE7WUFDZnJCLGVBQWVBO1lBQ2ZHLGNBQWNBO1lBQ2RtQixVQUFVakI7WUFDVmhELFlBQVksSUFBSSxDQUFDQSxVQUFVO1lBQzNCa0UsZ0JBQWdCLElBQUksQ0FBQ2pFLGFBQWEsQ0FBQ2tFLFlBQVk7WUFDL0NDLGtCQUFrQixJQUFJLENBQUNuRSxhQUFhLENBQUNvRSxjQUFjO1lBQ25EQyxlQUFlLElBQUksQ0FBQ3JFLGFBQWEsQ0FBQ3NFLFdBQVc7WUFDN0NwRSxjQUFjLElBQUksQ0FBQ0EsWUFBWTtZQUMvQkMsa0JBQWtCLElBQUksQ0FBQ0EsZ0JBQWdCO1lBQ3ZDb0UsZ0JBQWdCLElBQUksQ0FBQ3RFLGNBQWM7WUFDbkN1RSxpQ0FBaUMsSUFBSSxDQUFDeEUsYUFBYSxDQUFDeUUsd0JBQXdCO1lBQzVFQyxrQ0FBa0M7WUFDbEN0RSwwQkFBMEIsSUFBSSxDQUFDQSx3QkFBd0I7WUFDdkRDLDhCQUE4QixJQUFJLENBQUNBLDRCQUE0QjtZQUMvRHNFLHdCQUF3QixDQUFDckMsS0FBSyxJQUFJLENBQUN2RCxPQUFPLENBQUNpRCxLQUFLLENBQUM0QyxlQUFlLE1BQU0sUUFBUXRDLE9BQU8sS0FBSyxJQUFJQSxLQUFLO1lBQ25HdUMseUJBQXlCLENBQUN0QyxLQUFLLElBQUksQ0FBQ3hELE9BQU8sQ0FBQ2lELEtBQUssQ0FBQzhDLGdCQUFnQixNQUFNLFFBQVF2QyxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUN6RztRQUNBLE9BQU93QjtJQUNYO0lBQ0FnQiwwQkFBMEI7UUFDdEIsSUFBSSxDQUFDLElBQUksQ0FBQ3RGLGVBQWUsRUFBRTtZQUN2QjtRQUNKO1FBQ0EsSUFBSSxJQUFJLENBQUNLLGlCQUFpQixFQUFFO1lBQ3hCbEQsV0FBV29JLHFCQUFxQixDQUFDLElBQUksQ0FBQ2xGLGlCQUFpQjtZQUN2RCxJQUFJLENBQUNGLGVBQWUsQ0FBQ3FGLFVBQVUsQ0FBQyxJQUFJLENBQUNuRixpQkFBaUI7WUFDdEQsSUFBSSxDQUFDQSxpQkFBaUIsR0FBRztRQUM3QjtRQUNBLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUlwRCxXQUFXK0MsbUJBQW1CO1FBQ3ZELElBQUksQ0FBQ00sY0FBYyxHQUFHO1FBQ3RCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7UUFDeEIsSUFBSSxDQUFDQyx3QkFBd0IsR0FBRztRQUNoQyxJQUFJLENBQUNDLDRCQUE0QixHQUFHO0lBQ3hDO0lBQ0F1QixNQUFNc0QsSUFBSSxFQUFFO1FBQ1I1SSxRQUFRc0YsS0FBSyxDQUFDckYsWUFBWTRJLFlBQVksQ0FBQ0MsS0FBSyxFQUFFckksYUFBYSxNQUFNLElBQUksQ0FBQ3lFLFdBQVcsQ0FBQzZELEVBQUUsR0FBRyxPQUFPLElBQUksQ0FBQ2pFLHVCQUF1QixHQUFHLE1BQU04RDtJQUN2STtJQUNBSSxTQUFTSixJQUFJLEVBQUU7UUFDWDVJLFFBQVFzRixLQUFLLENBQUNyRixZQUFZNEksWUFBWSxDQUFDQyxLQUFLLEVBQUUsdUJBQXVCLE1BQU0sSUFBSSxDQUFDNUQsV0FBVyxDQUFDNkQsRUFBRSxHQUFHLE9BQU8sSUFBSSxDQUFDakUsdUJBQXVCLEdBQUcsTUFBTThEO0lBQ2pKO0lBQ0FLLGlCQUFpQkwsSUFBSSxFQUFFO1FBQ25CNUksUUFBUXNGLEtBQUssQ0FBQ3JGLFlBQVk0SSxZQUFZLENBQUNDLEtBQUssRUFBRXBJLDBCQUEwQixNQUFNLElBQUksQ0FBQ3dFLFdBQVcsQ0FBQzZELEVBQUUsR0FBRyxPQUFPLElBQUksQ0FBQ2pFLHVCQUF1QixHQUFHLE1BQU04RDtJQUNwSjtJQUNBTSxlQUFlTixJQUFJLEVBQUU7UUFDakI1SSxRQUFRc0YsS0FBSyxDQUFDckYsWUFBWTRJLFlBQVksQ0FBQ0MsS0FBSyxFQUFFLHdCQUF3QixNQUFNLElBQUksQ0FBQzVELFdBQVcsQ0FBQzZELEVBQUUsR0FBRyxPQUFPLElBQUksQ0FBQ2pFLHVCQUF1QixHQUFHLE1BQU04RDtJQUNsSjtJQUNBTyxlQUFlUCxJQUFJLEVBQUU7UUFDakI1SSxRQUFRc0YsS0FBSyxDQUFDckYsWUFBWTRJLFlBQVksQ0FBQ0MsS0FBSyxFQUFFLGFBQWEsTUFBTSxJQUFJLENBQUM1RCxXQUFXLENBQUM2RCxFQUFFLEdBQUcsT0FBTyxJQUFJLENBQUNqRSx1QkFBdUIsR0FBRyxNQUFNOEQ7SUFDdkk7SUFDQS9ELHFCQUFxQjtRQUNqQixJQUFJLElBQUksQ0FBQ25DLGtCQUFrQixFQUFFO1lBQ3pCLElBQUksQ0FBQzBHLGlCQUFpQixDQUFDO2dCQUFDdkoscUJBQXFCMEMsaUJBQWlCLENBQUM4RyxpQkFBaUI7YUFBQyxFQUFFeEoscUJBQXFCMEMsaUJBQWlCLENBQUMrRyxVQUFVO1FBQ3hJLE9BQ0s7WUFDRCxJQUFJLENBQUNGLGlCQUFpQixDQUFDO2dCQUFDdkoscUJBQXFCMEMsaUJBQWlCLENBQUM4RyxpQkFBaUI7YUFBQyxFQUFFeEoscUJBQXFCMEMsaUJBQWlCLENBQUNDLElBQUk7UUFDbEk7SUFDSjtJQUNBOztLQUVDLEdBQ0QrRyxlQUFlO1FBQ1gsSUFBSSxDQUFDNUUsY0FBYyxDQUFDNkUsT0FBTztJQUMvQjtJQUNBQyxjQUFjO1FBQ1YsSUFBSSxDQUFDOUUsY0FBYyxDQUFDK0UsSUFBSTtRQUN4QixJQUFJLENBQUMvRSxjQUFjLENBQUNnRixLQUFLO0lBQzdCO0lBQ0FDLFdBQVc7UUFDUCxJQUFJN0QsSUFBSUM7UUFDUixJQUFJLElBQUksQ0FBQzdDLGVBQWUsRUFBRTtZQUN0QixJQUFJLENBQUNRLGNBQWMsSUFBSTtRQUMzQjtRQUNBLElBQUksQ0FBQ3dGLGNBQWMsQ0FBQywrQkFBK0IsSUFBSSxDQUFDcEcsa0JBQWtCLEdBQUc7UUFDN0UsSUFBSSxDQUFDd0Isa0JBQWtCLEdBQUdGLFdBQVc7WUFDakMsSUFBSSxDQUFDOEUsY0FBYyxDQUFDO1lBQ3BCLElBQUksQ0FBQ1UsZ0JBQWdCO1FBQ3pCLEdBQUcsSUFBSSxDQUFDOUcsa0JBQWtCO1FBQ3pCaUQsQ0FBQUEsS0FBSyxDQUFDRCxLQUFLLElBQUksQ0FBQ3hCLGtCQUFrQixFQUFFdUYsS0FBSyxNQUFNLFFBQVE5RCxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUcrRCxJQUFJLENBQUNoRTtRQUN6RixJQUFJO1lBQ0EsSUFBSSxDQUFDdEQsT0FBTyxDQUFDdUgsSUFBSSxDQUFDLENBQUNDLEtBQUtDLFVBQVVDO2dCQUM5QixJQUFJLENBQUNoQixjQUFjLENBQUM7Z0JBQ3BCN0UsYUFBYSxJQUFJLENBQUNDLGtCQUFrQjtZQUN4QztRQUNKLEVBQ0EsT0FBT0wsR0FBRztZQUNOO3FDQUN5QixHQUN6QixJQUFJLENBQUNrRixpQkFBaUIsQ0FBQztnQkFBQ3ZKLHFCQUFxQjBDLGlCQUFpQixDQUFDNkgsS0FBSzthQUFDLEVBQUV2SyxxQkFBcUIwQyxpQkFBaUIsQ0FBQzhHLGlCQUFpQjtRQUNuSTtJQUNKO0lBQ0FnQixzQkFBc0I7UUFDbEIsSUFBSXRFLElBQUlDO1FBQ1IsSUFBSSxDQUFDNUIsbUJBQW1CLEdBQUdrRyxZQUFZO1lBQ25DLElBQUksQ0FBQ1YsUUFBUTtRQUNqQixHQUFHLElBQUksQ0FBQzlHLGVBQWU7UUFDdEJrRCxDQUFBQSxLQUFLLENBQUNELEtBQUssSUFBSSxDQUFDM0IsbUJBQW1CLEVBQUUwRixLQUFLLE1BQU0sUUFBUTlELE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBRytELElBQUksQ0FBQ2hFO0lBQzFGO29FQUM0RCxHQUNoRTtJQUNBOzs7O0tBSUMsR0FDRHdFLHFCQUFxQjtRQUNqQkMsY0FBYyxJQUFJLENBQUNwRyxtQkFBbUI7UUFDdENFLGFBQWEsSUFBSSxDQUFDQyxrQkFBa0I7SUFDeEM7SUFDQWtHLGNBQWNDLHFCQUFxQixFQUFFO1FBQ2pDLElBQUkzRSxJQUFJQyxJQUFJQztRQUNaLElBQUl5RSxzQkFBc0JDLFVBQVUsRUFBRTtZQUNsQyxJQUFJLENBQUNsSCxVQUFVLEdBQUdyRCxhQUFhd0ssV0FBVyxDQUFDRixzQkFBc0JDLFVBQVU7WUFDM0UsSUFBSSxDQUFDckYsS0FBSyxDQUFDLDhDQUE4Q29GLHNCQUFzQkMsVUFBVTtRQUM3RixPQUNLO1lBQ0QsSUFBSSxDQUFDbEgsVUFBVSxHQUFHO1lBQ2xCLElBQUksQ0FBQzZCLEtBQUssQ0FBQztRQUNmO1FBQ0EsTUFBTXVGLGtCQUFrQjlLLFdBQVcrSyxtQkFBbUIsQ0FBQyxDQUFDL0UsS0FBSzJFLHNCQUFzQkMsVUFBVSxNQUFNLFFBQVE1RSxPQUFPLEtBQUssSUFBSUEsS0FBSyxJQUFJLENBQUM3RCxhQUFhO1FBQ2xKLElBQUk2SSxvQkFBb0IsSUFBSSxDQUFDMUksV0FBVyxDQUFDMkkscUJBQXFCLE1BQU0sQ0FBQztRQUNyRUQsa0JBQWtCRSx3QkFBd0IsR0FBR0MsT0FBT0MsZ0JBQWdCO1FBQ3BFLElBQUksa0NBQWtDLElBQUksQ0FBQy9JLE9BQU8sRUFBRTtZQUNoRDJJLGtCQUFrQkssZ0JBQWdCLEdBQUcsSUFBSSxDQUFDaEosT0FBTyxDQUFDLCtCQUErQjtRQUNyRixPQUNLO1lBQ0Q7OztnREFHb0MsR0FDcEMySSxrQkFBa0JLLGdCQUFnQixHQUFHRixPQUFPQyxnQkFBZ0I7UUFDaEU7UUFDQSxJQUFJRSxnQkFBZ0I7UUFDcEIsSUFBSSxtQkFBbUJOLG1CQUFtQjtZQUN0Q00sZ0JBQWdCO1lBQ2hCLHlFQUF5RTtZQUN6RSxpRUFBaUU7WUFDakUsd0NBQXdDO1lBQ3hDLElBQUksSUFBSSxDQUFDakosT0FBTyxDQUFDLGdDQUFnQyxFQUFFO2dCQUMvQyxNQUFNa0osd0JBQXdCLElBQUksQ0FBQ2xKLE9BQU8sQ0FBQyxnQ0FBZ0M7Z0JBQzNFMkksa0JBQWtCUSxtQkFBbUIsR0FBRyxDQUFDQyxNQUFNQztvQkFDM0MsT0FBTzdMLE1BQU0yTCxtQkFBbUIsQ0FBQ0QsdUJBQXVCRztnQkFDNUQ7Z0JBQ0FWLGtCQUFrQlcsVUFBVSxHQUFHSjtZQUNuQyxPQUNLO2dCQUNELE1BQU1LLG9CQUFvQixDQUFDMUYsS0FBSyxDQUFDRCxLQUFLNUYsYUFBYXdMLGFBQWEsQ0FBQ2YsZ0JBQWUsTUFBTyxRQUFRN0UsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHd0YsSUFBSSxNQUFNLFFBQVF2RixPQUFPLEtBQUssSUFBSUEsS0FBSztnQkFDbEssa0RBQWtEO2dCQUNsRDhFLGtCQUFrQlcsVUFBVSxHQUFHQztZQUNuQztZQUNBLElBQUlqQixzQkFBc0J2RSxNQUFNLEVBQUU7Z0JBQzlCOzs7OzRFQUk0RCxHQUM1RDRFLGtCQUFrQmMsZ0JBQWdCLEdBQUcsQ0FBQ0MsV0FBV0M7b0JBQzdDLE9BQU9yQixzQkFBc0J2RSxNQUFNO2dCQUN2QztZQUNKO1FBQ0osT0FDSztZQUNEOztxREFFeUMsR0FDekM0RSxrQkFBa0JjLGdCQUFnQixHQUFHLENBQUNDLFdBQVdDO2dCQUM3QyxJQUFJckIsc0JBQXNCdkUsTUFBTSxFQUFFO29CQUM5QixPQUFPdUUsc0JBQXNCdkUsTUFBTTtnQkFDdkMsT0FDSztvQkFDRDs7c0RBRWtDLEdBQ2xDLE9BQU9oRyxJQUFJNkwsT0FBTyxDQUFDLElBQUksQ0FBQzdKLGlCQUFpQjtnQkFDN0M7WUFDSjtRQUNKO1FBQ0E0SSxvQkFBb0IxTCxPQUFPNE0sTUFBTSxDQUFDNU0sT0FBTzRNLE1BQU0sQ0FBQyxDQUFDLEdBQUdsQixvQkFBb0IsSUFBSSxDQUFDNUksaUJBQWlCO1FBQzlGOzs7Ozs7Ozs7Ozs7Ozs7O1NBZ0JDLEdBQ0QsTUFBTU0sVUFBVS9DLE1BQU1zTSxPQUFPLENBQUNYLGdCQUFnQlIsaUJBQWlCRTtRQUMvRCxJQUFJLENBQUN0SSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDZSxpQkFBaUIsR0FBR2xELFdBQVc0TCxzQkFBc0IsQ0FBQyxJQUFJLENBQUNwSCx1QkFBdUIsRUFBRSxJQUFNLElBQUksQ0FBQ2dCLHFCQUFxQixJQUFJLElBQUksQ0FBQzNDLGVBQWU7UUFDakosSUFBSSxJQUFJLENBQUNBLGVBQWUsRUFBRTtZQUN0QixJQUFJLENBQUNHLGVBQWUsQ0FBQzZJLFFBQVEsQ0FBQyxJQUFJLENBQUMzSSxpQkFBaUI7UUFDeEQ7UUFDQWYsUUFBUXFILEtBQUs7UUFDYjs7O3dCQUdnQixHQUNoQnJILFFBQVEySixJQUFJLENBQUMsV0FBVztZQUNwQixJQUFJLElBQUksQ0FBQzNKLE9BQU8sS0FBS0EsU0FBUztnQkFDMUIsSUFBSSxDQUFDMkcsaUJBQWlCLENBQUM7b0JBQUN2SixxQkFBcUIwQyxpQkFBaUIsQ0FBQytHLFVBQVU7aUJBQUMsRUFBRXpKLHFCQUFxQjBDLGlCQUFpQixDQUFDNkgsS0FBSztZQUM1SDtRQUNKO1FBQ0EzSCxRQUFRMkosSUFBSSxDQUFDLFNBQVM7WUFDbEIsSUFBSSxJQUFJLENBQUMzSixPQUFPLEtBQUtBLFNBQVM7Z0JBQzFCLElBQUksQ0FBQzZDLEtBQUssQ0FBQztnQkFDWCxJQUFJLENBQUM4RCxpQkFBaUIsQ0FBQztvQkFBQ3ZKLHFCQUFxQjBDLGlCQUFpQixDQUFDK0csVUFBVTtpQkFBQyxFQUFFekoscUJBQXFCMEMsaUJBQWlCLENBQUM4RyxpQkFBaUI7Z0JBQ3BJOzt5QkFFUyxHQUNULElBQUksQ0FBQ0QsaUJBQWlCLENBQUM7b0JBQUN2SixxQkFBcUIwQyxpQkFBaUIsQ0FBQzZILEtBQUs7aUJBQUMsRUFBRXZLLHFCQUFxQjBDLGlCQUFpQixDQUFDQyxJQUFJO1lBQ3RIO1FBQ0o7UUFDQUMsUUFBUTJKLElBQUksQ0FBQyxVQUFVLENBQUNDLFdBQVdDLGNBQWNDO1lBQzdDLElBQUksSUFBSSxDQUFDOUosT0FBTyxLQUFLQSxTQUFTO2dCQUMxQjs0R0FDNEYsR0FDNUYsSUFBSTRKLGNBQWMzTSxNQUFNOEIsU0FBUyxDQUFDZ0wseUJBQXlCLElBQ3ZERCxXQUFXRSxNQUFNLENBQUMzSyxtQkFBbUI7b0JBQ3JDLElBQUksQ0FBQ2dCLGVBQWUsR0FBR2xCLEtBQUtGLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQ29CLGVBQWUsRUFBRTlCO29CQUMxRGhCLFFBQVEwTSxHQUFHLENBQUN6TSxZQUFZNEksWUFBWSxDQUFDOEQsS0FBSyxFQUFFLENBQUMsY0FBYyxFQUFFdk0sYUFBYXdLLFdBQVcsQ0FBQyxJQUFJLENBQUMxSSxhQUFhLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQzRDLHVCQUF1QixDQUFDLHlFQUF5RSxFQUFFLElBQUksQ0FBQ2hDLGVBQWUsQ0FBQyxHQUFHLENBQUM7Z0JBQ3JQO2dCQUNBLElBQUksQ0FBQ3dDLEtBQUssQ0FBQywyQ0FDUCtHO2dCQUNKLElBQUksQ0FBQ2pELGlCQUFpQixDQUFDO29CQUFDdkoscUJBQXFCMEMsaUJBQWlCLENBQUMrRyxVQUFVO29CQUFFekoscUJBQXFCMEMsaUJBQWlCLENBQUM2SCxLQUFLO2lCQUFDLEVBQUV2SyxxQkFBcUIwQyxpQkFBaUIsQ0FBQ0MsSUFBSTtZQUN6SztRQUNKO1FBQ0FDLFFBQVEySixJQUFJLENBQUMsU0FBUyxDQUFDUTtZQUNuQjs4Q0FDa0MsR0FDbEMsSUFBSSxDQUFDdEgsS0FBSyxDQUFDLGtDQUNQc0gsTUFBTUMsT0FBTztRQUNyQjtRQUNBLElBQUk3TSxRQUFROE0sZUFBZSxDQUFDck0sY0FBYztZQUN0Q2dDLFFBQVFzSyxFQUFFLENBQUMsa0JBQWtCLENBQUNDO2dCQUMxQixJQUFJLENBQUMxSCxLQUFLLENBQUMsMEJBQ04sS0FBSSxDQUFDN0MsT0FBTyxLQUFLQSxVQUFVLDJCQUEyQixFQUFDLElBQ3hELE9BQ0E4QyxLQUFLQyxTQUFTLENBQUN3SDtZQUN2QjtZQUNBdkssUUFBUXNLLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQ0M7Z0JBQ3pCLElBQUksQ0FBQzFILEtBQUssQ0FBQywwQ0FDTixLQUFJLENBQUM3QyxPQUFPLEtBQUtBLFVBQVUsMkJBQTJCLEVBQUMsSUFDeEQsT0FDQThDLEtBQUtDLFNBQVMsQ0FBQ3dIO1lBQ3ZCO1FBQ0o7SUFDSjtJQUNBQywwQkFBMEI7UUFDdEIsSUFBSWxILElBQUlDO1FBQ1I7OzswRUFHa0UsR0FDbEUsTUFBTStFLG9CQUFvQixJQUFJLENBQUMxSSxXQUFXLENBQUMySSxxQkFBcUIsTUFBTSxDQUFDO1FBQ3ZFLElBQUksbUJBQW1CRCxtQkFBbUI7WUFDdENBLGtCQUFrQm1DLGFBQWEsR0FBRztnQkFBQzthQUFLO1lBQ3hDLHlFQUF5RTtZQUN6RSxpRUFBaUU7WUFDakUsd0NBQXdDO1lBQ3hDLElBQUksSUFBSSxDQUFDOUssT0FBTyxDQUFDLGdDQUFnQyxFQUFFO2dCQUMvQyxNQUFNa0osd0JBQXdCLElBQUksQ0FBQ2xKLE9BQU8sQ0FBQyxnQ0FBZ0M7Z0JBQzNFMkksa0JBQWtCUSxtQkFBbUIsR0FBRyxDQUFDQyxNQUFNQztvQkFDM0MsT0FBTzdMLE1BQU0yTCxtQkFBbUIsQ0FBQ0QsdUJBQXVCRztnQkFDNUQ7Z0JBQ0FWLGtCQUFrQlcsVUFBVSxHQUFHSjtZQUNuQyxPQUNLO2dCQUNELElBQUksOEJBQThCLElBQUksQ0FBQ2xKLE9BQU8sRUFBRTtvQkFDNUM7Ozs4QkFHVSxHQUNWLE1BQU0rSyxhQUFhcE4sV0FBVytLLG1CQUFtQixDQUFDLENBQUMvRSxLQUFLM0YsYUFBYWdOLFFBQVEsQ0FBQyxJQUFJLENBQUNoTCxPQUFPLENBQUMsMkJBQTJCLE9BQU8sUUFBUTJELE9BQU8sS0FBSyxJQUFJQSxLQUFLO3dCQUN0SnNILE1BQU07b0JBQ1Y7b0JBQ0EsTUFBTUMsV0FBV2xOLGFBQWF3TCxhQUFhLENBQUN1QjtvQkFDNUNwQyxrQkFBa0JXLFVBQVUsR0FBRyxDQUFDMUYsS0FBS3NILGFBQWEsUUFBUUEsYUFBYSxLQUFLLElBQUksS0FBSyxJQUFJQSxTQUFTOUIsSUFBSSxNQUFNLFFBQVF4RixPQUFPLEtBQUssSUFBSUEsS0FBS21IO2dCQUM3STtZQUNKO1FBQ0o7UUFDQWpOLGFBQWFxTixvQkFBb0IsQ0FBQyxJQUFJLENBQUNwTCxpQkFBaUIsRUFBRSxJQUFJLENBQUNDLE9BQU8sRUFBRTJJLG1CQUFtQnlDLElBQUksQ0FBQyxDQUFDQztZQUM3RixJQUFJLENBQUNoRCxhQUFhLENBQUNnRDtRQUN2QixHQUFHLENBQUNDO1lBQ0EsSUFBSSxDQUFDdEUsaUJBQWlCLENBQUM7Z0JBQUN2SixxQkFBcUIwQyxpQkFBaUIsQ0FBQytHLFVBQVU7YUFBQyxFQUFFekoscUJBQXFCMEMsaUJBQWlCLENBQUM4RyxpQkFBaUI7UUFDeEk7SUFDSjtJQUNBUSxtQkFBbUI7UUFDZixJQUFJLENBQUNULGlCQUFpQixDQUFDO1lBQUN2SixxQkFBcUIwQyxpQkFBaUIsQ0FBQzZILEtBQUs7U0FBQyxFQUFFdksscUJBQXFCMEMsaUJBQWlCLENBQUM4RyxpQkFBaUI7UUFDL0gsS0FBSyxNQUFNc0UsWUFBWSxJQUFJLENBQUMvSyxtQkFBbUIsQ0FBQ2dMLE1BQU0sR0FBSTtZQUN0REQ7UUFDSjtJQUNKO0lBQ0E7Ozs7OztLQU1DLEdBQ0R2RSxrQkFBa0J5RSxTQUFTLEVBQUVDLFFBQVEsRUFBRTtRQUNuQyxJQUFJRCxVQUFVRSxPQUFPLENBQUMsSUFBSSxDQUFDekwsaUJBQWlCLE1BQU0sQ0FBQyxHQUFHO1lBQ2xELE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ2dELEtBQUssQ0FBQ3pGLHFCQUFxQjBDLGlCQUFpQixDQUFDLElBQUksQ0FBQ0QsaUJBQWlCLENBQUMsR0FDckUsU0FDQXpDLHFCQUFxQjBDLGlCQUFpQixDQUFDdUwsU0FBUztRQUNwRCxJQUFJLElBQUksQ0FBQzNLLGVBQWUsRUFBRTtZQUN0QixJQUFJLENBQUM2QixhQUFhLENBQUNLLFFBQVEsQ0FBQyxXQUFXeEYscUJBQXFCMEMsaUJBQWlCLENBQUMsSUFBSSxDQUFDRCxpQkFBaUIsQ0FBQyxHQUFHLFNBQVN6QyxxQkFBcUIwQyxpQkFBaUIsQ0FBQ3VMLFNBQVM7UUFDcks7UUFDQSxNQUFNRSxnQkFBZ0IsSUFBSSxDQUFDMUwsaUJBQWlCO1FBQzVDLElBQUksQ0FBQ0EsaUJBQWlCLEdBQUd3TDtRQUN6QixPQUFRQTtZQUNKLEtBQUtqTyxxQkFBcUIwQyxpQkFBaUIsQ0FBQzZILEtBQUs7Z0JBQzdDLElBQUksQ0FBQ1gsV0FBVztnQkFDaEIsTUFBTWhILFVBQVUsSUFBSSxDQUFDQSxPQUFPO2dCQUM1QkEsUUFBUTBELE1BQU0sQ0FBQ2lHLElBQUksQ0FBQyxTQUFTO29CQUN6QixJQUFJLElBQUksQ0FBQzNKLE9BQU8sS0FBS0EsU0FBUzt3QkFDMUIsSUFBSSxDQUFDb0gsZ0JBQWdCO29CQUN6QjtnQkFDSjtnQkFDQSxJQUFJLElBQUksQ0FBQzdHLHFCQUFxQixFQUFFO29CQUM1QixJQUFJLENBQUNxSCxtQkFBbUI7Z0JBQzVCO2dCQUNBO1lBQ0osS0FBS3hLLHFCQUFxQjBDLGlCQUFpQixDQUFDK0csVUFBVTtnQkFDbEQsSUFBSSxDQUFDQyxZQUFZO2dCQUNqQixJQUFJLENBQUMwRCx1QkFBdUI7Z0JBQzVCLElBQUksQ0FBQ3ZLLGtCQUFrQixHQUFHO2dCQUMxQjtZQUNKLEtBQUs3QyxxQkFBcUIwQyxpQkFBaUIsQ0FBQzhHLGlCQUFpQjtnQkFDekQsSUFBSSxJQUFJLENBQUM1RyxPQUFPLEVBQUU7b0JBQ2QsSUFBSSxDQUFDQSxPQUFPLENBQUN3TCxLQUFLO2dCQUN0QjtnQkFDQSxJQUFJLENBQUN4TCxPQUFPLEdBQUc7Z0JBQ2YsSUFBSSxDQUFDZ0csdUJBQXVCO2dCQUM1QixJQUFJLENBQUM4QixrQkFBa0I7Z0JBQ3ZCOztxRkFFcUUsR0FDckUsSUFBSSxDQUFDLElBQUksQ0FBQzVGLGNBQWMsQ0FBQ3VKLFNBQVMsSUFBSTtvQkFDbENDLFFBQVFDLFFBQVEsQ0FBQzt3QkFDYixJQUFJLENBQUN2SixrQkFBa0I7b0JBQzNCO2dCQUNKO2dCQUNBO1lBQ0osS0FBS2hGLHFCQUFxQjBDLGlCQUFpQixDQUFDQyxJQUFJO2dCQUM1QyxJQUFJLElBQUksQ0FBQ0MsT0FBTyxFQUFFO29CQUNkLElBQUksQ0FBQ0EsT0FBTyxDQUFDd0wsS0FBSztnQkFDdEI7Z0JBQ0EsSUFBSSxDQUFDeEwsT0FBTyxHQUFHO2dCQUNmLElBQUksQ0FBQ2dHLHVCQUF1QjtnQkFDNUIsSUFBSSxDQUFDOEIsa0JBQWtCO2dCQUN2QjtZQUNKO2dCQUNJLE1BQU0sSUFBSThELE1BQU0sQ0FBQyx5Q0FBeUMsRUFBRVAsU0FBUyxDQUFDO1FBQzlFO1FBQ0E7NENBQ29DLEdBQ3BDLEtBQUssTUFBTUgsWUFBWTtlQUFJLElBQUksQ0FBQ2hMLGNBQWM7U0FBQyxDQUFFO1lBQzdDZ0wsU0FBUyxJQUFJLEVBQUVLLGVBQWVGO1FBQ2xDO1FBQ0EsT0FBTztJQUNYO0lBQ0E7OztLQUdDLEdBQ0RRLHFCQUFxQjtRQUNqQjt3RUFDZ0UsR0FDaEUsSUFBSSxJQUFJLENBQUNyTCxZQUFZLEtBQUssS0FBSyxJQUFJLENBQUNDLFFBQVEsS0FBSyxHQUFHO1lBQ2hELElBQUksSUFBSSxDQUFDQyxlQUFlLEVBQUU7Z0JBQ3RCLElBQUksQ0FBQzZCLGFBQWEsQ0FBQ0ssUUFBUSxDQUFDLFdBQVc7WUFDM0M7WUFDQSxJQUFJLENBQUMrRCxpQkFBaUIsQ0FBQztnQkFBQ3ZKLHFCQUFxQjBDLGlCQUFpQixDQUFDK0csVUFBVTtnQkFBRXpKLHFCQUFxQjBDLGlCQUFpQixDQUFDNkgsS0FBSzthQUFDLEVBQUV2SyxxQkFBcUIwQyxpQkFBaUIsQ0FBQ0MsSUFBSTtZQUNySyxJQUFJLElBQUksQ0FBQ1csZUFBZSxFQUFFO2dCQUN0QjdDLFdBQVdvSSxxQkFBcUIsQ0FBQyxJQUFJLENBQUN4RCxXQUFXO1lBQ3JEO1FBQ0o7SUFDSjtJQUNBcUosVUFBVTtRQUNOLElBQUksQ0FBQ3ZGLFFBQVEsQ0FBQyxrQkFDVixJQUFJLENBQUMvRixZQUFZLEdBQ2pCLFNBQ0MsS0FBSSxDQUFDQSxZQUFZLEdBQUc7UUFDekIsSUFBSSxJQUFJLENBQUNBLFlBQVksS0FBSyxHQUFHO1lBQ3pCLElBQUksSUFBSSxDQUFDUixPQUFPLEVBQUU7Z0JBQ2QsSUFBSSxDQUFDQSxPQUFPLENBQUMrTCxHQUFHO1lBQ3BCO1lBQ0EsSUFBSSxDQUFDN0osY0FBYyxDQUFDNkosR0FBRztZQUN2QixJQUFJLENBQUMsSUFBSSxDQUFDeEwscUJBQXFCLEVBQUU7Z0JBQzdCLElBQUksQ0FBQ3FILG1CQUFtQjtZQUM1QjtRQUNKO1FBQ0EsSUFBSSxDQUFDcEgsWUFBWSxJQUFJO0lBQ3pCO0lBQ0F3TCxZQUFZO1FBQ1IsSUFBSSxDQUFDekYsUUFBUSxDQUFDLGtCQUNWLElBQUksQ0FBQy9GLFlBQVksR0FDakIsU0FDQyxLQUFJLENBQUNBLFlBQVksR0FBRztRQUN6QixJQUFJLENBQUNBLFlBQVksSUFBSTtRQUNyQixJQUFJLElBQUksQ0FBQ0EsWUFBWSxLQUFLLEdBQUc7WUFDekIsSUFBSSxJQUFJLENBQUNSLE9BQU8sRUFBRTtnQkFDZCxJQUFJLENBQUNBLE9BQU8sQ0FBQ3FILEtBQUs7WUFDdEI7WUFDQSxJQUFJLENBQUNuRixjQUFjLENBQUNtRixLQUFLO1lBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUM5RyxxQkFBcUIsRUFBRTtnQkFDN0J3SCxjQUFjLElBQUksQ0FBQ3BHLG1CQUFtQjtZQUMxQztZQUNBLElBQUksQ0FBQ2tLLGtCQUFrQjtRQUMzQjtJQUNKO0lBQ0FFLE1BQU07UUFDRixJQUFJLENBQUN4RixRQUFRLENBQUMsY0FDVixJQUFJLENBQUM5RixRQUFRLEdBQ2IsU0FDQyxLQUFJLENBQUNBLFFBQVEsR0FBRztRQUNyQixJQUFJLENBQUNBLFFBQVEsSUFBSTtJQUNyQjtJQUNBNEcsUUFBUTtRQUNKLElBQUksQ0FBQ2QsUUFBUSxDQUFDLGNBQ1YsSUFBSSxDQUFDOUYsUUFBUSxHQUNiLFNBQ0MsS0FBSSxDQUFDQSxRQUFRLEdBQUc7UUFDckIsSUFBSSxDQUFDQSxRQUFRLElBQUk7UUFDakIsSUFBSSxDQUFDb0wsa0JBQWtCO0lBQzNCO0lBQ0FJLGdCQUFnQjtRQUNaLElBQUksSUFBSSxDQUFDeEwsUUFBUSxLQUFLLEdBQUc7WUFDckIsSUFBSSxDQUFDNEcsS0FBSztZQUNWLE9BQU87UUFDWDtRQUNBLE9BQU87SUFDWDtJQUNBOzs7Ozs7S0FNQyxHQUNENkUsZ0JBQWdCQyxRQUFRLEVBQUVDLFVBQVUsRUFBRUMsWUFBWSxFQUFFO1FBQ2hELE1BQU1DLFVBQVVILFNBQVNJLGNBQWM7UUFDdkNELE9BQU8sQ0FBQzdOLHVCQUF1QixHQUFHMk4sV0FBV0ksT0FBTztRQUNwREYsT0FBTyxDQUFDeE4sd0JBQXdCLEdBQUcsSUFBSSxDQUFDeUMsU0FBUztRQUNqRCtLLE9BQU8sQ0FBQzVOLDBCQUEwQixHQUFHO1FBQ3JDNE4sT0FBTyxDQUFDM04sb0JBQW9CLEdBQUc7UUFDL0IyTixPQUFPLENBQUMxTixrQkFBa0IsR0FBR3dOLFdBQVdLLFNBQVM7UUFDakRILE9BQU8sQ0FBQ3pOLGdCQUFnQixHQUFHO1FBQzNCLElBQUk2TjtRQUNKOzs7Ozs7O1NBT0MsR0FDRCxJQUFJO1lBQ0FBLGNBQWMsSUFBSSxDQUFDMU0sT0FBTyxDQUFDMk0sT0FBTyxDQUFDTDtRQUN2QyxFQUNBLE9BQU83SyxHQUFHO1lBQ04sSUFBSSxDQUFDa0YsaUJBQWlCLENBQUM7Z0JBQUN2SixxQkFBcUIwQyxpQkFBaUIsQ0FBQzZILEtBQUs7YUFBQyxFQUFFdksscUJBQXFCMEMsaUJBQWlCLENBQUM4RyxpQkFBaUI7WUFDL0gsTUFBTW5GO1FBQ1Y7UUFDQSxJQUFJbUwsZ0JBQWdCO1FBQ3BCLEtBQUssTUFBTUMsVUFBVWpRLE9BQU9rUSxJQUFJLENBQUNSLFNBQVU7WUFDdkNNLGlCQUFpQixPQUFTQyxTQUFTLE9BQU9QLE9BQU8sQ0FBQ08sT0FBTyxHQUFHO1FBQ2hFO1FBQ0F0UCxRQUFRc0YsS0FBSyxDQUFDckYsWUFBWTRJLFlBQVksQ0FBQ0MsS0FBSyxFQUFFLGVBQWUsc0JBQXNCK0YsV0FBV1csYUFBYSxLQUFLLHFCQUM1RyxNQUFNLElBQUksQ0FBQ3RLLFdBQVcsQ0FBQzZELEVBQUUsR0FBRyxPQUM1QixJQUFJLENBQUNqRSx1QkFBdUIsR0FDNUIsb0JBQ0F1SztRQUNKLElBQUksQ0FBQ3BHLGdCQUFnQixDQUFDLHdCQUNsQixJQUFJLENBQUN4RyxPQUFPLENBQUNpRCxLQUFLLENBQUM0QyxlQUFlLEdBQ2xDLDBCQUNBLElBQUksQ0FBQzdGLE9BQU8sQ0FBQ2lELEtBQUssQ0FBQzhDLGdCQUFnQjtRQUN2QyxNQUFNaUgsZ0JBQWdCLElBQUksQ0FBQ2hOLE9BQU87UUFDbEMsSUFBSSxDQUFDeUcsY0FBYyxDQUFDLG9CQUNoQnVHLGNBQWNDLE1BQU0sR0FDcEIsd0JBQ0FELGNBQWNFLFNBQVMsR0FDdkIsK0JBQ0FGLGNBQWN0SixNQUFNLENBQUN3SixTQUFTO1FBQ2xDLElBQUlDO1FBQ0osSUFBSSxJQUFJLENBQUN6TSxlQUFlLEVBQUU7WUFDdEIsSUFBSSxDQUFDQyxXQUFXLENBQUN5TSxjQUFjO1lBQy9CaEIsV0FBV2lCLGdCQUFnQixDQUFDQyxDQUFBQTtnQkFDeEIsSUFBSUEsT0FBT0MsSUFBSSxLQUFLL1AsWUFBWWdRLE1BQU0sQ0FBQ0MsRUFBRSxFQUFFO29CQUN2QyxJQUFJLENBQUM5TSxXQUFXLENBQUMrTSxnQkFBZ0I7Z0JBQ3JDLE9BQ0s7b0JBQ0QsSUFBSSxDQUFDL00sV0FBVyxDQUFDZ04sYUFBYTtnQkFDbEM7WUFDSjtZQUNBLElBQUksQ0FBQzFNLGFBQWEsQ0FBQ21NLGNBQWM7WUFDakNoQixXQUFXd0IsbUJBQW1CLENBQUNDLENBQUFBO2dCQUMzQixJQUFJYixrQkFBa0IsSUFBSSxDQUFDaE4sT0FBTyxFQUFFO29CQUNoQyxJQUFJNk4sU0FBUzt3QkFDVCxJQUFJLENBQUM1TSxhQUFhLENBQUN5TSxnQkFBZ0I7b0JBQ3ZDLE9BQ0s7d0JBQ0QsSUFBSSxDQUFDek0sYUFBYSxDQUFDME0sYUFBYTtvQkFDcEM7Z0JBQ0o7WUFDSjtZQUNBUixlQUFlO2dCQUNYVyxnQkFBZ0I7b0JBQ1osSUFBSSxDQUFDM00sWUFBWSxJQUFJO29CQUNyQixJQUFJLENBQUNFLHdCQUF3QixHQUFHLElBQUkwTTtnQkFDeEM7Z0JBQ0FDLG9CQUFvQjtvQkFDaEIsSUFBSSxDQUFDNU0sZ0JBQWdCLElBQUk7Z0JBQzdCO1lBQ0o7UUFDSixPQUNLO1lBQ0QrTCxlQUFlO2dCQUNYVyxnQkFBZ0IsS0FBUTtnQkFDeEJFLG9CQUFvQixLQUFRO1lBQ2hDO1FBQ0o7UUFDQTVCLFdBQVc2QixpQkFBaUIsQ0FBQ3ZCLGFBQWEsSUFBSSxFQUFFTCxjQUFjYztJQUNsRTtJQUNBOzs7OztLQUtDLEdBQ0RlLGtCQUFrQjtRQUNkOzs7eUVBR2lFLEdBQ2pFLElBQUksQ0FBQyxJQUFJLENBQUN2SCxpQkFBaUIsQ0FBQztZQUFDdkoscUJBQXFCMEMsaUJBQWlCLENBQUNDLElBQUk7U0FBQyxFQUFFM0MscUJBQXFCMEMsaUJBQWlCLENBQUMrRyxVQUFVLEdBQUc7WUFDM0gsSUFBSSxJQUFJLENBQUNoSCxpQkFBaUIsS0FBS3pDLHFCQUFxQjBDLGlCQUFpQixDQUFDOEcsaUJBQWlCLEVBQUU7Z0JBQ3JGLElBQUksQ0FBQzNHLGtCQUFrQixHQUFHO1lBQzlCO1FBQ0o7SUFDSjtJQUNBOztLQUVDLEdBQ0RrTyx1QkFBdUI7UUFDbkIsT0FBTyxJQUFJLENBQUN0TyxpQkFBaUI7SUFDakM7SUFDQTs7OztLQUlDLEdBQ0R1Tyw2QkFBNkJsRCxRQUFRLEVBQUU7UUFDbkMsSUFBSSxDQUFDaEwsY0FBYyxDQUFDbU8sSUFBSSxDQUFDbkQ7SUFDN0I7SUFDQTs7OztLQUlDLEdBQ0RvRCxnQ0FBZ0NwRCxRQUFRLEVBQUU7UUFDdEMsTUFBTXFELGdCQUFnQixJQUFJLENBQUNyTyxjQUFjLENBQUNvTCxPQUFPLENBQUNKO1FBQ2xELElBQUlxRCxnQkFBZ0IsQ0FBQyxHQUFHO1lBQ3BCLElBQUksQ0FBQ3JPLGNBQWMsQ0FBQ3NPLE1BQU0sQ0FBQ0QsZUFBZTtRQUM5QztJQUNKO0lBQ0FFLHNCQUFzQnZELFFBQVEsRUFBRTtRQUM1QixJQUFJLENBQUMvSyxtQkFBbUIsQ0FBQ3VPLEdBQUcsQ0FBQ3hEO0lBQ2pDO0lBQ0F5RCx5QkFBeUJ6RCxRQUFRLEVBQUU7UUFDL0IsSUFBSSxDQUFDL0ssbUJBQW1CLENBQUN5TyxNQUFNLENBQUMxRDtJQUNwQztJQUNBOztLQUVDLEdBQ0QyRCxlQUFlO1FBQ1gsSUFBSSxDQUFDM00sY0FBYyxDQUFDZ0YsS0FBSztRQUN6QixJQUFJLENBQUNQLGlCQUFpQixDQUFDO1lBQUN2SixxQkFBcUIwQyxpQkFBaUIsQ0FBQzhHLGlCQUFpQjtTQUFDLEVBQUV4SixxQkFBcUIwQyxpQkFBaUIsQ0FBQytHLFVBQVU7SUFDeEk7SUFDQWlJLGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQ3pNLHVCQUF1QjtJQUN2QztJQUNBME0saUJBQWlCO1FBQ2IsT0FBTyxJQUFJLENBQUN0TSxXQUFXO0lBQzNCO0lBQ0F1TSxvQkFBb0I7UUFDaEIsT0FBTyxJQUFJO0lBQ2Y7QUFDSjtBQUNBbFMsa0JBQWtCLEdBQUdFLFlBQ3JCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy9zdWJjaGFubmVsLmpzPzg4NzYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ29weXJpZ2h0IDIwMTkgZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3ViY2hhbm5lbCA9IHZvaWQgMDtcbmNvbnN0IGh0dHAyID0gcmVxdWlyZShcImh0dHAyXCIpO1xuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xuY29uc3QgY29ubmVjdGl2aXR5X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0aXZpdHktc3RhdGVcIik7XG5jb25zdCBiYWNrb2ZmX3RpbWVvdXRfMSA9IHJlcXVpcmUoXCIuL2JhY2tvZmYtdGltZW91dFwiKTtcbmNvbnN0IHJlc29sdmVyXzEgPSByZXF1aXJlKFwiLi9yZXNvbHZlclwiKTtcbmNvbnN0IGxvZ2dpbmcgPSByZXF1aXJlKFwiLi9sb2dnaW5nXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5jb25zdCBodHRwX3Byb3h5XzEgPSByZXF1aXJlKFwiLi9odHRwX3Byb3h5XCIpO1xuY29uc3QgbmV0ID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IHVyaV9wYXJzZXJfMSA9IHJlcXVpcmUoXCIuL3VyaS1wYXJzZXJcIik7XG5jb25zdCBzdWJjaGFubmVsX2FkZHJlc3NfMSA9IHJlcXVpcmUoXCIuL3N1YmNoYW5uZWwtYWRkcmVzc1wiKTtcbmNvbnN0IGNoYW5uZWx6XzEgPSByZXF1aXJlKFwiLi9jaGFubmVselwiKTtcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKCcuLi8uLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuY29uc3QgVFJBQ0VSX05BTUUgPSAnc3ViY2hhbm5lbCc7XG5jb25zdCBGTE9XX0NPTlRST0xfVFJBQ0VSX05BTUUgPSAnc3ViY2hhbm5lbF9mbG93Y3RybCc7XG5jb25zdCBNSU5fQ09OTkVDVF9USU1FT1VUX01TID0gMjAwMDA7XG5jb25zdCBJTklUSUFMX0JBQ0tPRkZfTVMgPSAxMDAwO1xuY29uc3QgQkFDS09GRl9NVUxUSVBMSUVSID0gMS42O1xuY29uc3QgTUFYX0JBQ0tPRkZfTVMgPSAxMjAwMDA7XG5jb25zdCBCQUNLT0ZGX0pJVFRFUiA9IDAuMjtcbi8qIHNldEludGVydmFsIGFuZCBzZXRUaW1lb3V0IG9ubHkgYWNjZXB0IHNpZ25lZCAzMiBiaXQgaW50ZWdlcnMuIEpTIGRvZXNuJ3RcbiAqIGhhdmUgYSBjb25zdGFudCBmb3IgdGhlIG1heCBzaWduZWQgMzIgYml0IGludGVnZXIsIHNvIHRoaXMgaXMgYSBzaW1wbGUgd2F5XG4gKiB0byBjYWxjdWxhdGUgaXQgKi9cbmNvbnN0IEtFRVBBTElWRV9NQVhfVElNRV9NUyA9IH4oMSA8PCAzMSk7XG5jb25zdCBLRUVQQUxJVkVfVElNRU9VVF9NUyA9IDIwMDAwO1xuY29uc3QgeyBIVFRQMl9IRUFERVJfQVVUSE9SSVRZLCBIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFLCBIVFRQMl9IRUFERVJfTUVUSE9ELCBIVFRQMl9IRUFERVJfUEFUSCwgSFRUUDJfSEVBREVSX1RFLCBIVFRQMl9IRUFERVJfVVNFUl9BR0VOVCwgfSA9IGh0dHAyLmNvbnN0YW50cztcbi8qKlxuICogR2V0IGEgbnVtYmVyIHVuaWZvcm1seSBhdCByYW5kb20gaW4gdGhlIHJhbmdlIFttaW4sIG1heClcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqL1xuZnVuY3Rpb24gdW5pZm9ybVJhbmRvbShtaW4sIG1heCkge1xuICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG59XG5jb25zdCB0b29NYW55UGluZ3NEYXRhID0gQnVmZmVyLmZyb20oJ3Rvb19tYW55X3BpbmdzJywgJ2FzY2lpJyk7XG5jbGFzcyBTdWJjaGFubmVsIHtcbiAgICAvKipcbiAgICAgKiBBIGNsYXNzIHJlcHJlc2VudGluZyBhIGNvbm5lY3Rpb24gdG8gYSBzaW5nbGUgYmFja2VuZC5cbiAgICAgKiBAcGFyYW0gY2hhbm5lbFRhcmdldCBUaGUgdGFyZ2V0IHN0cmluZyBmb3IgdGhlIGNoYW5uZWwgYXMgYSB3aG9sZVxuICAgICAqIEBwYXJhbSBzdWJjaGFubmVsQWRkcmVzcyBUaGUgYWRkcmVzcyBmb3IgdGhlIGJhY2tlbmQgdGhhdCB0aGlzIHN1YmNoYW5uZWxcbiAgICAgKiAgICAgd2lsbCBjb25uZWN0IHRvXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGNoYW5uZWwgb3B0aW9ucywgcGx1cyBhbnkgc3BlY2lmaWMgc3ViY2hhbm5lbCBvcHRpb25zXG4gICAgICogICAgIGZvciB0aGlzIHN1YmNoYW5uZWxcbiAgICAgKiBAcGFyYW0gY3JlZGVudGlhbHMgVGhlIGNoYW5uZWwgY3JlZGVudGlhbHMgdXNlZCB0byBlc3RhYmxpc2ggdGhpc1xuICAgICAqICAgICBjb25uZWN0aW9uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY2hhbm5lbFRhcmdldCwgc3ViY2hhbm5lbEFkZHJlc3MsIG9wdGlvbnMsIGNyZWRlbnRpYWxzKSB7XG4gICAgICAgIHRoaXMuY2hhbm5lbFRhcmdldCA9IGNoYW5uZWxUYXJnZXQ7XG4gICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3MgPSBzdWJjaGFubmVsQWRkcmVzcztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGNyZWRlbnRpYWxzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN1YmNoYW5uZWwncyBjdXJyZW50IGNvbm5lY3Rpdml0eSBzdGF0ZS4gSW52YXJpYW50OiBgc2Vzc2lvbmAgPT09IGBudWxsYFxuICAgICAgICAgKiBpZiBhbmQgb25seSBpZiBgY29ubmVjdGl2aXR5U3RhdGVgIGlzIElETEUgb3IgVFJBTlNJRU5UX0ZBSUxVUkUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlID0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmRlcmx5aW5nIGh0dHAyIHNlc3Npb24gdXNlZCB0byBtYWtlIHJlcXVlc3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSBzdWJjaGFubmVsIHNob3VsZCB0cmFuc2l0aW9uIGZyb20gVFJBTlNJRU5UX0ZBSUxVUkUgdG9cbiAgICAgICAgICogQ09OTkVDVElORyBpbnN0ZWFkIG9mIElETEUgd2hlbiB0aGUgYmFja29mZiB0aW1lb3V0IGVuZHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBjb25uZWN0aXZpdHlcbiAgICAgICAgICogc3RhdGUgY2hhbmdlcy4gV2lsbCBiZSBtb2RpZmllZCBieSBgYWRkQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lcmAgYW5kXG4gICAgICAgICAqIGByZW1vdmVDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHVuZGVybHlpbmdcbiAgICAgICAgICogc29ja2V0IGRpc2Nvbm5lY3RzLiBVc2VkIGZvciBlbmRpbmcgYWN0aXZlIGNhbGxzIHdpdGggYW4gVU5BVkFJTEFCTEVcbiAgICAgICAgICogc3RhdHVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiB0aW1lIGluIGJldHdlZW4gc2VuZGluZyBwaW5nc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPSBLRUVQQUxJVkVfTUFYX1RJTUVfTVM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYW1vdW50IG9mIHRpbWUgdG8gd2FpdCBmb3IgYW4gYWNrbm93bGVkZ2VtZW50IGFmdGVyIHNlbmRpbmcgYSBwaW5nXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9IEtFRVBBTElWRV9USU1FT1VUX01TO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIga2VlcGFsaXZlIHBpbmdzIHNob3VsZCBiZSBzZW50IHdpdGhvdXQgYW55IGFjdGl2ZSBjYWxsc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVXaXRob3V0Q2FsbHMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrcyBjYWxscyB3aXRoIHJlZmVyZW5jZXMgdG8gdGhpcyBzdWJjaGFubmVsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhbGxSZWZjb3VudCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3MgY2hhbm5lbHMgYW5kIHN1YmNoYW5uZWwgcG9vbHMgd2l0aCByZWZlcmVuY2VzIHRvIHRoaXMgc3ViY2hhbm5lbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZjb3VudCA9IDA7XG4gICAgICAgIC8vIENoYW5uZWx6IGluZm9cbiAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNhbGxUcmFja2VyID0gbmV3IGNoYW5uZWx6XzEuQ2hhbm5lbHpDYWxsVHJhY2tlcigpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyKCk7XG4gICAgICAgIC8vIENoYW5uZWx6IHNvY2tldCBpbmZvXG4gICAgICAgIHRoaXMuY2hhbm5lbHpTb2NrZXRSZWYgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGUgcmVtb3RlIHNlcnZlciwgaWYgaXQgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBzdWJjaGFubmVsXG4gICAgICAgICAqIGFkZHJlc3MsIGkuZS4gaWYgY29ubmVjdGluZyB0aHJvdWdoIGFuIEhUVFAgQ09OTkVDVCBwcm94eS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVtb3RlTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCA9IDA7XG4gICAgICAgIHRoaXMubWVzc2FnZXNTZW50ID0gMDtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1JlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICAvLyBCdWlsZCB1c2VyLWFnZW50IHN0cmluZy5cbiAgICAgICAgdGhpcy51c2VyQWdlbnQgPSBbXG4gICAgICAgICAgICBvcHRpb25zWydncnBjLnByaW1hcnlfdXNlcl9hZ2VudCddLFxuICAgICAgICAgICAgYGdycGMtbm9kZS1qcy8ke2NsaWVudFZlcnNpb259YCxcbiAgICAgICAgICAgIG9wdGlvbnNbJ2dycGMuc2Vjb25kYXJ5X3VzZXJfYWdlbnQnXSxcbiAgICAgICAgXVxuICAgICAgICAgICAgLmZpbHRlcigoZSkgPT4gZSlcbiAgICAgICAgICAgIC5qb2luKCcgJyk7IC8vIHJlbW92ZSBmYWxzZXkgdmFsdWVzIGZpcnN0XG4gICAgICAgIGlmICgnZ3JwYy5rZWVwYWxpdmVfdGltZV9tcycgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lTXMgPSBvcHRpb25zWydncnBjLmtlZXBhbGl2ZV90aW1lX21zJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdncnBjLmtlZXBhbGl2ZV90aW1lb3V0X21zJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyA9IG9wdGlvbnNbJ2dycGMua2VlcGFsaXZlX3RpbWVvdXRfbXMnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJ2dycGMua2VlcGFsaXZlX3Blcm1pdF93aXRob3V0X2NhbGxzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscyA9XG4gICAgICAgICAgICAgICAgb3B0aW9uc1snZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnXSA9PT0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZWVwYWxpdmVJbnRlcnZhbElkID0gc2V0VGltZW91dCgoKSA9PiB7IH0sIDApO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5rZWVwYWxpdmVJbnRlcnZhbElkKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHsgfSwgMCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmtlZXBhbGl2ZVRpbWVvdXRJZCk7XG4gICAgICAgIGNvbnN0IGJhY2tvZmZPcHRpb25zID0ge1xuICAgICAgICAgICAgaW5pdGlhbERlbGF5OiBvcHRpb25zWydncnBjLmluaXRpYWxfcmVjb25uZWN0X2JhY2tvZmZfbXMnXSxcbiAgICAgICAgICAgIG1heERlbGF5OiBvcHRpb25zWydncnBjLm1heF9yZWNvbm5lY3RfYmFja29mZl9tcyddLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0ID0gbmV3IGJhY2tvZmZfdGltZW91dF8xLkJhY2tvZmZUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmFja29mZlRpbWVyKCk7XG4gICAgICAgIH0sIGJhY2tvZmZPcHRpb25zKTtcbiAgICAgICAgdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZyA9IHN1YmNoYW5uZWxfYWRkcmVzc18xLnN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmcoc3ViY2hhbm5lbEFkZHJlc3MpO1xuICAgICAgICBpZiAob3B0aW9uc1snZ3JwYy5lbmFibGVfY2hhbm5lbHonXSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVsekVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UgPSBuZXcgY2hhbm5lbHpfMS5DaGFubmVselRyYWNlKCk7XG4gICAgICAgIHRoaXMuY2hhbm5lbHpSZWYgPSBjaGFubmVsel8xLnJlZ2lzdGVyQ2hhbm5lbHpTdWJjaGFubmVsKHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcsICgpID0+IHRoaXMuZ2V0Q2hhbm5lbHpJbmZvKCksIHRoaXMuY2hhbm5lbHpFbmFibGVkKTtcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWx6VHJhY2UuYWRkVHJhY2UoJ0NUX0lORk8nLCAnU3ViY2hhbm5lbCBjcmVhdGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZSgnU3ViY2hhbm5lbCBjb25zdHJ1Y3RlZCB3aXRoIG9wdGlvbnMgJyArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIHVuZGVmaW5lZCwgMikpO1xuICAgIH1cbiAgICBnZXRDaGFubmVsekluZm8oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZTogdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSxcbiAgICAgICAgICAgIHRyYWNlOiB0aGlzLmNoYW5uZWx6VHJhY2UsXG4gICAgICAgICAgICBjYWxsVHJhY2tlcjogdGhpcy5jYWxsVHJhY2tlcixcbiAgICAgICAgICAgIGNoaWxkcmVuOiB0aGlzLmNoaWxkcmVuVHJhY2tlci5nZXRDaGlsZExpc3RzKCksXG4gICAgICAgICAgICB0YXJnZXQ6IHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmdcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpTb2NrZXRJbmZvKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vzc2lvblNvY2tldCA9IHRoaXMuc2Vzc2lvbi5zb2NrZXQ7XG4gICAgICAgIGNvbnN0IHJlbW90ZUFkZHJlc3MgPSBzZXNzaW9uU29ja2V0LnJlbW90ZUFkZHJlc3MgPyBzdWJjaGFubmVsX2FkZHJlc3NfMS5zdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzKHNlc3Npb25Tb2NrZXQucmVtb3RlQWRkcmVzcywgc2Vzc2lvblNvY2tldC5yZW1vdGVQb3J0KSA6IG51bGw7XG4gICAgICAgIGNvbnN0IGxvY2FsQWRkcmVzcyA9IHNlc3Npb25Tb2NrZXQubG9jYWxBZGRyZXNzID8gc3ViY2hhbm5lbF9hZGRyZXNzXzEuc3RyaW5nVG9TdWJjaGFubmVsQWRkcmVzcyhzZXNzaW9uU29ja2V0LmxvY2FsQWRkcmVzcywgc2Vzc2lvblNvY2tldC5sb2NhbFBvcnQpIDogbnVsbDtcbiAgICAgICAgbGV0IHRsc0luZm87XG4gICAgICAgIGlmICh0aGlzLnNlc3Npb24uZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICBjb25zdCB0bHNTb2NrZXQgPSBzZXNzaW9uU29ja2V0O1xuICAgICAgICAgICAgY29uc3QgY2lwaGVySW5mbyA9IHRsc1NvY2tldC5nZXRDaXBoZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNlcnRpZmljYXRlID0gdGxzU29ja2V0LmdldENlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICBjb25zdCBwZWVyQ2VydGlmaWNhdGUgPSB0bHNTb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKCk7XG4gICAgICAgICAgICB0bHNJbmZvID0ge1xuICAgICAgICAgICAgICAgIGNpcGhlclN1aXRlU3RhbmRhcmROYW1lOiAoX2EgPSBjaXBoZXJJbmZvLnN0YW5kYXJkTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgICAgICAgICBjaXBoZXJTdWl0ZU90aGVyTmFtZTogY2lwaGVySW5mby5zdGFuZGFyZE5hbWUgPyBudWxsIDogY2lwaGVySW5mby5uYW1lLFxuICAgICAgICAgICAgICAgIGxvY2FsQ2VydGlmaWNhdGU6IChjZXJ0aWZpY2F0ZSAmJiAncmF3JyBpbiBjZXJ0aWZpY2F0ZSkgPyBjZXJ0aWZpY2F0ZS5yYXcgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlbW90ZUNlcnRpZmljYXRlOiAocGVlckNlcnRpZmljYXRlICYmICdyYXcnIGluIHBlZXJDZXJ0aWZpY2F0ZSkgPyBwZWVyQ2VydGlmaWNhdGUucmF3IDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRsc0luZm8gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldEluZm8gPSB7XG4gICAgICAgICAgICByZW1vdGVBZGRyZXNzOiByZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgbG9jYWxBZGRyZXNzOiBsb2NhbEFkZHJlc3MsXG4gICAgICAgICAgICBzZWN1cml0eTogdGxzSW5mbyxcbiAgICAgICAgICAgIHJlbW90ZU5hbWU6IHRoaXMucmVtb3RlTmFtZSxcbiAgICAgICAgICAgIHN0cmVhbXNTdGFydGVkOiB0aGlzLnN0cmVhbVRyYWNrZXIuY2FsbHNTdGFydGVkLFxuICAgICAgICAgICAgc3RyZWFtc1N1Y2NlZWRlZDogdGhpcy5zdHJlYW1UcmFja2VyLmNhbGxzU3VjY2VlZGVkLFxuICAgICAgICAgICAgc3RyZWFtc0ZhaWxlZDogdGhpcy5zdHJlYW1UcmFja2VyLmNhbGxzRmFpbGVkLFxuICAgICAgICAgICAgbWVzc2FnZXNTZW50OiB0aGlzLm1lc3NhZ2VzU2VudCxcbiAgICAgICAgICAgIG1lc3NhZ2VzUmVjZWl2ZWQ6IHRoaXMubWVzc2FnZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIGtlZXBBbGl2ZXNTZW50OiB0aGlzLmtlZXBhbGl2ZXNTZW50LFxuICAgICAgICAgICAgbGFzdExvY2FsU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcDogdGhpcy5zdHJlYW1UcmFja2VyLmxhc3RDYWxsU3RhcnRlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxhc3RSZW1vdGVTdHJlYW1DcmVhdGVkVGltZXN0YW1wOiBudWxsLFxuICAgICAgICAgICAgbGFzdE1lc3NhZ2VTZW50VGltZXN0YW1wOiB0aGlzLmxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXA6IHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZFRpbWVzdGFtcCxcbiAgICAgICAgICAgIGxvY2FsRmxvd0NvbnRyb2xXaW5kb3c6IChfYiA9IHRoaXMuc2Vzc2lvbi5zdGF0ZS5sb2NhbFdpbmRvd1NpemUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwsXG4gICAgICAgICAgICByZW1vdGVGbG93Q29udHJvbFdpbmRvdzogKF9jID0gdGhpcy5zZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHNvY2tldEluZm87XG4gICAgfVxuICAgIHJlc2V0Q2hhbm5lbHpTb2NrZXRJbmZvKCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpTb2NrZXRSZWYpIHtcbiAgICAgICAgICAgIGNoYW5uZWx6XzEudW5yZWdpc3RlckNoYW5uZWx6UmVmKHRoaXMuY2hhbm5lbHpTb2NrZXRSZWYpO1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIudW5yZWZDaGlsZCh0aGlzLmNoYW5uZWx6U29ja2V0UmVmKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpTb2NrZXRSZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3RlTmFtZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlciA9IG5ldyBjaGFubmVsel8xLkNoYW5uZWx6Q2FsbFRyYWNrZXIoKTtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCA9IDA7XG4gICAgICAgIHRoaXMubWVzc2FnZXNTZW50ID0gMDtcbiAgICAgICAgdGhpcy5tZXNzYWdlc1JlY2VpdmVkID0gMDtcbiAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAgPSBudWxsO1xuICAgIH1cbiAgICB0cmFjZSh0ZXh0KSB7XG4gICAgICAgIGxvZ2dpbmcudHJhY2UoY29uc3RhbnRzXzEuTG9nVmVyYm9zaXR5LkRFQlVHLCBUUkFDRVJfTkFNRSwgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIHJlZlRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdzdWJjaGFubmVsX3JlZmNvdW50JywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGZsb3dDb250cm9sVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgRkxPV19DT05UUk9MX1RSQUNFUl9OQU1FLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgKyAnICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgaW50ZXJuYWxzVHJhY2UodGV4dCkge1xuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ3N1YmNoYW5uZWxfaW50ZXJuYWxzJywgJygnICsgdGhpcy5jaGFubmVselJlZi5pZCArICcpICcgKyB0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nICsgJyAnICsgdGV4dCk7XG4gICAgfVxuICAgIGtlZXBhbGl2ZVRyYWNlKHRleHQpIHtcbiAgICAgICAgbG9nZ2luZy50cmFjZShjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuREVCVUcsICdrZWVwYWxpdmUnLCAnKCcgKyB0aGlzLmNoYW5uZWx6UmVmLmlkICsgJykgJyArIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgKyAnICcgKyB0ZXh0KTtcbiAgICB9XG4gICAgaGFuZGxlQmFja29mZlRpbWVyKCkge1xuICAgICAgICBpZiAodGhpcy5jb250aW51ZUNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElORyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgYmFja29mZiB0aW1lciB3aXRoIHRoZSBjdXJyZW50IG5leHRCYWNrb2ZmIHRpbWVvdXRcbiAgICAgKi9cbiAgICBzdGFydEJhY2tvZmYoKSB7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucnVuT25jZSgpO1xuICAgIH1cbiAgICBzdG9wQmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5zdG9wKCk7XG4gICAgICAgIHRoaXMuYmFja29mZlRpbWVvdXQucmVzZXQoKTtcbiAgICB9XG4gICAgc2VuZFBpbmcoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5rZWVwYWxpdmVzU2VudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVHJhY2UoJ1NlbmRpbmcgcGluZyB3aXRoIHRpbWVvdXQgJyArIHRoaXMua2VlcGFsaXZlVGltZW91dE1zICsgJ21zJyk7XG4gICAgICAgIHRoaXMua2VlcGFsaXZlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdQaW5nIHRpbWVvdXQgcGFzc2VkIHdpdGhvdXQgcmVzcG9uc2UnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICB9LCB0aGlzLmtlZXBhbGl2ZVRpbWVvdXRNcyk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMua2VlcGFsaXZlVGltZW91dElkKS51bnJlZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnBpbmcoKGVyciwgZHVyYXRpb24sIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmtlZXBhbGl2ZVRyYWNlKCdSZWNlaXZlZCBwaW5nIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMua2VlcGFsaXZlVGltZW91dElkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBJZiB3ZSBmYWlsIHRvIHNlbmQgYSBwaW5nLCB0aGUgY29ubmVjdGlvbiBpcyBubyBsb25nZXIgZnVuY3Rpb25hbCwgc29cbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBkaXNjYXJkIGl0LiAqL1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhcnRLZWVwYWxpdmVQaW5ncygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5rZWVwYWxpdmVJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZW5kUGluZygpO1xuICAgICAgICB9LCB0aGlzLmtlZXBhbGl2ZVRpbWVNcyk7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMua2VlcGFsaXZlSW50ZXJ2YWxJZCkudW5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgLyogRG9uJ3Qgc2VuZCBhIHBpbmcgaW1tZWRpYXRlbHkgYmVjYXVzZSB3aGF0ZXZlciBjYXVzZWQgdXMgdG8gc3RhcnRcbiAgICAgICAgICogc2VuZGluZyBwaW5ncyBzaG91bGQgYWxzbyBpbnZvbHZlIHNvbWUgbmV0d29yayBhY3Rpdml0eS4gKi9cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCBrZWVwYWxpdmUgcGluZ3Mgd2hlbiB0ZXJtaW5hdGluZyBhIGNvbm5lY3Rpb24uIFRoaXMgZGlzY2FyZHMgdGhlXG4gICAgICogb3V0c3RhbmRpbmcgcGluZyB0aW1lb3V0LCBzbyBpdCBzaG91bGQgbm90IGJlIGNhbGxlZCBpZiB0aGUgc2FtZVxuICAgICAqIGNvbm5lY3Rpb24gd2lsbCBzdGlsbCBiZSB1c2VkLlxuICAgICAqL1xuICAgIHN0b3BLZWVwYWxpdmVQaW5ncygpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZUludGVydmFsSWQpO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5rZWVwYWxpdmVUaW1lb3V0SWQpO1xuICAgIH1cbiAgICBjcmVhdGVTZXNzaW9uKHByb3h5Q29ubmVjdGlvblJlc3VsdCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW90ZU5hbWUgPSB1cmlfcGFyc2VyXzEudXJpVG9TdHJpbmcocHJveHlDb25uZWN0aW9uUmVzdWx0LnJlYWxUYXJnZXQpO1xuICAgICAgICAgICAgdGhpcy50cmFjZSgnY3JlYXRpbmcgSFRUUC8yIHNlc3Npb24gdGhyb3VnaCBwcm94eSB0byAnICsgcHJveHlDb25uZWN0aW9uUmVzdWx0LnJlYWxUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVOYW1lID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudHJhY2UoJ2NyZWF0aW5nIEhUVFAvMiBzZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0QXV0aG9yaXR5ID0gcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KChfYSA9IHByb3h5Q29ubmVjdGlvblJlc3VsdC5yZWFsVGFyZ2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNoYW5uZWxUYXJnZXQpO1xuICAgICAgICBsZXQgY29ubmVjdGlvbk9wdGlvbnMgPSB0aGlzLmNyZWRlbnRpYWxzLl9nZXRDb25uZWN0aW9uT3B0aW9ucygpIHx8IHt9O1xuICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5tYXhTZW5kSGVhZGVyQmxvY2tMZW5ndGggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgaWYgKCdncnBjLW5vZGUubWF4X3Nlc3Npb25fbWVtb3J5JyBpbiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLm1heFNlc3Npb25NZW1vcnkgPSB0aGlzLm9wdGlvbnNbJ2dycGMtbm9kZS5tYXhfc2Vzc2lvbl9tZW1vcnknXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIEJ5IGRlZmF1bHQsIHNldCBhIHZlcnkgbGFyZ2UgbWF4IHNlc3Npb24gbWVtb3J5IGxpbWl0LCB0byBlZmZlY3RpdmVseVxuICAgICAgICAgICAgICogZGlzYWJsZSBlbmZvcmNlbWVudCBvZiB0aGUgbGltaXQuIFNvbWUgdGVzdGluZyBpbmRpY2F0ZXMgdGhhdCBOb2RlJ3NcbiAgICAgICAgICAgICAqIGJlaGF2aW9yIGRlZ3JhZGVzIGJhZGx5IHdoZW4gdGhpcyBsaW1pdCBpcyByZWFjaGVkLCBzbyB3ZSBzb2x2ZSB0aGF0XG4gICAgICAgICAgICAgKiBieSBkaXNhYmxpbmcgdGhlIGNoZWNrIGVudGlyZWx5LiAqL1xuICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMubWF4U2Vzc2lvbk1lbW9yeSA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhZGRyZXNzU2NoZW1lID0gJ2h0dHA6Ly8nO1xuICAgICAgICBpZiAoJ3NlY3VyZUNvbnRleHQnIGluIGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgICAgICAgICBhZGRyZXNzU2NoZW1lID0gJ2h0dHBzOi8vJztcbiAgICAgICAgICAgIC8vIElmIHByb3ZpZGVkLCB0aGUgdmFsdWUgb2YgZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgIC8vIHRvIG92ZXJyaWRlIHRoZSB0YXJnZXQgaG9zdG5hbWUgd2hlbiBjaGVja2luZyBzZXJ2ZXIgaWRlbnRpdHkuXG4gICAgICAgICAgICAvLyBUaGlzIG9wdGlvbiBpcyB1c2VkIGZvciB0ZXN0aW5nIG9ubHkuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3NsVGFyZ2V0TmFtZU92ZXJyaWRlID0gdGhpcy5vcHRpb25zWydncnBjLnNzbF90YXJnZXRfbmFtZV9vdmVycmlkZSddO1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNoZWNrU2VydmVySWRlbnRpdHkgPSAoaG9zdCwgY2VydCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGxzXzEuY2hlY2tTZXJ2ZXJJZGVudGl0eShzc2xUYXJnZXROYW1lT3ZlcnJpZGUsIGNlcnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IHNzbFRhcmdldE5hbWVPdmVycmlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml0eUhvc3RuYW1lID0gKF9jID0gKF9iID0gdXJpX3BhcnNlcl8xLnNwbGl0SG9zdFBvcnQodGFyZ2V0QXV0aG9yaXR5KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhvc3QpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdsb2NhbGhvc3QnO1xuICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gYWx3YXlzIHNldCBzZXJ2ZXJuYW1lIHRvIHN1cHBvcnQgU05JXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMuc2VydmVybmFtZSA9IGF1dGhvcml0eUhvc3RuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAvKiBUaGlzIGlzIHBhcnQgb2YgdGhlIHdvcmthcm91bmQgZm9yXG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjkyMi4gV2l0aG91dCB0aGF0IGJ1ZyxcbiAgICAgICAgICAgICAgICAgKiBwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0IHdvdWxkIGFsd2F5cyBiZSBhIHBsYWludGV4dCBzb2NrZXQgYW5kXG4gICAgICAgICAgICAgICAgICogdGhpcyB3b3VsZCBzYXlcbiAgICAgICAgICAgICAgICAgKiBjb25uZWN0aW9uT3B0aW9ucy5zb2NrZXQgPSBwcm94eUNvbm5lY3Rpb25SZXN1bHQuc29ja2V0OyAqL1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNyZWF0ZUNvbm5lY3Rpb24gPSAoYXV0aG9yaXR5LCBvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3h5Q29ubmVjdGlvblJlc3VsdC5zb2NrZXQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIEluIGFsbCBidXQgdGhlIG1vc3QgcmVjZW50IHZlcnNpb25zIG9mIE5vZGUsIGh0dHAyLmNvbm5lY3QgZG9lcyBub3QgdXNlXG4gICAgICAgICAgICAgKiB0aGUgb3B0aW9ucyB3aGVuIGVzdGFibGlzaGluZyBwbGFpbnRleHQgY29ubmVjdGlvbnMsIHNvIHdlIG5lZWQgdG9cbiAgICAgICAgICAgICAqIGVzdGFibGlzaCB0aGF0IGNvbm5lY3Rpb24gZXhwbGljaXRseS4gKi9cbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmNyZWF0ZUNvbm5lY3Rpb24gPSAoYXV0aG9yaXR5LCBvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJveHlDb25uZWN0aW9uUmVzdWx0LnNvY2tldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIG5ldC5OZXRDb25uZWN0T3B0cyBpcyBkZWNsYXJlZCBpbiBhIHdheSB0aGF0IGlzIG1vcmUgcmVzdHJpY3RpdmVcbiAgICAgICAgICAgICAgICAgICAgICogdGhhbiB3aGF0IG5ldC5jb25uZWN0IHdpbGwgYWN0dWFsbHkgYWNjZXB0LCBzbyB3ZSB1c2UgdGhlIHR5cGVcbiAgICAgICAgICAgICAgICAgICAgICogYXNzZXJ0aW9uIHRvIHdvcmsgYXJvdW5kIHRoYXQuICovXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXQuY29ubmVjdCh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbm5lY3Rpb25PcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb25uZWN0aW9uT3B0aW9ucyksIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3MpO1xuICAgICAgICAvKiBodHRwMi5jb25uZWN0IHVzZXMgdGhlIG9wdGlvbnMgaGVyZTpcbiAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvNzBjMzJhNmQxOTBlMmI1ZDdiOWZmOWQ1YjZhNDU5ZDE0ZThiN2Q1OS9saWIvaW50ZXJuYWwvaHR0cDIvY29yZS5qcyNMMzAyOC1MMzAzNlxuICAgICAgICAgKiBUaGUgc3ByZWFkIG9wZXJhdG9yIG92ZXJpZGVzIGVhcmxpZXIgdmFsdWVzIHdpdGggbGF0ZXIgb25lcywgc28gYW55IHBvcnRcbiAgICAgICAgICogb3IgaG9zdCB2YWx1ZXMgaW4gdGhlIG9wdGlvbnMgd2lsbCBiZSB1c2VkIHJhdGhlciB0aGFuIGFueSB2YWx1ZXMgZXh0cmFjdGVkXG4gICAgICAgICAqIGZyb20gdGhlIGZpcnN0IGFyZ3VtZW50LiBJbiBhZGRpdGlvbiwgdGhlIHBhdGggb3ZlcnJpZGVzIHRoZSBob3N0IGFuZCBwb3J0LFxuICAgICAgICAgKiBhcyBkb2N1bWVudGVkIGZvciBwbGFpbnRleHQgY29ubmVjdGlvbnMgaGVyZTpcbiAgICAgICAgICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9uZXQuaHRtbCNuZXRfc29ja2V0X2Nvbm5lY3Rfb3B0aW9uc19jb25uZWN0bGlzdGVuZXJcbiAgICAgICAgICogYW5kIGZvciBUTFMgY29ubmVjdGlvbnMgaGVyZTpcbiAgICAgICAgICogaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90bHMuaHRtbCN0bHNfdGxzX2Nvbm5lY3Rfb3B0aW9uc19jYWxsYmFjay4gSW5cbiAgICAgICAgICogZWFybGllciB2ZXJzaW9ucyBvZiBOb2RlLCBodHRwMi5jb25uZWN0IHBhc3NlcyB0aGVzZSBvcHRpb25zIHRvXG4gICAgICAgICAqIHRscy5jb25uZWN0IGJ1dCBub3QgbmV0LmNvbm5lY3QsIHNvIGluIHRoZSBpbnNlY3VyZSBjYXNlIHdlIHN0aWxsIG5lZWRcbiAgICAgICAgICogdG8gc2V0IHRoZSBjcmVhdGVDb25uZWN0aW9uIG9wdGlvbiBhYm92ZSB0byBjcmVhdGUgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICogZXhwbGljaXRseS4gV2UgY2Fubm90IGRvIHRoYXQgaW4gdGhlIFRMUyBjYXNlIGJlY2F1c2UgaHR0cDIuY29ubmVjdFxuICAgICAgICAgKiBwYXNzZXMgbmVjZXNzYXJ5IGFkZGl0aW9uYWwgb3B0aW9ucyB0byB0bHMuY29ubmVjdC5cbiAgICAgICAgICogVGhlIGZpcnN0IGFyZ3VtZW50IGp1c3QgbmVlZHMgdG8gYmUgcGFyc2VhYmxlIGFzIGEgVVJMIGFuZCB0aGUgc2NoZW1lXG4gICAgICAgICAqIGRldGVybWluZXMgd2hldGhlciB0aGUgY29ubmVjdGlvbiB3aWxsIGJlIGVzdGFibGlzaGVkIG92ZXIgVExTIG9yIG5vdC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHNlc3Npb24gPSBodHRwMi5jb25uZWN0KGFkZHJlc3NTY2hlbWUgKyB0YXJnZXRBdXRob3JpdHksIGNvbm5lY3Rpb25PcHRpb25zKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICAgICAgdGhpcy5jaGFubmVselNvY2tldFJlZiA9IGNoYW5uZWx6XzEucmVnaXN0ZXJDaGFubmVselNvY2tldCh0aGlzLnN1YmNoYW5uZWxBZGRyZXNzU3RyaW5nLCAoKSA9PiB0aGlzLmdldENoYW5uZWx6U29ja2V0SW5mbygpLCB0aGlzLmNoYW5uZWx6RW5hYmxlZCk7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblRyYWNrZXIucmVmQ2hpbGQodGhpcy5jaGFubmVselNvY2tldFJlZik7XG4gICAgICAgIH1cbiAgICAgICAgc2Vzc2lvbi51bnJlZigpO1xuICAgICAgICAvKiBGb3IgYWxsIG9mIHRoZXNlIGV2ZW50cywgY2hlY2sgaWYgdGhlIHNlc3Npb24gYXQgdGhlIHRpbWUgb2YgdGhlIGV2ZW50XG4gICAgICAgICAqIGlzIHRoZSBzYW1lIG9uZSBjdXJyZW50bHkgYXR0YWNoZWQgdG8gdGhpcyBzdWJjaGFubmVsLCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAgKiBvbGQgZXZlbnRzIGZyb20gcHJldmlvdXMgY29ubmVjdGlvbiBhdHRlbXB0cyBjYW5ub3QgY2F1c2UgaW52YWxpZCBzdGF0ZVxuICAgICAgICAgKiB0cmFuc2l0aW9ucy4gKi9cbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiA9PT0gc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkddLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZXNzaW9uLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbiA9PT0gc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2UoJ2Nvbm5lY3Rpb24gY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuQ09OTkVDVElOR10sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlRSQU5TSUVOVF9GQUlMVVJFKTtcbiAgICAgICAgICAgICAgICAvKiBUcmFuc2l0aW9uaW5nIGRpcmVjdGx5IHRvIElETEUgaGVyZSBzaG91bGQgYmUgT0sgYmVjYXVzZSB3ZSBhcmUgbm90XG4gICAgICAgICAgICAgICAgICogZG9pbmcgYW55IGJhY2tvZmYsIGJlY2F1c2UgYSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCBhdCBzb21lXG4gICAgICAgICAgICAgICAgICogcG9pbnQgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdnb2F3YXknLCAoZXJyb3JDb2RlLCBsYXN0U3RyZWFtSUQsIG9wYXF1ZURhdGEpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24gPT09IHNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAvKiBTZWUgdGhlIGxhc3QgcGFyYWdyYXBoIG9mXG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL2dycGMvcHJvcG9zYWwvYmxvYi9tYXN0ZXIvQTgtY2xpZW50LXNpZGUta2VlcGFsaXZlLm1kI2Jhc2ljLWtlZXBhbGl2ZSAqL1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09IGh0dHAyLmNvbnN0YW50cy5OR0hUVFAyX0VOSEFOQ0VfWU9VUl9DQUxNICYmXG4gICAgICAgICAgICAgICAgICAgIG9wYXF1ZURhdGEuZXF1YWxzKHRvb01hbnlQaW5nc0RhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2VlcGFsaXZlVGltZU1zID0gTWF0aC5taW4oMiAqIHRoaXMua2VlcGFsaXZlVGltZU1zLCBLRUVQQUxJVkVfTUFYX1RJTUVfTVMpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nLmxvZyhjb25zdGFudHNfMS5Mb2dWZXJib3NpdHkuRVJST1IsIGBDb25uZWN0aW9uIHRvICR7dXJpX3BhcnNlcl8xLnVyaVRvU3RyaW5nKHRoaXMuY2hhbm5lbFRhcmdldCl9IGF0ICR7dGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZ30gcmVqZWN0ZWQgYnkgc2VydmVyIGJlY2F1c2Ugb2YgZXhjZXNzIHBpbmdzLiBJbmNyZWFzaW5nIHBpbmcgaW50ZXJ2YWwgdG8gJHt0aGlzLmtlZXBhbGl2ZVRpbWVNc30gbXNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnY29ubmVjdGlvbiBjbG9zZWQgYnkgR09BV0FZIHdpdGggY29kZSAnICtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2RlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5SRUFEWV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLklETEUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgc2Vzc2lvbi5vbmNlKCdlcnJvcicsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLyogRG8gbm90aGluZyBoZXJlLiBBbnkgZXJyb3Igc2hvdWxkIGFsc28gdHJpZ2dlciBhIGNsb3NlIGV2ZW50LCB3aGljaCBpc1xuICAgICAgICAgICAgICogd2hlcmUgd2Ugd2FudCB0byBoYW5kbGUgdGhhdC4gICovXG4gICAgICAgICAgICB0aGlzLnRyYWNlKCdjb25uZWN0aW9uIGNsb3NlZCB3aXRoIGVycm9yICcgK1xuICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxvZ2dpbmcuaXNUcmFjZXJFbmFibGVkKFRSQUNFUl9OQU1FKSkge1xuICAgICAgICAgICAgc2Vzc2lvbi5vbigncmVtb3RlU2V0dGluZ3MnLCAoc2V0dGluZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlKCduZXcgc2V0dGluZ3MgcmVjZWl2ZWQnICtcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuc2Vzc2lvbiAhPT0gc2Vzc2lvbiA/ICcgb24gdGhlIG9sZCBjb25uZWN0aW9uJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZXNzaW9uLm9uKCdsb2NhbFNldHRpbmdzJywgKHNldHRpbmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZSgnbG9jYWwgc2V0dGluZ3MgYWNrbm93bGVkZ2VkIGJ5IHJlbW90ZScgK1xuICAgICAgICAgICAgICAgICAgICAodGhpcy5zZXNzaW9uICE9PSBzZXNzaW9uID8gJyBvbiB0aGUgb2xkIGNvbm5lY3Rpb24nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydENvbm5lY3RpbmdJbnRlcm5hbCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgLyogUGFzcyBjb25uZWN0aW9uIG9wdGlvbnMgdGhyb3VnaCB0byB0aGUgcHJveHkgc28gdGhhdCBpdCdzIGFibGUgdG9cbiAgICAgICAgICogdXBncmFkZSBpdCdzIGNvbm5lY3Rpb24gdG8gc3VwcG9ydCB0bHMgaWYgbmVlZGVkLlxuICAgICAgICAgKiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8zMjkyMlxuICAgICAgICAgKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2dycGMvZ3JwYy1ub2RlL3B1bGwvMTM2OSBmb3IgbW9yZSBpbmZvLiAqL1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uT3B0aW9ucyA9IHRoaXMuY3JlZGVudGlhbHMuX2dldENvbm5lY3Rpb25PcHRpb25zKCkgfHwge307XG4gICAgICAgIGlmICgnc2VjdXJlQ29udGV4dCcgaW4gY29ubmVjdGlvbk9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLkFMUE5Qcm90b2NvbHMgPSBbJ2gyJ107XG4gICAgICAgICAgICAvLyBJZiBwcm92aWRlZCwgdGhlIHZhbHVlIG9mIGdycGMuc3NsX3RhcmdldF9uYW1lX292ZXJyaWRlIHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICAvLyB0byBvdmVycmlkZSB0aGUgdGFyZ2V0IGhvc3RuYW1lIHdoZW4gY2hlY2tpbmcgc2VydmVyIGlkZW50aXR5LlxuICAgICAgICAgICAgLy8gVGhpcyBvcHRpb24gaXMgdXNlZCBmb3IgdGVzdGluZyBvbmx5LlxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNzbFRhcmdldE5hbWVPdmVycmlkZSA9IHRoaXMub3B0aW9uc1snZ3JwYy5zc2xfdGFyZ2V0X25hbWVfb3ZlcnJpZGUnXTtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5jaGVja1NlcnZlcklkZW50aXR5ID0gKGhvc3QsIGNlcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRsc18xLmNoZWNrU2VydmVySWRlbnRpdHkoc3NsVGFyZ2V0TmFtZU92ZXJyaWRlLCBjZXJ0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnNlcnZlcm5hbWUgPSBzc2xUYXJnZXROYW1lT3ZlcnJpZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCcgaW4gdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFRoaXMgaXMgbW9yZSBvciBsZXNzIGhvdyBzZXJ2ZXJuYW1lIHdpbGwgYmUgc2V0IGluIGNyZWF0ZVNlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgICogaWYgYSBjb25uZWN0aW9uIGlzIHN1Y2Nlc3NmdWxseSBlc3RhYmxpc2hlZCB0aHJvdWdoIHRoZSBwcm94eS5cbiAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIHByb3h5IGlzIG5vdCB1c2VkLCB0aGVzZSBjb25uZWN0aW9uT3B0aW9ucyBhcmUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgICAgICAqIGFueXdheSAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRQYXRoID0gcmVzb2x2ZXJfMS5nZXREZWZhdWx0QXV0aG9yaXR5KChfYSA9IHVyaV9wYXJzZXJfMS5wYXJzZVVyaSh0aGlzLm9wdGlvbnNbJ2dycGMuaHR0cF9jb25uZWN0X3RhcmdldCddKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJ2xvY2FsaG9zdCcsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3N0UG9ydCA9IHVyaV9wYXJzZXJfMS5zcGxpdEhvc3RQb3J0KHRhcmdldFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5zZXJ2ZXJuYW1lID0gKF9iID0gaG9zdFBvcnQgPT09IG51bGwgfHwgaG9zdFBvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvc3RQb3J0Lmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRhcmdldFBhdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0dHBfcHJveHlfMS5nZXRQcm94aWVkQ29ubmVjdGlvbih0aGlzLnN1YmNoYW5uZWxBZGRyZXNzLCB0aGlzLm9wdGlvbnMsIGNvbm5lY3Rpb25PcHRpb25zKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlU2Vzc2lvbihyZXN1bHQpO1xuICAgICAgICB9LCAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5DT05ORUNUSU5HXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuUkVBRFldLCBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRSk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5kaXNjb25uZWN0TGlzdGVuZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIGEgc3RhdGUgdHJhbnNpdGlvbiBmcm9tIGFueSBlbGVtZW50IG9mIG9sZFN0YXRlcyB0byB0aGUgbmV3XG4gICAgICogc3RhdGUuIElmIHRoZSBjdXJyZW50IGNvbm5lY3Rpdml0eVN0YXRlIGlzIG5vdCBpbiBvbGRTdGF0ZXMsIGRvIG5vdGhpbmcuXG4gICAgICogQHBhcmFtIG9sZFN0YXRlcyBUaGUgc2V0IG9mIHN0YXRlcyB0byB0cmFuc2l0aW9uIGZyb21cbiAgICAgKiBAcGFyYW0gbmV3U3RhdGUgVGhlIHN0YXRlIHRvIHRyYW5zaXRpb24gdG9cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBzdGF0ZSBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICB0cmFuc2l0aW9uVG9TdGF0ZShvbGRTdGF0ZXMsIG5ld1N0YXRlKSB7XG4gICAgICAgIGlmIChvbGRTdGF0ZXMuaW5kZXhPZih0aGlzLmNvbm5lY3Rpdml0eVN0YXRlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyYWNlKGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY29ubmVjdGl2aXR5U3RhdGVdICtcbiAgICAgICAgICAgICcgLT4gJyArXG4gICAgICAgICAgICBjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZVtuZXdTdGF0ZV0pO1xuICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHpUcmFjZS5hZGRUcmFjZSgnQ1RfSU5GTycsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlW3RoaXMuY29ubmVjdGl2aXR5U3RhdGVdICsgJyAtPiAnICsgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGVbbmV3U3RhdGVdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5jb25uZWN0aXZpdHlTdGF0ZTtcbiAgICAgICAgdGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICBzd2l0Y2ggKG5ld1N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICAgICAgICAgIHNlc3Npb24uc29ja2V0Lm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uID09PSBzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0S2VlcGFsaXZlUGluZ3MoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkc6XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEJhY2tvZmYoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29ubmVjdGluZ0ludGVybmFsKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250aW51ZUNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkU6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Q2hhbm5lbHpTb2NrZXRJbmZvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wS2VlcGFsaXZlUGluZ3MoKTtcbiAgICAgICAgICAgICAgICAvKiBJZiB0aGUgYmFja29mZiB0aW1lciBoYXMgYWxyZWFkeSBlbmRlZCBieSB0aGUgdGltZSB3ZSBnZXQgdG8gdGhlXG4gICAgICAgICAgICAgICAgICogVFJBTlNJRU5UX0ZBSUxVUkUgc3RhdGUsIHdlIHdhbnQgdG8gaW1tZWRpYXRlbHkgdHJhbnNpdGlvbiBvdXQgb2ZcbiAgICAgICAgICAgICAgICAgKiBUUkFOU0lFTlRfRkFJTFVSRSBhcyB0aG91Z2ggdGhlIGJhY2tvZmYgdGltZXIgaXMgZW5kaW5nIHJpZ2h0IG5vdyAqL1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5iYWNrb2ZmVGltZW91dC5pc1J1bm5pbmcoKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQmFja29mZlRpbWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRDaGFubmVselNvY2tldEluZm8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3BLZWVwYWxpdmVQaW5ncygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RhdGU6IHVua25vd24gQ29ubmVjdGl2aXR5U3RhdGUgJHtuZXdTdGF0ZX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBXZSB1c2UgYSBzaGFsbG93IGNvcHkgb2YgdGhlIHN0YXRlTGlzdGVuZXJzIGFycmF5IGluIGNhc2UgYSBsaXN0ZW5lclxuICAgICAgICAgKiBpcyByZW1vdmVkIGR1cmluZyB0aGlzIGl0ZXJhdGlvbiAqL1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIFsuLi50aGlzLnN0YXRlTGlzdGVuZXJzXSkge1xuICAgICAgICAgICAgbGlzdGVuZXIodGhpcywgcHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgc3ViY2hhbm5lbCBhc3NvY2lhdGVkIHdpdGggemVybyBjYWxscyBhbmQgd2l0aCB6ZXJvIGNoYW5uZWxzLlxuICAgICAqIElmIHNvLCBzaHV0IGl0IGRvd24uXG4gICAgICovXG4gICAgY2hlY2tCb3RoUmVmY291bnRzKCkge1xuICAgICAgICAvKiBJZiBubyBjYWxscywgY2hhbm5lbHMsIG9yIHN1YmNoYW5uZWwgcG9vbHMgaGF2ZSBhbnkgbW9yZSByZWZlcmVuY2VzIHRvXG4gICAgICAgICAqIHRoaXMgc3ViY2hhbm5lbCwgd2UgY2FuIGJlIHN1cmUgaXQgd2lsbCBuZXZlciBiZSB1c2VkIGFnYWluLiAqL1xuICAgICAgICBpZiAodGhpcy5jYWxsUmVmY291bnQgPT09IDAgJiYgdGhpcy5yZWZjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbHpFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFubmVselRyYWNlLmFkZFRyYWNlKCdDVF9JTkZPJywgJ1NodXR0aW5nIGRvd24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcsIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRSk7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFubmVsekVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsel8xLnVucmVnaXN0ZXJDaGFubmVselJlZih0aGlzLmNoYW5uZWx6UmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsUmVmKCkge1xuICAgICAgICB0aGlzLnJlZlRyYWNlKCdjYWxsUmVmY291bnQgJyArXG4gICAgICAgICAgICB0aGlzLmNhbGxSZWZjb3VudCArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgKHRoaXMuY2FsbFJlZmNvdW50ICsgMSkpO1xuICAgICAgICBpZiAodGhpcy5jYWxsUmVmY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlc3Npb24ucmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnJlZigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmtlZXBhbGl2ZVdpdGhvdXRDYWxscykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRLZWVwYWxpdmVQaW5ncygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FsbFJlZmNvdW50ICs9IDE7XG4gICAgfVxuICAgIGNhbGxVbnJlZigpIHtcbiAgICAgICAgdGhpcy5yZWZUcmFjZSgnY2FsbFJlZmNvdW50ICcgK1xuICAgICAgICAgICAgdGhpcy5jYWxsUmVmY291bnQgK1xuICAgICAgICAgICAgJyAtPiAnICtcbiAgICAgICAgICAgICh0aGlzLmNhbGxSZWZjb3VudCAtIDEpKTtcbiAgICAgICAgdGhpcy5jYWxsUmVmY291bnQgLT0gMTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbFJlZmNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnVucmVmKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJhY2tvZmZUaW1lb3V0LnVucmVmKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMua2VlcGFsaXZlV2l0aG91dENhbGxzKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmtlZXBhbGl2ZUludGVydmFsSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGVja0JvdGhSZWZjb3VudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWYoKSB7XG4gICAgICAgIHRoaXMucmVmVHJhY2UoJ3JlZmNvdW50ICcgK1xuICAgICAgICAgICAgdGhpcy5yZWZjb3VudCArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgKHRoaXMucmVmY291bnQgKyAxKSk7XG4gICAgICAgIHRoaXMucmVmY291bnQgKz0gMTtcbiAgICB9XG4gICAgdW5yZWYoKSB7XG4gICAgICAgIHRoaXMucmVmVHJhY2UoJ3JlZmNvdW50ICcgK1xuICAgICAgICAgICAgdGhpcy5yZWZjb3VudCArXG4gICAgICAgICAgICAnIC0+ICcgK1xuICAgICAgICAgICAgKHRoaXMucmVmY291bnQgLSAxKSk7XG4gICAgICAgIHRoaXMucmVmY291bnQgLT0gMTtcbiAgICAgICAgdGhpcy5jaGVja0JvdGhSZWZjb3VudHMoKTtcbiAgICB9XG4gICAgdW5yZWZJZk9uZVJlZigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVmY291bnQgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWYoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYSBzdHJlYW0gb24gdGhlIGN1cnJlbnQgc2Vzc2lvbiB3aXRoIHRoZSBnaXZlbiBgbWV0YWRhdGFgIGFzIGhlYWRlcnNcbiAgICAgKiBhbmQgdGhlbiBhdHRhY2ggaXQgdG8gdGhlIGBjYWxsU3RyZWFtYC4gTXVzdCBvbmx5IGJlIGNhbGxlZCBpZiB0aGVcbiAgICAgKiBzdWJjaGFubmVsJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUgaXMgUkVBRFkuXG4gICAgICogQHBhcmFtIG1ldGFkYXRhXG4gICAgICogQHBhcmFtIGNhbGxTdHJlYW1cbiAgICAgKi9cbiAgICBzdGFydENhbGxTdHJlYW0obWV0YWRhdGEsIGNhbGxTdHJlYW0sIGV4dHJhRmlsdGVycykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWV0YWRhdGEudG9IdHRwMkhlYWRlcnMoKTtcbiAgICAgICAgaGVhZGVyc1tIVFRQMl9IRUFERVJfQVVUSE9SSVRZXSA9IGNhbGxTdHJlYW0uZ2V0SG9zdCgpO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9VU0VSX0FHRU5UXSA9IHRoaXMudXNlckFnZW50O1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9DT05URU5UX1RZUEVdID0gJ2FwcGxpY2F0aW9uL2dycGMnO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9NRVRIT0RdID0gJ1BPU1QnO1xuICAgICAgICBoZWFkZXJzW0hUVFAyX0hFQURFUl9QQVRIXSA9IGNhbGxTdHJlYW0uZ2V0TWV0aG9kKCk7XG4gICAgICAgIGhlYWRlcnNbSFRUUDJfSEVBREVSX1RFXSA9ICd0cmFpbGVycyc7XG4gICAgICAgIGxldCBodHRwMlN0cmVhbTtcbiAgICAgICAgLyogSW4gdGhlb3J5LCBpZiBhbiBlcnJvciBpcyB0aHJvd24gYnkgc2Vzc2lvbi5yZXF1ZXN0IGJlY2F1c2Ugc2Vzc2lvbiBoYXNcbiAgICAgICAgICogYmVjb21lIHVudXNhYmxlIChlLmcuIGJlY2F1c2UgaXQgaGFzIHJlY2VpdmVkIGEgZ29hd2F5KSwgdGhpcyBzdWJjaGFubmVsXG4gICAgICAgICAqIHNob3VsZCBzb29uIHNlZSB0aGUgY29ycmVzcG9uZGluZyBjbG9zZSBvciBnb2F3YXkgZXZlbnQgYW55d2F5IGFuZCBsZWF2ZVxuICAgICAgICAgKiBSRUFEWS4gQnV0IHdlIGhhdmUgc2VlbiByZXBvcnRzIHRoYXQgdGhpcyBkb2VzIG5vdCBoYXBwZW5cbiAgICAgICAgICogKGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGVhcGlzL25vZGVqcy1maXJlc3RvcmUvaXNzdWVzLzEwMjMjaXNzdWVjb21tZW50LTY1MzIwNDA5NilcbiAgICAgICAgICogc28gZm9yIGRlZmVuc2UgaW4gZGVwdGgsIHdlIGp1c3QgZGlzY2FyZCB0aGUgc2Vzc2lvbiB3aGVuIHdlIHNlZSBhblxuICAgICAgICAgKiBlcnJvciBoZXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGh0dHAyU3RyZWFtID0gdGhpcy5zZXNzaW9uLnJlcXVlc3QoaGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvU3RhdGUoW2Nvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLlJFQURZXSwgY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGVhZGVyc1N0cmluZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGhlYWRlciBvZiBPYmplY3Qua2V5cyhoZWFkZXJzKSkge1xuICAgICAgICAgICAgaGVhZGVyc1N0cmluZyArPSAnXFx0XFx0JyArIGhlYWRlciArICc6ICcgKyBoZWFkZXJzW2hlYWRlcl0gKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgICBsb2dnaW5nLnRyYWNlKGNvbnN0YW50c18xLkxvZ1ZlcmJvc2l0eS5ERUJVRywgJ2NhbGxfc3RyZWFtJywgJ1N0YXJ0aW5nIHN0cmVhbSBbJyArIGNhbGxTdHJlYW0uZ2V0Q2FsbE51bWJlcigpICsgJ10gb24gc3ViY2hhbm5lbCAnICtcbiAgICAgICAgICAgICcoJyArIHRoaXMuY2hhbm5lbHpSZWYuaWQgKyAnKSAnICtcbiAgICAgICAgICAgIHRoaXMuc3ViY2hhbm5lbEFkZHJlc3NTdHJpbmcgK1xuICAgICAgICAgICAgJyB3aXRoIGhlYWRlcnNcXG4nICtcbiAgICAgICAgICAgIGhlYWRlcnNTdHJpbmcpO1xuICAgICAgICB0aGlzLmZsb3dDb250cm9sVHJhY2UoJ2xvY2FsIHdpbmRvdyBzaXplOiAnICtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5zdGF0ZS5sb2NhbFdpbmRvd1NpemUgK1xuICAgICAgICAgICAgJyByZW1vdGUgd2luZG93IHNpemU6ICcgK1xuICAgICAgICAgICAgdGhpcy5zZXNzaW9uLnN0YXRlLnJlbW90ZVdpbmRvd1NpemUpO1xuICAgICAgICBjb25zdCBzdHJlYW1TZXNzaW9uID0gdGhpcy5zZXNzaW9uO1xuICAgICAgICB0aGlzLmludGVybmFsc1RyYWNlKCdzZXNzaW9uLmNsb3NlZD0nICtcbiAgICAgICAgICAgIHN0cmVhbVNlc3Npb24uY2xvc2VkICtcbiAgICAgICAgICAgICcgc2Vzc2lvbi5kZXN0cm95ZWQ9JyArXG4gICAgICAgICAgICBzdHJlYW1TZXNzaW9uLmRlc3Ryb3llZCArXG4gICAgICAgICAgICAnIHNlc3Npb24uc29ja2V0LmRlc3Ryb3llZD0nICtcbiAgICAgICAgICAgIHN0cmVhbVNlc3Npb24uc29ja2V0LmRlc3Ryb3llZCk7XG4gICAgICAgIGxldCBzdGF0c1RyYWNrZXI7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWx6RW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICAgICAgY2FsbFN0cmVhbS5hZGRTdGF0dXNXYXRjaGVyKHN0YXR1cyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy5jb2RlID09PSBjb25zdGFudHNfMS5TdGF0dXMuT0spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxUcmFja2VyLmFkZENhbGxGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsU3RhcnRlZCgpO1xuICAgICAgICAgICAgY2FsbFN0cmVhbS5hZGRTdHJlYW1FbmRXYXRjaGVyKHN1Y2Nlc3MgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW1TZXNzaW9uID09PSB0aGlzLnNlc3Npb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtVHJhY2tlci5hZGRDYWxsU3VjY2VlZGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVRyYWNrZXIuYWRkQ2FsbEZhaWxlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0c1RyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVNlbnQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlc1NlbnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0TWVzc2FnZVNlbnRUaW1lc3RhbXAgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVJlY2VpdmVkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZXNSZWNlaXZlZCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0c1RyYWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgYWRkTWVzc2FnZVNlbnQ6ICgpID0+IHsgfSxcbiAgICAgICAgICAgICAgICBhZGRNZXNzYWdlUmVjZWl2ZWQ6ICgpID0+IHsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsU3RyZWFtLmF0dGFjaEh0dHAyU3RyZWFtKGh0dHAyU3RyZWFtLCB0aGlzLCBleHRyYUZpbHRlcnMsIHN0YXRzVHJhY2tlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBzdWJjaGFubmVsIGlzIGN1cnJlbnRseSBJRExFLCBzdGFydCBjb25uZWN0aW5nIGFuZCBzd2l0Y2ggdG8gdGhlXG4gICAgICogQ09OTkVDVElORyBzdGF0ZS4gSWYgdGhlIHN1YmNoYW5uZWwgaXMgY3VycmVudCBpbiBUUkFOU0lFTlRfRkFJTFVSRSxcbiAgICAgKiB0aGUgbmV4dCB0aW1lIGl0IHdvdWxkIHRyYW5zaXRpb24gdG8gSURMRSwgc3RhcnQgY29ubmVjdGluZyBhZ2FpbiBpbnN0ZWFkLlxuICAgICAqIE90aGVyd2lzZSwgZG8gbm90aGluZy5cbiAgICAgKi9cbiAgICBzdGFydENvbm5lY3RpbmcoKSB7XG4gICAgICAgIC8qIEZpcnN0LCB0cnkgdG8gdHJhbnNpdGlvbiBmcm9tIElETEUgdG8gY29ubmVjdGluZy4gSWYgdGhhdCBkb2Vzbid0IGhhcHBlblxuICAgICAgICAgKiBiZWNhdXNlIHRoZSBzdGF0ZSBpcyBub3QgY3VycmVudGx5IElETEUsIGNoZWNrIGlmIGl0IGlzXG4gICAgICAgICAqIFRSQU5TSUVOVF9GQUlMVVJFLCBhbmQgaWYgc28gaW5kaWNhdGUgdGhhdCBpdCBzaG91bGQgZ28gYmFjayB0b1xuICAgICAgICAgKiBjb25uZWN0aW5nIGFmdGVyIHRoZSBiYWNrb2ZmIHRpbWVyIGVuZHMuIE90aGVyd2lzZSBkbyBub3RoaW5nICovXG4gICAgICAgIGlmICghdGhpcy50cmFuc2l0aW9uVG9TdGF0ZShbY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuSURMRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0aXZpdHlTdGF0ZSA9PT0gY29ubmVjdGl2aXR5X3N0YXRlXzEuQ29ubmVjdGl2aXR5U3RhdGUuVFJBTlNJRU5UX0ZBSUxVUkUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRpbnVlQ29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBzdWJjaGFubmVsJ3MgY3VycmVudCBjb25uZWN0aXZpdHkgc3RhdGUuXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdGl2aXR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpdml0eVN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbmV2ZXIgdGhlIHN1YmNoYW5uZWwnc1xuICAgICAqIGNvbm5lY3Rpdml0eSBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqL1xuICAgIGFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5zdGF0ZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbGlzdGVuZXIgcHJldmlvdXNseSBhZGRlZCB3aXRoIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBBIHJlZmVyZW5jZSB0byBhIGZ1bmN0aW9uIHByZXZpb3VzbHkgcGFzc2VkIHRvXG4gICAgICogICAgIGBhZGRDb25uZWN0aXZpdHlTdGF0ZUxpc3RlbmVyYFxuICAgICAqL1xuICAgIHJlbW92ZUNvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJJbmRleCA9IHRoaXMuc3RhdGVMaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgIGlmIChsaXN0ZW5lckluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVMaXN0ZW5lcnMuc3BsaWNlKGxpc3RlbmVySW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZERpc2Nvbm5lY3RMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RMaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmVtb3ZlRGlzY29ubmVjdExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgYmFja29mZiB0aW1lb3V0LCBhbmQgaW1tZWRpYXRlbHkgc3RhcnQgY29ubmVjdGluZyBpZiBpbiBiYWNrb2ZmLlxuICAgICAqL1xuICAgIHJlc2V0QmFja29mZigpIHtcbiAgICAgICAgdGhpcy5iYWNrb2ZmVGltZW91dC5yZXNldCgpO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub1N0YXRlKFtjb25uZWN0aXZpdHlfc3RhdGVfMS5Db25uZWN0aXZpdHlTdGF0ZS5UUkFOU0lFTlRfRkFJTFVSRV0sIGNvbm5lY3Rpdml0eV9zdGF0ZV8xLkNvbm5lY3Rpdml0eVN0YXRlLkNPTk5FQ1RJTkcpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJjaGFubmVsQWRkcmVzc1N0cmluZztcbiAgICB9XG4gICAgZ2V0Q2hhbm5lbHpSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYW5uZWx6UmVmO1xuICAgIH1cbiAgICBnZXRSZWFsU3ViY2hhbm5lbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5TdWJjaGFubmVsID0gU3ViY2hhbm5lbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN1YmNoYW5uZWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiU3ViY2hhbm5lbCIsImh0dHAyIiwicmVxdWlyZSIsInRsc18xIiwiY29ubmVjdGl2aXR5X3N0YXRlXzEiLCJiYWNrb2ZmX3RpbWVvdXRfMSIsInJlc29sdmVyXzEiLCJsb2dnaW5nIiwiY29uc3RhbnRzXzEiLCJodHRwX3Byb3h5XzEiLCJuZXQiLCJ1cmlfcGFyc2VyXzEiLCJzdWJjaGFubmVsX2FkZHJlc3NfMSIsImNoYW5uZWx6XzEiLCJjbGllbnRWZXJzaW9uIiwidmVyc2lvbiIsIlRSQUNFUl9OQU1FIiwiRkxPV19DT05UUk9MX1RSQUNFUl9OQU1FIiwiTUlOX0NPTk5FQ1RfVElNRU9VVF9NUyIsIklOSVRJQUxfQkFDS09GRl9NUyIsIkJBQ0tPRkZfTVVMVElQTElFUiIsIk1BWF9CQUNLT0ZGX01TIiwiQkFDS09GRl9KSVRURVIiLCJLRUVQQUxJVkVfTUFYX1RJTUVfTVMiLCJLRUVQQUxJVkVfVElNRU9VVF9NUyIsIkhUVFAyX0hFQURFUl9BVVRIT1JJVFkiLCJIVFRQMl9IRUFERVJfQ09OVEVOVF9UWVBFIiwiSFRUUDJfSEVBREVSX01FVEhPRCIsIkhUVFAyX0hFQURFUl9QQVRIIiwiSFRUUDJfSEVBREVSX1RFIiwiSFRUUDJfSEVBREVSX1VTRVJfQUdFTlQiLCJjb25zdGFudHMiLCJ1bmlmb3JtUmFuZG9tIiwibWluIiwibWF4IiwiTWF0aCIsInJhbmRvbSIsInRvb01hbnlQaW5nc0RhdGEiLCJCdWZmZXIiLCJmcm9tIiwiY29uc3RydWN0b3IiLCJjaGFubmVsVGFyZ2V0Iiwic3ViY2hhbm5lbEFkZHJlc3MiLCJvcHRpb25zIiwiY3JlZGVudGlhbHMiLCJjb25uZWN0aXZpdHlTdGF0ZSIsIkNvbm5lY3Rpdml0eVN0YXRlIiwiSURMRSIsInNlc3Npb24iLCJjb250aW51ZUNvbm5lY3RpbmciLCJzdGF0ZUxpc3RlbmVycyIsImRpc2Nvbm5lY3RMaXN0ZW5lcnMiLCJTZXQiLCJrZWVwYWxpdmVUaW1lTXMiLCJrZWVwYWxpdmVUaW1lb3V0TXMiLCJrZWVwYWxpdmVXaXRob3V0Q2FsbHMiLCJjYWxsUmVmY291bnQiLCJyZWZjb3VudCIsImNoYW5uZWx6RW5hYmxlZCIsImNhbGxUcmFja2VyIiwiQ2hhbm5lbHpDYWxsVHJhY2tlciIsImNoaWxkcmVuVHJhY2tlciIsIkNoYW5uZWx6Q2hpbGRyZW5UcmFja2VyIiwiY2hhbm5lbHpTb2NrZXRSZWYiLCJyZW1vdGVOYW1lIiwic3RyZWFtVHJhY2tlciIsImtlZXBhbGl2ZXNTZW50IiwibWVzc2FnZXNTZW50IiwibWVzc2FnZXNSZWNlaXZlZCIsImxhc3RNZXNzYWdlU2VudFRpbWVzdGFtcCIsImxhc3RNZXNzYWdlUmVjZWl2ZWRUaW1lc3RhbXAiLCJ1c2VyQWdlbnQiLCJmaWx0ZXIiLCJlIiwiam9pbiIsImtlZXBhbGl2ZUludGVydmFsSWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwia2VlcGFsaXZlVGltZW91dElkIiwiYmFja29mZk9wdGlvbnMiLCJpbml0aWFsRGVsYXkiLCJtYXhEZWxheSIsImJhY2tvZmZUaW1lb3V0IiwiQmFja29mZlRpbWVvdXQiLCJoYW5kbGVCYWNrb2ZmVGltZXIiLCJzdWJjaGFubmVsQWRkcmVzc1N0cmluZyIsInN1YmNoYW5uZWxBZGRyZXNzVG9TdHJpbmciLCJjaGFubmVselRyYWNlIiwiQ2hhbm5lbHpUcmFjZSIsImNoYW5uZWx6UmVmIiwicmVnaXN0ZXJDaGFubmVselN1YmNoYW5uZWwiLCJnZXRDaGFubmVsekluZm8iLCJhZGRUcmFjZSIsInRyYWNlIiwiSlNPTiIsInN0cmluZ2lmeSIsInVuZGVmaW5lZCIsInN0YXRlIiwiY2hpbGRyZW4iLCJnZXRDaGlsZExpc3RzIiwidGFyZ2V0IiwiZ2V0Q2hhbm5lbHpTb2NrZXRJbmZvIiwiX2EiLCJfYiIsIl9jIiwic2Vzc2lvblNvY2tldCIsInNvY2tldCIsInJlbW90ZUFkZHJlc3MiLCJzdHJpbmdUb1N1YmNoYW5uZWxBZGRyZXNzIiwicmVtb3RlUG9ydCIsImxvY2FsQWRkcmVzcyIsImxvY2FsUG9ydCIsInRsc0luZm8iLCJlbmNyeXB0ZWQiLCJ0bHNTb2NrZXQiLCJjaXBoZXJJbmZvIiwiZ2V0Q2lwaGVyIiwiY2VydGlmaWNhdGUiLCJnZXRDZXJ0aWZpY2F0ZSIsInBlZXJDZXJ0aWZpY2F0ZSIsImdldFBlZXJDZXJ0aWZpY2F0ZSIsImNpcGhlclN1aXRlU3RhbmRhcmROYW1lIiwic3RhbmRhcmROYW1lIiwiY2lwaGVyU3VpdGVPdGhlck5hbWUiLCJuYW1lIiwibG9jYWxDZXJ0aWZpY2F0ZSIsInJhdyIsInJlbW90ZUNlcnRpZmljYXRlIiwic29ja2V0SW5mbyIsInNlY3VyaXR5Iiwic3RyZWFtc1N0YXJ0ZWQiLCJjYWxsc1N0YXJ0ZWQiLCJzdHJlYW1zU3VjY2VlZGVkIiwiY2FsbHNTdWNjZWVkZWQiLCJzdHJlYW1zRmFpbGVkIiwiY2FsbHNGYWlsZWQiLCJrZWVwQWxpdmVzU2VudCIsImxhc3RMb2NhbFN0cmVhbUNyZWF0ZWRUaW1lc3RhbXAiLCJsYXN0Q2FsbFN0YXJ0ZWRUaW1lc3RhbXAiLCJsYXN0UmVtb3RlU3RyZWFtQ3JlYXRlZFRpbWVzdGFtcCIsImxvY2FsRmxvd0NvbnRyb2xXaW5kb3ciLCJsb2NhbFdpbmRvd1NpemUiLCJyZW1vdGVGbG93Q29udHJvbFdpbmRvdyIsInJlbW90ZVdpbmRvd1NpemUiLCJyZXNldENoYW5uZWx6U29ja2V0SW5mbyIsInVucmVnaXN0ZXJDaGFubmVselJlZiIsInVucmVmQ2hpbGQiLCJ0ZXh0IiwiTG9nVmVyYm9zaXR5IiwiREVCVUciLCJpZCIsInJlZlRyYWNlIiwiZmxvd0NvbnRyb2xUcmFjZSIsImludGVybmFsc1RyYWNlIiwia2VlcGFsaXZlVHJhY2UiLCJ0cmFuc2l0aW9uVG9TdGF0ZSIsIlRSQU5TSUVOVF9GQUlMVVJFIiwiQ09OTkVDVElORyIsInN0YXJ0QmFja29mZiIsInJ1bk9uY2UiLCJzdG9wQmFja29mZiIsInN0b3AiLCJyZXNldCIsInNlbmRQaW5nIiwiaGFuZGxlRGlzY29ubmVjdCIsInVucmVmIiwiY2FsbCIsInBpbmciLCJlcnIiLCJkdXJhdGlvbiIsInBheWxvYWQiLCJSRUFEWSIsInN0YXJ0S2VlcGFsaXZlUGluZ3MiLCJzZXRJbnRlcnZhbCIsInN0b3BLZWVwYWxpdmVQaW5ncyIsImNsZWFySW50ZXJ2YWwiLCJjcmVhdGVTZXNzaW9uIiwicHJveHlDb25uZWN0aW9uUmVzdWx0IiwicmVhbFRhcmdldCIsInVyaVRvU3RyaW5nIiwidGFyZ2V0QXV0aG9yaXR5IiwiZ2V0RGVmYXVsdEF1dGhvcml0eSIsImNvbm5lY3Rpb25PcHRpb25zIiwiX2dldENvbm5lY3Rpb25PcHRpb25zIiwibWF4U2VuZEhlYWRlckJsb2NrTGVuZ3RoIiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIm1heFNlc3Npb25NZW1vcnkiLCJhZGRyZXNzU2NoZW1lIiwic3NsVGFyZ2V0TmFtZU92ZXJyaWRlIiwiY2hlY2tTZXJ2ZXJJZGVudGl0eSIsImhvc3QiLCJjZXJ0Iiwic2VydmVybmFtZSIsImF1dGhvcml0eUhvc3RuYW1lIiwic3BsaXRIb3N0UG9ydCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJhdXRob3JpdHkiLCJvcHRpb24iLCJjb25uZWN0IiwiYXNzaWduIiwicmVnaXN0ZXJDaGFubmVselNvY2tldCIsInJlZkNoaWxkIiwib25jZSIsImVycm9yQ29kZSIsImxhc3RTdHJlYW1JRCIsIm9wYXF1ZURhdGEiLCJOR0hUVFAyX0VOSEFOQ0VfWU9VUl9DQUxNIiwiZXF1YWxzIiwibG9nIiwiRVJST1IiLCJlcnJvciIsIm1lc3NhZ2UiLCJpc1RyYWNlckVuYWJsZWQiLCJvbiIsInNldHRpbmdzIiwic3RhcnRDb25uZWN0aW5nSW50ZXJuYWwiLCJBTFBOUHJvdG9jb2xzIiwidGFyZ2V0UGF0aCIsInBhcnNlVXJpIiwicGF0aCIsImhvc3RQb3J0IiwiZ2V0UHJveGllZENvbm5lY3Rpb24iLCJ0aGVuIiwicmVzdWx0IiwicmVhc29uIiwibGlzdGVuZXIiLCJ2YWx1ZXMiLCJvbGRTdGF0ZXMiLCJuZXdTdGF0ZSIsImluZGV4T2YiLCJwcmV2aW91c1N0YXRlIiwiY2xvc2UiLCJpc1J1bm5pbmciLCJwcm9jZXNzIiwibmV4dFRpY2siLCJFcnJvciIsImNoZWNrQm90aFJlZmNvdW50cyIsImNhbGxSZWYiLCJyZWYiLCJjYWxsVW5yZWYiLCJ1bnJlZklmT25lUmVmIiwic3RhcnRDYWxsU3RyZWFtIiwibWV0YWRhdGEiLCJjYWxsU3RyZWFtIiwiZXh0cmFGaWx0ZXJzIiwiaGVhZGVycyIsInRvSHR0cDJIZWFkZXJzIiwiZ2V0SG9zdCIsImdldE1ldGhvZCIsImh0dHAyU3RyZWFtIiwicmVxdWVzdCIsImhlYWRlcnNTdHJpbmciLCJoZWFkZXIiLCJrZXlzIiwiZ2V0Q2FsbE51bWJlciIsInN0cmVhbVNlc3Npb24iLCJjbG9zZWQiLCJkZXN0cm95ZWQiLCJzdGF0c1RyYWNrZXIiLCJhZGRDYWxsU3RhcnRlZCIsImFkZFN0YXR1c1dhdGNoZXIiLCJzdGF0dXMiLCJjb2RlIiwiU3RhdHVzIiwiT0siLCJhZGRDYWxsU3VjY2VlZGVkIiwiYWRkQ2FsbEZhaWxlZCIsImFkZFN0cmVhbUVuZFdhdGNoZXIiLCJzdWNjZXNzIiwiYWRkTWVzc2FnZVNlbnQiLCJEYXRlIiwiYWRkTWVzc2FnZVJlY2VpdmVkIiwiYXR0YWNoSHR0cDJTdHJlYW0iLCJzdGFydENvbm5lY3RpbmciLCJnZXRDb25uZWN0aXZpdHlTdGF0ZSIsImFkZENvbm5lY3Rpdml0eVN0YXRlTGlzdGVuZXIiLCJwdXNoIiwicmVtb3ZlQ29ubmVjdGl2aXR5U3RhdGVMaXN0ZW5lciIsImxpc3RlbmVySW5kZXgiLCJzcGxpY2UiLCJhZGREaXNjb25uZWN0TGlzdGVuZXIiLCJhZGQiLCJyZW1vdmVEaXNjb25uZWN0TGlzdGVuZXIiLCJkZWxldGUiLCJyZXNldEJhY2tvZmYiLCJnZXRBZGRyZXNzIiwiZ2V0Q2hhbm5lbHpSZWYiLCJnZXRSZWFsU3ViY2hhbm5lbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/subchannel.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js":
/*!*************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/tls-helpers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.getDefaultRootsData = exports.CIPHER_SUITES = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nexports.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;\nconst DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;\nlet defaultRootsData = null;\nfunction getDefaultRootsData() {\n    if (DEFAULT_ROOTS_FILE_PATH) {\n        if (defaultRootsData === null) {\n            defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);\n        }\n        return defaultRootsData;\n    }\n    return null;\n}\nexports.getDefaultRootsData = getDefaultRootsData; //# sourceMappingURL=tls-helpers.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdGxzLWhlbHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELDJCQUEyQixHQUFHQSxxQkFBcUIsR0FBRyxLQUFLO0FBQzNELE1BQU1JLEtBQUtDLG1CQUFPQSxDQUFDLGNBQUk7QUFDdkJMLHFCQUFxQixHQUFHTSxRQUFRQyxHQUFHLENBQUNDLHNCQUFzQjtBQUMxRCxNQUFNQywwQkFBMEJILFFBQVFDLEdBQUcsQ0FBQ0csZ0NBQWdDO0FBQzVFLElBQUlDLG1CQUFtQjtBQUN2QixTQUFTVDtJQUNMLElBQUlPLHlCQUF5QjtRQUN6QixJQUFJRSxxQkFBcUIsTUFBTTtZQUMzQkEsbUJBQW1CUCxHQUFHUSxZQUFZLENBQUNIO1FBQ3ZDO1FBQ0EsT0FBT0U7SUFDWDtJQUNBLE9BQU87QUFDWDtBQUNBWCwyQkFBMkIsR0FBR0UscUJBQzlCLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL2J1aWxkL3NyYy90bHMtaGVscGVycy5qcz8wZWQ1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLypcbiAqIENvcHlyaWdodCAyMDE5IGdSUEMgYXV0aG9ycy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERlZmF1bHRSb290c0RhdGEgPSBleHBvcnRzLkNJUEhFUl9TVUlURVMgPSB2b2lkIDA7XG5jb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbmV4cG9ydHMuQ0lQSEVSX1NVSVRFUyA9IHByb2Nlc3MuZW52LkdSUENfU1NMX0NJUEhFUl9TVUlURVM7XG5jb25zdCBERUZBVUxUX1JPT1RTX0ZJTEVfUEFUSCA9IHByb2Nlc3MuZW52LkdSUENfREVGQVVMVF9TU0xfUk9PVFNfRklMRV9QQVRIO1xubGV0IGRlZmF1bHRSb290c0RhdGEgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFJvb3RzRGF0YSgpIHtcbiAgICBpZiAoREVGQVVMVF9ST09UU19GSUxFX1BBVEgpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRSb290c0RhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmF1bHRSb290c0RhdGEgPSBmcy5yZWFkRmlsZVN5bmMoREVGQVVMVF9ST09UU19GSUxFX1BBVEgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0Um9vdHNEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuZ2V0RGVmYXVsdFJvb3RzRGF0YSA9IGdldERlZmF1bHRSb290c0RhdGE7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10bHMtaGVscGVycy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJnZXREZWZhdWx0Um9vdHNEYXRhIiwiQ0lQSEVSX1NVSVRFUyIsImZzIiwicmVxdWlyZSIsInByb2Nlc3MiLCJlbnYiLCJHUlBDX1NTTF9DSVBIRVJfU1VJVEVTIiwiREVGQVVMVF9ST09UU19GSUxFX1BBVEgiLCJHUlBDX0RFRkFVTFRfU1NMX1JPT1RTX0ZJTEVfUEFUSCIsImRlZmF1bHRSb290c0RhdGEiLCJyZWFkRmlsZVN5bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/tls-helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/build/src/uri-parser.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.uriToString = exports.splitHostPort = exports.parseUri = void 0;\n/*\n * The groups correspond to URI parts as follows:\n * 1. scheme\n * 2. authority\n * 3. path\n */ const URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\\/\\/([^/]*)\\/)?(.+)$/;\nfunction parseUri(uriString) {\n    const parsedUri = URI_REGEX.exec(uriString);\n    if (parsedUri === null) {\n        return null;\n    }\n    return {\n        scheme: parsedUri[1],\n        authority: parsedUri[2],\n        path: parsedUri[3]\n    };\n}\nexports.parseUri = parseUri;\nconst NUMBER_REGEX = /^\\d+$/;\nfunction splitHostPort(path) {\n    if (path.startsWith(\"[\")) {\n        const hostEnd = path.indexOf(\"]\");\n        if (hostEnd === -1) {\n            return null;\n        }\n        const host = path.substring(1, hostEnd);\n        /* Only an IPv6 address should be in bracketed notation, and an IPv6\n         * address should have at least one colon */ if (host.indexOf(\":\") === -1) {\n            return null;\n        }\n        if (path.length > hostEnd + 1) {\n            if (path[hostEnd + 1] === \":\") {\n                const portString = path.substring(hostEnd + 2);\n                if (NUMBER_REGEX.test(portString)) {\n                    return {\n                        host: host,\n                        port: +portString\n                    };\n                } else {\n                    return null;\n                }\n            } else {\n                return null;\n            }\n        } else {\n            return {\n                host\n            };\n        }\n    } else {\n        const splitPath = path.split(\":\");\n        /* Exactly one colon means that this is host:port. Zero colons means that\n         * there is no port. And multiple colons means that this is a bare IPv6\n         * address with no port */ if (splitPath.length === 2) {\n            if (NUMBER_REGEX.test(splitPath[1])) {\n                return {\n                    host: splitPath[0],\n                    port: +splitPath[1]\n                };\n            } else {\n                return null;\n            }\n        } else {\n            return {\n                host: path\n            };\n        }\n    }\n}\nexports.splitHostPort = splitHostPort;\nfunction uriToString(uri) {\n    let result = \"\";\n    if (uri.scheme !== undefined) {\n        result += uri.scheme + \":\";\n    }\n    if (uri.authority !== undefined) {\n        result += \"//\" + uri.authority + \"/\";\n    }\n    result += uri.path;\n    return result;\n}\nexports.uriToString = uriToString; //# sourceMappingURL=uri-parser.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9idWlsZC9zcmMvdXJpLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNEQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUM3REQsbUJBQW1CLEdBQUdBLHFCQUFxQixHQUFHQSxnQkFBZ0IsR0FBRyxLQUFLO0FBQ3RFOzs7OztDQUtDLEdBQ0QsTUFBTUssWUFBWTtBQUNsQixTQUFTRCxTQUFTRSxTQUFTO0lBQ3ZCLE1BQU1DLFlBQVlGLFVBQVVHLElBQUksQ0FBQ0Y7SUFDakMsSUFBSUMsY0FBYyxNQUFNO1FBQ3BCLE9BQU87SUFDWDtJQUNBLE9BQU87UUFDSEUsUUFBUUYsU0FBUyxDQUFDLEVBQUU7UUFDcEJHLFdBQVdILFNBQVMsQ0FBQyxFQUFFO1FBQ3ZCSSxNQUFNSixTQUFTLENBQUMsRUFBRTtJQUN0QjtBQUNKO0FBQ0FQLGdCQUFnQixHQUFHSTtBQUNuQixNQUFNUSxlQUFlO0FBQ3JCLFNBQVNULGNBQWNRLElBQUk7SUFDdkIsSUFBSUEsS0FBS0UsVUFBVSxDQUFDLE1BQU07UUFDdEIsTUFBTUMsVUFBVUgsS0FBS0ksT0FBTyxDQUFDO1FBQzdCLElBQUlELFlBQVksQ0FBQyxHQUFHO1lBQ2hCLE9BQU87UUFDWDtRQUNBLE1BQU1FLE9BQU9MLEtBQUtNLFNBQVMsQ0FBQyxHQUFHSDtRQUMvQjtrREFDMEMsR0FDMUMsSUFBSUUsS0FBS0QsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO1lBQzFCLE9BQU87UUFDWDtRQUNBLElBQUlKLEtBQUtPLE1BQU0sR0FBR0osVUFBVSxHQUFHO1lBQzNCLElBQUlILElBQUksQ0FBQ0csVUFBVSxFQUFFLEtBQUssS0FBSztnQkFDM0IsTUFBTUssYUFBYVIsS0FBS00sU0FBUyxDQUFDSCxVQUFVO2dCQUM1QyxJQUFJRixhQUFhUSxJQUFJLENBQUNELGFBQWE7b0JBQy9CLE9BQU87d0JBQ0hILE1BQU1BO3dCQUNOSyxNQUFNLENBQUNGO29CQUNYO2dCQUNKLE9BQ0s7b0JBQ0QsT0FBTztnQkFDWDtZQUNKLE9BQ0s7Z0JBQ0QsT0FBTztZQUNYO1FBQ0osT0FDSztZQUNELE9BQU87Z0JBQ0hIO1lBQ0o7UUFDSjtJQUNKLE9BQ0s7UUFDRCxNQUFNTSxZQUFZWCxLQUFLWSxLQUFLLENBQUM7UUFDN0I7O2dDQUV3QixHQUN4QixJQUFJRCxVQUFVSixNQUFNLEtBQUssR0FBRztZQUN4QixJQUFJTixhQUFhUSxJQUFJLENBQUNFLFNBQVMsQ0FBQyxFQUFFLEdBQUc7Z0JBQ2pDLE9BQU87b0JBQ0hOLE1BQU1NLFNBQVMsQ0FBQyxFQUFFO29CQUNsQkQsTUFBTSxDQUFDQyxTQUFTLENBQUMsRUFBRTtnQkFDdkI7WUFDSixPQUNLO2dCQUNELE9BQU87WUFDWDtRQUNKLE9BQ0s7WUFDRCxPQUFPO2dCQUNITixNQUFNTDtZQUNWO1FBQ0o7SUFDSjtBQUNKO0FBQ0FYLHFCQUFxQixHQUFHRztBQUN4QixTQUFTRCxZQUFZc0IsR0FBRztJQUNwQixJQUFJQyxTQUFTO0lBQ2IsSUFBSUQsSUFBSWYsTUFBTSxLQUFLaUIsV0FBVztRQUMxQkQsVUFBVUQsSUFBSWYsTUFBTSxHQUFHO0lBQzNCO0lBQ0EsSUFBSWUsSUFBSWQsU0FBUyxLQUFLZ0IsV0FBVztRQUM3QkQsVUFBVSxPQUFPRCxJQUFJZCxTQUFTLEdBQUc7SUFDckM7SUFDQWUsVUFBVUQsSUFBSWIsSUFBSTtJQUNsQixPQUFPYztBQUNYO0FBQ0F6QixtQkFBbUIsR0FBR0UsYUFDdEIsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvYnVpbGQvc3JjL3VyaS1wYXJzZXIuanM/MmFjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qXG4gKiBDb3B5cmlnaHQgMjAyMCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51cmlUb1N0cmluZyA9IGV4cG9ydHMuc3BsaXRIb3N0UG9ydCA9IGV4cG9ydHMucGFyc2VVcmkgPSB2b2lkIDA7XG4vKlxuICogVGhlIGdyb3VwcyBjb3JyZXNwb25kIHRvIFVSSSBwYXJ0cyBhcyBmb2xsb3dzOlxuICogMS4gc2NoZW1lXG4gKiAyLiBhdXRob3JpdHlcbiAqIDMuIHBhdGhcbiAqL1xuY29uc3QgVVJJX1JFR0VYID0gL14oPzooW0EtWmEtejAtOSsuLV0rKTopPyg/OlxcL1xcLyhbXi9dKilcXC8pPyguKykkLztcbmZ1bmN0aW9uIHBhcnNlVXJpKHVyaVN0cmluZykge1xuICAgIGNvbnN0IHBhcnNlZFVyaSA9IFVSSV9SRUdFWC5leGVjKHVyaVN0cmluZyk7XG4gICAgaWYgKHBhcnNlZFVyaSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2NoZW1lOiBwYXJzZWRVcmlbMV0sXG4gICAgICAgIGF1dGhvcml0eTogcGFyc2VkVXJpWzJdLFxuICAgICAgICBwYXRoOiBwYXJzZWRVcmlbM10sXG4gICAgfTtcbn1cbmV4cG9ydHMucGFyc2VVcmkgPSBwYXJzZVVyaTtcbmNvbnN0IE5VTUJFUl9SRUdFWCA9IC9eXFxkKyQvO1xuZnVuY3Rpb24gc3BsaXRIb3N0UG9ydChwYXRoKSB7XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnWycpKSB7XG4gICAgICAgIGNvbnN0IGhvc3RFbmQgPSBwYXRoLmluZGV4T2YoJ10nKTtcbiAgICAgICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBob3N0ID0gcGF0aC5zdWJzdHJpbmcoMSwgaG9zdEVuZCk7XG4gICAgICAgIC8qIE9ubHkgYW4gSVB2NiBhZGRyZXNzIHNob3VsZCBiZSBpbiBicmFja2V0ZWQgbm90YXRpb24sIGFuZCBhbiBJUHY2XG4gICAgICAgICAqIGFkZHJlc3Mgc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIGNvbG9uICovXG4gICAgICAgIGlmIChob3N0LmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IGhvc3RFbmQgKyAxKSB7XG4gICAgICAgICAgICBpZiAocGF0aFtob3N0RW5kICsgMV0gPT09ICc6Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcnRTdHJpbmcgPSBwYXRoLnN1YnN0cmluZyhob3N0RW5kICsgMik7XG4gICAgICAgICAgICAgICAgaWYgKE5VTUJFUl9SRUdFWC50ZXN0KHBvcnRTdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogK3BvcnRTdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaG9zdCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHNwbGl0UGF0aCA9IHBhdGguc3BsaXQoJzonKTtcbiAgICAgICAgLyogRXhhY3RseSBvbmUgY29sb24gbWVhbnMgdGhhdCB0aGlzIGlzIGhvc3Q6cG9ydC4gWmVybyBjb2xvbnMgbWVhbnMgdGhhdFxuICAgICAgICAgKiB0aGVyZSBpcyBubyBwb3J0LiBBbmQgbXVsdGlwbGUgY29sb25zIG1lYW5zIHRoYXQgdGhpcyBpcyBhIGJhcmUgSVB2NlxuICAgICAgICAgKiBhZGRyZXNzIHdpdGggbm8gcG9ydCAqL1xuICAgICAgICBpZiAoc3BsaXRQYXRoLmxlbmd0aCA9PT0gMikge1xuICAgICAgICAgICAgaWYgKE5VTUJFUl9SRUdFWC50ZXN0KHNwbGl0UGF0aFsxXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBob3N0OiBzcGxpdFBhdGhbMF0sXG4gICAgICAgICAgICAgICAgICAgIHBvcnQ6ICtzcGxpdFBhdGhbMV0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBob3N0OiBwYXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuc3BsaXRIb3N0UG9ydCA9IHNwbGl0SG9zdFBvcnQ7XG5mdW5jdGlvbiB1cmlUb1N0cmluZyh1cmkpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgaWYgKHVyaS5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgKz0gdXJpLnNjaGVtZSArICc6JztcbiAgICB9XG4gICAgaWYgKHVyaS5hdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgKz0gJy8vJyArIHVyaS5hdXRob3JpdHkgKyAnLyc7XG4gICAgfVxuICAgIHJlc3VsdCArPSB1cmkucGF0aDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy51cmlUb1N0cmluZyA9IHVyaVRvU3RyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJpLXBhcnNlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1cmlUb1N0cmluZyIsInNwbGl0SG9zdFBvcnQiLCJwYXJzZVVyaSIsIlVSSV9SRUdFWCIsInVyaVN0cmluZyIsInBhcnNlZFVyaSIsImV4ZWMiLCJzY2hlbWUiLCJhdXRob3JpdHkiLCJwYXRoIiwiTlVNQkVSX1JFR0VYIiwic3RhcnRzV2l0aCIsImhvc3RFbmQiLCJpbmRleE9mIiwiaG9zdCIsInN1YnN0cmluZyIsImxlbmd0aCIsInBvcnRTdHJpbmciLCJ0ZXN0IiwicG9ydCIsInNwbGl0UGF0aCIsInNwbGl0IiwidXJpIiwicmVzdWx0IiwidW5kZWZpbmVkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/build/src/uri-parser.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.loadFileDescriptorSetFromObject = exports.loadFileDescriptorSetFromBuffer = exports.fromJSON = exports.loadSync = exports.load = exports.IdempotencyLevel = exports.isAnyExtension = exports.Long = void 0;\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(ssr)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/long/umd/index.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return \"@type\" in obj && typeof obj[\"@type\"] === \"string\";\n}\nexports.isAnyExtension = isAnyExtension;\nvar IdempotencyLevel;\n(function(IdempotencyLevel) {\n    IdempotencyLevel[\"IDEMPOTENCY_UNKNOWN\"] = \"IDEMPOTENCY_UNKNOWN\";\n    IdempotencyLevel[\"NO_SIDE_EFFECTS\"] = \"NO_SIDE_EFFECTS\";\n    IdempotencyLevel[\"IDEMPOTENT\"] = \"IDEMPOTENT\";\n})(IdempotencyLevel = exports.IdempotencyLevel || (exports.IdempotencyLevel = {}));\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true\n};\nfunction joinName(baseName, name) {\n    if (baseName === \"\") {\n        return name;\n    } else {\n        return baseName + \".\" + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [\n            [\n                objName,\n                obj\n            ]\n        ];\n    } else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== \"undefined\") {\n            return Object.keys(obj.nested).map((name)=>{\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            }).reduce((accumulator, currentValue)=>accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction mapMethodOptions(options) {\n    return (options || []).reduce((obj, item)=>{\n        for (const [key, value] of Object.entries(item)){\n            switch(key){\n                case \"uninterpreted_option\":\n                    obj.uninterpreted_option.push(item.uninterpreted_option);\n                    break;\n                default:\n                    obj[key] = value;\n            }\n        }\n        return obj;\n    }, {\n        deprecated: false,\n        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,\n        uninterpreted_option: []\n    });\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */ const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: \"/\" + serviceName + \"/\" + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors),\n        options: mapMethodOptions(method.parsedOptions)\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray){\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 DescriptorProto\",\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 EnumDescriptorProto\",\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */ function createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    } else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    } else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    } else {\n        throw new Error(\"Type mismatch in reflection object handling\");\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor(\"proto3\").file;\n    const bufferList = descriptorList.map((value)=>Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, \"\")){\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */ function load(filename, options) {\n    return (0, util_1.loadProtosWithOptions)(filename, options).then((loadedRoot)=>{\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n(0, util_1.addCommonProtos)(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCx1Q0FBdUMsR0FBR0EsdUNBQXVDLEdBQUdBLGdCQUFnQixHQUFHQSxnQkFBZ0IsR0FBR0EsWUFBWSxHQUFHQSx3QkFBd0IsR0FBR0Esc0JBQXNCLEdBQUdBLFlBQVksR0FBRyxLQUFLO0FBQ2pOLE1BQU1VLFlBQVlDLG1CQUFPQSxDQUFDLHdFQUFrQjtBQUM1QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyx1RkFBWTtBQUNyQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQyxxSEFBMkI7QUFDdEQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMsb0dBQVE7QUFDL0IsTUFBTUYsT0FBT0UsbUJBQU9BLENBQUMsK0VBQU07QUFDM0JYLFlBQVksR0FBR1M7QUFDZixTQUFTRCxlQUFlTyxHQUFHO0lBQ3ZCLE9BQU8sV0FBWUEsT0FBUyxPQUFPQSxHQUFHLENBQUMsUUFBUSxLQUFLO0FBQ3hEO0FBQ0FmLHNCQUFzQixHQUFHUTtBQUN6QixJQUFJRDtBQUNILFVBQVVBLGdCQUFnQjtJQUN2QkEsZ0JBQWdCLENBQUMsc0JBQXNCLEdBQUc7SUFDMUNBLGdCQUFnQixDQUFDLGtCQUFrQixHQUFHO0lBQ3RDQSxnQkFBZ0IsQ0FBQyxhQUFhLEdBQUc7QUFDckMsR0FBR0EsbUJBQW1CUCxRQUFRTyxnQkFBZ0IsSUFBS1AsQ0FBQUEsd0JBQXdCLEdBQUcsQ0FBQztBQUMvRSxNQUFNZ0Isb0JBQW9CO0lBQ3RCQyxPQUFPQztJQUNQQyxPQUFPRDtJQUNQRSxPQUFPRjtJQUNQRyxVQUFVO0lBQ1ZDLFFBQVE7SUFDUkMsTUFBTTtBQUNWO0FBQ0EsU0FBU0MsU0FBU0MsUUFBUSxFQUFF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SjtBQUNBOUMsWUFBWSxHQUFHTTtBQUNmLFNBQVNELFNBQVM2RyxRQUFRLEVBQUVwRSxPQUFPO0lBQy9CLE1BQU11RSxhQUFhLENBQUMsR0FBR3ZHLE9BQU93Ryx5QkFBeUIsRUFBRUosVUFBVXBFO0lBQ25FLE9BQU93RCx3QkFBd0JlLFlBQVl2RTtBQUMvQztBQUNBOUMsZ0JBQWdCLEdBQUdLO0FBQ25CLFNBQVNELFNBQVNtQixJQUFJLEVBQUV1QixPQUFPO0lBQzNCQSxVQUFVQSxXQUFXLENBQUM7SUFDdEIsTUFBTXVFLGFBQWF6RyxTQUFTcUIsSUFBSSxDQUFDN0IsUUFBUSxDQUFDbUI7SUFDMUM4RixXQUFXYixVQUFVO0lBQ3JCLE9BQU9GLHdCQUF3QmUsWUFBWXZFO0FBQy9DO0FBQ0E5QyxnQkFBZ0IsR0FBR0k7QUFDbkIsU0FBU0QsZ0NBQWdDb0gsYUFBYSxFQUFFekUsT0FBTztJQUMzRCxNQUFNa0UsdUJBQXVCbkcsV0FBVzJHLGlCQUFpQixDQUFDdEUsTUFBTSxDQUFDcUU7SUFDakUsT0FBT1IseUNBQXlDQyxzQkFBc0JsRTtBQUMxRTtBQUNBOUMsdUNBQXVDLEdBQUdHO0FBQzFDLFNBQVNELGdDQUFnQ3FILGFBQWEsRUFBRXpFLE9BQU87SUFDM0QsTUFBTWtFLHVCQUF1Qm5HLFdBQVcyRyxpQkFBaUIsQ0FBQzlELFVBQVUsQ0FBQzZEO0lBQ3JFLE9BQU9SLHlDQUF5Q0Msc0JBQXNCbEU7QUFDMUU7QUFDQTlDLHVDQUF1QyxHQUFHRTtBQUN6QyxJQUFHWSxPQUFPMkcsZUFBZSxLQUMxQixpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcz9hNTY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciA9IGV4cG9ydHMuZnJvbUpTT04gPSBleHBvcnRzLmxvYWRTeW5jID0gZXhwb3J0cy5sb2FkID0gZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsID0gZXhwb3J0cy5pc0FueUV4dGVuc2lvbiA9IGV4cG9ydHMuTG9uZyA9IHZvaWQgMDtcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoXCJsb2Rhc2guY2FtZWxjYXNlXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmNvbnN0IGRlc2NyaXB0b3IgPSByZXF1aXJlKFwicHJvdG9idWZqcy9leHQvZGVzY3JpcHRvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBMb25nID0gcmVxdWlyZShcImxvbmdcIik7XG5leHBvcnRzLkxvbmcgPSBMb25nO1xuZnVuY3Rpb24gaXNBbnlFeHRlbnNpb24ob2JqKSB7XG4gICAgcmV0dXJuICgnQHR5cGUnIGluIG9iaikgJiYgKHR5cGVvZiBvYmpbJ0B0eXBlJ10gPT09ICdzdHJpbmcnKTtcbn1cbmV4cG9ydHMuaXNBbnlFeHRlbnNpb24gPSBpc0FueUV4dGVuc2lvbjtcbnZhciBJZGVtcG90ZW5jeUxldmVsO1xuKGZ1bmN0aW9uIChJZGVtcG90ZW5jeUxldmVsKSB7XG4gICAgSWRlbXBvdGVuY3lMZXZlbFtcIklERU1QT1RFTkNZX1VOS05PV05cIl0gPSBcIklERU1QT1RFTkNZX1VOS05PV05cIjtcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiTk9fU0lERV9FRkZFQ1RTXCJdID0gXCJOT19TSURFX0VGRkVDVFNcIjtcbiAgICBJZGVtcG90ZW5jeUxldmVsW1wiSURFTVBPVEVOVFwiXSA9IFwiSURFTVBPVEVOVFwiO1xufSkoSWRlbXBvdGVuY3lMZXZlbCA9IGV4cG9ydHMuSWRlbXBvdGVuY3lMZXZlbCB8fCAoZXhwb3J0cy5JZGVtcG90ZW5jeUxldmVsID0ge30pKTtcbmNvbnN0IGRlc2NyaXB0b3JPcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgIG9uZW9mczogdHJ1ZSxcbiAgICBqc29uOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGpvaW5OYW1lKGJhc2VOYW1lLCBuYW1lKSB7XG4gICAgaWYgKGJhc2VOYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBiYXNlTmFtZSArICcuJyArIG5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZXNwYWNlQmFzZShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuTmFtZXNwYWNlIHx8IG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlJvb3Q7XG59XG5mdW5jdGlvbiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMob2JqLCBwYXJlbnROYW1lKSB7XG4gICAgY29uc3Qgb2JqTmFtZSA9IGpvaW5OYW1lKHBhcmVudE5hbWUsIG9iai5uYW1lKTtcbiAgICBpZiAoaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBbW29iak5hbWUsIG9ial1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlQmFzZShvYmopICYmIHR5cGVvZiBvYmoubmVzdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iai5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iai5uZXN0ZWRbbmFtZV0sIG9iak5hbWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvci5jb25jYXQoY3VycmVudFZhbHVlKSwgW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2VyaWFsaXplcihjbHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVzZXJpYWxpemUoYXJnQnVmKSB7XG4gICAgICAgIHJldHVybiBjbHMudG9PYmplY3QoY2xzLmRlY29kZShhcmdCdWYpLCBvcHRpb25zKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihjbHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VyaWFsaXplKGFyZykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXJpYWxpemUgbWVzc2FnZTogZXhwZWN0ZWQgb2JqZWN0IHdpdGggJHtjbHMubmFtZX0gc3RydWN0dXJlLCBnb3QgYXJyYXkgaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjbHMuZnJvbU9iamVjdChhcmcpO1xuICAgICAgICByZXR1cm4gY2xzLmVuY29kZShtZXNzYWdlKS5maW5pc2goKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFwTWV0aG9kT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zIHx8IFtdKS5yZWR1Y2UoKG9iaiwgaXRlbSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhpdGVtKSkge1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd1bmludGVycHJldGVkX29wdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIG9iai51bmludGVycHJldGVkX29wdGlvbi5wdXNoKGl0ZW0udW5pbnRlcnByZXRlZF9vcHRpb24pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge1xuICAgICAgICBkZXByZWNhdGVkOiBmYWxzZSxcbiAgICAgICAgaWRlbXBvdGVuY3lfbGV2ZWw6IElkZW1wb3RlbmN5TGV2ZWwuSURFTVBPVEVOQ1lfVU5LTk9XTixcbiAgICAgICAgdW5pbnRlcnByZXRlZF9vcHRpb246IFtdLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIHNlcnZpY2VOYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICAvKiBUaGlzIGlzIG9ubHkgZXZlciBjYWxsZWQgYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgcm9vdC5yZXNvbHZlQWxsKCksIHNvIHdlXG4gICAgICogY2FuIGFzc3VtZSB0aGF0IHRoZSByZXNvbHZlZCByZXF1ZXN0IGFuZCByZXNwb25zZSB0eXBlcyBhcmUgbm9uLW51bGwgKi9cbiAgICBjb25zdCByZXF1ZXN0VHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlO1xuICAgIGNvbnN0IHJlc3BvbnNlVHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiAnLycgKyBzZXJ2aWNlTmFtZSArICcvJyArIG1ldGhvZC5uYW1lLFxuICAgICAgICByZXF1ZXN0U3RyZWFtOiAhIW1ldGhvZC5yZXF1ZXN0U3RyZWFtLFxuICAgICAgICByZXNwb25zZVN0cmVhbTogISFtZXRob2QucmVzcG9uc2VTdHJlYW0sXG4gICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVxdWVzdFR5cGUpLFxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXF1ZXN0VHlwZSwgb3B0aW9ucyksXG4gICAgICAgIHJlc3BvbnNlU2VyaWFsaXplOiBjcmVhdGVTZXJpYWxpemVyKHJlc3BvbnNlVHlwZSksXG4gICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXNwb25zZVR5cGUsIG9wdGlvbnMpLFxuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzXG4gICAgICAgIG9yaWdpbmFsTmFtZTogY2FtZWxDYXNlKG1ldGhvZC5uYW1lKSxcbiAgICAgICAgcmVxdWVzdFR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlcXVlc3RUeXBlLCBmaWxlRGVzY3JpcHRvcnMpLFxuICAgICAgICByZXNwb25zZVR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlc3BvbnNlVHlwZSwgZmlsZURlc2NyaXB0b3JzKSxcbiAgICAgICAgb3B0aW9uczogbWFwTWV0aG9kT3B0aW9ucyhtZXRob2QucGFyc2VkT3B0aW9ucyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uKHNlcnZpY2UsIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IGRlZiA9IHt9O1xuICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIHNlcnZpY2UubWV0aG9kc0FycmF5KSB7XG4gICAgICAgIGRlZlttZXRob2QubmFtZV0gPSBjcmVhdGVNZXRob2REZWZpbml0aW9uKG1ldGhvZCwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKG1lc3NhZ2UsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IG1lc3NhZ2VEZXNjcmlwdG9yID0gbWVzc2FnZS50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdDogJ1Byb3RvY29sIEJ1ZmZlciAzIERlc2NyaXB0b3JQcm90bycsXG4gICAgICAgIHR5cGU6IG1lc3NhZ2VEZXNjcmlwdG9yLiR0eXBlLnRvT2JqZWN0KG1lc3NhZ2VEZXNjcmlwdG9yLCBkZXNjcmlwdG9yT3B0aW9ucyksXG4gICAgICAgIGZpbGVEZXNjcmlwdG9yUHJvdG9zOiBmaWxlRGVzY3JpcHRvcnMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVudW1EZWZpbml0aW9uKGVudW1UeXBlLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICBjb25zdCBlbnVtRGVzY3JpcHRvciA9IGVudW1UeXBlLnRvRGVzY3JpcHRvcigncHJvdG8zJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0OiAnUHJvdG9jb2wgQnVmZmVyIDMgRW51bURlc2NyaXB0b3JQcm90bycsXG4gICAgICAgIHR5cGU6IGVudW1EZXNjcmlwdG9yLiR0eXBlLnRvT2JqZWN0KGVudW1EZXNjcmlwdG9yLCBkZXNjcmlwdG9yT3B0aW9ucyksXG4gICAgICAgIGZpbGVEZXNjcmlwdG9yUHJvdG9zOiBmaWxlRGVzY3JpcHRvcnMsXG4gICAgfTtcbn1cbi8qKlxuICogZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLlNlcnZpY2UsIG5hbWU6IHN0cmluZywgb3B0aW9uczpcbiAqIE9wdGlvbnMpOiBTZXJ2aWNlRGVmaW5pdGlvbjsgZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmo6IFByb3RvYnVmLlR5cGUsXG4gKiBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IE9wdGlvbnMpOiBNZXNzYWdlVHlwZURlZmluaXRpb247IGZ1bmN0aW9uXG4gKiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuRW51bSwgbmFtZTogc3RyaW5nLCBvcHRpb25zOiBPcHRpb25zKTpcbiAqIEVudW1UeXBlRGVmaW5pdGlvbjtcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5TZXJ2aWNlKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVTZXJ2aWNlRGVmaW5pdGlvbihvYmosIG5hbWUsIG9wdGlvbnMsIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKG9iaiwgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuRW51bSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRW51bURlZmluaXRpb24ob2JqLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUeXBlIG1pc21hdGNoIGluIHJlZmxlY3Rpb24gb2JqZWN0IGhhbmRsaW5nJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUGFja2FnZURlZmluaXRpb24ocm9vdCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlZiA9IHt9O1xuICAgIHJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIGNvbnN0IGRlc2NyaXB0b3JMaXN0ID0gcm9vdC50b0Rlc2NyaXB0b3IoJ3Byb3RvMycpLmZpbGU7XG4gICAgY29uc3QgYnVmZmVyTGlzdCA9IGRlc2NyaXB0b3JMaXN0Lm1hcCh2YWx1ZSA9PiBCdWZmZXIuZnJvbShkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yUHJvdG8uZW5jb2RlKHZhbHVlKS5maW5pc2goKSkpO1xuICAgIGZvciAoY29uc3QgW25hbWUsIG9ial0gb2YgZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKHJvb3QsICcnKSkge1xuICAgICAgICBkZWZbbmFtZV0gPSBjcmVhdGVEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgYnVmZmVyTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3Qgcm9vdCA9IFByb3RvYnVmLlJvb3QuZnJvbURlc2NyaXB0b3IoZGVjb2RlZERlc2NyaXB0b3JTZXQpO1xuICAgIHJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihyb290LCBvcHRpb25zKTtcbn1cbi8qKlxuICogTG9hZCBhIC5wcm90byBmaWxlIHdpdGggdGhlIHNwZWNpZmllZCBvcHRpb25zLlxuICogQHBhcmFtIGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlIHBhdGhzIHRvIGxvYWQuIENhbiBiZSBhbiBhYnNvbHV0ZSBwYXRoXG4gKiAgICAgb3IgcmVsYXRpdmUgdG8gYW4gaW5jbHVkZSBwYXRoLlxuICogQHBhcmFtIG9wdGlvbnMua2VlcENhc2UgUHJlc2VydmUgZmllbGQgbmFtZXMuIFRoZSBkZWZhdWx0IGlzIHRvIGNoYW5nZSB0aGVtXG4gKiAgICAgdG8gY2FtZWwgY2FzZS5cbiAqIEBwYXJhbSBvcHRpb25zLmxvbmdzIFRoZSB0eXBlIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmVwcmVzZW50IGBsb25nYCB2YWx1ZXMuXG4gKiAgICAgVmFsaWQgb3B0aW9ucyBhcmUgYE51bWJlcmAgYW5kIGBTdHJpbmdgLiBEZWZhdWx0cyB0byBhIGBMb25nYCBvYmplY3QgdHlwZVxuICogICAgIGZyb20gYSBsaWJyYXJ5LlxuICogQHBhcmFtIG9wdGlvbnMuZW51bXMgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGVudW1gIHZhbHVlcy5cbiAqICAgICBUaGUgb25seSB2YWxpZCBvcHRpb24gaXMgYFN0cmluZ2AuIERlZmF1bHRzIHRvIHRoZSBudW1lcmljIHZhbHVlLlxuICogQHBhcmFtIG9wdGlvbnMuYnl0ZXMgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGJ5dGVzYFxuICogICAgIHZhbHVlcy4gVmFsaWQgb3B0aW9ucyBhcmUgYEFycmF5YCBhbmQgYFN0cmluZ2AuIFRoZSBkZWZhdWx0IGlzIHRvIHVzZVxuICogICAgIGBCdWZmZXJgLlxuICogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdHMgU2V0IGRlZmF1bHQgdmFsdWVzIG9uIG91dHB1dCBvYmplY3RzLiBEZWZhdWx0cyB0b1xuICogICAgIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5hcnJheXMgU2V0IGVtcHR5IGFycmF5cyBmb3IgbWlzc2luZyBhcnJheSB2YWx1ZXMgZXZlbiBpZlxuICogICAgIGBkZWZhdWx0c2AgaXMgYGZhbHNlYC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLm9iamVjdHMgU2V0IGVtcHR5IG9iamVjdHMgZm9yIG1pc3Npbmcgb2JqZWN0IHZhbHVlcyBldmVuIGlmXG4gKiAgICAgYGRlZmF1bHRzYCBpcyBgZmFsc2VgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMub25lb2ZzIFNldCB2aXJ0dWFsIG9uZW9mIHByb3BlcnRpZXMgdG8gdGhlIHByZXNlbnQgZmllbGQnc1xuICogICAgIG5hbWVcbiAqIEBwYXJhbSBvcHRpb25zLmpzb24gUmVwcmVzZW50IEluZmluaXR5IGFuZCBOYU4gYXMgc3RyaW5ncyBpbiBmbG9hdCBmaWVsZHMsXG4gKiAgICAgYW5kIGF1dG9tYXRpY2FsbHkgZGVjb2RlIGdvb2dsZS5wcm90b2J1Zi5BbnkgdmFsdWVzLlxuICogQHBhcmFtIG9wdGlvbnMuaW5jbHVkZURpcnMgUGF0aHMgdG8gc2VhcmNoIGZvciBpbXBvcnRlZCBgLnByb3RvYCBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gbG9hZChmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIHJldHVybiAoMCwgdXRpbF8xLmxvYWRQcm90b3NXaXRoT3B0aW9ucykoZmlsZW5hbWUsIG9wdGlvbnMpLnRoZW4obG9hZGVkUm9vdCA9PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5mdW5jdGlvbiBsb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSAoMCwgdXRpbF8xLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMpKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb24obG9hZGVkUm9vdCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRTeW5jID0gbG9hZFN5bmM7XG5mdW5jdGlvbiBmcm9tSlNPTihqc29uLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgbG9hZGVkUm9vdCA9IFByb3RvYnVmLlJvb3QuZnJvbUpTT04oanNvbik7XG4gICAgbG9hZGVkUm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5mcm9tSlNPTiA9IGZyb21KU09OO1xuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlcihkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVjb2RlZERlc2NyaXB0b3JTZXQgPSBkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yU2V0LmRlY29kZShkZXNjcmlwdG9yU2V0KTtcbiAgICByZXR1cm4gY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldChkZWNvZGVkRGVzY3JpcHRvclNldCwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIgPSBsb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyO1xuZnVuY3Rpb24gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdChkZXNjcmlwdG9yU2V0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVjb2RlZERlc2NyaXB0b3JTZXQgPSBkZXNjcmlwdG9yLkZpbGVEZXNjcmlwdG9yU2V0LmZyb21PYmplY3QoZGVzY3JpcHRvclNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tT2JqZWN0ID0gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdDtcbigwLCB1dGlsXzEuYWRkQ29tbW9uUHJvdG9zKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCIsImxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIiLCJmcm9tSlNPTiIsImxvYWRTeW5jIiwibG9hZCIsIklkZW1wb3RlbmN5TGV2ZWwiLCJpc0FueUV4dGVuc2lvbiIsIkxvbmciLCJjYW1lbENhc2UiLCJyZXF1aXJlIiwiUHJvdG9idWYiLCJkZXNjcmlwdG9yIiwidXRpbF8xIiwib2JqIiwiZGVzY3JpcHRvck9wdGlvbnMiLCJsb25ncyIsIlN0cmluZyIsImVudW1zIiwiYnl0ZXMiLCJkZWZhdWx0cyIsIm9uZW9mcyIsImpzb24iLCJqb2luTmFtZSIsImJhc2VOYW1lIiwibmFtZSIsImlzSGFuZGxlZFJlZmxlY3Rpb25PYmplY3QiLCJTZXJ2aWNlIiwiVHlwZSIsIkVudW0iLCJpc05hbWVzcGFjZUJhc2UiLCJOYW1lc3BhY2UiLCJSb290IiwiZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzIiwicGFyZW50TmFtZSIsIm9iak5hbWUiLCJuZXN0ZWQiLCJrZXlzIiwibWFwIiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJjdXJyZW50VmFsdWUiLCJjb25jYXQiLCJjcmVhdGVEZXNlcmlhbGl6ZXIiLCJjbHMiLCJvcHRpb25zIiwiZGVzZXJpYWxpemUiLCJhcmdCdWYiLCJ0b09iamVjdCIsImRlY29kZSIsImNyZWF0ZVNlcmlhbGl6ZXIiLCJzZXJpYWxpemUiLCJhcmciLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsIm1lc3NhZ2UiLCJmcm9tT2JqZWN0IiwiZW5jb2RlIiwiZmluaXNoIiwibWFwTWV0aG9kT3B0aW9ucyIsIml0ZW0iLCJrZXkiLCJlbnRyaWVzIiwidW5pbnRlcnByZXRlZF9vcHRpb24iLCJwdXNoIiwiZGVwcmVjYXRlZCIsImlkZW1wb3RlbmN5X2xldmVsIiwiSURFTVBPVEVOQ1lfVU5LTk9XTiIsImNyZWF0ZU1ldGhvZERlZmluaXRpb24iLCJtZXRob2QiLCJzZXJ2aWNlTmFtZSIsImZpbGVEZXNjcmlwdG9ycyIsInJlcXVlc3RUeXBlIiwicmVzb2x2ZWRSZXF1ZXN0VHlwZSIsInJlc3BvbnNlVHlwZSIsInJlc29sdmVkUmVzcG9uc2VUeXBlIiwicGF0aCIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsInJlcXVlc3RTZXJpYWxpemUiLCJyZXF1ZXN0RGVzZXJpYWxpemUiLCJyZXNwb25zZVNlcmlhbGl6ZSIsInJlc3BvbnNlRGVzZXJpYWxpemUiLCJvcmlnaW5hbE5hbWUiLCJjcmVhdGVNZXNzYWdlRGVmaW5pdGlvbiIsInBhcnNlZE9wdGlvbnMiLCJjcmVhdGVTZXJ2aWNlRGVmaW5pdGlvbiIsInNlcnZpY2UiLCJkZWYiLCJtZXRob2RzQXJyYXkiLCJtZXNzYWdlRGVzY3JpcHRvciIsInRvRGVzY3JpcHRvciIsImZvcm1hdCIsInR5cGUiLCIkdHlwZSIsImZpbGVEZXNjcmlwdG9yUHJvdG9zIiwiY3JlYXRlRW51bURlZmluaXRpb24iLCJlbnVtVHlwZSIsImVudW1EZXNjcmlwdG9yIiwiY3JlYXRlRGVmaW5pdGlvbiIsImNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uIiwicm9vdCIsInJlc29sdmVBbGwiLCJkZXNjcmlwdG9yTGlzdCIsImZpbGUiLCJidWZmZXJMaXN0IiwiQnVmZmVyIiwiZnJvbSIsIkZpbGVEZXNjcmlwdG9yUHJvdG8iLCJjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0IiwiZGVjb2RlZERlc2NyaXB0b3JTZXQiLCJmcm9tRGVzY3JpcHRvciIsImZpbGVuYW1lIiwibG9hZFByb3Rvc1dpdGhPcHRpb25zIiwidGhlbiIsImxvYWRlZFJvb3QiLCJsb2FkUHJvdG9zV2l0aE9wdGlvbnNTeW5jIiwiZGVzY3JpcHRvclNldCIsIkZpbGVEZXNjcmlwdG9yU2V0IiwiYWRkQ29tbW9uUHJvdG9zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.addCommonProtos = exports.loadProtosWithOptionsSync = exports.loadProtosWithOptions = void 0;\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target)=>{\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths){\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            } catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error(\"The includeDirs option must be an array\"));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error(\"The includeDirs option must be an array\");\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */ function addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common(\"api\", apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"descriptor\", descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"source_context\", sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"type\", typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos; //# sourceMappingURL=util.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0RELHVCQUF1QixHQUFHQSxpQ0FBaUMsR0FBR0EsNkJBQTZCLEdBQUcsS0FBSztBQUNuRyxNQUFNSyxLQUFLQyxtQkFBT0EsQ0FBQyxjQUFJO0FBQ3ZCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDLGtCQUFNO0FBQzNCLE1BQU1FLFdBQVdGLG1CQUFPQSxDQUFDLHVGQUFZO0FBQ3JDLFNBQVNHLHVCQUF1QkMsSUFBSSxFQUFFQyxZQUFZO0lBQzlDLE1BQU1DLHNCQUFzQkYsS0FBS0csV0FBVztJQUM1Q0gsS0FBS0csV0FBVyxHQUFHLENBQUNDLFFBQVFDO1FBQ3hCLElBQUlSLEtBQUtTLFVBQVUsQ0FBQ0QsU0FBUztZQUN6QixPQUFPQTtRQUNYO1FBQ0EsS0FBSyxNQUFNRSxhQUFhTixhQUFjO1lBQ2xDLE1BQU1PLFdBQVdYLEtBQUtZLElBQUksQ0FBQ0YsV0FBV0Y7WUFDdEMsSUFBSTtnQkFDQVYsR0FBR2UsVUFBVSxDQUFDRixVQUFVYixHQUFHZ0IsU0FBUyxDQUFDQyxJQUFJO2dCQUN6QyxPQUFPSjtZQUNYLEVBQ0EsT0FBT0ssS0FBSztnQkFDUjtZQUNKO1FBQ0o7UUFDQUMsUUFBUUMsV0FBVyxDQUFDLENBQUMsRUFBRVYsT0FBTyx1Q0FBdUMsRUFBRUosYUFBYSxDQUFDO1FBQ3JGLE9BQU9DLG9CQUFvQkUsUUFBUUM7SUFDdkM7QUFDSjtBQUNBLGVBQWVYLHNCQUFzQnNCLFFBQVEsRUFBRUMsT0FBTztJQUNsRCxNQUFNakIsT0FBTyxJQUFJRixTQUFTb0IsSUFBSTtJQUM5QkQsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUksQ0FBQyxDQUFDQSxRQUFRRSxXQUFXLEVBQUU7UUFDdkIsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNKLFFBQVFFLFdBQVcsR0FBRztZQUNyQyxPQUFPRyxRQUFRQyxNQUFNLENBQUMsSUFBSUMsTUFBTTtRQUNwQztRQUNBekIsdUJBQXVCQyxNQUFNaUIsUUFBUUUsV0FBVztJQUNwRDtJQUNBLE1BQU1NLGFBQWEsTUFBTXpCLEtBQUswQixJQUFJLENBQUNWLFVBQVVDO0lBQzdDUSxXQUFXRSxVQUFVO0lBQ3JCLE9BQU9GO0FBQ1g7QUFDQW5DLDZCQUE2QixHQUFHSTtBQUNoQyxTQUFTRCwwQkFBMEJ1QixRQUFRLEVBQUVDLE9BQU87SUFDaEQsTUFBTWpCLE9BQU8sSUFBSUYsU0FBU29CLElBQUk7SUFDOUJELFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFJLENBQUMsQ0FBQ0EsUUFBUUUsV0FBVyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSixRQUFRRSxXQUFXLEdBQUc7WUFDckMsTUFBTSxJQUFJSyxNQUFNO1FBQ3BCO1FBQ0F6Qix1QkFBdUJDLE1BQU1pQixRQUFRRSxXQUFXO0lBQ3BEO0lBQ0EsTUFBTU0sYUFBYXpCLEtBQUs0QixRQUFRLENBQUNaLFVBQVVDO0lBQzNDUSxXQUFXRSxVQUFVO0lBQ3JCLE9BQU9GO0FBQ1g7QUFDQW5DLGlDQUFpQyxHQUFHRztBQUNwQzs7Q0FFQyxHQUNELFNBQVNEO0lBQ0wsNEVBQTRFO0lBQzVFLHFFQUFxRTtJQUNyRSxtRUFBbUU7SUFDbkUsTUFBTXFDLGdCQUFnQmpDLG1CQUFPQSxDQUFDO0lBQzlCLE1BQU1rQyx1QkFBdUJsQyxtQkFBT0EsQ0FBQztJQUNyQyxNQUFNbUMsMEJBQTBCbkMsbUJBQU9BLENBQUM7SUFDeEMsTUFBTW9DLGlCQUFpQnBDLG1CQUFPQSxDQUFDO0lBQy9CRSxTQUFTbUMsTUFBTSxDQUFDLE9BQU9KLGNBQWNLLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRCxNQUFNLENBQUNFLFFBQVEsQ0FBQ0YsTUFBTTtJQUN6RXBDLFNBQVNtQyxNQUFNLENBQUMsY0FBY0gscUJBQXFCSSxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07SUFDdkZwQyxTQUFTbUMsTUFBTSxDQUFDLGtCQUFrQkYsd0JBQXdCRyxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07SUFDOUZwQyxTQUFTbUMsTUFBTSxDQUFDLFFBQVFELGVBQWVFLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRCxNQUFNLENBQUNFLFFBQVEsQ0FBQ0YsTUFBTTtBQUMvRTtBQUNBNUMsdUJBQXVCLEdBQUdFLGlCQUMxQixnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzPzA4NjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBnUlBDIGF1dGhvcnMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBleHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMgPSBleHBvcnRzLmxvYWRQcm90b3NXaXRoT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmZ1bmN0aW9uIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgaW5jbHVkZVBhdGhzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxSZXNvbHZlUGF0aCA9IHJvb3QucmVzb2x2ZVBhdGg7XG4gICAgcm9vdC5yZXNvbHZlUGF0aCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgICAgICBpZiAocGF0aC5pc0Fic29sdXRlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rvcnkgb2YgaW5jbHVkZVBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIHRhcmdldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLmFjY2Vzc1N5bmMoZnVsbFBhdGgsIGZzLmNvbnN0YW50cy5SX09LKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgJHt0YXJnZXR9IG5vdCBmb3VuZCBpbiBhbnkgb2YgdGhlIGluY2x1ZGUgcGF0aHMgJHtpbmNsdWRlUGF0aHN9YCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlc29sdmVQYXRoKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgcm9vdCA9IG5ldyBQcm90b2J1Zi5Sb290KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCEhb3B0aW9ucy5pbmNsdWRlRGlycykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlRGlycykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRSb290ID0gYXdhaXQgcm9vdC5sb2FkKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zID0gbG9hZFByb3Rvc1dpdGhPcHRpb25zO1xuZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUHJvdG9idWYuUm9vdCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZURpcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgb3B0aW9ucy5pbmNsdWRlRGlycyk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSByb290LmxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyA9IGxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmM7XG4vKipcbiAqIExvYWQgR29vZ2xlJ3Mgd2VsbC1rbm93biBwcm90byBmaWxlcyB0aGF0IGFyZW4ndCBleHBvc2VkIGJ5IFByb3RvYnVmLmpzLlxuICovXG5mdW5jdGlvbiBhZGRDb21tb25Qcm90b3MoKSB7XG4gICAgLy8gUHJvdG9idWYuanMgZXhwb3NlczogYW55LCBkdXJhdGlvbiwgZW1wdHksIGZpZWxkX21hc2ssIHN0cnVjdCwgdGltZXN0YW1wLFxuICAgIC8vIGFuZCB3cmFwcGVycy4gY29tcGlsZXIvcGx1Z2luIGlzIGV4Y2x1ZGVkIGluIFByb3RvYnVmLmpzIGFuZCBoZXJlLlxuICAgIC8vIFVzaW5nIGNvbnN0YW50IHN0cmluZ3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0b29scyBsaWtlIFdlYnBhY2tcbiAgICBjb25zdCBhcGlEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvYXBpLmpzb24nKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IuanNvbicpO1xuICAgIGNvbnN0IHNvdXJjZUNvbnRleHREZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQuanNvbicpO1xuICAgIGNvbnN0IHR5cGVEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvdHlwZS5qc29uJyk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdhcGknLCBhcGlEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdkZXNjcmlwdG9yJywgZGVzY3JpcHRvckRlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3NvdXJjZV9jb250ZXh0Jywgc291cmNlQ29udGV4dERlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3R5cGUnLCB0eXBlRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xufVxuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBhZGRDb21tb25Qcm90b3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImFkZENvbW1vblByb3RvcyIsImxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmMiLCJsb2FkUHJvdG9zV2l0aE9wdGlvbnMiLCJmcyIsInJlcXVpcmUiLCJwYXRoIiwiUHJvdG9idWYiLCJhZGRJbmNsdWRlUGF0aFJlc29sdmVyIiwicm9vdCIsImluY2x1ZGVQYXRocyIsIm9yaWdpbmFsUmVzb2x2ZVBhdGgiLCJyZXNvbHZlUGF0aCIsIm9yaWdpbiIsInRhcmdldCIsImlzQWJzb2x1dGUiLCJkaXJlY3RvcnkiLCJmdWxsUGF0aCIsImpvaW4iLCJhY2Nlc3NTeW5jIiwiY29uc3RhbnRzIiwiUl9PSyIsImVyciIsInByb2Nlc3MiLCJlbWl0V2FybmluZyIsImZpbGVuYW1lIiwib3B0aW9ucyIsIlJvb3QiLCJpbmNsdWRlRGlycyIsIkFycmF5IiwiaXNBcnJheSIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsImxvYWRlZFJvb3QiLCJsb2FkIiwicmVzb2x2ZUFsbCIsImxvYWRTeW5jIiwiYXBpRGVzY3JpcHRvciIsImRlc2NyaXB0b3JEZXNjcmlwdG9yIiwic291cmNlQ29udGV4dERlc2NyaXB0b3IiLCJ0eXBlRGVzY3JpcHRvciIsImNvbW1vbiIsIm5lc3RlZCIsImdvb2dsZSIsInByb3RvYnVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/ext/descriptor/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/ext/descriptor/index.js ***!
  \************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nvar $protobuf = __webpack_require__(/*! ../.. */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js\");\nmodule.exports = exports = $protobuf.descriptor = $protobuf.Root.fromJSON(__webpack_require__(/*! ../../google/protobuf/descriptor.json */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/descriptor.json\")).lookup(\".google.protobuf\");\nvar Namespace = $protobuf.Namespace, Root = $protobuf.Root, Enum = $protobuf.Enum, Type = $protobuf.Type, Field = $protobuf.Field, MapField = $protobuf.MapField, OneOf = $protobuf.OneOf, Service = $protobuf.Service, Method = $protobuf.Method;\n// --- Root ---\n/**\n * Properties of a FileDescriptorSet message.\n * @interface IFileDescriptorSet\n * @property {IFileDescriptorProto[]} file Files\n */ /**\n * Properties of a FileDescriptorProto message.\n * @interface IFileDescriptorProto\n * @property {string} [name] File name\n * @property {string} [package] Package\n * @property {*} [dependency] Not supported\n * @property {*} [publicDependency] Not supported\n * @property {*} [weakDependency] Not supported\n * @property {IDescriptorProto[]} [messageType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IServiceDescriptorProto[]} [service] Nested services\n * @property {IFieldDescriptorProto[]} [extension] Nested extension fields\n * @property {IFileOptions} [options] Options\n * @property {*} [sourceCodeInfo] Not supported\n * @property {string} [syntax=\"proto2\"] Syntax\n * @property {IEdition} [edition] Edition\n */ /**\n * Values of the Edition enum.\n * @typedef IEdition\n * @type {number}\n * @property {number} EDITION_UNKNOWN=0\n * @property {number} EDITION_LEGACY=900\n * @property {number} EDITION_PROTO2=998\n * @property {number} EDITION_PROTO3=999\n * @property {number} EDITION_2023=1000\n * @property {number} EDITION_2024=1001\n * @property {number} EDITION_1_TEST_ONLY=1\n * @property {number} EDITION_2_TEST_ONLY=2\n * @property {number} EDITION_99997_TEST_ONLY=99997\n * @property {number} EDITION_99998_TEST_ONLY=99998\n * @property {number} EDITION_99998_TEST_ONLY=99999\n * @property {number} EDITION_MAX=2147483647\n */ /**\n * Properties of a FileOptions message.\n * @interface IFileOptions\n * @property {string} [javaPackage]\n * @property {string} [javaOuterClassname]\n * @property {boolean} [javaMultipleFiles]\n * @property {boolean} [javaGenerateEqualsAndHash]\n * @property {boolean} [javaStringCheckUtf8]\n * @property {IFileOptionsOptimizeMode} [optimizeFor=1]\n * @property {string} [goPackage]\n * @property {boolean} [ccGenericServices]\n * @property {boolean} [javaGenericServices]\n * @property {boolean} [pyGenericServices]\n * @property {boolean} [deprecated]\n * @property {boolean} [ccEnableArenas]\n * @property {string} [objcClassPrefix]\n * @property {string} [csharpNamespace]\n */ /**\n * Values of he FileOptions.OptimizeMode enum.\n * @typedef IFileOptionsOptimizeMode\n * @type {number}\n * @property {number} SPEED=1\n * @property {number} CODE_SIZE=2\n * @property {number} LITE_RUNTIME=3\n */ /**\n * Creates a root from a descriptor set.\n * @param {IFileDescriptorSet|Reader|Uint8Array} descriptor Descriptor\n * @returns {Root} Root instance\n */ Root.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.FileDescriptorSet.decode(descriptor);\n    var root = new Root();\n    if (descriptor.file) {\n        var fileDescriptor, filePackage;\n        for(var j = 0, i; j < descriptor.file.length; ++j){\n            filePackage = root;\n            if ((fileDescriptor = descriptor.file[j])[\"package\"] && fileDescriptor[\"package\"].length) filePackage = root.define(fileDescriptor[\"package\"]);\n            var edition = editionFromDescriptor(fileDescriptor);\n            if (fileDescriptor.name && fileDescriptor.name.length) root.files.push(filePackage.filename = fileDescriptor.name);\n            if (fileDescriptor.messageType) for(i = 0; i < fileDescriptor.messageType.length; ++i)filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], edition));\n            if (fileDescriptor.enumType) for(i = 0; i < fileDescriptor.enumType.length; ++i)filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i], edition));\n            if (fileDescriptor.extension) for(i = 0; i < fileDescriptor.extension.length; ++i)filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i], edition));\n            if (fileDescriptor.service) for(i = 0; i < fileDescriptor.service.length; ++i)filePackage.add(Service.fromDescriptor(fileDescriptor.service[i], edition));\n            var opts = fromDescriptorOptions(fileDescriptor.options, exports.FileOptions);\n            if (opts) {\n                var ks = Object.keys(opts);\n                for(i = 0; i < ks.length; ++i)filePackage.setOption(ks[i], opts[ks[i]]);\n            }\n        }\n    }\n    return root.resolveAll();\n};\n/**\n * Converts a root to a descriptor set.\n * @returns {Message<IFileDescriptorSet>} Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n */ Root.prototype.toDescriptor = function toDescriptor(edition) {\n    var set = exports.FileDescriptorSet.create();\n    Root_toDescriptorRecursive(this, set.file, edition);\n    return set;\n};\n// Traverses a namespace and assembles the descriptor set\nfunction Root_toDescriptorRecursive(ns, files, edition) {\n    // Create a new file\n    var file = exports.FileDescriptorProto.create({\n        name: ns.filename || (ns.fullName.substring(1).replace(/\\./g, \"_\") || \"root\") + \".proto\"\n    });\n    editionToDescriptor(edition, file);\n    if (!(ns instanceof Root)) file[\"package\"] = ns.fullName.substring(1);\n    // Add nested types\n    for(var i = 0, nested; i < ns.nestedArray.length; ++i)if ((nested = ns._nestedArray[i]) instanceof Type) file.messageType.push(nested.toDescriptor(edition));\n    else if (nested instanceof Enum) file.enumType.push(nested.toDescriptor());\n    else if (nested instanceof Field) file.extension.push(nested.toDescriptor(edition));\n    else if (nested instanceof Service) file.service.push(nested.toDescriptor());\n    else if (nested instanceof /* plain */ Namespace) Root_toDescriptorRecursive(nested, files, edition); // requires new file\n    // Keep package-level options\n    file.options = toDescriptorOptions(ns.options, exports.FileOptions);\n    // And keep the file only if there is at least one nested object\n    if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length) files.push(file);\n}\n// --- Type ---\n/**\n * Properties of a DescriptorProto message.\n * @interface IDescriptorProto\n * @property {string} [name] Message type name\n * @property {IFieldDescriptorProto[]} [field] Fields\n * @property {IFieldDescriptorProto[]} [extension] Extension fields\n * @property {IDescriptorProto[]} [nestedType] Nested message types\n * @property {IEnumDescriptorProto[]} [enumType] Nested enums\n * @property {IDescriptorProtoExtensionRange[]} [extensionRange] Extension ranges\n * @property {IOneofDescriptorProto[]} [oneofDecl] Oneofs\n * @property {IMessageOptions} [options] Not supported\n * @property {IDescriptorProtoReservedRange[]} [reservedRange] Reserved ranges\n * @property {string[]} [reservedName] Reserved names\n */ /**\n * Properties of a MessageOptions message.\n * @interface IMessageOptions\n * @property {boolean} [mapEntry=false] Whether this message is a map entry\n */ /**\n * Properties of an ExtensionRange message.\n * @interface IDescriptorProtoExtensionRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */ /**\n * Properties of a ReservedRange message.\n * @interface IDescriptorProtoReservedRange\n * @property {number} [start] Start field id\n * @property {number} [end] End field id\n */ var unnamedMessageIndex = 0;\n/**\n * Creates a type from a descriptor.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @param {IDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n * @param {boolean} [nested=false] Whether or not this is a nested object\n * @returns {Type} Type instance\n */ Type.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n    // Create the message type\n    var type = new Type(descriptor.name.length ? descriptor.name : \"Type\" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports.MessageOptions)), i;\n    if (!nested) type._edition = edition;\n    /* Oneofs */ if (descriptor.oneofDecl) for(i = 0; i < descriptor.oneofDecl.length; ++i)type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));\n    /* Fields */ if (descriptor.field) for(i = 0; i < descriptor.field.length; ++i){\n        var field = Field.fromDescriptor(descriptor.field[i], edition, true);\n        type.add(field);\n        if (descriptor.field[i].hasOwnProperty(\"oneofIndex\")) type.oneofsArray[descriptor.field[i].oneofIndex].add(field);\n    }\n    /* Extension fields */ if (descriptor.extension) for(i = 0; i < descriptor.extension.length; ++i)type.add(Field.fromDescriptor(descriptor.extension[i], edition, true));\n    /* Nested types */ if (descriptor.nestedType) for(i = 0; i < descriptor.nestedType.length; ++i){\n        type.add(Type.fromDescriptor(descriptor.nestedType[i], edition, true));\n        if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry) type.setOption(\"map_entry\", true);\n    }\n    /* Nested enums */ if (descriptor.enumType) for(i = 0; i < descriptor.enumType.length; ++i)type.add(Enum.fromDescriptor(descriptor.enumType[i], edition, true));\n    /* Extension ranges */ if (descriptor.extensionRange && descriptor.extensionRange.length) {\n        type.extensions = [];\n        for(i = 0; i < descriptor.extensionRange.length; ++i)type.extensions.push([\n            descriptor.extensionRange[i].start,\n            descriptor.extensionRange[i].end\n        ]);\n    }\n    /* Reserved... */ if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {\n        type.reserved = [];\n        /* Ranges */ if (descriptor.reservedRange) for(i = 0; i < descriptor.reservedRange.length; ++i)type.reserved.push([\n            descriptor.reservedRange[i].start,\n            descriptor.reservedRange[i].end\n        ]);\n        /* Names */ if (descriptor.reservedName) for(i = 0; i < descriptor.reservedName.length; ++i)type.reserved.push(descriptor.reservedName[i]);\n    }\n    return type;\n};\n/**\n * Converts a type to a descriptor.\n * @returns {Message<IDescriptorProto>} Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n */ Type.prototype.toDescriptor = function toDescriptor(edition) {\n    var descriptor = exports.DescriptorProto.create({\n        name: this.name\n    }), i;\n    /* Fields */ for(i = 0; i < this.fieldsArray.length; ++i){\n        var fieldDescriptor;\n        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(edition));\n        if (this._fieldsArray[i] instanceof MapField) {\n            var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType, false), valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType, false), valueTypeName = valueType === /* type */ 11 || valueType === /* enum */ 14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : undefined;\n            descriptor.nestedType.push(exports.DescriptorProto.create({\n                name: fieldDescriptor.typeName,\n                field: [\n                    exports.FieldDescriptorProto.create({\n                        name: \"key\",\n                        number: 1,\n                        label: 1,\n                        type: keyType\n                    }),\n                    exports.FieldDescriptorProto.create({\n                        name: \"value\",\n                        number: 2,\n                        label: 1,\n                        type: valueType,\n                        typeName: valueTypeName\n                    })\n                ],\n                options: exports.MessageOptions.create({\n                    mapEntry: true\n                })\n            }));\n        }\n    }\n    /* Oneofs */ for(i = 0; i < this.oneofsArray.length; ++i)descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());\n    /* Nested... */ for(i = 0; i < this.nestedArray.length; ++i){\n        /* Extension fields */ if (this._nestedArray[i] instanceof Field) descriptor.field.push(this._nestedArray[i].toDescriptor(edition));\n        else if (this._nestedArray[i] instanceof Type) descriptor.nestedType.push(this._nestedArray[i].toDescriptor(edition));\n        else if (this._nestedArray[i] instanceof Enum) descriptor.enumType.push(this._nestedArray[i].toDescriptor());\n    // plain nested namespaces become packages instead in Root#toDescriptor\n    }\n    /* Extension ranges */ if (this.extensions) for(i = 0; i < this.extensions.length; ++i)descriptor.extensionRange.push(exports.DescriptorProto.ExtensionRange.create({\n        start: this.extensions[i][0],\n        end: this.extensions[i][1]\n    }));\n    /* Reserved... */ if (this.reserved) for(i = 0; i < this.reserved.length; ++i)/* Names */ if (typeof this.reserved[i] === \"string\") descriptor.reservedName.push(this.reserved[i]);\n    else descriptor.reservedRange.push(exports.DescriptorProto.ReservedRange.create({\n        start: this.reserved[i][0],\n        end: this.reserved[i][1]\n    }));\n    descriptor.options = toDescriptorOptions(this.options, exports.MessageOptions);\n    return descriptor;\n};\n// --- Field ---\n/**\n * Properties of a FieldDescriptorProto message.\n * @interface IFieldDescriptorProto\n * @property {string} [name] Field name\n * @property {number} [number] Field id\n * @property {IFieldDescriptorProtoLabel} [label] Field rule\n * @property {IFieldDescriptorProtoType} [type] Field basic type\n * @property {string} [typeName] Field type name\n * @property {string} [extendee] Extended type name\n * @property {string} [defaultValue] Literal default value\n * @property {number} [oneofIndex] Oneof index if part of a oneof\n * @property {*} [jsonName] Not supported\n * @property {IFieldOptions} [options] Field options\n */ /**\n * Values of the FieldDescriptorProto.Label enum.\n * @typedef IFieldDescriptorProtoLabel\n * @type {number}\n * @property {number} LABEL_OPTIONAL=1\n * @property {number} LABEL_REQUIRED=2\n * @property {number} LABEL_REPEATED=3\n */ /**\n * Values of the FieldDescriptorProto.Type enum.\n * @typedef IFieldDescriptorProtoType\n * @type {number}\n * @property {number} TYPE_DOUBLE=1\n * @property {number} TYPE_FLOAT=2\n * @property {number} TYPE_INT64=3\n * @property {number} TYPE_UINT64=4\n * @property {number} TYPE_INT32=5\n * @property {number} TYPE_FIXED64=6\n * @property {number} TYPE_FIXED32=7\n * @property {number} TYPE_BOOL=8\n * @property {number} TYPE_STRING=9\n * @property {number} TYPE_GROUP=10\n * @property {number} TYPE_MESSAGE=11\n * @property {number} TYPE_BYTES=12\n * @property {number} TYPE_UINT32=13\n * @property {number} TYPE_ENUM=14\n * @property {number} TYPE_SFIXED32=15\n * @property {number} TYPE_SFIXED64=16\n * @property {number} TYPE_SINT32=17\n * @property {number} TYPE_SINT64=18\n */ /**\n * Properties of a FieldOptions message.\n * @interface IFieldOptions\n * @property {boolean} [packed] Whether packed or not (defaults to `false` for proto2 and `true` for proto3)\n * @property {IFieldOptionsJSType} [jstype] JavaScript value type (not used by protobuf.js)\n */ /**\n * Values of the FieldOptions.JSType enum.\n * @typedef IFieldOptionsJSType\n * @type {number}\n * @property {number} JS_NORMAL=0\n * @property {number} JS_STRING=1\n * @property {number} JS_NUMBER=2\n */ // copied here from parse.js\nvar numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;\n/**\n * Creates a field from a descriptor.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @param {IFieldDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n * @param {boolean} [nested=false] Whether or not this is a top-level object\n * @returns {Field} Field instance\n */ Field.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.DescriptorProto.decode(descriptor);\n    if (typeof descriptor.number !== \"number\") throw Error(\"missing field id\");\n    // Rewire field type\n    var fieldType;\n    if (descriptor.typeName && descriptor.typeName.length) fieldType = descriptor.typeName;\n    else fieldType = fromDescriptorType(descriptor.type);\n    // Rewire field rule\n    var fieldRule;\n    switch(descriptor.label){\n        // 0 is reserved for errors\n        case 1:\n            fieldRule = undefined;\n            break;\n        case 2:\n            fieldRule = \"required\";\n            break;\n        case 3:\n            fieldRule = \"repeated\";\n            break;\n        default:\n            throw Error(\"illegal label: \" + descriptor.label);\n    }\n    var extendee = descriptor.extendee;\n    if (descriptor.extendee !== undefined) {\n        extendee = extendee.length ? extendee : undefined;\n    }\n    var field = new Field(descriptor.name.length ? descriptor.name : \"field\" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);\n    if (!nested) field._edition = edition;\n    field.options = fromDescriptorOptions(descriptor.options, exports.FieldOptions);\n    if (descriptor.proto3_optional) field.options.proto3_optional = true;\n    if (descriptor.defaultValue && descriptor.defaultValue.length) {\n        var defaultValue = descriptor.defaultValue;\n        switch(defaultValue){\n            case \"true\":\n            case \"TRUE\":\n                defaultValue = true;\n                break;\n            case \"false\":\n            case \"FALSE\":\n                defaultValue = false;\n                break;\n            default:\n                var match = numberRe.exec(defaultValue);\n                if (match) defaultValue = parseInt(defaultValue); // eslint-disable-line radix\n                break;\n        }\n        field.setOption(\"default\", defaultValue);\n    }\n    if (packableDescriptorType(descriptor.type)) {\n        if (edition === \"proto3\") {\n            if (descriptor.options && !descriptor.options.packed) field.setOption(\"packed\", false);\n        } else if ((!edition || edition === \"proto2\") && descriptor.options && descriptor.options.packed) field.setOption(\"packed\", true);\n    }\n    return field;\n};\n/**\n * Converts a field to a descriptor.\n * @returns {Message<IFieldDescriptorProto>} Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n */ Field.prototype.toDescriptor = function toDescriptor(edition) {\n    var descriptor = exports.FieldDescriptorProto.create({\n        name: this.name,\n        number: this.id\n    });\n    if (this.map) {\n        descriptor.type = 11; // message\n        descriptor.typeName = $protobuf.util.ucFirst(this.name); // fieldName -> FieldNameEntry (built in Type#toDescriptor)\n        descriptor.label = 3; // repeated\n    } else {\n        // Rewire field type\n        switch(descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType, this.delimited)){\n            case 10:\n            case 11:\n            case 14:\n                descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;\n                break;\n        }\n        // Rewire field rule\n        if (this.rule === \"repeated\") {\n            descriptor.label = 3;\n        } else if (this.required && edition === \"proto2\") {\n            descriptor.label = 2;\n        } else {\n            descriptor.label = 1;\n        }\n    }\n    // Handle extension field\n    descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;\n    // Handle part of oneof\n    if (this.partOf) {\n        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0) throw Error(\"missing oneof\");\n    }\n    if (this.options) {\n        descriptor.options = toDescriptorOptions(this.options, exports.FieldOptions);\n        if (this.options[\"default\"] != null) descriptor.defaultValue = String(this.options[\"default\"]);\n        if (this.options.proto3_optional) descriptor.proto3_optional = true;\n    }\n    if (edition === \"proto3\") {\n        if (!this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = false;\n    } else if ((!edition || edition === \"proto2\") && this.packed) (descriptor.options || (descriptor.options = exports.FieldOptions.create())).packed = true;\n    return descriptor;\n};\n// --- Enum ---\n/**\n * Properties of an EnumDescriptorProto message.\n * @interface IEnumDescriptorProto\n * @property {string} [name] Enum name\n * @property {IEnumValueDescriptorProto[]} [value] Enum values\n * @property {IEnumOptions} [options] Enum options\n */ /**\n * Properties of an EnumValueDescriptorProto message.\n * @interface IEnumValueDescriptorProto\n * @property {string} [name] Name\n * @property {number} [number] Value\n * @property {*} [options] Not supported\n */ /**\n * Properties of an EnumOptions message.\n * @interface IEnumOptions\n * @property {boolean} [allowAlias] Whether aliases are allowed\n * @property {boolean} [deprecated]\n */ var unnamedEnumIndex = 0;\n/**\n * Creates an enum from a descriptor.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @param {IEnumDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n * @param {boolean} [nested=false] Whether or not this is a top-level object\n * @returns {Enum} Enum instance\n */ Enum.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.EnumDescriptorProto.decode(descriptor);\n    // Construct values object\n    var values = {};\n    if (descriptor.value) for(var i = 0; i < descriptor.value.length; ++i){\n        var name = descriptor.value[i].name, value = descriptor.value[i].number || 0;\n        values[name && name.length ? name : \"NAME\" + value] = value;\n    }\n    var enm = new Enum(descriptor.name && descriptor.name.length ? descriptor.name : \"Enum\" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports.EnumOptions));\n    if (!nested) enm._edition = edition;\n    return enm;\n};\n/**\n * Converts an enum to a descriptor.\n * @returns {Message<IEnumDescriptorProto>} Descriptor\n */ Enum.prototype.toDescriptor = function toDescriptor() {\n    // Values\n    var values = [];\n    for(var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)values.push(exports.EnumValueDescriptorProto.create({\n        name: ks[i],\n        number: this.values[ks[i]]\n    }));\n    return exports.EnumDescriptorProto.create({\n        name: this.name,\n        value: values,\n        options: toDescriptorOptions(this.options, exports.EnumOptions)\n    });\n};\n// --- OneOf ---\n/**\n * Properties of a OneofDescriptorProto message.\n * @interface IOneofDescriptorProto\n * @property {string} [name] Oneof name\n * @property {*} [options] Not supported\n */ var unnamedOneofIndex = 0;\n/**\n * Creates a oneof from a descriptor.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @param {IOneofDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {OneOf} OneOf instance\n */ OneOf.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.OneofDescriptorProto.decode(descriptor);\n    return new OneOf(// unnamedOneOfIndex is global, not per type, because we have no ref to a type here\n    descriptor.name && descriptor.name.length ? descriptor.name : \"oneof\" + unnamedOneofIndex++);\n};\n/**\n * Converts a oneof to a descriptor.\n * @returns {Message<IOneofDescriptorProto>} Descriptor\n */ OneOf.prototype.toDescriptor = function toDescriptor() {\n    return exports.OneofDescriptorProto.create({\n        name: this.name\n    });\n};\n// --- Service ---\n/**\n * Properties of a ServiceDescriptorProto message.\n * @interface IServiceDescriptorProto\n * @property {string} [name] Service name\n * @property {IMethodDescriptorProto[]} [method] Methods\n * @property {IServiceOptions} [options] Options\n */ /**\n * Properties of a ServiceOptions message.\n * @interface IServiceOptions\n * @property {boolean} [deprecated]\n */ var unnamedServiceIndex = 0;\n/**\n * Creates a service from a descriptor.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @param {IServiceDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @param {string} [edition=\"proto2\"] The syntax or edition to use\n * @param {boolean} [nested=false] Whether or not this is a top-level object\n * @returns {Service} Service instance\n */ Service.fromDescriptor = function fromDescriptor(descriptor, edition, nested) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.ServiceDescriptorProto.decode(descriptor);\n    var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : \"Service\" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports.ServiceOptions));\n    if (!nested) service._edition = edition;\n    if (descriptor.method) for(var i = 0; i < descriptor.method.length; ++i)service.add(Method.fromDescriptor(descriptor.method[i]));\n    return service;\n};\n/**\n * Converts a service to a descriptor.\n * @returns {Message<IServiceDescriptorProto>} Descriptor\n */ Service.prototype.toDescriptor = function toDescriptor() {\n    // Methods\n    var methods = [];\n    for(var i = 0; i < this.methodsArray.length; ++i)methods.push(this._methodsArray[i].toDescriptor());\n    return exports.ServiceDescriptorProto.create({\n        name: this.name,\n        method: methods,\n        options: toDescriptorOptions(this.options, exports.ServiceOptions)\n    });\n};\n// --- Method ---\n/**\n * Properties of a MethodDescriptorProto message.\n * @interface IMethodDescriptorProto\n * @property {string} [name] Method name\n * @property {string} [inputType] Request type name\n * @property {string} [outputType] Response type name\n * @property {IMethodOptions} [options] Not supported\n * @property {boolean} [clientStreaming=false] Whether requests are streamed\n * @property {boolean} [serverStreaming=false] Whether responses are streamed\n */ /**\n * Properties of a MethodOptions message.\n *\n * Warning: this is not safe to use with editions protos, since it discards relevant file context.\n *\n * @interface IMethodOptions\n * @property {boolean} [deprecated]\n */ var unnamedMethodIndex = 0;\n/**\n * Creates a method from a descriptor.\n * @param {IMethodDescriptorProto|Reader|Uint8Array} descriptor Descriptor\n * @returns {Method} Reflected method instance\n */ Method.fromDescriptor = function fromDescriptor(descriptor) {\n    // Decode the descriptor message if specified as a buffer:\n    if (typeof descriptor.length === \"number\") descriptor = exports.MethodDescriptorProto.decode(descriptor);\n    return new Method(// unnamedMethodIndex is global, not per service, because we have no ref to a service here\n    descriptor.name && descriptor.name.length ? descriptor.name : \"Method\" + unnamedMethodIndex++, \"rpc\", descriptor.inputType, descriptor.outputType, Boolean(descriptor.clientStreaming), Boolean(descriptor.serverStreaming), fromDescriptorOptions(descriptor.options, exports.MethodOptions));\n};\n/**\n * Converts a method to a descriptor.\n * @returns {Message<IMethodDescriptorProto>} Descriptor\n */ Method.prototype.toDescriptor = function toDescriptor() {\n    return exports.MethodDescriptorProto.create({\n        name: this.name,\n        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,\n        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,\n        clientStreaming: this.requestStream,\n        serverStreaming: this.responseStream,\n        options: toDescriptorOptions(this.options, exports.MethodOptions)\n    });\n};\n// --- utility ---\n// Converts a descriptor type to a protobuf.js basic type\nfunction fromDescriptorType(type) {\n    switch(type){\n        // 0 is reserved for errors\n        case 1:\n            return \"double\";\n        case 2:\n            return \"float\";\n        case 3:\n            return \"int64\";\n        case 4:\n            return \"uint64\";\n        case 5:\n            return \"int32\";\n        case 6:\n            return \"fixed64\";\n        case 7:\n            return \"fixed32\";\n        case 8:\n            return \"bool\";\n        case 9:\n            return \"string\";\n        case 12:\n            return \"bytes\";\n        case 13:\n            return \"uint32\";\n        case 15:\n            return \"sfixed32\";\n        case 16:\n            return \"sfixed64\";\n        case 17:\n            return \"sint32\";\n        case 18:\n            return \"sint64\";\n    }\n    throw Error(\"illegal type: \" + type);\n}\n// Tests if a descriptor type is packable\nfunction packableDescriptorType(type) {\n    switch(type){\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 13:\n        case 14:\n        case 15:\n        case 16:\n        case 17:\n        case 18:\n            return true;\n    }\n    return false;\n}\n// Converts a protobuf.js basic type to a descriptor type\nfunction toDescriptorType(type, resolvedType, delimited) {\n    switch(type){\n        // 0 is reserved for errors\n        case \"double\":\n            return 1;\n        case \"float\":\n            return 2;\n        case \"int64\":\n            return 3;\n        case \"uint64\":\n            return 4;\n        case \"int32\":\n            return 5;\n        case \"fixed64\":\n            return 6;\n        case \"fixed32\":\n            return 7;\n        case \"bool\":\n            return 8;\n        case \"string\":\n            return 9;\n        case \"bytes\":\n            return 12;\n        case \"uint32\":\n            return 13;\n        case \"sfixed32\":\n            return 15;\n        case \"sfixed64\":\n            return 16;\n        case \"sint32\":\n            return 17;\n        case \"sint64\":\n            return 18;\n    }\n    if (resolvedType instanceof Enum) return 14;\n    if (resolvedType instanceof Type) return delimited ? 10 : 11;\n    throw Error(\"illegal type: \" + type);\n}\nfunction fromDescriptorOptionsRecursive(obj, type) {\n    var val = {};\n    for(var i = 0, field, key; i < type.fieldsArray.length; ++i){\n        if ((key = (field = type._fieldsArray[i]).name) === \"uninterpretedOption\") continue;\n        if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;\n        var newKey = underScore(key);\n        if (field.resolvedType instanceof Type) {\n            val[newKey] = fromDescriptorOptionsRecursive(obj[key], field.resolvedType);\n        } else if (field.resolvedType instanceof Enum) {\n            val[newKey] = field.resolvedType.valuesById[obj[key]];\n        } else {\n            val[newKey] = obj[key];\n        }\n    }\n    return val;\n}\n// Converts descriptor options to an options object\nfunction fromDescriptorOptions(options, type) {\n    if (!options) return undefined;\n    return fromDescriptorOptionsRecursive(type.toObject(options), type);\n}\nfunction toDescriptorOptionsRecursive(obj, type) {\n    var val = {};\n    var keys = Object.keys(obj);\n    for(var i = 0; i < keys.length; ++i){\n        var key = keys[i];\n        var newKey = $protobuf.util.camelCase(key);\n        if (!Object.prototype.hasOwnProperty.call(type.fields, newKey)) continue;\n        var field = type.fields[newKey];\n        if (field.resolvedType instanceof Type) {\n            val[newKey] = toDescriptorOptionsRecursive(obj[key], field.resolvedType);\n        } else {\n            val[newKey] = obj[key];\n        }\n        if (field.repeated && !Array.isArray(val[newKey])) {\n            val[newKey] = [\n                val[newKey]\n            ];\n        }\n    }\n    return val;\n}\n// Converts an options object to descriptor options\nfunction toDescriptorOptions(options, type) {\n    if (!options) return undefined;\n    return type.fromObject(toDescriptorOptionsRecursive(options, type));\n}\n// Calculates the shortest relative path from `from` to `to`.\nfunction shortname(from, to) {\n    var fromPath = from.fullName.split(\".\"), toPath = to.fullName.split(\".\"), i = 0, j = 0, k = toPath.length - 1;\n    if (!(from instanceof Root) && to instanceof Namespace) while(i < fromPath.length && j < k && fromPath[i] === toPath[j]){\n        var other = to.lookup(fromPath[i++], true);\n        if (other !== null && other !== to) break;\n        ++j;\n    }\n    else for(; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j);\n    return toPath.slice(j).join(\".\");\n}\n// copied here from cli/targets/proto.js\nfunction underScore(str) {\n    return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) {\n        return \"_\" + $1.toLowerCase();\n    });\n}\nfunction editionFromDescriptor(fileDescriptor) {\n    if (fileDescriptor.syntax === \"editions\") {\n        switch(fileDescriptor.edition){\n            case exports.Edition.EDITION_2023:\n                return \"2023\";\n            default:\n                throw new Error(\"Unsupported edition \" + fileDescriptor.edition);\n        }\n    }\n    if (fileDescriptor.syntax === \"proto3\") {\n        return \"proto3\";\n    }\n    return \"proto2\";\n}\nfunction editionToDescriptor(edition, fileDescriptor) {\n    if (!edition) return;\n    if (edition === \"proto2\" || edition === \"proto3\") {\n        fileDescriptor.syntax = edition;\n    } else {\n        fileDescriptor.syntax = \"editions\";\n        switch(edition){\n            case \"2023\":\n                fileDescriptor.edition = exports.Edition.EDITION_2023;\n                break;\n            default:\n                throw new Error(\"Unsupported edition \" + edition);\n        }\n    }\n} // --- exports ---\n /**\n * Reflected file descriptor set.\n * @name FileDescriptorSet\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected file descriptor proto.\n * @name FileDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected descriptor proto.\n * @name DescriptorProto\n * @type {Type}\n * @property {Type} ExtensionRange\n * @property {Type} ReservedRange\n * @const\n * @tstype $protobuf.Type & {\n *     ExtensionRange: $protobuf.Type,\n *     ReservedRange: $protobuf.Type\n * }\n */  /**\n * Reflected field descriptor proto.\n * @name FieldDescriptorProto\n * @type {Type}\n * @property {Enum} Label\n * @property {Enum} Type\n * @const\n * @tstype $protobuf.Type & {\n *     Label: $protobuf.Enum,\n *     Type: $protobuf.Enum\n * }\n */  /**\n * Reflected oneof descriptor proto.\n * @name OneofDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum descriptor proto.\n * @name EnumDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected service descriptor proto.\n * @name ServiceDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum value descriptor proto.\n * @name EnumValueDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected method descriptor proto.\n * @name MethodDescriptorProto\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected file options.\n * @name FileOptions\n * @type {Type}\n * @property {Enum} OptimizeMode\n * @const\n * @tstype $protobuf.Type & {\n *     OptimizeMode: $protobuf.Enum\n * }\n */  /**\n * Reflected message options.\n * @name MessageOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected field options.\n * @name FieldOptions\n * @type {Type}\n * @property {Enum} CType\n * @property {Enum} JSType\n * @const\n * @tstype $protobuf.Type & {\n *     CType: $protobuf.Enum,\n *     JSType: $protobuf.Enum\n * }\n */  /**\n * Reflected oneof options.\n * @name OneofOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum options.\n * @name EnumOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected enum value options.\n * @name EnumValueOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected service options.\n * @name ServiceOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected method options.\n * @name MethodOptions\n * @type {Type}\n * @const\n * @tstype $protobuf.Type\n */  /**\n * Reflected uninterpretet option.\n * @name UninterpretedOption\n * @type {Type}\n * @property {Type} NamePart\n * @const\n * @tstype $protobuf.Type & {\n *     NamePart: $protobuf.Type\n * }\n */  /**\n * Reflected source code info.\n * @name SourceCodeInfo\n * @type {Type}\n * @property {Type} Location\n * @const\n * @tstype $protobuf.Type & {\n *     Location: $protobuf.Type\n * }\n */  /**\n * Reflected generated code info.\n * @name GeneratedCodeInfo\n * @type {Type}\n * @property {Type} Annotation\n * @const\n * @tstype $protobuf.Type & {\n *     Annotation: $protobuf.Type\n * }\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9leHQvZGVzY3JpcHRvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVlDLG1CQUFPQSxDQUFDLGtGQUFPO0FBQy9CQyxPQUFPQyxPQUFPLEdBQUdBLFVBQVVILFVBQVVJLFVBQVUsR0FBR0osVUFBVUssSUFBSSxDQUFDQyxRQUFRLENBQUNMLG1CQUFPQSxDQUFDLHlJQUF1QyxHQUFHTSxNQUFNLENBQUM7QUFFbkksSUFBSUMsWUFBWVIsVUFBVVEsU0FBUyxFQUMvQkgsT0FBWUwsVUFBVUssSUFBSSxFQUMxQkksT0FBWVQsVUFBVVMsSUFBSSxFQUMxQkMsT0FBWVYsVUFBVVUsSUFBSSxFQUMxQkMsUUFBWVgsVUFBVVcsS0FBSyxFQUMzQkMsV0FBWVosVUFBVVksUUFBUSxFQUM5QkMsUUFBWWIsVUFBVWEsS0FBSyxFQUMzQkMsVUFBWWQsVUFBVWMsT0FBTyxFQUM3QkMsU0FBWWYsVUFBVWUsTUFBTTtBQUVoQyxlQUFlO0FBRWY7Ozs7Q0FJQyxHQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FFRDs7Ozs7OztDQU9DLEdBRUQ7Ozs7Q0FJQyxHQUNEVixLQUFLVyxjQUFjLEdBQUcsU0FBU0EsZUFBZVosVUFBVTtJQUVwRCwwREFBMEQ7SUFDMUQsSUFBSSxPQUFPQSxXQUFXYSxNQUFNLEtBQUssVUFDN0JiLGFBQWFELFFBQVFlLGlCQUFpQixDQUFDQyxNQUFNLENBQUNmO0lBRWxELElBQUlnQixPQUFPLElBQUlmO0lBRWYsSUFBSUQsV0FBV2lCLElBQUksRUFBRTtRQUNqQixJQUFJQyxnQkFDQUM7UUFDSixJQUFLLElBQUlDLElBQUksR0FBR0MsR0FBR0QsSUFBSXBCLFdBQVdpQixJQUFJLENBQUNKLE1BQU0sRUFBRSxFQUFFTyxFQUFHO1lB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O0NBTUMsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7Ozs7Ozs7Q0FXQyxJQUVEOzs7Ozs7Ozs7OztDQVdDLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7Ozs7OztDQVNDLElBRUQ7Ozs7OztDQU1DLElBRUQ7Ozs7Ozs7Ozs7O0NBV0MsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7O0NBTUMsSUFFRDs7Ozs7Ozs7O0NBU0MsSUFFRDs7Ozs7Ozs7O0NBU0MsSUFFRDs7Ozs7Ozs7O0NBU0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9leHQvZGVzY3JpcHRvci9pbmRleC5qcz82NWNjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyICRwcm90b2J1ZiA9IHJlcXVpcmUoXCIuLi8uLlwiKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9ICRwcm90b2J1Zi5kZXNjcmlwdG9yID0gJHByb3RvYnVmLlJvb3QuZnJvbUpTT04ocmVxdWlyZShcIi4uLy4uL2dvb2dsZS9wcm90b2J1Zi9kZXNjcmlwdG9yLmpzb25cIikpLmxvb2t1cChcIi5nb29nbGUucHJvdG9idWZcIik7XG5cbnZhciBOYW1lc3BhY2UgPSAkcHJvdG9idWYuTmFtZXNwYWNlLFxuICAgIFJvb3QgICAgICA9ICRwcm90b2J1Zi5Sb290LFxuICAgIEVudW0gICAgICA9ICRwcm90b2J1Zi5FbnVtLFxuICAgIFR5cGUgICAgICA9ICRwcm90b2J1Zi5UeXBlLFxuICAgIEZpZWxkICAgICA9ICRwcm90b2J1Zi5GaWVsZCxcbiAgICBNYXBGaWVsZCAgPSAkcHJvdG9idWYuTWFwRmllbGQsXG4gICAgT25lT2YgICAgID0gJHByb3RvYnVmLk9uZU9mLFxuICAgIFNlcnZpY2UgICA9ICRwcm90b2J1Zi5TZXJ2aWNlLFxuICAgIE1ldGhvZCAgICA9ICRwcm90b2J1Zi5NZXRob2Q7XG5cbi8vIC0tLSBSb290IC0tLVxuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBGaWxlRGVzY3JpcHRvclNldCBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRmlsZURlc2NyaXB0b3JTZXRcbiAqIEBwcm9wZXJ0eSB7SUZpbGVEZXNjcmlwdG9yUHJvdG9bXX0gZmlsZSBGaWxlc1xuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIEZpbGVEZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSUZpbGVEZXNjcmlwdG9yUHJvdG9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gRmlsZSBuYW1lXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BhY2thZ2VdIFBhY2thZ2VcbiAqIEBwcm9wZXJ0eSB7Kn0gW2RlcGVuZGVuY3ldIE5vdCBzdXBwb3J0ZWRcbiAqIEBwcm9wZXJ0eSB7Kn0gW3B1YmxpY0RlcGVuZGVuY3ldIE5vdCBzdXBwb3J0ZWRcbiAqIEBwcm9wZXJ0eSB7Kn0gW3dlYWtEZXBlbmRlbmN5XSBOb3Qgc3VwcG9ydGVkXG4gKiBAcHJvcGVydHkge0lEZXNjcmlwdG9yUHJvdG9bXX0gW21lc3NhZ2VUeXBlXSBOZXN0ZWQgbWVzc2FnZSB0eXBlc1xuICogQHByb3BlcnR5IHtJRW51bURlc2NyaXB0b3JQcm90b1tdfSBbZW51bVR5cGVdIE5lc3RlZCBlbnVtc1xuICogQHByb3BlcnR5IHtJU2VydmljZURlc2NyaXB0b3JQcm90b1tdfSBbc2VydmljZV0gTmVzdGVkIHNlcnZpY2VzXG4gKiBAcHJvcGVydHkge0lGaWVsZERlc2NyaXB0b3JQcm90b1tdfSBbZXh0ZW5zaW9uXSBOZXN0ZWQgZXh0ZW5zaW9uIGZpZWxkc1xuICogQHByb3BlcnR5IHtJRmlsZU9wdGlvbnN9IFtvcHRpb25zXSBPcHRpb25zXG4gKiBAcHJvcGVydHkgeyp9IFtzb3VyY2VDb2RlSW5mb10gTm90IHN1cHBvcnRlZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzeW50YXg9XCJwcm90bzJcIl0gU3ludGF4XG4gKiBAcHJvcGVydHkge0lFZGl0aW9ufSBbZWRpdGlvbl0gRWRpdGlvblxuICovXG5cbi8qKlxuICogVmFsdWVzIG9mIHRoZSBFZGl0aW9uIGVudW0uXG4gKiBAdHlwZWRlZiBJRWRpdGlvblxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFRElUSU9OX1VOS05PV049MFxuICogQHByb3BlcnR5IHtudW1iZXJ9IEVESVRJT05fTEVHQUNZPTkwMFxuICogQHByb3BlcnR5IHtudW1iZXJ9IEVESVRJT05fUFJPVE8yPTk5OFxuICogQHByb3BlcnR5IHtudW1iZXJ9IEVESVRJT05fUFJPVE8zPTk5OVxuICogQHByb3BlcnR5IHtudW1iZXJ9IEVESVRJT05fMjAyMz0xMDAwXG4gKiBAcHJvcGVydHkge251bWJlcn0gRURJVElPTl8yMDI0PTEwMDFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFRElUSU9OXzFfVEVTVF9PTkxZPTFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFRElUSU9OXzJfVEVTVF9PTkxZPTJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFRElUSU9OXzk5OTk3X1RFU1RfT05MWT05OTk5N1xuICogQHByb3BlcnR5IHtudW1iZXJ9IEVESVRJT05fOTk5OThfVEVTVF9PTkxZPTk5OTk4XG4gKiBAcHJvcGVydHkge251bWJlcn0gRURJVElPTl85OTk5OF9URVNUX09OTFk9OTk5OTlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBFRElUSU9OX01BWD0yMTQ3NDgzNjQ3XG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgRmlsZU9wdGlvbnMgbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSUZpbGVPcHRpb25zXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2phdmFQYWNrYWdlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtqYXZhT3V0ZXJDbGFzc25hbWVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqYXZhTXVsdGlwbGVGaWxlc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2phdmFHZW5lcmF0ZUVxdWFsc0FuZEhhc2hdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqYXZhU3RyaW5nQ2hlY2tVdGY4XVxuICogQHByb3BlcnR5IHtJRmlsZU9wdGlvbnNPcHRpbWl6ZU1vZGV9IFtvcHRpbWl6ZUZvcj0xXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtnb1BhY2thZ2VdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjY0dlbmVyaWNTZXJ2aWNlc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2phdmFHZW5lcmljU2VydmljZXNdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtweUdlbmVyaWNTZXJ2aWNlc11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlcHJlY2F0ZWRdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjY0VuYWJsZUFyZW5hc11cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbb2JqY0NsYXNzUHJlZml4XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjc2hhcnBOYW1lc3BhY2VdXG4gKi9cblxuLyoqXG4gKiBWYWx1ZXMgb2YgaGUgRmlsZU9wdGlvbnMuT3B0aW1pemVNb2RlIGVudW0uXG4gKiBAdHlwZWRlZiBJRmlsZU9wdGlvbnNPcHRpbWl6ZU1vZGVcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAcHJvcGVydHkge251bWJlcn0gU1BFRUQ9MVxuICogQHByb3BlcnR5IHtudW1iZXJ9IENPREVfU0laRT0yXG4gKiBAcHJvcGVydHkge251bWJlcn0gTElURV9SVU5USU1FPTNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSByb290IGZyb20gYSBkZXNjcmlwdG9yIHNldC5cbiAqIEBwYXJhbSB7SUZpbGVEZXNjcmlwdG9yU2V0fFJlYWRlcnxVaW50OEFycmF5fSBkZXNjcmlwdG9yIERlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtSb290fSBSb290IGluc3RhbmNlXG4gKi9cblJvb3QuZnJvbURlc2NyaXB0b3IgPSBmdW5jdGlvbiBmcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yKSB7XG5cbiAgICAvLyBEZWNvZGUgdGhlIGRlc2NyaXB0b3IgbWVzc2FnZSBpZiBzcGVjaWZpZWQgYXMgYSBidWZmZXI6XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuRmlsZURlc2NyaXB0b3JTZXQuZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgdmFyIHJvb3QgPSBuZXcgUm9vdCgpO1xuXG4gICAgaWYgKGRlc2NyaXB0b3IuZmlsZSkge1xuICAgICAgICB2YXIgZmlsZURlc2NyaXB0b3IsXG4gICAgICAgICAgICBmaWxlUGFja2FnZTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGk7IGogPCBkZXNjcmlwdG9yLmZpbGUubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIGZpbGVQYWNrYWdlID0gcm9vdDtcbiAgICAgICAgICAgIGlmICgoZmlsZURlc2NyaXB0b3IgPSBkZXNjcmlwdG9yLmZpbGVbal0pW1wicGFja2FnZVwiXSAmJiBmaWxlRGVzY3JpcHRvcltcInBhY2thZ2VcIl0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZpbGVQYWNrYWdlID0gcm9vdC5kZWZpbmUoZmlsZURlc2NyaXB0b3JbXCJwYWNrYWdlXCJdKTtcbiAgICAgICAgICAgIHZhciBlZGl0aW9uID0gZWRpdGlvbkZyb21EZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIGlmIChmaWxlRGVzY3JpcHRvci5uYW1lICYmIGZpbGVEZXNjcmlwdG9yLm5hbWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJvb3QuZmlsZXMucHVzaChmaWxlUGFja2FnZS5maWxlbmFtZSA9IGZpbGVEZXNjcmlwdG9yLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpbGVEZXNjcmlwdG9yLm1lc3NhZ2VUeXBlKVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlRGVzY3JpcHRvci5tZXNzYWdlVHlwZS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgZmlsZVBhY2thZ2UuYWRkKFR5cGUuZnJvbURlc2NyaXB0b3IoZmlsZURlc2NyaXB0b3IubWVzc2FnZVR5cGVbaV0sIGVkaXRpb24pKTtcbiAgICAgICAgICAgIGlmIChmaWxlRGVzY3JpcHRvci5lbnVtVHlwZSlcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmlsZURlc2NyaXB0b3IuZW51bVR5cGUubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYWNrYWdlLmFkZChFbnVtLmZyb21EZXNjcmlwdG9yKGZpbGVEZXNjcmlwdG9yLmVudW1UeXBlW2ldLCBlZGl0aW9uKSk7XG4gICAgICAgICAgICBpZiAoZmlsZURlc2NyaXB0b3IuZXh0ZW5zaW9uKVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlRGVzY3JpcHRvci5leHRlbnNpb24ubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgIGZpbGVQYWNrYWdlLmFkZChGaWVsZC5mcm9tRGVzY3JpcHRvcihmaWxlRGVzY3JpcHRvci5leHRlbnNpb25baV0sIGVkaXRpb24pKTtcbiAgICAgICAgICAgIGlmIChmaWxlRGVzY3JpcHRvci5zZXJ2aWNlKVxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaWxlRGVzY3JpcHRvci5zZXJ2aWNlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGFja2FnZS5hZGQoU2VydmljZS5mcm9tRGVzY3JpcHRvcihmaWxlRGVzY3JpcHRvci5zZXJ2aWNlW2ldLCBlZGl0aW9uKSk7XG4gICAgICAgICAgICB2YXIgb3B0cyA9IGZyb21EZXNjcmlwdG9yT3B0aW9ucyhmaWxlRGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLkZpbGVPcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtzID0gT2JqZWN0LmtleXMob3B0cyk7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGtzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgICAgICBmaWxlUGFja2FnZS5zZXRPcHRpb24oa3NbaV0sIG9wdHNba3NbaV1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByb290LnJlc29sdmVBbGwoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSByb290IHRvIGEgZGVzY3JpcHRvciBzZXQuXG4gKiBAcmV0dXJucyB7TWVzc2FnZTxJRmlsZURlc2NyaXB0b3JTZXQ+fSBEZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VkaXRpb249XCJwcm90bzJcIl0gVGhlIHN5bnRheCBvciBlZGl0aW9uIHRvIHVzZVxuICovXG5Sb290LnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3IoZWRpdGlvbikge1xuICAgIHZhciBzZXQgPSBleHBvcnRzLkZpbGVEZXNjcmlwdG9yU2V0LmNyZWF0ZSgpO1xuICAgIFJvb3RfdG9EZXNjcmlwdG9yUmVjdXJzaXZlKHRoaXMsIHNldC5maWxlLCBlZGl0aW9uKTtcbiAgICByZXR1cm4gc2V0O1xufTtcblxuLy8gVHJhdmVyc2VzIGEgbmFtZXNwYWNlIGFuZCBhc3NlbWJsZXMgdGhlIGRlc2NyaXB0b3Igc2V0XG5mdW5jdGlvbiBSb290X3RvRGVzY3JpcHRvclJlY3Vyc2l2ZShucywgZmlsZXMsIGVkaXRpb24pIHtcblxuICAgIC8vIENyZWF0ZSBhIG5ldyBmaWxlXG4gICAgdmFyIGZpbGUgPSBleHBvcnRzLkZpbGVEZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHsgbmFtZTogbnMuZmlsZW5hbWUgfHwgKG5zLmZ1bGxOYW1lLnN1YnN0cmluZygxKS5yZXBsYWNlKC9cXC4vZywgXCJfXCIpIHx8IFwicm9vdFwiKSArIFwiLnByb3RvXCIgfSk7XG4gICAgZWRpdGlvblRvRGVzY3JpcHRvcihlZGl0aW9uLCBmaWxlKTtcbiAgICBpZiAoIShucyBpbnN0YW5jZW9mIFJvb3QpKVxuICAgICAgICBmaWxlW1wicGFja2FnZVwiXSA9IG5zLmZ1bGxOYW1lLnN1YnN0cmluZygxKTtcblxuICAgIC8vIEFkZCBuZXN0ZWQgdHlwZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbmVzdGVkOyBpIDwgbnMubmVzdGVkQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmICgobmVzdGVkID0gbnMuX25lc3RlZEFycmF5W2ldKSBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgICAgICBmaWxlLm1lc3NhZ2VUeXBlLnB1c2gobmVzdGVkLnRvRGVzY3JpcHRvcihlZGl0aW9uKSk7XG4gICAgICAgIGVsc2UgaWYgKG5lc3RlZCBpbnN0YW5jZW9mIEVudW0pXG4gICAgICAgICAgICBmaWxlLmVudW1UeXBlLnB1c2gobmVzdGVkLnRvRGVzY3JpcHRvcigpKTtcbiAgICAgICAgZWxzZSBpZiAobmVzdGVkIGluc3RhbmNlb2YgRmllbGQpXG4gICAgICAgICAgICBmaWxlLmV4dGVuc2lvbi5wdXNoKG5lc3RlZC50b0Rlc2NyaXB0b3IoZWRpdGlvbikpO1xuICAgICAgICBlbHNlIGlmIChuZXN0ZWQgaW5zdGFuY2VvZiBTZXJ2aWNlKVxuICAgICAgICAgICAgZmlsZS5zZXJ2aWNlLnB1c2gobmVzdGVkLnRvRGVzY3JpcHRvcigpKTtcbiAgICAgICAgZWxzZSBpZiAobmVzdGVkIGluc3RhbmNlb2YgLyogcGxhaW4gKi8gTmFtZXNwYWNlKVxuICAgICAgICAgICAgUm9vdF90b0Rlc2NyaXB0b3JSZWN1cnNpdmUobmVzdGVkLCBmaWxlcywgZWRpdGlvbik7IC8vIHJlcXVpcmVzIG5ldyBmaWxlXG5cbiAgICAvLyBLZWVwIHBhY2thZ2UtbGV2ZWwgb3B0aW9uc1xuICAgIGZpbGUub3B0aW9ucyA9IHRvRGVzY3JpcHRvck9wdGlvbnMobnMub3B0aW9ucywgZXhwb3J0cy5GaWxlT3B0aW9ucyk7XG5cbiAgICAvLyBBbmQga2VlcCB0aGUgZmlsZSBvbmx5IGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBuZXN0ZWQgb2JqZWN0XG4gICAgaWYgKGZpbGUubWVzc2FnZVR5cGUubGVuZ3RoICsgZmlsZS5lbnVtVHlwZS5sZW5ndGggKyBmaWxlLmV4dGVuc2lvbi5sZW5ndGggKyBmaWxlLnNlcnZpY2UubGVuZ3RoKVxuICAgICAgICBmaWxlcy5wdXNoKGZpbGUpO1xufVxuXG4vLyAtLS0gVHlwZSAtLS1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElEZXNjcmlwdG9yUHJvdG9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gTWVzc2FnZSB0eXBlIG5hbWVcbiAqIEBwcm9wZXJ0eSB7SUZpZWxkRGVzY3JpcHRvclByb3RvW119IFtmaWVsZF0gRmllbGRzXG4gKiBAcHJvcGVydHkge0lGaWVsZERlc2NyaXB0b3JQcm90b1tdfSBbZXh0ZW5zaW9uXSBFeHRlbnNpb24gZmllbGRzXG4gKiBAcHJvcGVydHkge0lEZXNjcmlwdG9yUHJvdG9bXX0gW25lc3RlZFR5cGVdIE5lc3RlZCBtZXNzYWdlIHR5cGVzXG4gKiBAcHJvcGVydHkge0lFbnVtRGVzY3JpcHRvclByb3RvW119IFtlbnVtVHlwZV0gTmVzdGVkIGVudW1zXG4gKiBAcHJvcGVydHkge0lEZXNjcmlwdG9yUHJvdG9FeHRlbnNpb25SYW5nZVtdfSBbZXh0ZW5zaW9uUmFuZ2VdIEV4dGVuc2lvbiByYW5nZXNcbiAqIEBwcm9wZXJ0eSB7SU9uZW9mRGVzY3JpcHRvclByb3RvW119IFtvbmVvZkRlY2xdIE9uZW9mc1xuICogQHByb3BlcnR5IHtJTWVzc2FnZU9wdGlvbnN9IFtvcHRpb25zXSBOb3Qgc3VwcG9ydGVkXG4gKiBAcHJvcGVydHkge0lEZXNjcmlwdG9yUHJvdG9SZXNlcnZlZFJhbmdlW119IFtyZXNlcnZlZFJhbmdlXSBSZXNlcnZlZCByYW5nZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nW119IFtyZXNlcnZlZE5hbWVdIFJlc2VydmVkIG5hbWVzXG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgTWVzc2FnZU9wdGlvbnMgbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSU1lc3NhZ2VPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFttYXBFbnRyeT1mYWxzZV0gV2hldGhlciB0aGlzIG1lc3NhZ2UgaXMgYSBtYXAgZW50cnlcbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYW4gRXh0ZW5zaW9uUmFuZ2UgbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSURlc2NyaXB0b3JQcm90b0V4dGVuc2lvblJhbmdlXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N0YXJ0XSBTdGFydCBmaWVsZCBpZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtlbmRdIEVuZCBmaWVsZCBpZFxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIFJlc2VydmVkUmFuZ2UgbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSURlc2NyaXB0b3JQcm90b1Jlc2VydmVkUmFuZ2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3RhcnRdIFN0YXJ0IGZpZWxkIGlkXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2VuZF0gRW5kIGZpZWxkIGlkXG4gKi9cblxudmFyIHVubmFtZWRNZXNzYWdlSW5kZXggPSAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0eXBlIGZyb20gYSBkZXNjcmlwdG9yLlxuICpcbiAqIFdhcm5pbmc6IHRoaXMgaXMgbm90IHNhZmUgdG8gdXNlIHdpdGggZWRpdGlvbnMgcHJvdG9zLCBzaW5jZSBpdCBkaXNjYXJkcyByZWxldmFudCBmaWxlIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtJRGVzY3JpcHRvclByb3RvfFJlYWRlcnxVaW50OEFycmF5fSBkZXNjcmlwdG9yIERlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZWRpdGlvbj1cInByb3RvMlwiXSBUaGUgc3ludGF4IG9yIGVkaXRpb24gdG8gdXNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtuZXN0ZWQ9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgYSBuZXN0ZWQgb2JqZWN0XG4gKiBAcmV0dXJucyB7VHlwZX0gVHlwZSBpbnN0YW5jZVxuICovXG5UeXBlLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvciwgZWRpdGlvbiwgbmVzdGVkKSB7XG4gICAgLy8gRGVjb2RlIHRoZSBkZXNjcmlwdG9yIG1lc3NhZ2UgaWYgc3BlY2lmaWVkIGFzIGEgYnVmZmVyOlxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLkRlc2NyaXB0b3JQcm90by5kZWNvZGUoZGVzY3JpcHRvcik7XG5cbiAgICAvLyBDcmVhdGUgdGhlIG1lc3NhZ2UgdHlwZVxuICAgIHZhciB0eXBlID0gbmV3IFR5cGUoZGVzY3JpcHRvci5uYW1lLmxlbmd0aCA/IGRlc2NyaXB0b3IubmFtZSA6IFwiVHlwZVwiICsgdW5uYW1lZE1lc3NhZ2VJbmRleCsrLCBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLk1lc3NhZ2VPcHRpb25zKSksXG4gICAgICAgIGk7XG5cbiAgICBpZiAoIW5lc3RlZClcbiAgICAgICAgdHlwZS5fZWRpdGlvbiA9IGVkaXRpb247XG5cbiAgICAvKiBPbmVvZnMgKi8gaWYgKGRlc2NyaXB0b3Iub25lb2ZEZWNsKVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5vbmVvZkRlY2wubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0eXBlLmFkZChPbmVPZi5mcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLm9uZW9mRGVjbFtpXSkpO1xuICAgIC8qIEZpZWxkcyAqLyBpZiAoZGVzY3JpcHRvci5maWVsZClcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3IuZmllbGQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IEZpZWxkLmZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IuZmllbGRbaV0sIGVkaXRpb24sIHRydWUpO1xuICAgICAgICAgICAgdHlwZS5hZGQoZmllbGQpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IuZmllbGRbaV0uaGFzT3duUHJvcGVydHkoXCJvbmVvZkluZGV4XCIpKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgICAgIHR5cGUub25lb2ZzQXJyYXlbZGVzY3JpcHRvci5maWVsZFtpXS5vbmVvZkluZGV4XS5hZGQoZmllbGQpO1xuICAgICAgICB9XG4gICAgLyogRXh0ZW5zaW9uIGZpZWxkcyAqLyBpZiAoZGVzY3JpcHRvci5leHRlbnNpb24pXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLmV4dGVuc2lvbi5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHR5cGUuYWRkKEZpZWxkLmZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IuZXh0ZW5zaW9uW2ldLCBlZGl0aW9uLCB0cnVlKSk7XG4gICAgLyogTmVzdGVkIHR5cGVzICovIGlmIChkZXNjcmlwdG9yLm5lc3RlZFR5cGUpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLm5lc3RlZFR5cGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHR5cGUuYWRkKFR5cGUuZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvci5uZXN0ZWRUeXBlW2ldLCBlZGl0aW9uLCB0cnVlKSk7XG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5uZXN0ZWRUeXBlW2ldLm9wdGlvbnMgJiYgZGVzY3JpcHRvci5uZXN0ZWRUeXBlW2ldLm9wdGlvbnMubWFwRW50cnkpXG4gICAgICAgICAgICAgICAgdHlwZS5zZXRPcHRpb24oXCJtYXBfZW50cnlcIiwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAvKiBOZXN0ZWQgZW51bXMgKi8gaWYgKGRlc2NyaXB0b3IuZW51bVR5cGUpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXNjcmlwdG9yLmVudW1UeXBlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdHlwZS5hZGQoRW51bS5mcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLmVudW1UeXBlW2ldLCBlZGl0aW9uLCB0cnVlKSk7XG4gICAgLyogRXh0ZW5zaW9uIHJhbmdlcyAqLyBpZiAoZGVzY3JpcHRvci5leHRlbnNpb25SYW5nZSAmJiBkZXNjcmlwdG9yLmV4dGVuc2lvblJhbmdlLmxlbmd0aCkge1xuICAgICAgICB0eXBlLmV4dGVuc2lvbnMgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3IuZXh0ZW5zaW9uUmFuZ2UubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB0eXBlLmV4dGVuc2lvbnMucHVzaChbIGRlc2NyaXB0b3IuZXh0ZW5zaW9uUmFuZ2VbaV0uc3RhcnQsIGRlc2NyaXB0b3IuZXh0ZW5zaW9uUmFuZ2VbaV0uZW5kIF0pO1xuICAgIH1cbiAgICAvKiBSZXNlcnZlZC4uLiAqLyBpZiAoZGVzY3JpcHRvci5yZXNlcnZlZFJhbmdlICYmIGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZS5sZW5ndGggfHwgZGVzY3JpcHRvci5yZXNlcnZlZE5hbWUgJiYgZGVzY3JpcHRvci5yZXNlcnZlZE5hbWUubGVuZ3RoKSB7XG4gICAgICAgIHR5cGUucmVzZXJ2ZWQgPSBbXTtcbiAgICAgICAgLyogUmFuZ2VzICovIGlmIChkZXNjcmlwdG9yLnJlc2VydmVkUmFuZ2UpXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZGVzY3JpcHRvci5yZXNlcnZlZFJhbmdlLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHR5cGUucmVzZXJ2ZWQucHVzaChbIGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZVtpXS5zdGFydCwgZGVzY3JpcHRvci5yZXNlcnZlZFJhbmdlW2ldLmVuZCBdKTtcbiAgICAgICAgLyogTmFtZXMgKi8gaWYgKGRlc2NyaXB0b3IucmVzZXJ2ZWROYW1lKVxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGRlc2NyaXB0b3IucmVzZXJ2ZWROYW1lLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHR5cGUucmVzZXJ2ZWQucHVzaChkZXNjcmlwdG9yLnJlc2VydmVkTmFtZVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgdHlwZSB0byBhIGRlc2NyaXB0b3IuXG4gKiBAcmV0dXJucyB7TWVzc2FnZTxJRGVzY3JpcHRvclByb3RvPn0gRGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd9IFtlZGl0aW9uPVwicHJvdG8yXCJdIFRoZSBzeW50YXggb3IgZWRpdGlvbiB0byB1c2VcbiAqL1xuVHlwZS5wcm90b3R5cGUudG9EZXNjcmlwdG9yID0gZnVuY3Rpb24gdG9EZXNjcmlwdG9yKGVkaXRpb24pIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IHRoaXMubmFtZSB9KSxcbiAgICAgICAgaTtcblxuICAgIC8qIEZpZWxkcyAqLyBmb3IgKGkgPSAwOyBpIDwgdGhpcy5maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGREZXNjcmlwdG9yO1xuICAgICAgICBkZXNjcmlwdG9yLmZpZWxkLnB1c2goZmllbGREZXNjcmlwdG9yID0gdGhpcy5fZmllbGRzQXJyYXlbaV0udG9EZXNjcmlwdG9yKGVkaXRpb24pKTtcbiAgICAgICAgaWYgKHRoaXMuX2ZpZWxkc0FycmF5W2ldIGluc3RhbmNlb2YgTWFwRmllbGQpIHsgLy8gbWFwIGZpZWxkcyBhcmUgcmVwZWF0ZWQgRmllbGROYW1lRW50cnlcbiAgICAgICAgICAgIHZhciBrZXlUeXBlID0gdG9EZXNjcmlwdG9yVHlwZSh0aGlzLl9maWVsZHNBcnJheVtpXS5rZXlUeXBlLCB0aGlzLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlZEtleVR5cGUsIGZhbHNlKSxcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGUgPSB0b0Rlc2NyaXB0b3JUeXBlKHRoaXMuX2ZpZWxkc0FycmF5W2ldLnR5cGUsIHRoaXMuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmVkVHlwZSwgZmFsc2UpLFxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZU5hbWUgPSB2YWx1ZVR5cGUgPT09IC8qIHR5cGUgKi8gMTEgfHwgdmFsdWVUeXBlID09PSAvKiBlbnVtICovIDE0XG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZWRUeXBlICYmIHNob3J0bmFtZSh0aGlzLnBhcmVudCwgdGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZWRUeXBlKSB8fCB0aGlzLl9maWVsZHNBcnJheVtpXS50eXBlXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgZGVzY3JpcHRvci5uZXN0ZWRUeXBlLnB1c2goZXhwb3J0cy5EZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBmaWVsZERlc2NyaXB0b3IudHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgZmllbGQ6IFtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5GaWVsZERlc2NyaXB0b3JQcm90by5jcmVhdGUoeyBuYW1lOiBcImtleVwiLCBudW1iZXI6IDEsIGxhYmVsOiAxLCB0eXBlOiBrZXlUeXBlIH0pLCAvLyBjYW4ndCByZWZlcmVuY2UgYSB0eXBlIG9yIGVudW1cbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0cy5GaWVsZERlc2NyaXB0b3JQcm90by5jcmVhdGUoeyBuYW1lOiBcInZhbHVlXCIsIG51bWJlcjogMiwgbGFiZWw6IDEsIHR5cGU6IHZhbHVlVHlwZSwgdHlwZU5hbWU6IHZhbHVlVHlwZU5hbWUgfSlcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cG9ydHMuTWVzc2FnZU9wdGlvbnMuY3JlYXRlKHsgbWFwRW50cnk6IHRydWUgfSlcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBPbmVvZnMgKi8gZm9yIChpID0gMDsgaSA8IHRoaXMub25lb2ZzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIGRlc2NyaXB0b3Iub25lb2ZEZWNsLnB1c2godGhpcy5fb25lb2ZzQXJyYXlbaV0udG9EZXNjcmlwdG9yKCkpO1xuICAgIC8qIE5lc3RlZC4uLiAqLyBmb3IgKGkgPSAwOyBpIDwgdGhpcy5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICAvKiBFeHRlbnNpb24gZmllbGRzICovIGlmICh0aGlzLl9uZXN0ZWRBcnJheVtpXSBpbnN0YW5jZW9mIEZpZWxkKVxuICAgICAgICAgICAgZGVzY3JpcHRvci5maWVsZC5wdXNoKHRoaXMuX25lc3RlZEFycmF5W2ldLnRvRGVzY3JpcHRvcihlZGl0aW9uKSk7XG4gICAgICAgIC8qIFR5cGVzICovIGVsc2UgaWYgKHRoaXMuX25lc3RlZEFycmF5W2ldIGluc3RhbmNlb2YgVHlwZSlcbiAgICAgICAgICAgIGRlc2NyaXB0b3IubmVzdGVkVHlwZS5wdXNoKHRoaXMuX25lc3RlZEFycmF5W2ldLnRvRGVzY3JpcHRvcihlZGl0aW9uKSk7XG4gICAgICAgIC8qIEVudW1zICovIGVsc2UgaWYgKHRoaXMuX25lc3RlZEFycmF5W2ldIGluc3RhbmNlb2YgRW51bSlcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bVR5cGUucHVzaCh0aGlzLl9uZXN0ZWRBcnJheVtpXS50b0Rlc2NyaXB0b3IoKSk7XG4gICAgICAgIC8vIHBsYWluIG5lc3RlZCBuYW1lc3BhY2VzIGJlY29tZSBwYWNrYWdlcyBpbnN0ZWFkIGluIFJvb3QjdG9EZXNjcmlwdG9yXG4gICAgfVxuICAgIC8qIEV4dGVuc2lvbiByYW5nZXMgKi8gaWYgKHRoaXMuZXh0ZW5zaW9ucylcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZXh0ZW5zaW9ucy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZXh0ZW5zaW9uUmFuZ2UucHVzaChleHBvcnRzLkRlc2NyaXB0b3JQcm90by5FeHRlbnNpb25SYW5nZS5jcmVhdGUoeyBzdGFydDogdGhpcy5leHRlbnNpb25zW2ldWzBdLCBlbmQ6IHRoaXMuZXh0ZW5zaW9uc1tpXVsxXSB9KSk7XG4gICAgLyogUmVzZXJ2ZWQuLi4gKi8gaWYgKHRoaXMucmVzZXJ2ZWQpXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlc2VydmVkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgLyogTmFtZXMgKi8gaWYgKHR5cGVvZiB0aGlzLnJlc2VydmVkW2ldID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IucmVzZXJ2ZWROYW1lLnB1c2godGhpcy5yZXNlcnZlZFtpXSk7XG4gICAgICAgICAgICAvKiBSYW5nZXMgKi8gZWxzZVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IucmVzZXJ2ZWRSYW5nZS5wdXNoKGV4cG9ydHMuRGVzY3JpcHRvclByb3RvLlJlc2VydmVkUmFuZ2UuY3JlYXRlKHsgc3RhcnQ6IHRoaXMucmVzZXJ2ZWRbaV1bMF0sIGVuZDogdGhpcy5yZXNlcnZlZFtpXVsxXSB9KSk7XG5cbiAgICBkZXNjcmlwdG9yLm9wdGlvbnMgPSB0b0Rlc2NyaXB0b3JPcHRpb25zKHRoaXMub3B0aW9ucywgZXhwb3J0cy5NZXNzYWdlT3B0aW9ucyk7XG5cbiAgICByZXR1cm4gZGVzY3JpcHRvcjtcbn07XG5cbi8vIC0tLSBGaWVsZCAtLS1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgRmllbGREZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSUZpZWxkRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIEZpZWxkIG5hbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyXSBGaWVsZCBpZFxuICogQHByb3BlcnR5IHtJRmllbGREZXNjcmlwdG9yUHJvdG9MYWJlbH0gW2xhYmVsXSBGaWVsZCBydWxlXG4gKiBAcHJvcGVydHkge0lGaWVsZERlc2NyaXB0b3JQcm90b1R5cGV9IFt0eXBlXSBGaWVsZCBiYXNpYyB0eXBlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3R5cGVOYW1lXSBGaWVsZCB0eXBlIG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXh0ZW5kZWVdIEV4dGVuZGVkIHR5cGUgbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtkZWZhdWx0VmFsdWVdIExpdGVyYWwgZGVmYXVsdCB2YWx1ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtvbmVvZkluZGV4XSBPbmVvZiBpbmRleCBpZiBwYXJ0IG9mIGEgb25lb2ZcbiAqIEBwcm9wZXJ0eSB7Kn0gW2pzb25OYW1lXSBOb3Qgc3VwcG9ydGVkXG4gKiBAcHJvcGVydHkge0lGaWVsZE9wdGlvbnN9IFtvcHRpb25zXSBGaWVsZCBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBWYWx1ZXMgb2YgdGhlIEZpZWxkRGVzY3JpcHRvclByb3RvLkxhYmVsIGVudW0uXG4gKiBAdHlwZWRlZiBJRmllbGREZXNjcmlwdG9yUHJvdG9MYWJlbFxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBMQUJFTF9PUFRJT05BTD0xXG4gKiBAcHJvcGVydHkge251bWJlcn0gTEFCRUxfUkVRVUlSRUQ9MlxuICogQHByb3BlcnR5IHtudW1iZXJ9IExBQkVMX1JFUEVBVEVEPTNcbiAqL1xuXG4vKipcbiAqIFZhbHVlcyBvZiB0aGUgRmllbGREZXNjcmlwdG9yUHJvdG8uVHlwZSBlbnVtLlxuICogQHR5cGVkZWYgSUZpZWxkRGVzY3JpcHRvclByb3RvVHlwZVxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0RPVUJMRT0xXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9GTE9BVD0yXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9JTlQ2ND0zXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9VSU5UNjQ9NFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfSU5UMzI9NVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfRklYRUQ2ND02XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9GSVhFRDMyPTdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0JPT0w9OFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfU1RSSU5HPTlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX0dST1VQPTEwXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9NRVNTQUdFPTExXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9CWVRFUz0xMlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfVUlOVDMyPTEzXG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9FTlVNPTE0XG4gKiBAcHJvcGVydHkge251bWJlcn0gVFlQRV9TRklYRUQzMj0xNVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfU0ZJWEVENjQ9MTZcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBUWVBFX1NJTlQzMj0xN1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFRZUEVfU0lOVDY0PTE4XG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgRmllbGRPcHRpb25zIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElGaWVsZE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3BhY2tlZF0gV2hldGhlciBwYWNrZWQgb3Igbm90IChkZWZhdWx0cyB0byBgZmFsc2VgIGZvciBwcm90bzIgYW5kIGB0cnVlYCBmb3IgcHJvdG8zKVxuICogQHByb3BlcnR5IHtJRmllbGRPcHRpb25zSlNUeXBlfSBbanN0eXBlXSBKYXZhU2NyaXB0IHZhbHVlIHR5cGUgKG5vdCB1c2VkIGJ5IHByb3RvYnVmLmpzKVxuICovXG5cbi8qKlxuICogVmFsdWVzIG9mIHRoZSBGaWVsZE9wdGlvbnMuSlNUeXBlIGVudW0uXG4gKiBAdHlwZWRlZiBJRmllbGRPcHRpb25zSlNUeXBlXG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQHByb3BlcnR5IHtudW1iZXJ9IEpTX05PUk1BTD0wXG4gKiBAcHJvcGVydHkge251bWJlcn0gSlNfU1RSSU5HPTFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBKU19OVU1CRVI9MlxuICovXG5cbi8vIGNvcGllZCBoZXJlIGZyb20gcGFyc2UuanNcbnZhciBudW1iZXJSZSA9IC9eKD8hW2VFXSlbMC05XSooPzpcXC5bMC05XSopPyg/OltlRV1bKy1dP1swLTldKyk/JC87XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZpZWxkIGZyb20gYSBkZXNjcmlwdG9yLlxuICpcbiAqIFdhcm5pbmc6IHRoaXMgaXMgbm90IHNhZmUgdG8gdXNlIHdpdGggZWRpdGlvbnMgcHJvdG9zLCBzaW5jZSBpdCBkaXNjYXJkcyByZWxldmFudCBmaWxlIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtJRmllbGREZXNjcmlwdG9yUHJvdG98UmVhZGVyfFVpbnQ4QXJyYXl9IGRlc2NyaXB0b3IgRGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd9IFtlZGl0aW9uPVwicHJvdG8yXCJdIFRoZSBzeW50YXggb3IgZWRpdGlvbiB0byB1c2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW25lc3RlZD1mYWxzZV0gV2hldGhlciBvciBub3QgdGhpcyBpcyBhIHRvcC1sZXZlbCBvYmplY3RcbiAqIEByZXR1cm5zIHtGaWVsZH0gRmllbGQgaW5zdGFuY2VcbiAqL1xuRmllbGQuZnJvbURlc2NyaXB0b3IgPSBmdW5jdGlvbiBmcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yLCBlZGl0aW9uLCBuZXN0ZWQpIHtcblxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICBkZXNjcmlwdG9yID0gZXhwb3J0cy5EZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLm51bWJlciAhPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJtaXNzaW5nIGZpZWxkIGlkXCIpO1xuXG4gICAgLy8gUmV3aXJlIGZpZWxkIHR5cGVcbiAgICB2YXIgZmllbGRUeXBlO1xuICAgIGlmIChkZXNjcmlwdG9yLnR5cGVOYW1lICYmIGRlc2NyaXB0b3IudHlwZU5hbWUubGVuZ3RoKVxuICAgICAgICBmaWVsZFR5cGUgPSBkZXNjcmlwdG9yLnR5cGVOYW1lO1xuICAgIGVsc2VcbiAgICAgICAgZmllbGRUeXBlID0gZnJvbURlc2NyaXB0b3JUeXBlKGRlc2NyaXB0b3IudHlwZSk7XG5cbiAgICAvLyBSZXdpcmUgZmllbGQgcnVsZVxuICAgIHZhciBmaWVsZFJ1bGU7XG4gICAgc3dpdGNoIChkZXNjcmlwdG9yLmxhYmVsKSB7XG4gICAgICAgIC8vIDAgaXMgcmVzZXJ2ZWQgZm9yIGVycm9yc1xuICAgICAgICBjYXNlIDE6IGZpZWxkUnVsZSA9IHVuZGVmaW5lZDsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogZmllbGRSdWxlID0gXCJyZXF1aXJlZFwiOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBmaWVsZFJ1bGUgPSBcInJlcGVhdGVkXCI7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBFcnJvcihcImlsbGVnYWwgbGFiZWw6IFwiICsgZGVzY3JpcHRvci5sYWJlbCk7XG4gICAgfVxuXG5cdHZhciBleHRlbmRlZSA9IGRlc2NyaXB0b3IuZXh0ZW5kZWU7XG5cdGlmIChkZXNjcmlwdG9yLmV4dGVuZGVlICE9PSB1bmRlZmluZWQpIHtcblx0XHRleHRlbmRlZSA9IGV4dGVuZGVlLmxlbmd0aCA/IGV4dGVuZGVlIDogdW5kZWZpbmVkO1xuXHR9XG4gICAgdmFyIGZpZWxkID0gbmV3IEZpZWxkKFxuICAgICAgICBkZXNjcmlwdG9yLm5hbWUubGVuZ3RoID8gZGVzY3JpcHRvci5uYW1lIDogXCJmaWVsZFwiICsgZGVzY3JpcHRvci5udW1iZXIsXG4gICAgICAgIGRlc2NyaXB0b3IubnVtYmVyLFxuICAgICAgICBmaWVsZFR5cGUsXG4gICAgICAgIGZpZWxkUnVsZSxcbiAgICAgICAgZXh0ZW5kZWVcbiAgICApO1xuXG4gICAgaWYgKCFuZXN0ZWQpXG4gICAgICAgIGZpZWxkLl9lZGl0aW9uID0gZWRpdGlvbjtcblxuICAgIGZpZWxkLm9wdGlvbnMgPSBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLkZpZWxkT3B0aW9ucyk7XG4gICAgaWYgKGRlc2NyaXB0b3IucHJvdG8zX29wdGlvbmFsKVxuICAgICAgICBmaWVsZC5vcHRpb25zLnByb3RvM19vcHRpb25hbCA9IHRydWU7XG5cbiAgICBpZiAoZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUgJiYgZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBkZXNjcmlwdG9yLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgc3dpdGNoIChkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0cnVlXCI6IGNhc2UgXCJUUlVFXCI6XG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmYWxzZVwiOiBjYXNlIFwiRkFMU0VcIjpcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gbnVtYmVyUmUuZXhlYyhkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlID0gcGFyc2VJbnQoZGVmYXVsdFZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByYWRpeFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGZpZWxkLnNldE9wdGlvbihcImRlZmF1bHRcIiwgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAocGFja2FibGVEZXNjcmlwdG9yVHlwZShkZXNjcmlwdG9yLnR5cGUpKSB7XG4gICAgICAgIGlmIChlZGl0aW9uID09PSBcInByb3RvM1wiKSB7IC8vIGRlZmF1bHRzIHRvIHBhY2tlZD10cnVlIChpbnRlcm5hbCBwcmVzZXQgaXMgcGFja2VkPXRydWUpXG4gICAgICAgICAgICBpZiAoZGVzY3JpcHRvci5vcHRpb25zICYmICFkZXNjcmlwdG9yLm9wdGlvbnMucGFja2VkKVxuICAgICAgICAgICAgICAgIGZpZWxkLnNldE9wdGlvbihcInBhY2tlZFwiLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKCFlZGl0aW9uIHx8IGVkaXRpb24gPT09IFwicHJvdG8yXCIpICYmIGRlc2NyaXB0b3Iub3B0aW9ucyAmJiBkZXNjcmlwdG9yLm9wdGlvbnMucGFja2VkKSAvLyBkZWZhdWx0cyB0byBwYWNrZWQ9ZmFsc2VcbiAgICAgICAgICAgIGZpZWxkLnNldE9wdGlvbihcInBhY2tlZFwiLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmllbGQ7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgZmllbGQgdG8gYSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge01lc3NhZ2U8SUZpZWxkRGVzY3JpcHRvclByb3RvPn0gRGVzY3JpcHRvclxuICogQHBhcmFtIHtzdHJpbmd9IFtlZGl0aW9uPVwicHJvdG8yXCJdIFRoZSBzeW50YXggb3IgZWRpdGlvbiB0byB1c2VcbiAqL1xuRmllbGQucHJvdG90eXBlLnRvRGVzY3JpcHRvciA9IGZ1bmN0aW9uIHRvRGVzY3JpcHRvcihlZGl0aW9uKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBleHBvcnRzLkZpZWxkRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7IG5hbWU6IHRoaXMubmFtZSwgbnVtYmVyOiB0aGlzLmlkIH0pO1xuXG4gICAgaWYgKHRoaXMubWFwKSB7XG5cbiAgICAgICAgZGVzY3JpcHRvci50eXBlID0gMTE7IC8vIG1lc3NhZ2VcbiAgICAgICAgZGVzY3JpcHRvci50eXBlTmFtZSA9ICRwcm90b2J1Zi51dGlsLnVjRmlyc3QodGhpcy5uYW1lKTsgLy8gZmllbGROYW1lIC0+IEZpZWxkTmFtZUVudHJ5IChidWlsdCBpbiBUeXBlI3RvRGVzY3JpcHRvcilcbiAgICAgICAgZGVzY3JpcHRvci5sYWJlbCA9IDM7IC8vIHJlcGVhdGVkXG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFJld2lyZSBmaWVsZCB0eXBlXG4gICAgICAgIHN3aXRjaCAoZGVzY3JpcHRvci50eXBlID0gdG9EZXNjcmlwdG9yVHlwZSh0aGlzLnR5cGUsIHRoaXMucmVzb2x2ZSgpLnJlc29sdmVkVHlwZSwgdGhpcy5kZWxpbWl0ZWQpKSB7XG4gICAgICAgICAgICBjYXNlIDEwOiAvLyBncm91cFxuICAgICAgICAgICAgY2FzZSAxMTogLy8gdHlwZVxuICAgICAgICAgICAgY2FzZSAxNDogLy8gZW51bVxuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IudHlwZU5hbWUgPSB0aGlzLnJlc29sdmVkVHlwZSA/IHNob3J0bmFtZSh0aGlzLnBhcmVudCwgdGhpcy5yZXNvbHZlZFR5cGUpIDogdGhpcy50eXBlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmV3aXJlIGZpZWxkIHJ1bGVcbiAgICAgICAgaWYgKHRoaXMucnVsZSA9PT0gXCJyZXBlYXRlZFwiKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmxhYmVsID0gMztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJlcXVpcmVkICYmIGVkaXRpb24gPT09IFwicHJvdG8yXCIpIHtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IubGFiZWwgPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzY3JpcHRvci5sYWJlbCA9IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZXh0ZW5zaW9uIGZpZWxkXG4gICAgZGVzY3JpcHRvci5leHRlbmRlZSA9IHRoaXMuZXh0ZW5zaW9uRmllbGQgPyB0aGlzLmV4dGVuc2lvbkZpZWxkLnBhcmVudC5mdWxsTmFtZSA6IHRoaXMuZXh0ZW5kO1xuXG4gICAgLy8gSGFuZGxlIHBhcnQgb2Ygb25lb2ZcbiAgICBpZiAodGhpcy5wYXJ0T2YpXG4gICAgICAgIGlmICgoZGVzY3JpcHRvci5vbmVvZkluZGV4ID0gdGhpcy5wYXJlbnQub25lb2ZzQXJyYXkuaW5kZXhPZih0aGlzLnBhcnRPZikpIDwgMClcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibWlzc2luZyBvbmVvZlwiKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgZGVzY3JpcHRvci5vcHRpb25zID0gdG9EZXNjcmlwdG9yT3B0aW9ucyh0aGlzLm9wdGlvbnMsIGV4cG9ydHMuRmllbGRPcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl0gIT0gbnVsbClcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZGVmYXVsdFZhbHVlID0gU3RyaW5nKHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnByb3RvM19vcHRpb25hbClcbiAgICAgICAgICAgIGRlc2NyaXB0b3IucHJvdG8zX29wdGlvbmFsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoZWRpdGlvbiA9PT0gXCJwcm90bzNcIikgeyAvLyBkZWZhdWx0cyB0byBwYWNrZWQ9dHJ1ZVxuICAgICAgICBpZiAoIXRoaXMucGFja2VkKVxuICAgICAgICAgICAgKGRlc2NyaXB0b3Iub3B0aW9ucyB8fCAoZGVzY3JpcHRvci5vcHRpb25zID0gZXhwb3J0cy5GaWVsZE9wdGlvbnMuY3JlYXRlKCkpKS5wYWNrZWQgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCghZWRpdGlvbiB8fCBlZGl0aW9uID09PSBcInByb3RvMlwiKSAmJiB0aGlzLnBhY2tlZCkgLy8gZGVmYXVsdHMgdG8gcGFja2VkPWZhbHNlXG4gICAgICAgIChkZXNjcmlwdG9yLm9wdGlvbnMgfHwgKGRlc2NyaXB0b3Iub3B0aW9ucyA9IGV4cG9ydHMuRmllbGRPcHRpb25zLmNyZWF0ZSgpKSkucGFja2VkID0gdHJ1ZTtcblxuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxuLy8gLS0tIEVudW0gLS0tXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhbiBFbnVtRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElFbnVtRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIEVudW0gbmFtZVxuICogQHByb3BlcnR5IHtJRW51bVZhbHVlRGVzY3JpcHRvclByb3RvW119IFt2YWx1ZV0gRW51bSB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7SUVudW1PcHRpb25zfSBbb3B0aW9uc10gRW51bSBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGFuIEVudW1WYWx1ZURlc2NyaXB0b3JQcm90byBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRW51bVZhbHVlRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIE5hbWVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyXSBWYWx1ZVxuICogQHByb3BlcnR5IHsqfSBbb3B0aW9uc10gTm90IHN1cHBvcnRlZFxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhbiBFbnVtT3B0aW9ucyBtZXNzYWdlLlxuICogQGludGVyZmFjZSBJRW51bU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FsbG93QWxpYXNdIFdoZXRoZXIgYWxpYXNlcyBhcmUgYWxsb3dlZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVwcmVjYXRlZF1cbiAqL1xuXG52YXIgdW5uYW1lZEVudW1JbmRleCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBlbnVtIGZyb20gYSBkZXNjcmlwdG9yLlxuICpcbiAqIFdhcm5pbmc6IHRoaXMgaXMgbm90IHNhZmUgdG8gdXNlIHdpdGggZWRpdGlvbnMgcHJvdG9zLCBzaW5jZSBpdCBkaXNjYXJkcyByZWxldmFudCBmaWxlIGNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtJRW51bURlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VkaXRpb249XCJwcm90bzJcIl0gVGhlIHN5bnRheCBvciBlZGl0aW9uIHRvIHVzZVxuICogQHBhcmFtIHtib29sZWFufSBbbmVzdGVkPWZhbHNlXSBXaGV0aGVyIG9yIG5vdCB0aGlzIGlzIGEgdG9wLWxldmVsIG9iamVjdFxuICogQHJldHVybnMge0VudW19IEVudW0gaW5zdGFuY2VcbiAqL1xuRW51bS5mcm9tRGVzY3JpcHRvciA9IGZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IsIGVkaXRpb24sIG5lc3RlZCkge1xuXG4gICAgLy8gRGVjb2RlIHRoZSBkZXNjcmlwdG9yIG1lc3NhZ2UgaWYgc3BlY2lmaWVkIGFzIGEgYnVmZmVyOlxuICAgIGlmICh0eXBlb2YgZGVzY3JpcHRvci5sZW5ndGggPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGRlc2NyaXB0b3IgPSBleHBvcnRzLkVudW1EZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgLy8gQ29uc3RydWN0IHZhbHVlcyBvYmplY3RcbiAgICB2YXIgdmFsdWVzID0ge307XG4gICAgaWYgKGRlc2NyaXB0b3IudmFsdWUpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzY3JpcHRvci52YWx1ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgID0gZGVzY3JpcHRvci52YWx1ZVtpXS5uYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gZGVzY3JpcHRvci52YWx1ZVtpXS5udW1iZXIgfHwgMDtcbiAgICAgICAgICAgIHZhbHVlc1tuYW1lICYmIG5hbWUubGVuZ3RoID8gbmFtZSA6IFwiTkFNRVwiICsgdmFsdWVdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgIHZhciBlbm0gPSBuZXcgRW51bShcbiAgICAgICAgZGVzY3JpcHRvci5uYW1lICYmIGRlc2NyaXB0b3IubmFtZS5sZW5ndGggPyBkZXNjcmlwdG9yLm5hbWUgOiBcIkVudW1cIiArIHVubmFtZWRFbnVtSW5kZXgrKyxcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLkVudW1PcHRpb25zKVxuICAgICk7XG5cbiAgICBpZiAoIW5lc3RlZClcbiAgICAgICAgZW5tLl9lZGl0aW9uID0gZWRpdGlvbjtcblxuICAgIHJldHVybiBlbm07XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGVudW0gdG8gYSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge01lc3NhZ2U8SUVudW1EZXNjcmlwdG9yUHJvdG8+fSBEZXNjcmlwdG9yXG4gKi9cbkVudW0ucHJvdG90eXBlLnRvRGVzY3JpcHRvciA9IGZ1bmN0aW9uIHRvRGVzY3JpcHRvcigpIHtcblxuICAgIC8vIFZhbHVlc1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwga3MgPSBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcyk7IGkgPCBrcy5sZW5ndGg7ICsraSlcbiAgICAgICAgdmFsdWVzLnB1c2goZXhwb3J0cy5FbnVtVmFsdWVEZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHsgbmFtZToga3NbaV0sIG51bWJlcjogdGhpcy52YWx1ZXNba3NbaV1dIH0pKTtcblxuICAgIHJldHVybiBleHBvcnRzLkVudW1EZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWVzLFxuICAgICAgICBvcHRpb25zOiB0b0Rlc2NyaXB0b3JPcHRpb25zKHRoaXMub3B0aW9ucywgZXhwb3J0cy5FbnVtT3B0aW9ucylcbiAgICB9KTtcbn07XG5cbi8vIC0tLSBPbmVPZiAtLS1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgT25lb2ZEZXNjcmlwdG9yUHJvdG8gbWVzc2FnZS5cbiAqIEBpbnRlcmZhY2UgSU9uZW9mRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIE9uZW9mIG5hbWVcbiAqIEBwcm9wZXJ0eSB7Kn0gW29wdGlvbnNdIE5vdCBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgdW5uYW1lZE9uZW9mSW5kZXggPSAwO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBvbmVvZiBmcm9tIGEgZGVzY3JpcHRvci5cbiAqXG4gKiBXYXJuaW5nOiB0aGlzIGlzIG5vdCBzYWZlIHRvIHVzZSB3aXRoIGVkaXRpb25zIHByb3Rvcywgc2luY2UgaXQgZGlzY2FyZHMgcmVsZXZhbnQgZmlsZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7SU9uZW9mRGVzY3JpcHRvclByb3RvfFJlYWRlcnxVaW50OEFycmF5fSBkZXNjcmlwdG9yIERlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtPbmVPZn0gT25lT2YgaW5zdGFuY2VcbiAqL1xuT25lT2YuZnJvbURlc2NyaXB0b3IgPSBmdW5jdGlvbiBmcm9tRGVzY3JpcHRvcihkZXNjcmlwdG9yKSB7XG5cbiAgICAvLyBEZWNvZGUgdGhlIGRlc2NyaXB0b3IgbWVzc2FnZSBpZiBzcGVjaWZpZWQgYXMgYSBidWZmZXI6XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuT25lb2ZEZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgcmV0dXJuIG5ldyBPbmVPZihcbiAgICAgICAgLy8gdW5uYW1lZE9uZU9mSW5kZXggaXMgZ2xvYmFsLCBub3QgcGVyIHR5cGUsIGJlY2F1c2Ugd2UgaGF2ZSBubyByZWYgdG8gYSB0eXBlIGhlcmVcbiAgICAgICAgZGVzY3JpcHRvci5uYW1lICYmIGRlc2NyaXB0b3IubmFtZS5sZW5ndGggPyBkZXNjcmlwdG9yLm5hbWUgOiBcIm9uZW9mXCIgKyB1bm5hbWVkT25lb2ZJbmRleCsrXG4gICAgICAgIC8vIGZyb21EZXNjcmlwdG9yT3B0aW9ucyhkZXNjcmlwdG9yLm9wdGlvbnMsIGV4cG9ydHMuT25lb2ZPcHRpb25zKSAtIG9ubHkgdW5pbnRlcnByZXRlZF9vcHRpb25cbiAgICApO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG9uZW9mIHRvIGEgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtNZXNzYWdlPElPbmVvZkRlc2NyaXB0b3JQcm90bz59IERlc2NyaXB0b3JcbiAqL1xuT25lT2YucHJvdG90eXBlLnRvRGVzY3JpcHRvciA9IGZ1bmN0aW9uIHRvRGVzY3JpcHRvcigpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5PbmVvZkRlc2NyaXB0b3JQcm90by5jcmVhdGUoe1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWVcbiAgICAgICAgLy8gb3B0aW9uczogdG9EZXNjcmlwdG9yT3B0aW9ucyh0aGlzLm9wdGlvbnMsIGV4cG9ydHMuT25lb2ZPcHRpb25zKSAtIG9ubHkgdW5pbnRlcnByZXRlZF9vcHRpb25cbiAgICB9KTtcbn07XG5cbi8vIC0tLSBTZXJ2aWNlIC0tLVxuXG4vKipcbiAqIFByb3BlcnRpZXMgb2YgYSBTZXJ2aWNlRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElTZXJ2aWNlRGVzY3JpcHRvclByb3RvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW25hbWVdIFNlcnZpY2UgbmFtZVxuICogQHByb3BlcnR5IHtJTWV0aG9kRGVzY3JpcHRvclByb3RvW119IFttZXRob2RdIE1ldGhvZHNcbiAqIEBwcm9wZXJ0eSB7SVNlcnZpY2VPcHRpb25zfSBbb3B0aW9uc10gT3B0aW9uc1xuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIFNlcnZpY2VPcHRpb25zIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElTZXJ2aWNlT3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVwcmVjYXRlZF1cbiAqL1xuXG52YXIgdW5uYW1lZFNlcnZpY2VJbmRleCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNlcnZpY2UgZnJvbSBhIGRlc2NyaXB0b3IuXG4gKlxuICogV2FybmluZzogdGhpcyBpcyBub3Qgc2FmZSB0byB1c2Ugd2l0aCBlZGl0aW9ucyBwcm90b3MsIHNpbmNlIGl0IGRpc2NhcmRzIHJlbGV2YW50IGZpbGUgY29udGV4dC5cbiAqXG4gKiBAcGFyYW0ge0lTZXJ2aWNlRGVzY3JpcHRvclByb3RvfFJlYWRlcnxVaW50OEFycmF5fSBkZXNjcmlwdG9yIERlc2NyaXB0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZWRpdGlvbj1cInByb3RvMlwiXSBUaGUgc3ludGF4IG9yIGVkaXRpb24gdG8gdXNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtuZXN0ZWQ9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRoaXMgaXMgYSB0b3AtbGV2ZWwgb2JqZWN0XG4gKiBAcmV0dXJucyB7U2VydmljZX0gU2VydmljZSBpbnN0YW5jZVxuICovXG5TZXJ2aWNlLmZyb21EZXNjcmlwdG9yID0gZnVuY3Rpb24gZnJvbURlc2NyaXB0b3IoZGVzY3JpcHRvciwgZWRpdGlvbiwgbmVzdGVkKSB7XG5cbiAgICAvLyBEZWNvZGUgdGhlIGRlc2NyaXB0b3IgbWVzc2FnZSBpZiBzcGVjaWZpZWQgYXMgYSBidWZmZXI6XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yLmxlbmd0aCA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgZGVzY3JpcHRvciA9IGV4cG9ydHMuU2VydmljZURlc2NyaXB0b3JQcm90by5kZWNvZGUoZGVzY3JpcHRvcik7XG5cbiAgICB2YXIgc2VydmljZSA9IG5ldyBTZXJ2aWNlKGRlc2NyaXB0b3IubmFtZSAmJiBkZXNjcmlwdG9yLm5hbWUubGVuZ3RoID8gZGVzY3JpcHRvci5uYW1lIDogXCJTZXJ2aWNlXCIgKyB1bm5hbWVkU2VydmljZUluZGV4KyssIGZyb21EZXNjcmlwdG9yT3B0aW9ucyhkZXNjcmlwdG9yLm9wdGlvbnMsIGV4cG9ydHMuU2VydmljZU9wdGlvbnMpKTtcbiAgICBpZiAoIW5lc3RlZClcbiAgICAgICAgc2VydmljZS5fZWRpdGlvbiA9IGVkaXRpb247XG4gICAgaWYgKGRlc2NyaXB0b3IubWV0aG9kKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlc2NyaXB0b3IubWV0aG9kLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgc2VydmljZS5hZGQoTWV0aG9kLmZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IubWV0aG9kW2ldKSk7XG5cbiAgICByZXR1cm4gc2VydmljZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBzZXJ2aWNlIHRvIGEgZGVzY3JpcHRvci5cbiAqIEByZXR1cm5zIHtNZXNzYWdlPElTZXJ2aWNlRGVzY3JpcHRvclByb3RvPn0gRGVzY3JpcHRvclxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3IoKSB7XG5cbiAgICAvLyBNZXRob2RzXG4gICAgdmFyIG1ldGhvZHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubWV0aG9kc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBtZXRob2RzLnB1c2godGhpcy5fbWV0aG9kc0FycmF5W2ldLnRvRGVzY3JpcHRvcigpKTtcblxuICAgIHJldHVybiBleHBvcnRzLlNlcnZpY2VEZXNjcmlwdG9yUHJvdG8uY3JlYXRlKHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICBtZXRob2Q6IG1ldGhvZHMsXG4gICAgICAgIG9wdGlvbnM6IHRvRGVzY3JpcHRvck9wdGlvbnModGhpcy5vcHRpb25zLCBleHBvcnRzLlNlcnZpY2VPcHRpb25zKVxuICAgIH0pO1xufTtcblxuLy8gLS0tIE1ldGhvZCAtLS1cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIG9mIGEgTWV0aG9kRGVzY3JpcHRvclByb3RvIG1lc3NhZ2UuXG4gKiBAaW50ZXJmYWNlIElNZXRob2REZXNjcmlwdG9yUHJvdG9cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbmFtZV0gTWV0aG9kIG5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbaW5wdXRUeXBlXSBSZXF1ZXN0IHR5cGUgbmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtvdXRwdXRUeXBlXSBSZXNwb25zZSB0eXBlIG5hbWVcbiAqIEBwcm9wZXJ0eSB7SU1ldGhvZE9wdGlvbnN9IFtvcHRpb25zXSBOb3Qgc3VwcG9ydGVkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtjbGllbnRTdHJlYW1pbmc9ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzZXJ2ZXJTdHJlYW1pbmc9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBzdHJlYW1lZFxuICovXG5cbi8qKlxuICogUHJvcGVydGllcyBvZiBhIE1ldGhvZE9wdGlvbnMgbWVzc2FnZS5cbiAqXG4gKiBXYXJuaW5nOiB0aGlzIGlzIG5vdCBzYWZlIHRvIHVzZSB3aXRoIGVkaXRpb25zIHByb3Rvcywgc2luY2UgaXQgZGlzY2FyZHMgcmVsZXZhbnQgZmlsZSBjb250ZXh0LlxuICpcbiAqIEBpbnRlcmZhY2UgSU1ldGhvZE9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RlcHJlY2F0ZWRdXG4gKi9cblxudmFyIHVubmFtZWRNZXRob2RJbmRleCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1ldGhvZCBmcm9tIGEgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SU1ldGhvZERlc2NyaXB0b3JQcm90b3xSZWFkZXJ8VWludDhBcnJheX0gZGVzY3JpcHRvciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7TWV0aG9kfSBSZWZsZWN0ZWQgbWV0aG9kIGluc3RhbmNlXG4gKi9cbk1ldGhvZC5mcm9tRGVzY3JpcHRvciA9IGZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yKGRlc2NyaXB0b3IpIHtcblxuICAgIC8vIERlY29kZSB0aGUgZGVzY3JpcHRvciBtZXNzYWdlIGlmIHNwZWNpZmllZCBhcyBhIGJ1ZmZlcjpcbiAgICBpZiAodHlwZW9mIGRlc2NyaXB0b3IubGVuZ3RoID09PSBcIm51bWJlclwiKVxuICAgICAgICBkZXNjcmlwdG9yID0gZXhwb3J0cy5NZXRob2REZXNjcmlwdG9yUHJvdG8uZGVjb2RlKGRlc2NyaXB0b3IpO1xuXG4gICAgcmV0dXJuIG5ldyBNZXRob2QoXG4gICAgICAgIC8vIHVubmFtZWRNZXRob2RJbmRleCBpcyBnbG9iYWwsIG5vdCBwZXIgc2VydmljZSwgYmVjYXVzZSB3ZSBoYXZlIG5vIHJlZiB0byBhIHNlcnZpY2UgaGVyZVxuICAgICAgICBkZXNjcmlwdG9yLm5hbWUgJiYgZGVzY3JpcHRvci5uYW1lLmxlbmd0aCA/IGRlc2NyaXB0b3IubmFtZSA6IFwiTWV0aG9kXCIgKyB1bm5hbWVkTWV0aG9kSW5kZXgrKyxcbiAgICAgICAgXCJycGNcIixcbiAgICAgICAgZGVzY3JpcHRvci5pbnB1dFR5cGUsXG4gICAgICAgIGRlc2NyaXB0b3Iub3V0cHV0VHlwZSxcbiAgICAgICAgQm9vbGVhbihkZXNjcmlwdG9yLmNsaWVudFN0cmVhbWluZyksXG4gICAgICAgIEJvb2xlYW4oZGVzY3JpcHRvci5zZXJ2ZXJTdHJlYW1pbmcpLFxuICAgICAgICBmcm9tRGVzY3JpcHRvck9wdGlvbnMoZGVzY3JpcHRvci5vcHRpb25zLCBleHBvcnRzLk1ldGhvZE9wdGlvbnMpXG4gICAgKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBtZXRob2QgdG8gYSBkZXNjcmlwdG9yLlxuICogQHJldHVybnMge01lc3NhZ2U8SU1ldGhvZERlc2NyaXB0b3JQcm90bz59IERlc2NyaXB0b3JcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS50b0Rlc2NyaXB0b3IgPSBmdW5jdGlvbiB0b0Rlc2NyaXB0b3IoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuTWV0aG9kRGVzY3JpcHRvclByb3RvLmNyZWF0ZSh7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgaW5wdXRUeXBlOiB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUgPyB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUuZnVsbE5hbWUgOiB0aGlzLnJlcXVlc3RUeXBlLFxuICAgICAgICBvdXRwdXRUeXBlOiB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID8gdGhpcy5yZXNvbHZlZFJlc3BvbnNlVHlwZS5mdWxsTmFtZSA6IHRoaXMucmVzcG9uc2VUeXBlLFxuICAgICAgICBjbGllbnRTdHJlYW1pbmc6IHRoaXMucmVxdWVzdFN0cmVhbSxcbiAgICAgICAgc2VydmVyU3RyZWFtaW5nOiB0aGlzLnJlc3BvbnNlU3RyZWFtLFxuICAgICAgICBvcHRpb25zOiB0b0Rlc2NyaXB0b3JPcHRpb25zKHRoaXMub3B0aW9ucywgZXhwb3J0cy5NZXRob2RPcHRpb25zKVxuICAgIH0pO1xufTtcblxuLy8gLS0tIHV0aWxpdHkgLS0tXG5cbi8vIENvbnZlcnRzIGEgZGVzY3JpcHRvciB0eXBlIHRvIGEgcHJvdG9idWYuanMgYmFzaWMgdHlwZVxuZnVuY3Rpb24gZnJvbURlc2NyaXB0b3JUeXBlKHR5cGUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzXG4gICAgICAgIGNhc2UgMTogcmV0dXJuIFwiZG91YmxlXCI7XG4gICAgICAgIGNhc2UgMjogcmV0dXJuIFwiZmxvYXRcIjtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gXCJpbnQ2NFwiO1xuICAgICAgICBjYXNlIDQ6IHJldHVybiBcInVpbnQ2NFwiO1xuICAgICAgICBjYXNlIDU6IHJldHVybiBcImludDMyXCI7XG4gICAgICAgIGNhc2UgNjogcmV0dXJuIFwiZml4ZWQ2NFwiO1xuICAgICAgICBjYXNlIDc6IHJldHVybiBcImZpeGVkMzJcIjtcbiAgICAgICAgY2FzZSA4OiByZXR1cm4gXCJib29sXCI7XG4gICAgICAgIGNhc2UgOTogcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIGNhc2UgMTI6IHJldHVybiBcImJ5dGVzXCI7XG4gICAgICAgIGNhc2UgMTM6IHJldHVybiBcInVpbnQzMlwiO1xuICAgICAgICBjYXNlIDE1OiByZXR1cm4gXCJzZml4ZWQzMlwiO1xuICAgICAgICBjYXNlIDE2OiByZXR1cm4gXCJzZml4ZWQ2NFwiO1xuICAgICAgICBjYXNlIDE3OiByZXR1cm4gXCJzaW50MzJcIjtcbiAgICAgICAgY2FzZSAxODogcmV0dXJuIFwic2ludDY0XCI7XG4gICAgfVxuICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHR5cGUpO1xufVxuXG4vLyBUZXN0cyBpZiBhIGRlc2NyaXB0b3IgdHlwZSBpcyBwYWNrYWJsZVxuZnVuY3Rpb24gcGFja2FibGVEZXNjcmlwdG9yVHlwZSh0eXBlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgMTogLy8gZG91YmxlXG4gICAgICAgIGNhc2UgMjogLy8gZmxvYXRcbiAgICAgICAgY2FzZSAzOiAvLyBpbnQ2NFxuICAgICAgICBjYXNlIDQ6IC8vIHVpbnQ2NFxuICAgICAgICBjYXNlIDU6IC8vIGludDMyXG4gICAgICAgIGNhc2UgNjogLy8gZml4ZWQ2NFxuICAgICAgICBjYXNlIDc6IC8vIGZpeGVkMzJcbiAgICAgICAgY2FzZSA4OiAvLyBib29sXG4gICAgICAgIGNhc2UgMTM6IC8vIHVpbnQzMlxuICAgICAgICBjYXNlIDE0OiAvLyBlbnVtICghKVxuICAgICAgICBjYXNlIDE1OiAvLyBzZml4ZWQzMlxuICAgICAgICBjYXNlIDE2OiAvLyBzZml4ZWQ2NFxuICAgICAgICBjYXNlIDE3OiAvLyBzaW50MzJcbiAgICAgICAgY2FzZSAxODogLy8gc2ludDY0XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBDb252ZXJ0cyBhIHByb3RvYnVmLmpzIGJhc2ljIHR5cGUgdG8gYSBkZXNjcmlwdG9yIHR5cGVcbmZ1bmN0aW9uIHRvRGVzY3JpcHRvclR5cGUodHlwZSwgcmVzb2x2ZWRUeXBlLCBkZWxpbWl0ZWQpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgLy8gMCBpcyByZXNlcnZlZCBmb3IgZXJyb3JzXG4gICAgICAgIGNhc2UgXCJkb3VibGVcIjogcmV0dXJuIDE7XG4gICAgICAgIGNhc2UgXCJmbG9hdFwiOiByZXR1cm4gMjtcbiAgICAgICAgY2FzZSBcImludDY0XCI6IHJldHVybiAzO1xuICAgICAgICBjYXNlIFwidWludDY0XCI6IHJldHVybiA0O1xuICAgICAgICBjYXNlIFwiaW50MzJcIjogcmV0dXJuIDU7XG4gICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6IHJldHVybiA2O1xuICAgICAgICBjYXNlIFwiZml4ZWQzMlwiOiByZXR1cm4gNztcbiAgICAgICAgY2FzZSBcImJvb2xcIjogcmV0dXJuIDg7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjogcmV0dXJuIDk7XG4gICAgICAgIGNhc2UgXCJieXRlc1wiOiByZXR1cm4gMTI7XG4gICAgICAgIGNhc2UgXCJ1aW50MzJcIjogcmV0dXJuIDEzO1xuICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjogcmV0dXJuIDE1O1xuICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogcmV0dXJuIDE2O1xuICAgICAgICBjYXNlIFwic2ludDMyXCI6IHJldHVybiAxNztcbiAgICAgICAgY2FzZSBcInNpbnQ2NFwiOiByZXR1cm4gMTg7XG4gICAgfVxuICAgIGlmIChyZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKVxuICAgICAgICByZXR1cm4gMTQ7XG4gICAgaWYgKHJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgIHJldHVybiBkZWxpbWl0ZWQgPyAxMCA6IDExO1xuICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCB0eXBlOiBcIiArIHR5cGUpO1xufVxuXG5mdW5jdGlvbiBmcm9tRGVzY3JpcHRvck9wdGlvbnNSZWN1cnNpdmUob2JqLCB0eXBlKSB7XG4gICAgdmFyIHZhbCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZCwga2V5OyBpIDwgdHlwZS5maWVsZHNBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoKGtleSA9IChmaWVsZCA9IHR5cGUuX2ZpZWxkc0FycmF5W2ldKS5uYW1lKSA9PT0gXCJ1bmludGVycHJldGVkT3B0aW9uXCIpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBuZXdLZXkgPSB1bmRlclNjb3JlKGtleSk7XG4gICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBUeXBlKSB7XG4gICAgICAgICAgICB2YWxbbmV3S2V5XSA9IGZyb21EZXNjcmlwdG9yT3B0aW9uc1JlY3Vyc2l2ZShvYmpba2V5XSwgZmllbGQucmVzb2x2ZWRUeXBlKTtcbiAgICAgICAgfSBlbHNlIGlmKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIHtcbiAgICAgICAgICAgIHZhbFtuZXdLZXldID0gZmllbGQucmVzb2x2ZWRUeXBlLnZhbHVlc0J5SWRbb2JqW2tleV1dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsW25ld0tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG4vLyBDb252ZXJ0cyBkZXNjcmlwdG9yIG9wdGlvbnMgdG8gYW4gb3B0aW9ucyBvYmplY3RcbmZ1bmN0aW9uIGZyb21EZXNjcmlwdG9yT3B0aW9ucyhvcHRpb25zLCB0eXBlKSB7XG4gICAgaWYgKCFvcHRpb25zKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBmcm9tRGVzY3JpcHRvck9wdGlvbnNSZWN1cnNpdmUodHlwZS50b09iamVjdChvcHRpb25zKSwgdHlwZSk7XG59XG5cbmZ1bmN0aW9uIHRvRGVzY3JpcHRvck9wdGlvbnNSZWN1cnNpdmUob2JqLCB0eXBlKSB7XG4gICAgdmFyIHZhbCA9IHt9O1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgIHZhciBuZXdLZXkgPSAkcHJvdG9idWYudXRpbC5jYW1lbENhc2Uoa2V5KTtcbiAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodHlwZS5maWVsZHMsIG5ld0tleSkpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgZmllbGQgPSB0eXBlLmZpZWxkc1tuZXdLZXldO1xuICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgVHlwZSkge1xuICAgICAgICAgICAgdmFsW25ld0tleV0gPSB0b0Rlc2NyaXB0b3JPcHRpb25zUmVjdXJzaXZlKG9ialtrZXldLCBmaWVsZC5yZXNvbHZlZFR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsW25ld0tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQucmVwZWF0ZWQgJiYgIUFycmF5LmlzQXJyYXkodmFsW25ld0tleV0pKSB7XG4gICAgICAgICAgICB2YWxbbmV3S2V5XSA9IFt2YWxbbmV3S2V5XV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbDtcbn1cblxuLy8gQ29udmVydHMgYW4gb3B0aW9ucyBvYmplY3QgdG8gZGVzY3JpcHRvciBvcHRpb25zXG5mdW5jdGlvbiB0b0Rlc2NyaXB0b3JPcHRpb25zKG9wdGlvbnMsIHR5cGUpIHtcbiAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHR5cGUuZnJvbU9iamVjdCh0b0Rlc2NyaXB0b3JPcHRpb25zUmVjdXJzaXZlKG9wdGlvbnMsIHR5cGUpKTtcbn1cblxuLy8gQ2FsY3VsYXRlcyB0aGUgc2hvcnRlc3QgcmVsYXRpdmUgcGF0aCBmcm9tIGBmcm9tYCB0byBgdG9gLlxuZnVuY3Rpb24gc2hvcnRuYW1lKGZyb20sIHRvKSB7XG4gICAgdmFyIGZyb21QYXRoID0gZnJvbS5mdWxsTmFtZS5zcGxpdChcIi5cIiksXG4gICAgICAgIHRvUGF0aCA9IHRvLmZ1bGxOYW1lLnNwbGl0KFwiLlwiKSxcbiAgICAgICAgaSA9IDAsXG4gICAgICAgIGogPSAwLFxuICAgICAgICBrID0gdG9QYXRoLmxlbmd0aCAtIDE7XG4gICAgaWYgKCEoZnJvbSBpbnN0YW5jZW9mIFJvb3QpICYmIHRvIGluc3RhbmNlb2YgTmFtZXNwYWNlKVxuICAgICAgICB3aGlsZSAoaSA8IGZyb21QYXRoLmxlbmd0aCAmJiBqIDwgayAmJiBmcm9tUGF0aFtpXSA9PT0gdG9QYXRoW2pdKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0by5sb29rdXAoZnJvbVBhdGhbaSsrXSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAob3RoZXIgIT09IG51bGwgJiYgb3RoZXIgIT09IHRvKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgKytqO1xuICAgICAgICB9XG4gICAgZWxzZVxuICAgICAgICBmb3IgKDsgaSA8IGZyb21QYXRoLmxlbmd0aCAmJiBqIDwgayAmJiBmcm9tUGF0aFtpXSA9PT0gdG9QYXRoW2pdOyArK2ksICsraik7XG4gICAgcmV0dXJuIHRvUGF0aC5zbGljZShqKS5qb2luKFwiLlwiKTtcbn1cblxuLy8gY29waWVkIGhlcmUgZnJvbSBjbGkvdGFyZ2V0cy9wcm90by5qc1xuZnVuY3Rpb24gdW5kZXJTY29yZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnN1YnN0cmluZygwLDEpXG4gICAgICAgICArIHN0ci5zdWJzdHJpbmcoMSlcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oW0EtWl0pKD89W2Etel18JCkvZywgZnVuY3Rpb24oJDAsICQxKSB7IHJldHVybiBcIl9cIiArICQxLnRvTG93ZXJDYXNlKCk7IH0pO1xufVxuXG5mdW5jdGlvbiBlZGl0aW9uRnJvbURlc2NyaXB0b3IoZmlsZURlc2NyaXB0b3IpIHtcbiAgICBpZiAoZmlsZURlc2NyaXB0b3Iuc3ludGF4ID09PSBcImVkaXRpb25zXCIpIHtcbiAgICAgICAgc3dpdGNoKGZpbGVEZXNjcmlwdG9yLmVkaXRpb24pIHtcbiAgICAgICAgICAgIGNhc2UgZXhwb3J0cy5FZGl0aW9uLkVESVRJT05fMjAyMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIyMDIzXCI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGVkaXRpb24gXCIgKyBmaWxlRGVzY3JpcHRvci5lZGl0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmlsZURlc2NyaXB0b3Iuc3ludGF4ID09PSBcInByb3RvM1wiKSB7XG4gICAgICAgIHJldHVybiBcInByb3RvM1wiO1xuICAgIH1cbiAgICByZXR1cm4gXCJwcm90bzJcIjtcbn1cblxuZnVuY3Rpb24gZWRpdGlvblRvRGVzY3JpcHRvcihlZGl0aW9uLCBmaWxlRGVzY3JpcHRvcikge1xuICAgIGlmICghZWRpdGlvbikgcmV0dXJuO1xuICAgIGlmIChlZGl0aW9uID09PSBcInByb3RvMlwiIHx8IGVkaXRpb24gPT09IFwicHJvdG8zXCIpIHtcbiAgICAgICAgZmlsZURlc2NyaXB0b3Iuc3ludGF4ID0gZWRpdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmaWxlRGVzY3JpcHRvci5zeW50YXggPSBcImVkaXRpb25zXCI7XG4gICAgICAgIHN3aXRjaChlZGl0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFwiMjAyM1wiOlxuICAgICAgICAgICAgICAgIGZpbGVEZXNjcmlwdG9yLmVkaXRpb24gPSBleHBvcnRzLkVkaXRpb24uRURJVElPTl8yMDIzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBlZGl0aW9uIFwiICsgZWRpdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIC0tLSBleHBvcnRzIC0tLVxuXG4vKipcbiAqIFJlZmxlY3RlZCBmaWxlIGRlc2NyaXB0b3Igc2V0LlxuICogQG5hbWUgRmlsZURlc2NyaXB0b3JTZXRcbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZmlsZSBkZXNjcmlwdG9yIHByb3RvLlxuICogQG5hbWUgRmlsZURlc2NyaXB0b3JQcm90b1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBkZXNjcmlwdG9yIHByb3RvLlxuICogQG5hbWUgRGVzY3JpcHRvclByb3RvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBwcm9wZXJ0eSB7VHlwZX0gRXh0ZW5zaW9uUmFuZ2VcbiAqIEBwcm9wZXJ0eSB7VHlwZX0gUmVzZXJ2ZWRSYW5nZVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xuICogICAgIEV4dGVuc2lvblJhbmdlOiAkcHJvdG9idWYuVHlwZSxcbiAqICAgICBSZXNlcnZlZFJhbmdlOiAkcHJvdG9idWYuVHlwZVxuICogfVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGZpZWxkIGRlc2NyaXB0b3IgcHJvdG8uXG4gKiBAbmFtZSBGaWVsZERlc2NyaXB0b3JQcm90b1xuICogQHR5cGUge1R5cGV9XG4gKiBAcHJvcGVydHkge0VudW19IExhYmVsXG4gKiBAcHJvcGVydHkge0VudW19IFR5cGVcbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZSAmIHtcbiAqICAgICBMYWJlbDogJHByb3RvYnVmLkVudW0sXG4gKiAgICAgVHlwZTogJHByb3RvYnVmLkVudW1cbiAqIH1cbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBvbmVvZiBkZXNjcmlwdG9yIHByb3RvLlxuICogQG5hbWUgT25lb2ZEZXNjcmlwdG9yUHJvdG9cbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgZW51bSBkZXNjcmlwdG9yIHByb3RvLlxuICogQG5hbWUgRW51bURlc2NyaXB0b3JQcm90b1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBzZXJ2aWNlIGRlc2NyaXB0b3IgcHJvdG8uXG4gKiBAbmFtZSBTZXJ2aWNlRGVzY3JpcHRvclByb3RvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGVudW0gdmFsdWUgZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIEVudW1WYWx1ZURlc2NyaXB0b3JQcm90b1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBtZXRob2QgZGVzY3JpcHRvciBwcm90by5cbiAqIEBuYW1lIE1ldGhvZERlc2NyaXB0b3JQcm90b1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBmaWxlIG9wdGlvbnMuXG4gKiBAbmFtZSBGaWxlT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAcHJvcGVydHkge0VudW19IE9wdGltaXplTW9kZVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlICYge1xuICogICAgIE9wdGltaXplTW9kZTogJHByb3RvYnVmLkVudW1cbiAqIH1cbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBtZXNzYWdlIG9wdGlvbnMuXG4gKiBAbmFtZSBNZXNzYWdlT3B0aW9uc1xuICogQHR5cGUge1R5cGV9XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGVcbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBmaWVsZCBvcHRpb25zLlxuICogQG5hbWUgRmllbGRPcHRpb25zXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBwcm9wZXJ0eSB7RW51bX0gQ1R5cGVcbiAqIEBwcm9wZXJ0eSB7RW51bX0gSlNUeXBlXG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGUgJiB7XG4gKiAgICAgQ1R5cGU6ICRwcm90b2J1Zi5FbnVtLFxuICogICAgIEpTVHlwZTogJHByb3RvYnVmLkVudW1cbiAqIH1cbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBvbmVvZiBvcHRpb25zLlxuICogQG5hbWUgT25lb2ZPcHRpb25zXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGVudW0gb3B0aW9ucy5cbiAqIEBuYW1lIEVudW1PcHRpb25zXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIGVudW0gdmFsdWUgb3B0aW9ucy5cbiAqIEBuYW1lIEVudW1WYWx1ZU9wdGlvbnNcbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgc2VydmljZSBvcHRpb25zLlxuICogQG5hbWUgU2VydmljZU9wdGlvbnNcbiAqIEB0eXBlIHtUeXBlfVxuICogQGNvbnN0XG4gKiBAdHN0eXBlICRwcm90b2J1Zi5UeXBlXG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgbWV0aG9kIG9wdGlvbnMuXG4gKiBAbmFtZSBNZXRob2RPcHRpb25zXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZVxuICovXG5cbi8qKlxuICogUmVmbGVjdGVkIHVuaW50ZXJwcmV0ZXQgb3B0aW9uLlxuICogQG5hbWUgVW5pbnRlcnByZXRlZE9wdGlvblxuICogQHR5cGUge1R5cGV9XG4gKiBAcHJvcGVydHkge1R5cGV9IE5hbWVQYXJ0XG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGUgJiB7XG4gKiAgICAgTmFtZVBhcnQ6ICRwcm90b2J1Zi5UeXBlXG4gKiB9XG4gKi9cblxuLyoqXG4gKiBSZWZsZWN0ZWQgc291cmNlIGNvZGUgaW5mby5cbiAqIEBuYW1lIFNvdXJjZUNvZGVJbmZvXG4gKiBAdHlwZSB7VHlwZX1cbiAqIEBwcm9wZXJ0eSB7VHlwZX0gTG9jYXRpb25cbiAqIEBjb25zdFxuICogQHRzdHlwZSAkcHJvdG9idWYuVHlwZSAmIHtcbiAqICAgICBMb2NhdGlvbjogJHByb3RvYnVmLlR5cGVcbiAqIH1cbiAqL1xuXG4vKipcbiAqIFJlZmxlY3RlZCBnZW5lcmF0ZWQgY29kZSBpbmZvLlxuICogQG5hbWUgR2VuZXJhdGVkQ29kZUluZm9cbiAqIEB0eXBlIHtUeXBlfVxuICogQHByb3BlcnR5IHtUeXBlfSBBbm5vdGF0aW9uXG4gKiBAY29uc3RcbiAqIEB0c3R5cGUgJHByb3RvYnVmLlR5cGUgJiB7XG4gKiAgICAgQW5ub3RhdGlvbjogJHByb3RvYnVmLlR5cGVcbiAqIH1cbiAqL1xuIl0sIm5hbWVzIjpbIiRwcm90b2J1ZiIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwiZGVzY3JpcHRvciIsIlJvb3QiLCJmcm9tSlNPTiIsImxvb2t1cCIsIk5hbWVzcGFjZSIsIkVudW0iLCJUeXBlIiwiRmllbGQiLCJNYXBGaWVsZCIsIk9uZU9mIiwiU2VydmljZSIsIk1ldGhvZCIsImZyb21EZXNjcmlwdG9yIiwibGVuZ3RoIiwiRmlsZURlc2NyaXB0b3JTZXQiLCJkZWNvZGUiLCJyb290IiwiZmlsZSIsImZpbGVEZXNjcmlwdG9yIiwiZmlsZVBhY2thZ2UiLCJqIiwiaSIsImRlZmluZSIsImVkaXRpb24iLCJlZGl0aW9uRnJvbURlc2NyaXB0b3IiLCJuYW1lIiwiZmlsZXMiLCJwdXNoIiwiZmlsZW5hbWUiLCJtZXNzYWdlVHlwZSIsImFkZCIsImVudW1UeXBlIiwiZXh0ZW5zaW9uIiwic2VydmljZSIsIm9wdHMiLCJmcm9tRGVzY3JpcHRvck9wdGlvbnMiLCJvcHRpb25zIiwiRmlsZU9wdGlvbnMiLCJrcyIsIk9iamVjdCIsImtleXMiLCJzZXRPcHRpb24iLCJyZXNvbHZlQWxsIiwicHJvdG90eXBlIiwidG9EZXNjcmlwdG9yIiwic2V0IiwiY3JlYXRlIiwiUm9vdF90b0Rlc2NyaXB0b3JSZWN1cnNpdmUiLCJucyIsIkZpbGVEZXNjcmlwdG9yUHJvdG8iLCJmdWxsTmFtZSIsInN1YnN0cmluZyIsInJlcGxhY2UiLCJlZGl0aW9uVG9EZXNjcmlwdG9yIiwibmVzdGVkIiwibmVzdGVkQXJyYXkiLCJfbmVzdGVkQXJyYXkiLCJ0b0Rlc2NyaXB0b3JPcHRpb25zIiwidW5uYW1lZE1lc3NhZ2VJbmRleCIsIkRlc2NyaXB0b3JQcm90byIsInR5cGUiLCJNZXNzYWdlT3B0aW9ucyIsIl9lZGl0aW9uIiwib25lb2ZEZWNsIiwiZmllbGQiLCJoYXNPd25Qcm9wZXJ0eSIsIm9uZW9mc0FycmF5Iiwib25lb2ZJbmRleCIsIm5lc3RlZFR5cGUiLCJtYXBFbnRyeSIsImV4dGVuc2lvblJhbmdlIiwiZXh0ZW5zaW9ucyIsInN0YXJ0IiwiZW5kIiwicmVzZXJ2ZWRSYW5nZSIsInJlc2VydmVkTmFtZSIsInJlc2VydmVkIiwiZmllbGRzQXJyYXkiLCJmaWVsZERlc2NyaXB0b3IiLCJfZmllbGRzQXJyYXkiLCJrZXlUeXBlIiwidG9EZXNjcmlwdG9yVHlwZSIsInJlc29sdmVkS2V5VHlwZSIsInZhbHVlVHlwZSIsInJlc29sdmVkVHlwZSIsInZhbHVlVHlwZU5hbWUiLCJzaG9ydG5hbWUiLCJwYXJlbnQiLCJ1bmRlZmluZWQiLCJ0eXBlTmFtZSIsIkZpZWxkRGVzY3JpcHRvclByb3RvIiwibnVtYmVyIiwibGFiZWwiLCJfb25lb2ZzQXJyYXkiLCJFeHRlbnNpb25SYW5nZSIsIlJlc2VydmVkUmFuZ2UiLCJudW1iZXJSZSIsIkVycm9yIiwiZmllbGRUeXBlIiwiZnJvbURlc2NyaXB0b3JUeXBlIiwiZmllbGRSdWxlIiwiZXh0ZW5kZWUiLCJGaWVsZE9wdGlvbnMiLCJwcm90bzNfb3B0aW9uYWwiLCJkZWZhdWx0VmFsdWUiLCJtYXRjaCIsImV4ZWMiLCJwYXJzZUludCIsInBhY2thYmxlRGVzY3JpcHRvclR5cGUiLCJwYWNrZWQiLCJpZCIsIm1hcCIsInV0aWwiLCJ1Y0ZpcnN0IiwicmVzb2x2ZSIsImRlbGltaXRlZCIsInJ1bGUiLCJyZXF1aXJlZCIsImV4dGVuc2lvbkZpZWxkIiwiZXh0ZW5kIiwicGFydE9mIiwiaW5kZXhPZiIsIlN0cmluZyIsInVubmFtZWRFbnVtSW5kZXgiLCJFbnVtRGVzY3JpcHRvclByb3RvIiwidmFsdWVzIiwidmFsdWUiLCJlbm0iLCJFbnVtT3B0aW9ucyIsIkVudW1WYWx1ZURlc2NyaXB0b3JQcm90byIsInVubmFtZWRPbmVvZkluZGV4IiwiT25lb2ZEZXNjcmlwdG9yUHJvdG8iLCJ1bm5hbWVkU2VydmljZUluZGV4IiwiU2VydmljZURlc2NyaXB0b3JQcm90byIsIlNlcnZpY2VPcHRpb25zIiwibWV0aG9kIiwibWV0aG9kcyIsIm1ldGhvZHNBcnJheSIsIl9tZXRob2RzQXJyYXkiLCJ1bm5hbWVkTWV0aG9kSW5kZXgiLCJNZXRob2REZXNjcmlwdG9yUHJvdG8iLCJpbnB1dFR5cGUiLCJvdXRwdXRUeXBlIiwiQm9vbGVhbiIsImNsaWVudFN0cmVhbWluZyIsInNlcnZlclN0cmVhbWluZyIsIk1ldGhvZE9wdGlvbnMiLCJyZXNvbHZlZFJlcXVlc3RUeXBlIiwicmVxdWVzdFR5cGUiLCJyZXNvbHZlZFJlc3BvbnNlVHlwZSIsInJlc3BvbnNlVHlwZSIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsImZyb21EZXNjcmlwdG9yT3B0aW9uc1JlY3Vyc2l2ZSIsIm9iaiIsInZhbCIsImtleSIsImNhbGwiLCJuZXdLZXkiLCJ1bmRlclNjb3JlIiwidmFsdWVzQnlJZCIsInRvT2JqZWN0IiwidG9EZXNjcmlwdG9yT3B0aW9uc1JlY3Vyc2l2ZSIsImNhbWVsQ2FzZSIsImZpZWxkcyIsInJlcGVhdGVkIiwiQXJyYXkiLCJpc0FycmF5IiwiZnJvbU9iamVjdCIsImZyb20iLCJ0byIsImZyb21QYXRoIiwic3BsaXQiLCJ0b1BhdGgiLCJrIiwib3RoZXIiLCJzbGljZSIsImpvaW4iLCJzdHIiLCIkMCIsIiQxIiwidG9Mb3dlckNhc2UiLCJzeW50YXgiLCJFZGl0aW9uIiwiRURJVElPTl8yMDIzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/ext/descriptor/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// full library entry point.\n\nmodule.exports = __webpack_require__(/*! ./src/index */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSw0QkFBNEI7QUFFZjtBQUNiQSxrSUFBdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9pbmRleC5qcz9jOTczIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZ1bGwgbGlicmFyeSBlbnRyeSBwb2ludC5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3NyYy9pbmRleFwiKTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/common.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/common.js ***!
  \**************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = common;\nvar commonRe = /\\/|\\./;\n/**\n * Provides common type definitions.\n * Can also be used to provide additional google types or your own custom types.\n * @param {string} name Short name as in `google/protobuf/[name].proto` or full file name\n * @param {Object.<string,*>} json JSON definition within `google.protobuf` if a short name, otherwise the file's root definition\n * @returns {undefined}\n * @property {INamespace} google/protobuf/any.proto Any\n * @property {INamespace} google/protobuf/duration.proto Duration\n * @property {INamespace} google/protobuf/empty.proto Empty\n * @property {INamespace} google/protobuf/field_mask.proto FieldMask\n * @property {INamespace} google/protobuf/struct.proto Struct, Value, NullValue and ListValue\n * @property {INamespace} google/protobuf/timestamp.proto Timestamp\n * @property {INamespace} google/protobuf/wrappers.proto Wrappers\n * @example\n * // manually provides descriptor.proto (assumes google/protobuf/ namespace and .proto extension)\n * protobuf.common(\"descriptor\", descriptorJson);\n *\n * // manually provides a custom definition (uses my.foo namespace)\n * protobuf.common(\"my/foo/bar.proto\", myFooBarJson);\n */ function common(name, json) {\n    if (!commonRe.test(name)) {\n        name = \"google/protobuf/\" + name + \".proto\";\n        json = {\n            nested: {\n                google: {\n                    nested: {\n                        protobuf: {\n                            nested: json\n                        }\n                    }\n                }\n            }\n        };\n    }\n    common[name] = json;\n}\n// Not provided because of limited use (feel free to discuss or to provide yourself):\n//\n// google/protobuf/descriptor.proto\n// google/protobuf/source_context.proto\n// google/protobuf/type.proto\n//\n// Stripped and pre-parsed versions of these non-bundled files are instead available as part of\n// the repository or package within the google/protobuf directory.\ncommon(\"any\", {\n    /**\n     * Properties of a google.protobuf.Any message.\n     * @interface IAny\n     * @type {Object}\n     * @property {string} [typeUrl]\n     * @property {Uint8Array} [bytes]\n     * @memberof common\n     */ Any: {\n        fields: {\n            type_url: {\n                type: \"string\",\n                id: 1\n            },\n            value: {\n                type: \"bytes\",\n                id: 2\n            }\n        }\n    }\n});\nvar timeType;\ncommon(\"duration\", {\n    /**\n     * Properties of a google.protobuf.Duration message.\n     * @interface IDuration\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */ Duration: timeType = {\n        fields: {\n            seconds: {\n                type: \"int64\",\n                id: 1\n            },\n            nanos: {\n                type: \"int32\",\n                id: 2\n            }\n        }\n    }\n});\ncommon(\"timestamp\", {\n    /**\n     * Properties of a google.protobuf.Timestamp message.\n     * @interface ITimestamp\n     * @type {Object}\n     * @property {number|Long} [seconds]\n     * @property {number} [nanos]\n     * @memberof common\n     */ Timestamp: timeType\n});\ncommon(\"empty\", {\n    /**\n     * Properties of a google.protobuf.Empty message.\n     * @interface IEmpty\n     * @memberof common\n     */ Empty: {\n        fields: {}\n    }\n});\ncommon(\"struct\", {\n    /**\n     * Properties of a google.protobuf.Struct message.\n     * @interface IStruct\n     * @type {Object}\n     * @property {Object.<string,IValue>} [fields]\n     * @memberof common\n     */ Struct: {\n        fields: {\n            fields: {\n                keyType: \"string\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Value message.\n     * @interface IValue\n     * @type {Object}\n     * @property {string} [kind]\n     * @property {0} [nullValue]\n     * @property {number} [numberValue]\n     * @property {string} [stringValue]\n     * @property {boolean} [boolValue]\n     * @property {IStruct} [structValue]\n     * @property {IListValue} [listValue]\n     * @memberof common\n     */ Value: {\n        oneofs: {\n            kind: {\n                oneof: [\n                    \"nullValue\",\n                    \"numberValue\",\n                    \"stringValue\",\n                    \"boolValue\",\n                    \"structValue\",\n                    \"listValue\"\n                ]\n            }\n        },\n        fields: {\n            nullValue: {\n                type: \"NullValue\",\n                id: 1\n            },\n            numberValue: {\n                type: \"double\",\n                id: 2\n            },\n            stringValue: {\n                type: \"string\",\n                id: 3\n            },\n            boolValue: {\n                type: \"bool\",\n                id: 4\n            },\n            structValue: {\n                type: \"Struct\",\n                id: 5\n            },\n            listValue: {\n                type: \"ListValue\",\n                id: 6\n            }\n        }\n    },\n    NullValue: {\n        values: {\n            NULL_VALUE: 0\n        }\n    },\n    /**\n     * Properties of a google.protobuf.ListValue message.\n     * @interface IListValue\n     * @type {Object}\n     * @property {Array.<IValue>} [values]\n     * @memberof common\n     */ ListValue: {\n        fields: {\n            values: {\n                rule: \"repeated\",\n                type: \"Value\",\n                id: 1\n            }\n        }\n    }\n});\ncommon(\"wrappers\", {\n    /**\n     * Properties of a google.protobuf.DoubleValue message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ DoubleValue: {\n        fields: {\n            value: {\n                type: \"double\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.FloatValue message.\n     * @interface IFloatValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ FloatValue: {\n        fields: {\n            value: {\n                type: \"float\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Int64Value message.\n     * @interface IInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */ Int64Value: {\n        fields: {\n            value: {\n                type: \"int64\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.UInt64Value message.\n     * @interface IUInt64Value\n     * @type {Object}\n     * @property {number|Long} [value]\n     * @memberof common\n     */ UInt64Value: {\n        fields: {\n            value: {\n                type: \"uint64\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.Int32Value message.\n     * @interface IInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ Int32Value: {\n        fields: {\n            value: {\n                type: \"int32\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.UInt32Value message.\n     * @interface IUInt32Value\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ UInt32Value: {\n        fields: {\n            value: {\n                type: \"uint32\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.BoolValue message.\n     * @interface IBoolValue\n     * @type {Object}\n     * @property {boolean} [value]\n     * @memberof common\n     */ BoolValue: {\n        fields: {\n            value: {\n                type: \"bool\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.StringValue message.\n     * @interface IStringValue\n     * @type {Object}\n     * @property {string} [value]\n     * @memberof common\n     */ StringValue: {\n        fields: {\n            value: {\n                type: \"string\",\n                id: 1\n            }\n        }\n    },\n    /**\n     * Properties of a google.protobuf.BytesValue message.\n     * @interface IBytesValue\n     * @type {Object}\n     * @property {Uint8Array} [value]\n     * @memberof common\n     */ BytesValue: {\n        fields: {\n            value: {\n                type: \"bytes\",\n                id: 1\n            }\n        }\n    }\n});\ncommon(\"field_mask\", {\n    /**\n     * Properties of a google.protobuf.FieldMask message.\n     * @interface IDoubleValue\n     * @type {Object}\n     * @property {number} [value]\n     * @memberof common\n     */ FieldMask: {\n        fields: {\n            paths: {\n                rule: \"repeated\",\n                type: \"string\",\n                id: 1\n            }\n        }\n    }\n});\n/**\n * Gets the root definition of the specified common proto file.\n *\n * Bundled definitions are:\n * - google/protobuf/any.proto\n * - google/protobuf/duration.proto\n * - google/protobuf/empty.proto\n * - google/protobuf/field_mask.proto\n * - google/protobuf/struct.proto\n * - google/protobuf/timestamp.proto\n * - google/protobuf/wrappers.proto\n *\n * @param {string} file Proto file name\n * @returns {INamespace|null} Root definition or `null` if not defined\n */ common.get = function get(file) {\n    return common[file] || null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvY29tbW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsV0FBVztBQUVmOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBbUJDLEdBQ0QsU0FBU0QsT0FBT0UsSUFBSSxFQUFFQyxJQUFJO0lBQ3RCLElBQUksQ0FBQ0YsU0FBU0csSUFBSSxDQUFDRixPQUFPO1FBQ3RCQSxPQUFPLHFCQUFxQkEsT0FBTztRQUNuQ0MsT0FBTztZQUFFRSxRQUFRO2dCQUFFQyxRQUFRO29CQUFFRCxRQUFRO3dCQUFFRSxVQUFVOzRCQUFFRixRQUFRRjt3QkFBSztvQkFBRTtnQkFBRTtZQUFFO1FBQUU7SUFDNUU7SUFDQUgsTUFBTSxDQUFDRSxLQUFLLEdBQUdDO0FBQ25CO0FBRUEscUZBQXFGO0FBQ3JGLEVBQUU7QUFDRixtQ0FBbUM7QUFDbkMsdUNBQXVDO0FBQ3ZDLDZCQUE2QjtBQUM3QixFQUFFO0FBQ0YsK0ZBQStGO0FBQy9GLGtFQUFrRTtBQUVsRUgsT0FBTyxPQUFPO0lBRVY7Ozs7Ozs7S0FPQyxHQUNEUSxLQUFLO1FBQ0RDLFFBQVE7WUFDSkMsVUFBVTtnQkFDTkMsTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1lBQ0FDLE9BQU87Z0JBQ0hGLE1BQU07Z0JBQ05DLElBQUk7WUFDUjtRQUNKO0lBQ0o7QUFDSjtBQUVBLElBQUlFO0FBRUpkLE9BQU8sWUFBWTtJQUVmOzs7Ozs7O0tBT0MsR0FDRGUsVUFBVUQsV0FBVztRQUNqQkwsUUFBUTtZQUNKTyxTQUFTO2dCQUNMTCxNQUFNO2dCQUNOQyxJQUFJO1lBQ1I7WUFDQUssT0FBTztnQkFDSE4sTUFBTTtnQkFDTkMsSUFBSTtZQUNSO1FBQ0o7SUFDSjtBQUNKO0FBRUFaLE9BQU8sYUFBYTtJQUVoQjs7Ozs7OztLQU9DLEdBQ0RrQixXQUFXSjtBQUNmO0FBRUFkLE9BQU8sU0FBUztJ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Ly4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2NvbW1vbi5qcz8wM2EwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBjb21tb247XG5cbnZhciBjb21tb25SZSA9IC9cXC98XFwuLztcblxuLyoqXG4gKiBQcm92aWRlcyBjb21tb24gdHlwZSBkZWZpbml0aW9ucy5cbiAqIENhbiBhbHNvIGJlIHVzZWQgdG8gcHJvdmlkZSBhZGRpdGlvbmFsIGdvb2dsZSB0eXBlcyBvciB5b3VyIG93biBjdXN0b20gdHlwZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTaG9ydCBuYW1lIGFzIGluIGBnb29nbGUvcHJvdG9idWYvW25hbWVdLnByb3RvYCBvciBmdWxsIGZpbGUgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0ganNvbiBKU09OIGRlZmluaXRpb24gd2l0aGluIGBnb29nbGUucHJvdG9idWZgIGlmIGEgc2hvcnQgbmFtZSwgb3RoZXJ3aXNlIHRoZSBmaWxlJ3Mgcm9vdCBkZWZpbml0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvYW55LnByb3RvIEFueVxuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvZHVyYXRpb24ucHJvdG8gRHVyYXRpb25cbiAqIEBwcm9wZXJ0eSB7SU5hbWVzcGFjZX0gZ29vZ2xlL3Byb3RvYnVmL2VtcHR5LnByb3RvIEVtcHR5XG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi9maWVsZF9tYXNrLnByb3RvIEZpZWxkTWFza1xuICogQHByb3BlcnR5IHtJTmFtZXNwYWNlfSBnb29nbGUvcHJvdG9idWYvc3RydWN0LnByb3RvIFN0cnVjdCwgVmFsdWUsIE51bGxWYWx1ZSBhbmQgTGlzdFZhbHVlXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi90aW1lc3RhbXAucHJvdG8gVGltZXN0YW1wXG4gKiBAcHJvcGVydHkge0lOYW1lc3BhY2V9IGdvb2dsZS9wcm90b2J1Zi93cmFwcGVycy5wcm90byBXcmFwcGVyc1xuICogQGV4YW1wbGVcbiAqIC8vIG1hbnVhbGx5IHByb3ZpZGVzIGRlc2NyaXB0b3IucHJvdG8gKGFzc3VtZXMgZ29vZ2xlL3Byb3RvYnVmLyBuYW1lc3BhY2UgYW5kIC5wcm90byBleHRlbnNpb24pXG4gKiBwcm90b2J1Zi5jb21tb24oXCJkZXNjcmlwdG9yXCIsIGRlc2NyaXB0b3JKc29uKTtcbiAqXG4gKiAvLyBtYW51YWxseSBwcm92aWRlcyBhIGN1c3RvbSBkZWZpbml0aW9uICh1c2VzIG15LmZvbyBuYW1lc3BhY2UpXG4gKiBwcm90b2J1Zi5jb21tb24oXCJteS9mb28vYmFyLnByb3RvXCIsIG15Rm9vQmFySnNvbik7XG4gKi9cbmZ1bmN0aW9uIGNvbW1vbihuYW1lLCBqc29uKSB7XG4gICAgaWYgKCFjb21tb25SZS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSBcImdvb2dsZS9wcm90b2J1Zi9cIiArIG5hbWUgKyBcIi5wcm90b1wiO1xuICAgICAgICBqc29uID0geyBuZXN0ZWQ6IHsgZ29vZ2xlOiB7IG5lc3RlZDogeyBwcm90b2J1ZjogeyBuZXN0ZWQ6IGpzb24gfSB9IH0gfSB9O1xuICAgIH1cbiAgICBjb21tb25bbmFtZV0gPSBqc29uO1xufVxuXG4vLyBOb3QgcHJvdmlkZWQgYmVjYXVzZSBvZiBsaW1pdGVkIHVzZSAoZmVlbCBmcmVlIHRvIGRpc2N1c3Mgb3IgdG8gcHJvdmlkZSB5b3Vyc2VsZik6XG4vL1xuLy8gZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IucHJvdG9cbi8vIGdvb2dsZS9wcm90b2J1Zi9zb3VyY2VfY29udGV4dC5wcm90b1xuLy8gZ29vZ2xlL3Byb3RvYnVmL3R5cGUucHJvdG9cbi8vXG4vLyBTdHJpcHBlZCBhbmQgcHJlLXBhcnNlZCB2ZXJzaW9ucyBvZiB0aGVzZSBub24tYnVuZGxlZCBmaWxlcyBhcmUgaW5zdGVhZCBhdmFpbGFibGUgYXMgcGFydCBvZlxuLy8gdGhlIHJlcG9zaXRvcnkgb3IgcGFja2FnZSB3aXRoaW4gdGhlIGdvb2dsZS9wcm90b2J1ZiBkaXJlY3RvcnkuXG5cbmNvbW1vbihcImFueVwiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkFueSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUFueVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlVXJsXVxuICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW2J5dGVzXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBBbnk6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB0eXBlX3VybDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYnl0ZXNcIixcbiAgICAgICAgICAgICAgICBpZDogMlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciB0aW1lVHlwZTtcblxuY29tbW9uKFwiZHVyYXRpb25cIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5EdXJhdGlvbiBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUR1cmF0aW9uXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbc2Vjb25kc11cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW25hbm9zXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBEdXJhdGlvbjogdGltZVR5cGUgPSB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgc2Vjb25kczoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW50NjRcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbm9zOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbnQzMlwiLFxuICAgICAgICAgICAgICAgIGlkOiAyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuY29tbW9uKFwidGltZXN0YW1wXCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJVGltZXN0YW1wXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcnxMb25nfSBbc2Vjb25kc11cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW25hbm9zXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBUaW1lc3RhbXA6IHRpbWVUeXBlXG59KTtcblxuY29tbW9uKFwiZW1wdHlcIiwge1xuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5FbXB0eSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUVtcHR5XG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEVtcHR5OiB7XG4gICAgICAgIGZpZWxkczoge31cbiAgICB9XG59KTtcblxuY29tbW9uKFwic3RydWN0XCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuU3RydWN0IG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJU3RydWN0XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLElWYWx1ZT59IFtmaWVsZHNdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFN0cnVjdDoge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgICAgIGtleVR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJWYWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5WYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW2tpbmRdXG4gICAgICogQHByb3BlcnR5IHswfSBbbnVsbFZhbHVlXVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyVmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IFtzdHJpbmdWYWx1ZV1cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IFtib29sVmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtJU3RydWN0fSBbc3RydWN0VmFsdWVdXG4gICAgICogQHByb3BlcnR5IHtJTGlzdFZhbHVlfSBbbGlzdFZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBWYWx1ZToge1xuICAgICAgICBvbmVvZnM6IHtcbiAgICAgICAgICAgIGtpbmQ6IHtcbiAgICAgICAgICAgICAgICBvbmVvZjogW1xuICAgICAgICAgICAgICAgICAgICBcIm51bGxWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcIm51bWJlclZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIFwic3RyaW5nVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJib29sVmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdHJ1Y3RWYWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBcImxpc3RWYWx1ZVwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIG51bGxWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiTnVsbFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudW1iZXJWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZG91YmxlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdHJpbmdWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib29sVmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xcIixcbiAgICAgICAgICAgICAgICBpZDogNFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHN0cnVjdFZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJTdHJ1Y3RcIixcbiAgICAgICAgICAgICAgICBpZDogNVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpc3RWYWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiTGlzdFZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDZcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBOdWxsVmFsdWU6IHtcbiAgICAgICAgdmFsdWVzOiB7XG4gICAgICAgICAgICBOVUxMX1ZBTFVFOiAwXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5MaXN0VmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElMaXN0VmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXkuPElWYWx1ZT59IFt2YWx1ZXNdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIExpc3RWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlczoge1xuICAgICAgICAgICAgICAgIHJ1bGU6IFwicmVwZWF0ZWRcIixcbiAgICAgICAgICAgICAgICB0eXBlOiBcIlZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb21tb24oXCJ3cmFwcGVyc1wiLCB7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkRvdWJsZVZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRG91YmxlVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIERvdWJsZVZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImRvdWJsZVwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5GbG9hdFZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRmxvYXRWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgRmxvYXRWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5JbnQ2NFZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJSW50NjRWYWx1ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ8TG9uZ30gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBJbnQ2NFZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludDY0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlVJbnQ2NFZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJVUludDY0VmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfExvbmd9IFt2YWx1ZV1cbiAgICAgKiBAbWVtYmVyb2YgY29tbW9uXG4gICAgICovXG4gICAgVUludDY0VmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidWludDY0XCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLkludDMyVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElJbnQzMlZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBJbnQzMlZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImludDMyXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0aWVzIG9mIGEgZ29vZ2xlLnByb3RvYnVmLlVJbnQzMlZhbHVlIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJVUludDMyVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIFVJbnQzMlZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVpbnQzMlwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5Cb29sVmFsdWUgbWVzc2FnZS5cbiAgICAgKiBAaW50ZXJmYWNlIElCb29sVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBCb29sVmFsdWU6IHtcbiAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbFwiLFxuICAgICAgICAgICAgICAgIGlkOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJvcGVydGllcyBvZiBhIGdvb2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSVN0cmluZ1ZhbHVlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBTdHJpbmdWYWx1ZToge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBpZDogMVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuQnl0ZXNWYWx1ZSBtZXNzYWdlLlxuICAgICAqIEBpbnRlcmZhY2UgSUJ5dGVzVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW3ZhbHVlXVxuICAgICAqIEBtZW1iZXJvZiBjb21tb25cbiAgICAgKi9cbiAgICBCeXRlc1ZhbHVlOiB7XG4gICAgICAgIGZpZWxkczoge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJ5dGVzXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5jb21tb24oXCJmaWVsZF9tYXNrXCIsIHtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnRpZXMgb2YgYSBnb29nbGUucHJvdG9idWYuRmllbGRNYXNrIG1lc3NhZ2UuXG4gICAgICogQGludGVyZmFjZSBJRG91YmxlVmFsdWVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdmFsdWVdXG4gICAgICogQG1lbWJlcm9mIGNvbW1vblxuICAgICAqL1xuICAgIEZpZWxkTWFzazoge1xuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIHBhdGhzOiB7XG4gICAgICAgICAgICAgICAgcnVsZTogXCJyZXBlYXRlZFwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgaWQ6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIEdldHMgdGhlIHJvb3QgZGVmaW5pdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGNvbW1vbiBwcm90byBmaWxlLlxuICpcbiAqIEJ1bmRsZWQgZGVmaW5pdGlvbnMgYXJlOlxuICogLSBnb29nbGUvcHJvdG9idWYvYW55LnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi9kdXJhdGlvbi5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvZW1wdHkucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL2ZpZWxkX21hc2sucHJvdG9cbiAqIC0gZ29vZ2xlL3Byb3RvYnVmL3N0cnVjdC5wcm90b1xuICogLSBnb29nbGUvcHJvdG9idWYvdGltZXN0YW1wLnByb3RvXG4gKiAtIGdvb2dsZS9wcm90b2J1Zi93cmFwcGVycy5wcm90b1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlIFByb3RvIGZpbGUgbmFtZVxuICogQHJldHVybnMge0lOYW1lc3BhY2V8bnVsbH0gUm9vdCBkZWZpbml0aW9uIG9yIGBudWxsYCBpZiBub3QgZGVmaW5lZFxuICovXG5jb21tb24uZ2V0ID0gZnVuY3Rpb24gZ2V0KGZpbGUpIHtcbiAgICByZXR1cm4gY29tbW9uW2ZpbGVdIHx8IG51bGw7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJjb21tb24iLCJjb21tb25SZSIsIm5hbWUiLCJqc29uIiwidGVzdCIsIm5lc3RlZCIsImdvb2dsZSIsInByb3RvYnVmIiwiQW55IiwiZmllbGRzIiwidHlwZV91cmwiLCJ0eXBlIiwiaWQiLCJ2YWx1ZSIsInRpbWVUeXBlIiwiRHVyYXRpb24iLCJzZWNvbmRzIiwibmFub3MiLCJUaW1lc3RhbXAiLCJFbXB0eSIsIlN0cnVjdCIsImtleVR5cGUiLCJWYWx1ZSIsIm9uZW9mcyIsImtpbmQiLCJvbmVvZiIsIm51bGxWYWx1ZSIsIm51bWJlclZhbHVlIiwic3RyaW5nVmFsdWUiLCJib29sVmFsdWUiLCJzdHJ1Y3RWYWx1ZSIsImxpc3RWYWx1ZSIsIk51bGxWYWx1ZSIsInZhbHVlcyIsIk5VTExfVkFMVUUiLCJMaXN0VmFsdWUiLCJydWxlIiwiRG91YmxlVmFsdWUiLCJGbG9hdFZhbHVlIiwiSW50NjRWYWx1ZSIsIlVJbnQ2NFZhbHVlIiwiSW50MzJWYWx1ZSIsIlVJbnQzMlZhbHVlIiwiQm9vbFZhbHVlIiwiU3RyaW5nVmFsdWUiLCJCeXRlc1ZhbHVlIiwiRmllbGRNYXNrIiwicGF0aHMiLCJnZXQiLCJmaWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/common.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/converter.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/converter.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Runtime message from/to plain object converters.\n * @namespace\n */ var converter = exports;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\n/**\n * Generates a partial value fromObject conveter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genValuePartial_fromObject(gen, field, fieldIndex, prop) {\n    var defaultAlreadyEmitted = false;\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) {\n            gen(\"switch(d%s){\", prop);\n            for(var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i){\n                // enum unknown values passthrough\n                if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {\n                    gen(\"default:\")('if(typeof(d%s)===\"number\"){m%s=d%s;break}', prop, prop, prop);\n                    if (!field.repeated) gen // fallback to default value only for\n                    (\"break\"); // for non-repeated fields, just ignore\n                    defaultAlreadyEmitted = true;\n                }\n                gen(\"case%j:\", keys[i])(\"case %i:\", values[keys[i]])(\"m%s=%j\", prop, values[keys[i]])(\"break\");\n            }\n            gen(\"}\");\n        } else gen('if(typeof d%s!==\"object\")', prop)(\"throw TypeError(%j)\", field.fullName + \": object expected\")(\"m%s=types[%i].fromObject(d%s)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch(field.type){\n            case \"double\":\n            case \"float\":\n                gen(\"m%s=Number(d%s)\", prop, prop); // also catches \"NaN\", \"Infinity\"\n                break;\n            case \"uint32\":\n            case \"fixed32\":\n                gen(\"m%s=d%s>>>0\", prop, prop);\n                break;\n            case \"int32\":\n            case \"sint32\":\n            case \"sfixed32\":\n                gen(\"m%s=d%s|0\", prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n            // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen(\"if(util.Long)\")(\"(m%s=util.Long.fromValue(d%s)).unsigned=%j\", prop, prop, isUnsigned)('else if(typeof d%s===\"string\")', prop)(\"m%s=parseInt(d%s,10)\", prop, prop)('else if(typeof d%s===\"number\")', prop)(\"m%s=d%s\", prop, prop)('else if(typeof d%s===\"object\")', prop)(\"m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)\", prop, prop, prop, isUnsigned ? \"true\" : \"\");\n                break;\n            case \"bytes\":\n                gen('if(typeof d%s===\"string\")', prop)(\"util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)\", prop, prop, prop)(\"else if(d%s.length >= 0)\", prop)(\"m%s=d%s\", prop, prop);\n                break;\n            case \"string\":\n                gen(\"m%s=String(d%s)\", prop, prop);\n                break;\n            case \"bool\":\n                gen(\"m%s=Boolean(d%s)\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n/**\n * Generates a plain object to runtime message converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ converter.fromObject = function fromObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var fields = mtype.fieldsArray;\n    var gen = util.codegen([\n        \"d\"\n    ], mtype.name + \"$fromObject\")(\"if(d instanceof this.ctor)\")(\"return d\");\n    if (!fields.length) return gen(\"return new this.ctor\");\n    gen(\"var m=new this.ctor\");\n    for(var i = 0; i < fields.length; ++i){\n        var field = fields[i].resolve(), prop = util.safeProp(field.name);\n        // Map fields\n        if (field.map) {\n            gen(\"if(d%s){\", prop)('if(typeof d%s!==\"object\")', prop)(\"throw TypeError(%j)\", field.fullName + \": object expected\")(\"m%s={}\", prop)(\"for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[ks[i]]\")(\"}\")(\"}\");\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(d%s){\", prop)(\"if(!Array.isArray(d%s))\", prop)(\"throw TypeError(%j)\", field.fullName + \": array expected\")(\"m%s=[]\", prop)(\"for(var i=0;i<d%s.length;++i){\", prop);\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop + \"[i]\")(\"}\")(\"}\");\n        // Non-repeated fields\n        } else {\n            if (!(field.resolvedType instanceof Enum)) gen // no need to test for null/undefined if an enum (uses switch)\n            (\"if(d%s!=null){\", prop); // !== undefined && !== null\n            genValuePartial_fromObject(gen, field, /* not sorted */ i, prop);\n            if (!(field.resolvedType instanceof Enum)) gen(\"}\");\n        }\n    }\n    return gen(\"return m\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ };\n/**\n * Generates a partial value toObject converter.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} prop Property reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genValuePartial_toObject(gen, field, fieldIndex, prop) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) gen(\"d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s\", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);\n        else gen(\"d%s=types[%i].toObject(m%s,o)\", prop, fieldIndex, prop);\n    } else {\n        var isUnsigned = false;\n        switch(field.type){\n            case \"double\":\n            case \"float\":\n                gen(\"d%s=o.json&&!isFinite(m%s)?String(m%s):m%s\", prop, prop, prop, prop);\n                break;\n            case \"uint64\":\n                isUnsigned = true;\n            // eslint-disable-next-line no-fallthrough\n            case \"int64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen('if(typeof m%s===\"number\")', prop)(\"d%s=o.longs===String?String(m%s):m%s\", prop, prop, prop)(\"else\") // Long-like\n                (\"d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s\", prop, prop, prop, prop, isUnsigned ? \"true\" : \"\", prop);\n                break;\n            case \"bytes\":\n                gen(\"d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s\", prop, prop, prop, prop, prop);\n                break;\n            default:\n                gen(\"d%s=m%s\", prop, prop);\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n/**\n * Generates a runtime message to plain object converter specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ converter.toObject = function toObject(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    if (!fields.length) return util.codegen()(\"return {}\");\n    var gen = util.codegen([\n        \"m\",\n        \"o\"\n    ], mtype.name + \"$toObject\")(\"if(!o)\")(\"o={}\")(\"var d={}\");\n    var repeatedFields = [], mapFields = [], normalFields = [], i = 0;\n    for(; i < fields.length; ++i)if (!fields[i].partOf) (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);\n    if (repeatedFields.length) {\n        gen(\"if(o.arrays||o.defaults){\");\n        for(i = 0; i < repeatedFields.length; ++i)gen(\"d%s=[]\", util.safeProp(repeatedFields[i].name));\n        gen(\"}\");\n    }\n    if (mapFields.length) {\n        gen(\"if(o.objects||o.defaults){\");\n        for(i = 0; i < mapFields.length; ++i)gen(\"d%s={}\", util.safeProp(mapFields[i].name));\n        gen(\"}\");\n    }\n    if (normalFields.length) {\n        gen(\"if(o.defaults){\");\n        for(i = 0; i < normalFields.length; ++i){\n            var field = normalFields[i], prop = util.safeProp(field.name);\n            if (field.resolvedType instanceof Enum) gen(\"d%s=o.enums===String?%j:%j\", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);\n            else if (field.long) gen(\"if(util.Long){\")(\"var n=new util.Long(%i,%i,%j)\", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)(\"d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n\", prop)(\"}else\")(\"d%s=o.longs===String?%j:%i\", prop, field.typeDefault.toString(), field.typeDefault.toNumber());\n            else if (field.bytes) {\n                var arrayDefault = \"[\" + Array.prototype.slice.call(field.typeDefault).join(\",\") + \"]\";\n                gen(\"if(o.bytes===String)d%s=%j\", prop, String.fromCharCode.apply(String, field.typeDefault))(\"else{\")(\"d%s=%s\", prop, arrayDefault)(\"if(o.bytes!==Array)d%s=util.newBuffer(d%s)\", prop, prop)(\"}\");\n            } else gen(\"d%s=%j\", prop, field.typeDefault); // also messages (=null)\n        }\n        gen(\"}\");\n    }\n    var hasKs2 = false;\n    for(i = 0; i < fields.length; ++i){\n        var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);\n        if (field.map) {\n            if (!hasKs2) {\n                hasKs2 = true;\n                gen(\"var ks2\");\n            }\n            gen(\"if(m%s&&(ks2=Object.keys(m%s)).length){\", prop, prop)(\"d%s={}\", prop)(\"for(var j=0;j<ks2.length;++j){\");\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[ks2[j]]\")(\"}\");\n        } else if (field.repeated) {\n            gen(\"if(m%s&&m%s.length){\", prop, prop)(\"d%s=[]\", prop)(\"for(var j=0;j<m%s.length;++j){\", prop);\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop + \"[j]\")(\"}\");\n        } else {\n            gen(\"if(m%s!=null&&m.hasOwnProperty(%j)){\", prop, field.name); // !== undefined && !== null\n            genValuePartial_toObject(gen, field, /* sorted */ index, prop);\n            if (field.partOf) gen(\"if(o.oneofs)\")(\"d%s=%j\", util.safeProp(field.partOf.name), field.name);\n        }\n        gen(\"}\");\n    }\n    return gen(\"return d\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvY29udmVydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7OztDQUdDLEdBQ0QsSUFBSUEsWUFBWUM7QUFFaEIsSUFBSUMsT0FBT0MsbUJBQU9BLENBQUMsc0ZBQVEsR0FDdkJDLE9BQU9ELG1CQUFPQSxDQUFDLHNGQUFRO0FBRTNCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0UsMkJBQTJCQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxJQUFJO0lBQzVELElBQUlDLHdCQUF3QjtJQUM1QiwwRUFBMEUsR0FDMUUsSUFBSUgsTUFBTUksWUFBWSxFQUFFO1FBQ3BCLElBQUlKLE1BQU1JLFlBQVksWUFBWVQsTUFBTTtZQUFFSSxJQUNyQyxnQkFBZ0JHO1lBQ2pCLElBQUssSUFBSUcsU0FBU0wsTUFBTUksWUFBWSxDQUFDQyxNQUFNLEVBQUVDLE9BQU9DLE9BQU9ELElBQUksQ0FBQ0QsU0FBU0csSUFBSSxHQUFHQSxJQUFJRixLQUFLRyxNQUFNLEVBQUUsRUFBRUQsRUFBRztnQkFDbEcsa0NBQWtDO2dCQUNsQyxJQUFJSCxNQUFNLENBQUNDLElBQUksQ0FBQ0UsRUFBRSxDQUFDLEtBQUtSLE1BQU1VLFdBQVcsSUFBSSxDQUFDUCx1QkFBdUI7b0JBQUVKLElBQ2xFLFlBQ0ksNkNBQStDRyxNQUFNQSxNQUFNQTtvQkFDaEUsSUFBSSxDQUFDRixNQUFNVyxRQUFRLEVBQUVaLElBQUkscUNBQXFDO3FCQUV6RCxVQUFvQix1Q0FBdUM7b0JBQ2hFSSx3QkFBd0I7Z0JBQzVCO2dCQUNBSixJQUNDLFdBQVdPLElBQUksQ0FBQ0UsRUFBRSxFQUNsQixZQUFZSCxNQUFNLENBQUNDLElBQUksQ0FBQ0UsRUFBRSxDQUFDLEVBQ3ZCLFVBQVVOLE1BQU1HLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDRSxFQUFFLENBQUMsRUFDL0I7WUFDVDtZQUFFVCxJQUNEO1FBQ0ws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QUVBLFNBQVM7Z0JBQU1uRCxJQUNyQztZQUNPO1lBQUVBLElBQ1QsMkNBQTJDRyxNQUFNQSxNQUM3QyxVQUFVQSxNQUNWO1lBQ0dzQix5QkFBeUJ6QixLQUFLQyxPQUFPLFVBQVUsR0FBR21ELE9BQU9qRCxPQUFPLFlBQ25FO1FBQ0QsT0FBTyxJQUFJRixNQUFNVyxRQUFRLEVBQUU7WUFBRVosSUFDaEMsd0JBQXdCRyxNQUFNQSxNQUMxQixVQUFVQSxNQUNWLGtDQUFrQ0E7WUFDL0JzQix5QkFBeUJ6QixLQUFLQyxPQUFPLFVBQVUsR0FBR21ELE9BQU9qRCxPQUFPLE9BQ25FO1FBQ0QsT0FBTztZQUFFSCxJQUNaLHdDQUF3Q0csTUFBTUYsTUFBTW9CLElBQUksR0FBRyw0QkFBNEI7WUFDcEZJLHlCQUF5QnpCLEtBQUtDLE9BQU8sVUFBVSxHQUFHbUQsT0FBT2pEO1lBQ3pELElBQUlGLE1BQU1nQyxNQUFNLEVBQUVqQyxJQUNqQixnQkFDSSxVQUFVRixLQUFLeUIsUUFBUSxDQUFDdEIsTUFBTWdDLE1BQU0sQ0FBQ1osSUFBSSxHQUFHcEIsTUFBTW9CLElBQUk7UUFDM0Q7UUFDQXJCLElBQ0g7SUFDRDtJQUNBLE9BQU9BLElBQ047QUFDRCx5RUFBeUUsR0FDN0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvY29udmVydGVyLmpzPzZmMjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIFJ1bnRpbWUgbWVzc2FnZSBmcm9tL3RvIHBsYWluIG9iamVjdCBjb252ZXJ0ZXJzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgY29udmVydGVyID0gZXhwb3J0cztcblxudmFyIEVudW0gPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBhcnRpYWwgdmFsdWUgZnJvbU9iamVjdCBjb252ZXRlci5cbiAqIEBwYXJhbSB7Q29kZWdlbn0gZ2VuIENvZGVnZW4gaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIFJlZmxlY3RlZCBmaWVsZFxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSW5kZXggRmllbGQgaW5kZXhcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcHJvcCkge1xuICAgIHZhciBkZWZhdWx0QWxyZWFkeUVtaXR0ZWQgPSBmYWxzZTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSkge1xuICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkgeyBnZW5cbiAgICAgICAgICAgIChcInN3aXRjaChkJXMpe1wiLCBwcm9wKTtcbiAgICAgICAgICAgIGZvciAodmFyIHZhbHVlcyA9IGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXMsIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpLCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnVtIHVua25vd24gdmFsdWVzIHBhc3N0aHJvdWdoXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXlzW2ldXSA9PT0gZmllbGQudHlwZURlZmF1bHQgJiYgIWRlZmF1bHRBbHJlYWR5RW1pdHRlZCkgeyBnZW5cbiAgICAgICAgICAgICAgICAgICAgKFwiZGVmYXVsdDpcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImlmKHR5cGVvZihkJXMpPT09XFxcIm51bWJlclxcXCIpe20lcz1kJXM7YnJlYWt9XCIsIHByb3AsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLnJlcGVhdGVkKSBnZW4gLy8gZmFsbGJhY2sgdG8gZGVmYXVsdCB2YWx1ZSBvbmx5IGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJyYXlzLCB0byBhdm9pZCBsZWF2aW5nIGhvbGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIik7ICAgICAgICAgICAvLyBmb3Igbm9uLXJlcGVhdGVkIGZpZWxkcywganVzdCBpZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdEFscmVhZHlFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgKFwiY2FzZSVqOlwiLCBrZXlzW2ldKVxuICAgICAgICAgICAgICAgIChcImNhc2UgJWk6XCIsIHZhbHVlc1trZXlzW2ldXSlcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPSVqXCIsIHByb3AsIHZhbHVlc1trZXlzW2ldXSlcbiAgICAgICAgICAgICAgICAgICAgKFwiYnJlYWtcIik7XG4gICAgICAgICAgICB9IGdlblxuICAgICAgICAgICAgKFwifVwiKTtcbiAgICAgICAgfSBlbHNlIGdlblxuICAgICAgICAgICAgKFwiaWYodHlwZW9mIGQlcyE9PVxcXCJvYmplY3RcXFwiKVwiLCBwcm9wKVxuICAgICAgICAgICAgICAgIChcInRocm93IFR5cGVFcnJvciglailcIiwgZmllbGQuZnVsbE5hbWUgKyBcIjogb2JqZWN0IGV4cGVjdGVkXCIpXG4gICAgICAgICAgICAoXCJtJXM9dHlwZXNbJWldLmZyb21PYmplY3QoZCVzKVwiLCBwcm9wLCBmaWVsZEluZGV4LCBwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXNVbnNpZ25lZCA9IGZhbHNlO1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkb3VibGVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmbG9hdFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9TnVtYmVyKGQlcylcIiwgcHJvcCwgcHJvcCk7IC8vIGFsc28gY2F0Y2hlcyBcIk5hTlwiLCBcIkluZmluaXR5XCJcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50MzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDMyXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1kJXM+Pj4wXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDMyXCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkMzJcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwibSVzPWQlc3wwXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInVpbnQ2NFwiOlxuICAgICAgICAgICAgICAgIGlzVW5zaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSBcImludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ludDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwiZml4ZWQ2NFwiOlxuICAgICAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKHV0aWwuTG9uZylcIilcbiAgICAgICAgICAgICAgICAgICAgKFwiKG0lcz11dGlsLkxvbmcuZnJvbVZhbHVlKGQlcykpLnVuc2lnbmVkPSVqXCIsIHByb3AsIHByb3AsIGlzVW5zaWduZWQpXG4gICAgICAgICAgICAgICAgKFwiZWxzZSBpZih0eXBlb2YgZCVzPT09XFxcInN0cmluZ1xcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz1wYXJzZUludChkJXMsMTApXCIsIHByb3AsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwiZWxzZSBpZih0eXBlb2YgZCVzPT09XFxcIm51bWJlclxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz1kJXNcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgICAgICAgICAoXCJlbHNlIGlmKHR5cGVvZiBkJXM9PT1cXFwib2JqZWN0XFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAgICAgKFwibSVzPW5ldyB1dGlsLkxvbmdCaXRzKGQlcy5sb3c+Pj4wLGQlcy5oaWdoPj4+MCkudG9OdW1iZXIoJXMpXCIsIHByb3AsIHByb3AsIHByb3AsIGlzVW5zaWduZWQgPyBcInRydWVcIiA6IFwiXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6IGdlblxuICAgICAgICAgICAgICAgIChcImlmKHR5cGVvZiBkJXM9PT1cXFwic3RyaW5nXFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgICAgICAgICAgKFwidXRpbC5iYXNlNjQuZGVjb2RlKGQlcyxtJXM9dXRpbC5uZXdCdWZmZXIodXRpbC5iYXNlNjQubGVuZ3RoKGQlcykpLDApXCIsIHByb3AsIHByb3AsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwiZWxzZSBpZihkJXMubGVuZ3RoID49IDApXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgICAgIChcIm0lcz1kJXNcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1TdHJpbmcoZCVzKVwiLCBwcm9wLCBwcm9wKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJib29sXCI6IGdlblxuICAgICAgICAgICAgICAgIChcIm0lcz1Cb29sZWFuKGQlcylcIiwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvKiBkZWZhdWx0OiBnZW5cbiAgICAgICAgICAgICAgICAoXCJtJXM9ZCVzXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAqL1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW47XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGxhaW4gb2JqZWN0IHRvIHJ1bnRpbWUgbWVzc2FnZSBjb252ZXJ0ZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuY29udmVydGVyLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xuICAgIHZhciBmaWVsZHMgPSBtdHlwZS5maWVsZHNBcnJheTtcbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcImRcIl0sIG10eXBlLm5hbWUgKyBcIiRmcm9tT2JqZWN0XCIpXG4gICAgKFwiaWYoZCBpbnN0YW5jZW9mIHRoaXMuY3RvcilcIilcbiAgICAgICAgKFwicmV0dXJuIGRcIik7XG4gICAgaWYgKCFmaWVsZHMubGVuZ3RoKSByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIG5ldyB0aGlzLmN0b3JcIik7XG4gICAgZ2VuXG4gICAgKFwidmFyIG09bmV3IHRoaXMuY3RvclwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZmllbGQgID0gZmllbGRzW2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIHByb3AgICA9IHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7XG5cbiAgICAgICAgLy8gTWFwIGZpZWxkc1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7IGdlblxuICAgIChcImlmKGQlcyl7XCIsIHByb3ApXG4gICAgICAgIChcImlmKHR5cGVvZiBkJXMhPT1cXFwib2JqZWN0XFxcIilcIiwgcHJvcClcbiAgICAgICAgICAgIChcInRocm93IFR5cGVFcnJvciglailcIiwgZmllbGQuZnVsbE5hbWUgKyBcIjogb2JqZWN0IGV4cGVjdGVkXCIpXG4gICAgICAgIChcIm0lcz17fVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGtzPU9iamVjdC5rZXlzKGQlcyksaT0wO2k8a3MubGVuZ3RoOysraSl7XCIsIHByb3ApO1xuICAgICAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgLyogbm90IHNvcnRlZCAqLyBpLCBwcm9wICsgXCJba3NbaV1dXCIpXG4gICAgICAgIChcIn1cIilcbiAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIFJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuICAgIChcImlmKGQlcyl7XCIsIHByb3ApXG4gICAgICAgIChcImlmKCFBcnJheS5pc0FycmF5KGQlcykpXCIsIHByb3ApXG4gICAgICAgICAgICAoXCJ0aHJvdyBUeXBlRXJyb3IoJWopXCIsIGZpZWxkLmZ1bGxOYW1lICsgXCI6IGFycmF5IGV4cGVjdGVkXCIpXG4gICAgICAgIChcIm0lcz1bXVwiLCBwcm9wKVxuICAgICAgICAoXCJmb3IodmFyIGk9MDtpPGQlcy5sZW5ndGg7KytpKXtcIiwgcHJvcCk7XG4gICAgICAgICAgICBnZW5WYWx1ZVBhcnRpYWxfZnJvbU9iamVjdChnZW4sIGZpZWxkLCAvKiBub3Qgc29ydGVkICovIGksIHByb3AgKyBcIltpXVwiKVxuICAgICAgICAoXCJ9XCIpXG4gICAgKFwifVwiKTtcblxuICAgICAgICAvLyBOb24tcmVwZWF0ZWQgZmllbGRzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIShmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSkgZ2VuIC8vIG5vIG5lZWQgdG8gdGVzdCBmb3IgbnVsbC91bmRlZmluZWQgaWYgYW4gZW51bSAodXNlcyBzd2l0Y2gpXG4gICAgKFwiaWYoZCVzIT1udWxsKXtcIiwgcHJvcCk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcbiAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QoZ2VuLCBmaWVsZCwgLyogbm90IHNvcnRlZCAqLyBpLCBwcm9wKTtcbiAgICAgICAgICAgIGlmICghKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pKSBnZW5cbiAgICAoXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfSByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIG1cIik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBhcnRpYWwgdmFsdWUgdG9PYmplY3QgY29udmVydGVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgcmVmZXJlbmNlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QoZ2VuLCBmaWVsZCwgZmllbGRJbmRleCwgcHJvcCkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lLCBibG9jay1zY29wZWQtdmFyLCBuby1yZWRlY2xhcmUgKi9cbiAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlKSB7XG4gICAgICAgIGlmIChmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtKSBnZW5cbiAgICAgICAgICAgIChcImQlcz1vLmVudW1zPT09U3RyaW5nPyh0eXBlc1slaV0udmFsdWVzW20lc109PT11bmRlZmluZWQ/bSVzOnR5cGVzWyVpXS52YWx1ZXNbbSVzXSk6bSVzXCIsIHByb3AsIGZpZWxkSW5kZXgsIHByb3AsIHByb3AsIGZpZWxkSW5kZXgsIHByb3AsIHByb3ApO1xuICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgKFwiZCVzPXR5cGVzWyVpXS50b09iamVjdChtJXMsbylcIiwgcHJvcCwgZmllbGRJbmRleCwgcHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGlzVW5zaWduZWQgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiZG91YmxlXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmxvYXRcIjogZ2VuXG4gICAgICAgICAgICAoXCJkJXM9by5qc29uJiYhaXNGaW5pdGUobSVzKT9TdHJpbmcobSVzKTptJXNcIiwgcHJvcCwgcHJvcCwgcHJvcCwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgICAgICAgICAgaXNVbnNpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogZ2VuXG4gICAgICAgICAgICAoXCJpZih0eXBlb2YgbSVzPT09XFxcIm51bWJlclxcXCIpXCIsIHByb3ApXG4gICAgICAgICAgICAgICAgKFwiZCVzPW8ubG9uZ3M9PT1TdHJpbmc/U3RyaW5nKG0lcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3ApXG4gICAgICAgICAgICAoXCJlbHNlXCIpIC8vIExvbmctbGlrZVxuICAgICAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nP3V0aWwuTG9uZy5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChtJXMpOm8ubG9uZ3M9PT1OdW1iZXI/bmV3IHV0aWwuTG9uZ0JpdHMobSVzLmxvdz4+PjAsbSVzLmhpZ2g+Pj4wKS50b051bWJlciglcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3AsIHByb3AsIGlzVW5zaWduZWQgPyBcInRydWVcIjogXCJcIiwgcHJvcCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjogZ2VuXG4gICAgICAgICAgICAoXCJkJXM9by5ieXRlcz09PVN0cmluZz91dGlsLmJhc2U2NC5lbmNvZGUobSVzLDAsbSVzLmxlbmd0aCk6by5ieXRlcz09PUFycmF5P0FycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG0lcyk6bSVzXCIsIHByb3AsIHByb3AsIHByb3AsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDogZ2VuXG4gICAgICAgICAgICAoXCJkJXM9bSVzXCIsIHByb3AsIHByb3ApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW47XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcnVudGltZSBtZXNzYWdlIHRvIHBsYWluIG9iamVjdCBjb252ZXJ0ZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuY29udmVydGVyLnRvT2JqZWN0ID0gZnVuY3Rpb24gdG9PYmplY3QobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgdmFyIGZpZWxkcyA9IG10eXBlLmZpZWxkc0FycmF5LnNsaWNlKCkuc29ydCh1dGlsLmNvbXBhcmVGaWVsZHNCeUlkKTtcbiAgICBpZiAoIWZpZWxkcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiB1dGlsLmNvZGVnZW4oKShcInJldHVybiB7fVwiKTtcbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcIm1cIiwgXCJvXCJdLCBtdHlwZS5uYW1lICsgXCIkdG9PYmplY3RcIilcbiAgICAoXCJpZighbylcIilcbiAgICAgICAgKFwibz17fVwiKVxuICAgIChcInZhciBkPXt9XCIpO1xuXG4gICAgdmFyIHJlcGVhdGVkRmllbGRzID0gW10sXG4gICAgICAgIG1hcEZpZWxkcyA9IFtdLFxuICAgICAgICBub3JtYWxGaWVsZHMgPSBbXSxcbiAgICAgICAgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmICghZmllbGRzW2ldLnBhcnRPZilcbiAgICAgICAgICAgICggZmllbGRzW2ldLnJlc29sdmUoKS5yZXBlYXRlZCA/IHJlcGVhdGVkRmllbGRzXG4gICAgICAgICAgICA6IGZpZWxkc1tpXS5tYXAgPyBtYXBGaWVsZHNcbiAgICAgICAgICAgIDogbm9ybWFsRmllbGRzKS5wdXNoKGZpZWxkc1tpXSk7XG5cbiAgICBpZiAocmVwZWF0ZWRGaWVsZHMubGVuZ3RoKSB7IGdlblxuICAgIChcImlmKG8uYXJyYXlzfHxvLmRlZmF1bHRzKXtcIik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZXBlYXRlZEZpZWxkcy5sZW5ndGg7ICsraSkgZ2VuXG4gICAgICAgIChcImQlcz1bXVwiLCB1dGlsLnNhZmVQcm9wKHJlcGVhdGVkRmllbGRzW2ldLm5hbWUpKTtcbiAgICAgICAgZ2VuXG4gICAgKFwifVwiKTtcbiAgICB9XG5cbiAgICBpZiAobWFwRmllbGRzLmxlbmd0aCkgeyBnZW5cbiAgICAoXCJpZihvLm9iamVjdHN8fG8uZGVmYXVsdHMpe1wiKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hcEZpZWxkcy5sZW5ndGg7ICsraSkgZ2VuXG4gICAgICAgIChcImQlcz17fVwiLCB1dGlsLnNhZmVQcm9wKG1hcEZpZWxkc1tpXS5uYW1lKSk7XG4gICAgICAgIGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuXG4gICAgaWYgKG5vcm1hbEZpZWxkcy5sZW5ndGgpIHsgZ2VuXG4gICAgKFwiaWYoby5kZWZhdWx0cyl7XCIpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9ybWFsRmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgZmllbGQgPSBub3JtYWxGaWVsZHNbaV0sXG4gICAgICAgICAgICAgICAgcHJvcCAgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pIGdlblxuICAgICAgICAoXCJkJXM9by5lbnVtcz09PVN0cmluZz8lajolalwiLCBwcm9wLCBmaWVsZC5yZXNvbHZlZFR5cGUudmFsdWVzQnlJZFtmaWVsZC50eXBlRGVmYXVsdF0sIGZpZWxkLnR5cGVEZWZhdWx0KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLmxvbmcpIGdlblxuICAgICAgICAoXCJpZih1dGlsLkxvbmcpe1wiKVxuICAgICAgICAgICAgKFwidmFyIG49bmV3IHV0aWwuTG9uZyglaSwlaSwlailcIiwgZmllbGQudHlwZURlZmF1bHQubG93LCBmaWVsZC50eXBlRGVmYXVsdC5oaWdoLCBmaWVsZC50eXBlRGVmYXVsdC51bnNpZ25lZClcbiAgICAgICAgICAgIChcImQlcz1vLmxvbmdzPT09U3RyaW5nP24udG9TdHJpbmcoKTpvLmxvbmdzPT09TnVtYmVyP24udG9OdW1iZXIoKTpuXCIsIHByb3ApXG4gICAgICAgIChcIn1lbHNlXCIpXG4gICAgICAgICAgICAoXCJkJXM9by5sb25ncz09PVN0cmluZz8lajolaVwiLCBwcm9wLCBmaWVsZC50eXBlRGVmYXVsdC50b1N0cmluZygpLCBmaWVsZC50eXBlRGVmYXVsdC50b051bWJlcigpKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkLmJ5dGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5RGVmYXVsdCA9IFwiW1wiICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZmllbGQudHlwZURlZmF1bHQpLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgIChcImlmKG8uYnl0ZXM9PT1TdHJpbmcpZCVzPSVqXCIsIHByb3AsIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBmaWVsZC50eXBlRGVmYXVsdCkpXG4gICAgICAgIChcImVsc2V7XCIpXG4gICAgICAgICAgICAoXCJkJXM9JXNcIiwgcHJvcCwgYXJyYXlEZWZhdWx0KVxuICAgICAgICAgICAgKFwiaWYoby5ieXRlcyE9PUFycmF5KWQlcz11dGlsLm5ld0J1ZmZlcihkJXMpXCIsIHByb3AsIHByb3ApXG4gICAgICAgIChcIn1cIik7XG4gICAgICAgICAgICB9IGVsc2UgZ2VuXG4gICAgICAgIChcImQlcz0lalwiLCBwcm9wLCBmaWVsZC50eXBlRGVmYXVsdCk7IC8vIGFsc28gbWVzc2FnZXMgKD1udWxsKVxuICAgICAgICB9IGdlblxuICAgIChcIn1cIik7XG4gICAgfVxuICAgIHZhciBoYXNLczIgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXSxcbiAgICAgICAgICAgIGluZGV4ID0gbXR5cGUuX2ZpZWxkc0FycmF5LmluZGV4T2YoZmllbGQpLFxuICAgICAgICAgICAgcHJvcCAgPSB1dGlsLnNhZmVQcm9wKGZpZWxkLm5hbWUpO1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7XG4gICAgICAgICAgICBpZiAoIWhhc0tzMikgeyBoYXNLczIgPSB0cnVlOyBnZW5cbiAgICAoXCJ2YXIga3MyXCIpO1xuICAgICAgICAgICAgfSBnZW5cbiAgICAoXCJpZihtJXMmJihrczI9T2JqZWN0LmtleXMobSVzKSkubGVuZ3RoKXtcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgKFwiZCVzPXt9XCIsIHByb3ApXG4gICAgICAgIChcImZvcih2YXIgaj0wO2o8a3MyLmxlbmd0aDsrK2ope1wiKTtcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCAvKiBzb3J0ZWQgKi8gaW5kZXgsIHByb3AgKyBcIltrczJbal1dXCIpXG4gICAgICAgIChcIn1cIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZmllbGQucmVwZWF0ZWQpIHsgZ2VuXG4gICAgKFwiaWYobSVzJiZtJXMubGVuZ3RoKXtcIiwgcHJvcCwgcHJvcClcbiAgICAgICAgKFwiZCVzPVtdXCIsIHByb3ApXG4gICAgICAgIChcImZvcih2YXIgaj0wO2o8bSVzLmxlbmd0aDsrK2ope1wiLCBwcm9wKTtcbiAgICAgICAgICAgIGdlblZhbHVlUGFydGlhbF90b09iamVjdChnZW4sIGZpZWxkLCAvKiBzb3J0ZWQgKi8gaW5kZXgsIHByb3AgKyBcIltqXVwiKVxuICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9IGVsc2UgeyBnZW5cbiAgICAoXCJpZihtJXMhPW51bGwmJm0uaGFzT3duUHJvcGVydHkoJWopKXtcIiwgcHJvcCwgZmllbGQubmFtZSk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcbiAgICAgICAgZ2VuVmFsdWVQYXJ0aWFsX3RvT2JqZWN0KGdlbiwgZmllbGQsIC8qIHNvcnRlZCAqLyBpbmRleCwgcHJvcCk7XG4gICAgICAgIGlmIChmaWVsZC5wYXJ0T2YpIGdlblxuICAgICAgICAoXCJpZihvLm9uZW9mcylcIilcbiAgICAgICAgICAgIChcImQlcz0lalwiLCB1dGlsLnNhZmVQcm9wKGZpZWxkLnBhcnRPZi5uYW1lKSwgZmllbGQubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2VuXG4gICAgKFwifVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBkXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufTtcbiJdLCJuYW1lcyI6WyJjb252ZXJ0ZXIiLCJleHBvcnRzIiwiRW51bSIsInJlcXVpcmUiLCJ1dGlsIiwiZ2VuVmFsdWVQYXJ0aWFsX2Zyb21PYmplY3QiLCJnZW4iLCJmaWVsZCIsImZpZWxkSW5kZXgiLCJwcm9wIiwiZGVmYXVsdEFscmVhZHlFbWl0dGVkIiwicmVzb2x2ZWRUeXBlIiwidmFsdWVzIiwia2V5cyIsIk9iamVjdCIsImkiLCJsZW5ndGgiLCJ0eXBlRGVmYXVsdCIsInJlcGVhdGVkIiwiZnVsbE5hbWUiLCJpc1Vuc2lnbmVkIiwidHlwZSIsImZyb21PYmplY3QiLCJtdHlwZSIsImZpZWxkcyIsImZpZWxkc0FycmF5IiwiY29kZWdlbiIsIm5hbWUiLCJyZXNvbHZlIiwic2FmZVByb3AiLCJtYXAiLCJnZW5WYWx1ZVBhcnRpYWxfdG9PYmplY3QiLCJ0b09iamVjdCIsInNsaWNlIiwic29ydCIsImNvbXBhcmVGaWVsZHNCeUlkIiwicmVwZWF0ZWRGaWVsZHMiLCJtYXBGaWVsZHMiLCJub3JtYWxGaWVsZHMiLCJwYXJ0T2YiLCJwdXNoIiwidmFsdWVzQnlJZCIsImxvbmciLCJsb3ciLCJoaWdoIiwidW5zaWduZWQiLCJ0b1N0cmluZyIsInRvTnVtYmVyIiwiYnl0ZXMiLCJhcnJheURlZmF1bHQiLCJBcnJheSIsInByb3RvdHlwZSIsImNhbGwiLCJqb2luIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYXBwbHkiLCJoYXNLczIiLCJpbmRleCIsIl9maWVsZHNBcnJheSIsImluZGV4T2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/converter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/decoder.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/decoder.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = decoder;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\nfunction missing(field) {\n    return \"missing required '\" + field.name + \"'\";\n}\n/**\n * Generates a decoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function decoder(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"r\",\n        \"l\",\n        \"e\"\n    ], mtype.name + \"$decode\")(\"if(!(r instanceof Reader))\")(\"r=Reader.create(r)\")(\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function(field) {\n        return field.map;\n    }).length ? \",k,value\" : \"\"))(\"while(r.pos<c){\")(\"var t=r.uint32()\")(\"if(t===e)\")(\"break\")(\"switch(t>>>3){\");\n    var i = 0;\n    for(; i < /* initializes */ mtype.fieldsArray.length; ++i){\n        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? \"int32\" : field.type, ref = \"m\" + util.safeProp(field.name);\n        gen(\"case %i: {\", field.id);\n        // Map fields\n        if (field.map) {\n            gen(\"if(%s===util.emptyObject)\", ref)(\"%s={}\", ref)(\"var c2 = r.uint32()+r.pos\");\n            if (types.defaults[field.keyType] !== undefined) gen(\"k=%j\", types.defaults[field.keyType]);\n            else gen(\"k=null\");\n            if (types.defaults[type] !== undefined) gen(\"value=%j\", types.defaults[type]);\n            else gen(\"value=null\");\n            gen(\"while(r.pos<c2){\")(\"var tag2=r.uint32()\")(\"switch(tag2>>>3){\")(\"case 1: k=r.%s(); break\", field.keyType)(\"case 2:\");\n            if (types.basic[type] === undefined) gen(\"value=types[%i].decode(r,r.uint32())\", i); // can't be groups\n            else gen(\"value=r.%s()\", type);\n            gen(\"break\")(\"default:\")(\"r.skipType(tag2&7)\")(\"break\")(\"}\")(\"}\");\n            if (types.long[field.keyType] !== undefined) gen('%s[typeof k===\"object\"?util.longToHash(k):k]=value', ref);\n            else gen(\"%s[k]=value\", ref);\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(!(%s&&%s.length))\", ref, ref)(\"%s=[]\", ref);\n            // Packable (always check for forward and backward compatiblity)\n            if (types.packed[type] !== undefined) gen(\"if((t&7)===2){\")(\"var c2=r.uint32()+r.pos\")(\"while(r.pos<c2)\")(\"%s.push(r.%s())\", ref, type)(\"}else\");\n            // Non-packed\n            if (types.basic[type] === undefined) gen(field.delimited ? \"%s.push(types[%i].decode(r,undefined,((t&~7)|4)))\" : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);\n            else gen(\"%s.push(r.%s())\", ref, type);\n        // Non-repeated\n        } else if (types.basic[type] === undefined) gen(field.delimited ? \"%s=types[%i].decode(r,undefined,((t&~7)|4))\" : \"%s=types[%i].decode(r,r.uint32())\", ref, i);\n        else gen(\"%s=r.%s()\", ref, type);\n        gen(\"break\")(\"}\");\n    // Unknown fields\n    }\n    gen(\"default:\")(\"r.skipType(t&7)\")(\"break\")(\"}\")(\"}\");\n    // Field presence\n    for(i = 0; i < mtype._fieldsArray.length; ++i){\n        var rfield = mtype._fieldsArray[i];\n        if (rfield.required) gen(\"if(!m.hasOwnProperty(%j))\", rfield.name)(\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n    }\n    return gen(\"return m\");\n/* eslint-enable no-unexpected-multiline */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZGVjb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQVVDLG1CQUFPQSxDQUFDLHNGQUFRLEdBQzFCQyxRQUFVRCxtQkFBT0EsQ0FBQyx3RkFBUyxHQUMzQkUsT0FBVUYsbUJBQU9BLENBQUMsc0ZBQVE7QUFFOUIsU0FBU0csUUFBUUMsS0FBSztJQUNsQixPQUFPLHVCQUF1QkEsTUFBTUMsSUFBSSxHQUFHO0FBQy9DO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNQLFFBQVFRLEtBQUs7SUFDbEIsMENBQTBDLEdBQzFDLElBQUlDLE1BQU1MLEtBQUtNLE9BQU8sQ0FBQztRQUFDO1FBQUs7UUFBSztLQUFJLEVBQUVGLE1BQU1ELElBQUksR0FBRyxXQUNwRCw4QkFDSSxzQkFDSixzREFBdURDLENBQUFBLE1BQU1HLFdBQVcsQ0FBQ0MsTUFBTSxDQUFDLFNBQVNOLEtBQUs7UUFBSSxPQUFPQSxNQUFNTyxHQUFHO0lBQUUsR0FBR0MsTUFBTSxHQUFHLGFBQWEsRUFBQyxHQUM5SSxtQkFDSSxvQkFDQSxhQUNJLFNBQ0o7SUFFTCxJQUFJQyxJQUFJO0lBQ1IsTUFBT0EsSUFBSSxlQUFlLEdBQUdQLE1BQU1HLFdBQVcsQ0FBQ0csTUFBTSxFQUFFLEVBQUVDLEVBQUc7UUFDeEQsSUFBSVQsUUFBUUUsTUFBTVEsWUFBWSxDQUFDRCxFQUFFLENBQUNFLE9BQU8sSUFDckNDLE9BQVFaLE1BQU1hLFlBQVksWUFBWWxCLE9BQU8sVUFBVUssTUFBTVksSUFBSSxFQUNqRUUsTUFBUSxNQUFNaEIsS0FBS2lCLFFBQVEsQ0FBQ2YsTUFBTUMsSUFBSTtRQUFHRSxJQUN4QyxjQUFjSCxNQUFNZ0IsRUFBRTtRQUUzQixhQUFhO1FBQ2IsSUFBSWhCLE1BQU1PLEdBQUcsRUFBRTtZQUFFSixJQUNSLDZCQUE2QlcsS0FDekIsU0FBU0EsS0FDYjtZQUVMLElBQUlqQixNQUFNb0IsUUFBUSxDQUFDakIsTUFBTWtCLE9BQU8sQ0FBQyxLQUFLQyxXQUFXaEIsSUFDNUMsUUFBUU4sTUFBTW9CLFFBQVEsQ0FBQ2pCLE1BQU1rQixPQUFPLENBQUM7aUJBQ3JDZixJQUNBO1lBRUwsSUFBSU4sTUFBTW9CLFFBQVEsQ0FBQ0wsS0FBSyxLQUFLTyxXQUFXaEIsSUFDbkMsWUFBWU4sTUFBTW9CLFFBQVEsQ0FBQ0wsS0FBSztpQkFDaENULElBQ0E7WUFFTEEsSUFDSyxvQkFDSSx1QkFDQSxxQkFDSSwyQkFBMkJILE1BQU1rQixPQUFPLEVBQ3hDO1lBRWIsSUFBSXJCLE1BQU11QixLQUFLLENBQUNSLEtBQUssS0FBS08sV0FBV2hCLElBQ3BCLHdDQUF3Q00sSUFBSSxrQkFBa0I7aUJBQzFFTixJQUNZLGdCQUFnQlM7WUFFakNULElBQ2lCLFNBQ0osWUFDSSxzQkFDQSxTQUNSLEtBQ0o7WUFFTCxJQUFJTixNQUFNd0IsSUFBSSxDQUFDckIsTUFBTWtCLE9BQU8sQ0FBQyxLQUFLQyxXQUFXaEIsSUFDeEMsc0RBQXdEVztpQkFDeERYLElBQ0EsZUFBZVc7UUFFeEIsa0JBQWtCO1FBQ2xCLE9BQU8sSUFBSWQsTUFBTXNCLFFBQVEsRUFBRTtZQUFFbkIsSUFFcEIsd0JBQXdCVyxLQUFLQSxLQUN6QixTQUFTQTtZQUVsQixnRUFBZ0U7WUFDaEUsSUFBSWpCLE1BQU0wQixNQUFNLENBQUNYLEtBQUssS0FBS08sV0FBV2hCLElBQ2pDLGtCQUNJLDJCQUNBLG1CQUNJLG1CQUFtQlcsS0FBS0YsTUFDaEM7WUFFTCxhQUFhO1lBQ2IsSUFBSWYsTUFBTXVCLEtBQUssQ0FBQ1IsS0FBSyxLQUFLTyxXQUFXaEIsSUFBSUgsTUFBTXdCLFNBQVMsR0FDOUMsc0RBQ0EsMkNBQTJDVixLQUFLTDtpQkFDckROLElBQ0ksbUJBQW1CVyxLQUFLRjtRQUVyQyxlQUFlO1FBQ2YsT0FBTyxJQUFJZixNQUFNdUIsS0FBSyxDQUFDUixLQUFLLEtBQUtPLFdBQVdoQixJQUFJSCxNQUFNd0IsU0FBUyxHQUNyRCxnREFDQSxxQ0FBcUNWLEtBQUtMO2FBQy9DTixJQUNJLGFBQWFXLEtBQUtGO1FBQzNCVCxJQUNTLFNBQ0o7SUFDTCxpQkFBaUI7SUFDckI7SUFBRUEsSUFDTyxZQUNJLG1CQUNBLFNBRVIsS0FDSjtJQUVELGlCQUFpQjtJQUNqQixJQUFLTSxJQUFJLEdBQUdBLElBQUlQLE1BQU1RLFlBQVksQ0FBQ0YsTUFBTSxFQUFFLEVBQUVDLEVBQUc7UUFDNUMsSUFBSWdCLFNBQVN2QixNQUFNUSxZQUFZLENBQUNELEVBQUU7UUFDbEMsSUFBSWdCLE9BQU9DLFFBQVEsRUFBRXZCLElBQ3hCLDZCQUE2QnNCLE9BQU94QixJQUFJLEVBQ3BDLDZDQUE2Q0YsUUFBUTBCO0lBQzFEO0lBRUEsT0FBT3RCLElBQ047QUFDRCx5Q0FBeUMsR0FDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZGVjb2Rlci5qcz9jZDk0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBkZWNvZGVyO1xuXG52YXIgRW51bSAgICA9IHJlcXVpcmUoXCIuL2VudW1cIiksXG4gICAgdHlwZXMgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBtaXNzaW5nKGZpZWxkKSB7XG4gICAgcmV0dXJuIFwibWlzc2luZyByZXF1aXJlZCAnXCIgKyBmaWVsZC5uYW1lICsgXCInXCI7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgZGVjb2RlciBzcGVjaWZpYyB0byB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UgdHlwZS5cbiAqIEBwYXJhbSB7VHlwZX0gbXR5cGUgTWVzc2FnZSB0eXBlXG4gKiBAcmV0dXJucyB7Q29kZWdlbn0gQ29kZWdlbiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBkZWNvZGVyKG10eXBlKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbiAgICB2YXIgZ2VuID0gdXRpbC5jb2RlZ2VuKFtcInJcIiwgXCJsXCIsIFwiZVwiXSwgbXR5cGUubmFtZSArIFwiJGRlY29kZVwiKVxuICAgIChcImlmKCEociBpbnN0YW5jZW9mIFJlYWRlcikpXCIpXG4gICAgICAgIChcInI9UmVhZGVyLmNyZWF0ZShyKVwiKVxuICAgIChcInZhciBjPWw9PT11bmRlZmluZWQ/ci5sZW46ci5wb3MrbCxtPW5ldyB0aGlzLmN0b3JcIiArIChtdHlwZS5maWVsZHNBcnJheS5maWx0ZXIoZnVuY3Rpb24oZmllbGQpIHsgcmV0dXJuIGZpZWxkLm1hcDsgfSkubGVuZ3RoID8gXCIsayx2YWx1ZVwiIDogXCJcIikpXG4gICAgKFwid2hpbGUoci5wb3M8Yyl7XCIpXG4gICAgICAgIChcInZhciB0PXIudWludDMyKClcIilcbiAgICAgICAgKFwiaWYodD09PWUpXCIpXG4gICAgICAgICAgICAoXCJicmVha1wiKVxuICAgICAgICAoXCJzd2l0Y2godD4+PjMpe1wiKTtcblxuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKDsgaSA8IC8qIGluaXRpYWxpemVzICovIG10eXBlLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlKCksXG4gICAgICAgICAgICB0eXBlICA9IGZpZWxkLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0gPyBcImludDMyXCIgOiBmaWVsZC50eXBlLFxuICAgICAgICAgICAgcmVmICAgPSBcIm1cIiArIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSk7IGdlblxuICAgICAgICAgICAgKFwiY2FzZSAlaToge1wiLCBmaWVsZC5pZCk7XG5cbiAgICAgICAgLy8gTWFwIGZpZWxkc1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7IGdlblxuICAgICAgICAgICAgICAgIChcImlmKCVzPT09dXRpbC5lbXB0eU9iamVjdClcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCIlcz17fVwiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwidmFyIGMyID0gci51aW50MzIoKStyLnBvc1wiKTtcblxuICAgICAgICAgICAgaWYgKHR5cGVzLmRlZmF1bHRzW2ZpZWxkLmtleVR5cGVdICE9PSB1bmRlZmluZWQpIGdlblxuICAgICAgICAgICAgICAgIChcIms9JWpcIiwgdHlwZXMuZGVmYXVsdHNbZmllbGQua2V5VHlwZV0pO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAoXCJrPW51bGxcIik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlcy5kZWZhdWx0c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAoXCJ2YWx1ZT0lalwiLCB0eXBlcy5kZWZhdWx0c1t0eXBlXSk7XG4gICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcInZhbHVlPW51bGxcIik7XG5cbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgIChcIndoaWxlKHIucG9zPGMyKXtcIilcbiAgICAgICAgICAgICAgICAgICAgKFwidmFyIHRhZzI9ci51aW50MzIoKVwiKVxuICAgICAgICAgICAgICAgICAgICAoXCJzd2l0Y2godGFnMj4+PjMpe1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgKFwiY2FzZSAxOiBrPXIuJXMoKTsgYnJlYWtcIiwgZmllbGQua2V5VHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIChcImNhc2UgMjpcIik7XG5cbiAgICAgICAgICAgIGlmICh0eXBlcy5iYXNpY1t0eXBlXSA9PT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJ2YWx1ZT10eXBlc1slaV0uZGVjb2RlKHIsci51aW50MzIoKSlcIiwgaSk7IC8vIGNhbid0IGJlIGdyb3Vwc1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJ2YWx1ZT1yLiVzKClcIiwgdHlwZSk7XG5cbiAgICAgICAgICAgIGdlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCJkZWZhdWx0OlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcInIuc2tpcFR5cGUodGFnMiY3KVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG4gICAgICAgICAgICAgICAgICAgIChcIn1cIilcbiAgICAgICAgICAgICAgICAoXCJ9XCIpO1xuXG4gICAgICAgICAgICBpZiAodHlwZXMubG9uZ1tmaWVsZC5rZXlUeXBlXSAhPT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgICAgICAoXCIlc1t0eXBlb2Ygaz09PVxcXCJvYmplY3RcXFwiP3V0aWwubG9uZ1RvSGFzaChrKTprXT12YWx1ZVwiLCByZWYpO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgICAgICAgICAoXCIlc1trXT12YWx1ZVwiLCByZWYpO1xuXG4gICAgICAgIC8vIFJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuXG4gICAgICAgICAgICAgICAgKFwiaWYoISglcyYmJXMubGVuZ3RoKSlcIiwgcmVmLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcIiVzPVtdXCIsIHJlZik7XG5cbiAgICAgICAgICAgIC8vIFBhY2thYmxlIChhbHdheXMgY2hlY2sgZm9yIGZvcndhcmQgYW5kIGJhY2t3YXJkIGNvbXBhdGlibGl0eSlcbiAgICAgICAgICAgIGlmICh0eXBlcy5wYWNrZWRbdHlwZV0gIT09IHVuZGVmaW5lZCkgZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoKHQmNyk9PT0yKXtcIilcbiAgICAgICAgICAgICAgICAgICAgKFwidmFyIGMyPXIudWludDMyKCkrci5wb3NcIilcbiAgICAgICAgICAgICAgICAgICAgKFwid2hpbGUoci5wb3M8YzIpXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAoXCIlcy5wdXNoKHIuJXMoKSlcIiwgcmVmLCB0eXBlKVxuICAgICAgICAgICAgICAgIChcIn1lbHNlXCIpO1xuXG4gICAgICAgICAgICAvLyBOb24tcGFja2VkXG4gICAgICAgICAgICBpZiAodHlwZXMuYmFzaWNbdHlwZV0gPT09IHVuZGVmaW5lZCkgZ2VuKGZpZWxkLmRlbGltaXRlZFxuICAgICAgICAgICAgICAgICAgICA/IFwiJXMucHVzaCh0eXBlc1slaV0uZGVjb2RlKHIsdW5kZWZpbmVkLCgodCZ+Nyl8NCkpKVwiXG4gICAgICAgICAgICAgICAgICAgIDogXCIlcy5wdXNoKHR5cGVzWyVpXS5kZWNvZGUocixyLnVpbnQzMigpKSlcIiwgcmVmLCBpKTtcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAgICAgICAgIChcIiVzLnB1c2goci4lcygpKVwiLCByZWYsIHR5cGUpO1xuXG4gICAgICAgIC8vIE5vbi1yZXBlYXRlZFxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVzLmJhc2ljW3R5cGVdID09PSB1bmRlZmluZWQpIGdlbihmaWVsZC5kZWxpbWl0ZWRcbiAgICAgICAgICAgICAgICA/IFwiJXM9dHlwZXNbJWldLmRlY29kZShyLHVuZGVmaW5lZCwoKHQmfjcpfDQpKVwiXG4gICAgICAgICAgICAgICAgOiBcIiVzPXR5cGVzWyVpXS5kZWNvZGUocixyLnVpbnQzMigpKVwiLCByZWYsIGkpO1xuICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgICAgIChcIiVzPXIuJXMoKVwiLCByZWYsIHR5cGUpO1xuICAgICAgICBnZW5cbiAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxuICAgICAgICAgICAgKFwifVwiKTtcbiAgICAgICAgLy8gVW5rbm93biBmaWVsZHNcbiAgICB9IGdlblxuICAgICAgICAgICAgKFwiZGVmYXVsdDpcIilcbiAgICAgICAgICAgICAgICAoXCJyLnNraXBUeXBlKHQmNylcIilcbiAgICAgICAgICAgICAgICAoXCJicmVha1wiKVxuXG4gICAgICAgIChcIn1cIilcbiAgICAoXCJ9XCIpO1xuXG4gICAgLy8gRmllbGQgcHJlc2VuY2VcbiAgICBmb3IgKGkgPSAwOyBpIDwgbXR5cGUuX2ZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciByZmllbGQgPSBtdHlwZS5fZmllbGRzQXJyYXlbaV07XG4gICAgICAgIGlmIChyZmllbGQucmVxdWlyZWQpIGdlblxuICAgIChcImlmKCFtLmhhc093blByb3BlcnR5KCVqKSlcIiwgcmZpZWxkLm5hbWUpXG4gICAgICAgIChcInRocm93IHV0aWwuUHJvdG9jb2xFcnJvciglaix7aW5zdGFuY2U6bX0pXCIsIG1pc3NpbmcocmZpZWxkKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiBtXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiZGVjb2RlciIsIkVudW0iLCJyZXF1aXJlIiwidHlwZXMiLCJ1dGlsIiwibWlzc2luZyIsImZpZWxkIiwibmFtZSIsIm10eXBlIiwiZ2VuIiwiY29kZWdlbiIsImZpZWxkc0FycmF5IiwiZmlsdGVyIiwibWFwIiwibGVuZ3RoIiwiaSIsIl9maWVsZHNBcnJheSIsInJlc29sdmUiLCJ0eXBlIiwicmVzb2x2ZWRUeXBlIiwicmVmIiwic2FmZVByb3AiLCJpZCIsImRlZmF1bHRzIiwia2V5VHlwZSIsInVuZGVmaW5lZCIsImJhc2ljIiwibG9uZyIsInJlcGVhdGVkIiwicGFja2VkIiwiZGVsaW1pdGVkIiwicmZpZWxkIiwicmVxdWlyZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/decoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/encoder.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/encoder.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = encoder;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\n/**\n * Generates a partial message type encoder.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genTypePartial(gen, field, fieldIndex, ref) {\n    return field.delimited ? gen(\"types[%i].encode(%s,w.uint32(%i)).uint32(%i)\", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen(\"types[%i].encode(%s,w.uint32(%i).fork()).ldelim()\", fieldIndex, ref, (field.id << 3 | 2) >>> 0);\n}\n/**\n * Generates an encoder specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function encoder(mtype) {\n    /* eslint-disable no-unexpected-multiline, block-scoped-var, no-redeclare */ var gen = util.codegen([\n        \"m\",\n        \"w\"\n    ], mtype.name + \"$encode\")(\"if(!w)\")(\"w=Writer.create()\");\n    var i, ref;\n    // \"when a message is serialized its known fields should be written sequentially by field number\"\n    var fields = /* initializes */ mtype.fieldsArray.slice().sort(util.compareFieldsById);\n    for(var i = 0; i < fields.length; ++i){\n        var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? \"int32\" : field.type, wireType = types.basic[type];\n        ref = \"m\" + util.safeProp(field.name);\n        // Map fields\n        if (field.map) {\n            gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j)){\", ref, field.name) // !== undefined && !== null\n            (\"for(var ks=Object.keys(%s),i=0;i<ks.length;++i){\", ref)(\"w.uint32(%i).fork().uint32(%i).%s(ks[i])\", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);\n            if (wireType === undefined) gen(\"types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()\", index, ref); // can't be groups\n            else gen(\".uint32(%i).%s(%s[ks[i]]).ldelim()\", 16 | wireType, type, ref);\n            gen(\"}\")(\"}\");\n        // Repeated fields\n        } else if (field.repeated) {\n            gen(\"if(%s!=null&&%s.length){\", ref, ref); // !== undefined && !== null\n            // Packed repeated\n            if (field.packed && types.packed[type] !== undefined) {\n                gen(\"w.uint32(%i).fork()\", (field.id << 3 | 2) >>> 0)(\"for(var i=0;i<%s.length;++i)\", ref)(\"w.%s(%s[i])\", type, ref)(\"w.ldelim()\");\n            // Non-packed\n            } else {\n                gen(\"for(var i=0;i<%s.length;++i)\", ref);\n                if (wireType === undefined) genTypePartial(gen, field, index, ref + \"[i]\");\n                else gen(\"w.uint32(%i).%s(%s[i])\", (field.id << 3 | wireType) >>> 0, type, ref);\n            }\n            gen(\"}\");\n        // Non-repeated\n        } else {\n            if (field.optional) gen(\"if(%s!=null&&Object.hasOwnProperty.call(m,%j))\", ref, field.name); // !== undefined && !== null\n            if (wireType === undefined) genTypePartial(gen, field, index, ref);\n            else gen(\"w.uint32(%i).%s(%s)\", (field.id << 3 | wireType) >>> 0, type, ref);\n        }\n    }\n    return gen(\"return w\");\n/* eslint-enable no-unexpected-multiline, block-scoped-var, no-redeclare */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZW5jb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQVdDLG1CQUFPQSxDQUFDLHNGQUFRLEdBQzNCQyxRQUFXRCxtQkFBT0EsQ0FBQyx3RkFBUyxHQUM1QkUsT0FBV0YsbUJBQU9BLENBQUMsc0ZBQVE7QUFFL0I7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTRyxlQUFlQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsVUFBVSxFQUFFQyxHQUFHO0lBQy9DLE9BQU9GLE1BQU1HLFNBQVMsR0FDaEJKLElBQUksZ0RBQWdERSxZQUFZQyxLQUFLLENBQUNGLE1BQU1JLEVBQUUsSUFBSSxJQUFJLE9BQU8sR0FBRyxDQUFDSixNQUFNSSxFQUFFLElBQUksSUFBSSxPQUFPLEtBQ3hITCxJQUFJLHFEQUFxREUsWUFBWUMsS0FBSyxDQUFDRixNQUFNSSxFQUFFLElBQUksSUFBSSxPQUFPO0FBQzVHO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNYLFFBQVFZLEtBQUs7SUFDbEIsMEVBQTBFLEdBQzFFLElBQUlOLE1BQU1GLEtBQUtTLE9BQU8sQ0FBQztRQUFDO1FBQUs7S0FBSSxFQUFFRCxNQUFNRSxJQUFJLEdBQUcsV0FDL0MsVUFDSTtJQUVMLElBQUlDLEdBQUdOO0lBRVAsaUdBQWlHO0lBQ2pHLElBQUlPLFNBQVMsZUFBZSxHQUFHSixNQUFNSyxXQUFXLENBQUNDLEtBQUssR0FBR0MsSUFBSSxDQUFDZixLQUFLZ0IsaUJBQWlCO0lBRXBGLElBQUssSUFBSUwsSUFBSSxHQUFHQSxJQUFJQyxPQUFPSyxNQUFNLEVBQUUsRUFBRU4sRUFBRztRQUNwQyxJQUFJUixRQUFXUyxNQUFNLENBQUNELEVBQUUsQ0FBQ08sT0FBTyxJQUM1QkMsUUFBV1gsTUFBTVksWUFBWSxDQUFDQyxPQUFPLENBQUNsQixRQUN0Q21CLE9BQVduQixNQUFNb0IsWUFBWSxZQUFZMUIsT0FBTyxVQUFVTSxNQUFNbUIsSUFBSSxFQUNwRUUsV0FBV3pCLE1BQU0wQixLQUFLLENBQUNILEtBQUs7UUFDNUJqQixNQUFXLE1BQU1MLEtBQUswQixRQUFRLENBQUN2QixNQUFNTyxJQUFJO1FBRTdDLGFBQWE7UUFDYixJQUFJUCxNQUFNd0IsR0FBRyxFQUFFO1lBQ1h6QixJQUNQLG1EQUFtREcsS0FBS0YsTUFBTU8sSUFBSSxFQUFFLDRCQUE0QjthQUM1RixvREFBb0RMLEtBQ2hELDRDQUE0QyxDQUFDRixNQUFNSSxFQUFFLElBQUksSUFBSSxPQUFPLEdBQUcsSUFBSVIsTUFBTTZCLE1BQU0sQ0FBQ3pCLE1BQU0wQixPQUFPLENBQUMsRUFBRTFCLE1BQU0wQixPQUFPO1lBQ3RILElBQUlMLGFBQWFNLFdBQVc1QixJQUMzQixxRUFBcUVpQixPQUFPZCxNQUFNLGtCQUFrQjtpQkFDaEdILElBQ0osc0NBQXNDLEtBQUtzQixVQUFVRixNQUFNakI7WUFDNURILElBQ0gsS0FDSjtRQUVPLGtCQUFrQjtRQUN0QixPQUFPLElBQUlDLE1BQU00QixRQUFRLEVBQUU7WUFBRTdCLElBQ2hDLDRCQUE0QkcsS0FBS0EsTUFBTSw0QkFBNEI7WUFFNUQsa0JBQWtCO1lBQ2xCLElBQUlGLE1BQU02QixNQUFNLElBQUlqQyxNQUFNaUMsTUFBTSxDQUFDVixLQUFLLEtBQUtRLFdBQVc7Z0JBQUU1QixJQUUzRCx1QkFBdUIsQ0FBQ0MsTUFBTUksRUFBRSxJQUFJLElBQUksT0FBTyxHQUMvQyxnQ0FBZ0NGLEtBQzVCLGVBQWVpQixNQUFNakIsS0FDekI7WUFFRyxhQUFhO1lBQ2IsT0FBTztnQkFBRUgsSUFFWixnQ0FBZ0NHO2dCQUN6QixJQUFJbUIsYUFBYU0sV0FDckI3QixlQUFlQyxLQUFLQyxPQUFPZ0IsT0FBT2QsTUFBTTtxQkFDL0JILElBQ1IsMEJBQTBCLENBQUNDLE1BQU1JLEVBQUUsSUFBSSxJQUFJaUIsUUFBTyxNQUFPLEdBQUdGLE1BQU1qQjtZQUVuRTtZQUFFSCxJQUNUO1FBRUcsZUFBZTtRQUNmLE9BQU87WUFDSCxJQUFJQyxNQUFNOEIsUUFBUSxFQUFFL0IsSUFDM0Isa0RBQWtERyxLQUFLRixNQUFNTyxJQUFJLEdBQUcsNEJBQTRCO1lBRXpGLElBQUljLGFBQWFNLFdBQ3JCN0IsZUFBZUMsS0FBS0MsT0FBT2dCLE9BQU9kO2lCQUN6QkgsSUFDUix1QkFBdUIsQ0FBQ0MsTUFBTUksRUFBRSxJQUFJLElBQUlpQixRQUFPLE1BQU8sR0FBR0YsTUFBTWpCO1FBRWhFO0lBQ0o7SUFFQSxPQUFPSCxJQUNOO0FBQ0QseUVBQXlFLEdBQzdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL2VuY29kZXIuanM/ZjJmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gZW5jb2RlcjtcblxudmFyIEVudW0gICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB0eXBlcyAgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIG1lc3NhZ2UgdHlwZSBlbmNvZGVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiBWYXJpYWJsZSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGZpZWxkSW5kZXgsIHJlZikge1xuICAgIHJldHVybiBmaWVsZC5kZWxpbWl0ZWRcbiAgICAgICAgPyBnZW4oXCJ0eXBlc1slaV0uZW5jb2RlKCVzLHcudWludDMyKCVpKSkudWludDMyKCVpKVwiLCBmaWVsZEluZGV4LCByZWYsIChmaWVsZC5pZCA8PCAzIHwgMykgPj4+IDAsIChmaWVsZC5pZCA8PCAzIHwgNCkgPj4+IDApXG4gICAgICAgIDogZ2VuKFwidHlwZXNbJWldLmVuY29kZSglcyx3LnVpbnQzMiglaSkuZm9yaygpKS5sZGVsaW0oKVwiLCBmaWVsZEluZGV4LCByZWYsIChmaWVsZC5pZCA8PCAzIHwgMikgPj4+IDApO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBlbmNvZGVyIHNwZWNpZmljIHRvIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSB0eXBlLlxuICogQHBhcmFtIHtUeXBlfSBtdHlwZSBNZXNzYWdlIHR5cGVcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZXIobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSwgYmxvY2stc2NvcGVkLXZhciwgbm8tcmVkZWNsYXJlICovXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJtXCIsIFwid1wiXSwgbXR5cGUubmFtZSArIFwiJGVuY29kZVwiKVxuICAgIChcImlmKCF3KVwiKVxuICAgICAgICAoXCJ3PVdyaXRlci5jcmVhdGUoKVwiKTtcblxuICAgIHZhciBpLCByZWY7XG5cbiAgICAvLyBcIndoZW4gYSBtZXNzYWdlIGlzIHNlcmlhbGl6ZWQgaXRzIGtub3duIGZpZWxkcyBzaG91bGQgYmUgd3JpdHRlbiBzZXF1ZW50aWFsbHkgYnkgZmllbGQgbnVtYmVyXCJcbiAgICB2YXIgZmllbGRzID0gLyogaW5pdGlhbGl6ZXMgKi8gbXR5cGUuZmllbGRzQXJyYXkuc2xpY2UoKS5zb3J0KHV0aWwuY29tcGFyZUZpZWxkc0J5SWQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkICAgID0gZmllbGRzW2ldLnJlc29sdmUoKSxcbiAgICAgICAgICAgIGluZGV4ICAgID0gbXR5cGUuX2ZpZWxkc0FycmF5LmluZGV4T2YoZmllbGQpLFxuICAgICAgICAgICAgdHlwZSAgICAgPSBmaWVsZC5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBFbnVtID8gXCJpbnQzMlwiIDogZmllbGQudHlwZSxcbiAgICAgICAgICAgIHdpcmVUeXBlID0gdHlwZXMuYmFzaWNbdHlwZV07XG4gICAgICAgICAgICByZWYgICAgICA9IFwibVwiICsgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcblxuICAgICAgICAvLyBNYXAgZmllbGRzXG4gICAgICAgIGlmIChmaWVsZC5tYXApIHtcbiAgICAgICAgICAgIGdlblxuICAgIChcImlmKCVzIT1udWxsJiZPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtLCVqKSl7XCIsIHJlZiwgZmllbGQubmFtZSkgLy8gIT09IHVuZGVmaW5lZCAmJiAhPT0gbnVsbFxuICAgICAgICAoXCJmb3IodmFyIGtzPU9iamVjdC5rZXlzKCVzKSxpPTA7aTxrcy5sZW5ndGg7KytpKXtcIiwgcmVmKVxuICAgICAgICAgICAgKFwidy51aW50MzIoJWkpLmZvcmsoKS51aW50MzIoJWkpLiVzKGtzW2ldKVwiLCAoZmllbGQuaWQgPDwgMyB8IDIpID4+PiAwLCA4IHwgdHlwZXMubWFwS2V5W2ZpZWxkLmtleVR5cGVdLCBmaWVsZC5rZXlUeXBlKTtcbiAgICAgICAgICAgIGlmICh3aXJlVHlwZSA9PT0gdW5kZWZpbmVkKSBnZW5cbiAgICAgICAgICAgIChcInR5cGVzWyVpXS5lbmNvZGUoJXNba3NbaV1dLHcudWludDMyKDE4KS5mb3JrKCkpLmxkZWxpbSgpLmxkZWxpbSgpXCIsIGluZGV4LCByZWYpOyAvLyBjYW4ndCBiZSBncm91cHNcbiAgICAgICAgICAgIGVsc2UgZ2VuXG4gICAgICAgICAgICAoXCIudWludDMyKCVpKS4lcyglc1trc1tpXV0pLmxkZWxpbSgpXCIsIDE2IHwgd2lyZVR5cGUsIHR5cGUsIHJlZik7XG4gICAgICAgICAgICBnZW5cbiAgICAgICAgKFwifVwiKVxuICAgIChcIn1cIik7XG5cbiAgICAgICAgICAgIC8vIFJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuICAgIChcImlmKCVzIT1udWxsJiYlcy5sZW5ndGgpe1wiLCByZWYsIHJlZik7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcblxuICAgICAgICAgICAgLy8gUGFja2VkIHJlcGVhdGVkXG4gICAgICAgICAgICBpZiAoZmllbGQucGFja2VkICYmIHR5cGVzLnBhY2tlZFt0eXBlXSAhPT0gdW5kZWZpbmVkKSB7IGdlblxuXG4gICAgICAgIChcIncudWludDMyKCVpKS5mb3JrKClcIiwgKGZpZWxkLmlkIDw8IDMgfCAyKSA+Pj4gMClcbiAgICAgICAgKFwiZm9yKHZhciBpPTA7aTwlcy5sZW5ndGg7KytpKVwiLCByZWYpXG4gICAgICAgICAgICAoXCJ3LiVzKCVzW2ldKVwiLCB0eXBlLCByZWYpXG4gICAgICAgIChcIncubGRlbGltKClcIik7XG5cbiAgICAgICAgICAgIC8vIE5vbi1wYWNrZWRcbiAgICAgICAgICAgIH0gZWxzZSB7IGdlblxuXG4gICAgICAgIChcImZvcih2YXIgaT0wO2k8JXMubGVuZ3RoOysraSlcIiwgcmVmKTtcbiAgICAgICAgICAgICAgICBpZiAod2lyZVR5cGUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGluZGV4LCByZWYgKyBcIltpXVwiKTtcbiAgICAgICAgICAgICAgICBlbHNlIGdlblxuICAgICAgICAgICAgKFwidy51aW50MzIoJWkpLiVzKCVzW2ldKVwiLCAoZmllbGQuaWQgPDwgMyB8IHdpcmVUeXBlKSA+Pj4gMCwgdHlwZSwgcmVmKTtcblxuICAgICAgICAgICAgfSBnZW5cbiAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIE5vbi1yZXBlYXRlZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpZWxkLm9wdGlvbmFsKSBnZW5cbiAgICAoXCJpZiglcyE9bnVsbCYmT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobSwlaikpXCIsIHJlZiwgZmllbGQubmFtZSk7IC8vICE9PSB1bmRlZmluZWQgJiYgIT09IG51bGxcblxuICAgICAgICAgICAgaWYgKHdpcmVUeXBlID09PSB1bmRlZmluZWQpXG4gICAgICAgIGdlblR5cGVQYXJ0aWFsKGdlbiwgZmllbGQsIGluZGV4LCByZWYpO1xuICAgICAgICAgICAgZWxzZSBnZW5cbiAgICAgICAgKFwidy51aW50MzIoJWkpLiVzKCVzKVwiLCAoZmllbGQuaWQgPDwgMyB8IHdpcmVUeXBlKSA+Pj4gMCwgdHlwZSwgcmVmKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdlblxuICAgIChcInJldHVybiB3XCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUsIGJsb2NrLXNjb3BlZC12YXIsIG5vLXJlZGVjbGFyZSAqL1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJlbmNvZGVyIiwiRW51bSIsInJlcXVpcmUiLCJ0eXBlcyIsInV0aWwiLCJnZW5UeXBlUGFydGlhbCIsImdlbiIsImZpZWxkIiwiZmllbGRJbmRleCIsInJlZiIsImRlbGltaXRlZCIsImlkIiwibXR5cGUiLCJjb2RlZ2VuIiwibmFtZSIsImkiLCJmaWVsZHMiLCJmaWVsZHNBcnJheSIsInNsaWNlIiwic29ydCIsImNvbXBhcmVGaWVsZHNCeUlkIiwibGVuZ3RoIiwicmVzb2x2ZSIsImluZGV4IiwiX2ZpZWxkc0FycmF5IiwiaW5kZXhPZiIsInR5cGUiLCJyZXNvbHZlZFR5cGUiLCJ3aXJlVHlwZSIsImJhc2ljIiwic2FmZVByb3AiLCJtYXAiLCJtYXBLZXkiLCJrZXlUeXBlIiwidW5kZWZpbmVkIiwicmVwZWF0ZWQiLCJwYWNrZWQiLCJvcHRpb25hbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/encoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Enum;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\n((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = \"Enum\";\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new enum instance.\n * @classdesc Reflected enum.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {Object.<string,number>} [values] Enum values as an object, by name\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this enum\n * @param {Object.<string,string>} [comments] The value comments for this enum\n * @param {Object.<string,Object<string,*>>|undefined} [valuesOptions] The value options for this enum\n */ function Enum(name, values, options, comment, comments, valuesOptions) {\n    ReflectionObject.call(this, name, options);\n    if (values && typeof values !== \"object\") throw TypeError(\"values must be an object\");\n    /**\n     * Enum values by id.\n     * @type {Object.<number,string>}\n     */ this.valuesById = {};\n    /**\n     * Enum values by name.\n     * @type {Object.<string,number>}\n     */ this.values = Object.create(this.valuesById); // toJSON, marker\n    /**\n     * Enum comment text.\n     * @type {string|null}\n     */ this.comment = comment;\n    /**\n     * Value comment texts, if any.\n     * @type {Object.<string,string>}\n     */ this.comments = comments || {};\n    /**\n     * Values options, if any\n     * @type {Object<string, Object<string, *>>|undefined}\n     */ this.valuesOptions = valuesOptions;\n    /**\n     * Resolved values features, if any\n     * @type {Object<string, Object<string, *>>|undefined}\n     */ this._valuesFeatures = {};\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */ this.reserved = undefined; // toJSON\n    // Note that values inherit valuesById on their prototype which makes them a TypeScript-\n    // compatible enum. This is used by pbts to write actual enum definitions that work for\n    // static and reflection code alike instead of emitting generic object definitions.\n    if (values) {\n        for(var keys = Object.keys(values), i = 0; i < keys.length; ++i)if (typeof values[keys[i]] === \"number\") this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];\n    }\n}\n/**\n * @override\n */ Enum.prototype._resolveFeatures = function _resolveFeatures(edition) {\n    edition = this._edition || edition;\n    ReflectionObject.prototype._resolveFeatures.call(this, edition);\n    Object.keys(this.values).forEach((key)=>{\n        var parentFeaturesCopy = Object.assign({}, this._features);\n        this._valuesFeatures[key] = Object.assign(parentFeaturesCopy, this.valuesOptions && this.valuesOptions[key] && this.valuesOptions[key].features);\n    });\n    return this;\n};\n/**\n * Enum descriptor.\n * @interface IEnum\n * @property {Object.<string,number>} values Enum values\n * @property {Object.<string,*>} [options] Enum options\n */ /**\n * Constructs an enum from an enum descriptor.\n * @param {string} name Enum name\n * @param {IEnum} json Enum descriptor\n * @returns {Enum} Created enum\n * @throws {TypeError} If arguments are invalid\n */ Enum.fromJSON = function fromJSON(name, json) {\n    var enm = new Enum(name, json.values, json.options, json.comment, json.comments);\n    enm.reserved = json.reserved;\n    if (json.edition) enm._edition = json.edition;\n    enm._defaultEdition = \"proto3\"; // For backwards-compatibility.\n    return enm;\n};\n/**\n * Converts this enum to an enum descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IEnum} Enum descriptor\n */ Enum.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"edition\",\n        this._editionToJSON(),\n        \"options\",\n        this.options,\n        \"valuesOptions\",\n        this.valuesOptions,\n        \"values\",\n        this.values,\n        \"reserved\",\n        this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined,\n        \"comments\",\n        keepComments ? this.comments : undefined\n    ]);\n};\n/**\n * Adds a value to this enum.\n * @param {string} name Value name\n * @param {number} id Value id\n * @param {string} [comment] Comment, if any\n * @param {Object.<string, *>|undefined} [options] Options, if any\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a value with this name or id\n */ Enum.prototype.add = function add(name, id, comment, options) {\n    // utilized by the parser but not by .fromJSON\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    if (!util.isInteger(id)) throw TypeError(\"id must be an integer\");\n    if (this.values[name] !== undefined) throw Error(\"duplicate name '\" + name + \"' in \" + this);\n    if (this.isReservedId(id)) throw Error(\"id \" + id + \" is reserved in \" + this);\n    if (this.isReservedName(name)) throw Error(\"name '\" + name + \"' is reserved in \" + this);\n    if (this.valuesById[id] !== undefined) {\n        if (!(this.options && this.options.allow_alias)) throw Error(\"duplicate id \" + id + \" in \" + this);\n        this.values[name] = id;\n    } else this.valuesById[this.values[name] = id] = name;\n    if (options) {\n        if (this.valuesOptions === undefined) this.valuesOptions = {};\n        this.valuesOptions[name] = options || null;\n    }\n    this.comments[name] = comment || null;\n    return this;\n};\n/**\n * Removes a value from this enum\n * @param {string} name Value name\n * @returns {Enum} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `name` is not a name of this enum\n */ Enum.prototype.remove = function remove(name) {\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    var val = this.values[name];\n    if (val == null) throw Error(\"name '\" + name + \"' does not exist in \" + this);\n    delete this.valuesById[val];\n    delete this.values[name];\n    delete this.comments[name];\n    if (this.valuesOptions) delete this.valuesOptions[name];\n    return this;\n};\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Enum.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Enum.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZW51bS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLDJCQUEyQjtBQUMzQixJQUFJQyxtQkFBbUJDLG1CQUFPQSxDQUFDLDBGQUFVO0FBQ3hDLEVBQUNGLEtBQUtHLFNBQVMsR0FBR0MsT0FBT0MsTUFBTSxDQUFDSixpQkFBaUJFLFNBQVMsR0FBR0csV0FBVyxHQUFHTixJQUFHLEVBQUdPLFNBQVMsR0FBRztBQUU5RixJQUFJQyxZQUFZTixtQkFBT0EsQ0FBQyxnR0FBYSxHQUNqQ08sT0FBT1AsbUJBQU9BLENBQUMsc0ZBQVE7QUFFM0I7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTRixLQUFLVSxJQUFJLEVBQUVDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLFFBQVEsRUFBRUMsYUFBYTtJQUNqRWQsaUJBQWlCZSxJQUFJLENBQUMsSUFBSSxFQUFFTixNQUFNRTtJQUVsQyxJQUFJRCxVQUFVLE9BQU9BLFdBQVcsVUFDNUIsTUFBTU0sVUFBVTtJQUVwQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLFVBQVUsR0FBRyxDQUFDO0lBRW5COzs7S0FHQyxHQUNELElBQUksQ0FBQ1AsTUFBTSxHQUFHUCxPQUFPQyxNQUFNLENBQUMsSUFBSSxDQUFDYSxVQUFVLEdBQUcsaUJBQWlCO0lBRS9EOzs7S0FHQyxHQUNELElBQUksQ0FBQ0wsT0FBTyxHQUFHQTtJQUVmOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsUUFBUSxHQUFHQSxZQUFZLENBQUM7SUFFN0I7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxhQUFhLEdBQUdBO0lBRXJCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0ksZUFBZSxHQUFHLENBQUM7SUFFeEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxRQUFRLEdBQUdDLFdBQVcsU0FBUztJQUVwQyx3RkFBd0Y7SUFDeEYsdUZBQXVGO0lBQ3ZGLG1GQUFtRjtJQUVuRixJQUFJVixRQUNBO1FBQUEsSUFBSyxJQUFJVyxPQUFPbEIsT0FBT2tCLElBQUksQ0FBQ1gsU0FBU1ksSUFBSSxHQUFHQSxJQUFJRCxLQUFLRSxNQUFNLEVBQUUsRUFBRUQsRUFDM0QsSUFBSSxPQUFPWixNQUFNLENBQUNXLElBQUksQ0FBQ0MsRUFBRSxDQUFDLEtBQUssVUFDM0IsSUFBSSxDQUFDTCxVQUFVLENBQUUsSUFBSSxDQUFDUCxNQUFNLENBQUNXLElBQUksQ0FBQ0MsRUFBRSxDQUFDLEdBQUdaLE1BQU0sQ0FBQ1csSUFBSSxDQUFDQyxFQUFFLENBQUMsQ0FBRSxHQUFHRCxJQUFJLENBQUNDLEVBQUU7SUFBQTtBQUNuRjtBQUVBOztDQUVDLEdBQ0R2QixLQUFLRyxTQUFTLENBQUNzQixnQkFBZ0IsR0FBRyxTQUFTQSxpQkFBaUJDLE9BQU87SUFDL0RBLFVBQVUsSUFBSSxDQUFDQyxRQUFRLElBQUlEO0lBQzNCekIsaUJBQWlCRSxTQUFTLENBQUNzQixnQkFBZ0IsQ0FBQ1QsSUFBSSxDQUFDLElBQUksRUFBRVU7SUFFdkR0QixPQUFPa0IsSUFBSSxDQUFDLElBQUksQ0FBQ1gsTUFBTSxFQUFFaUIsT0FBTyxDQUFDQyxDQUFBQTtRQUM3QixJQUFJQyxxQkFBcUIxQixPQUFPMkIsTUFBTSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUNDLFNBQVM7UUFDekQsSUFBSSxDQUFDYixlQUFlLENBQUNVLElBQUksR0FBR3pCLE9BQU8yQixNQUFNLENBQUNELG9CQUFvQixJQUFJLENBQUNmLGFBQWEsSUFBSSxJQUFJLENBQUNBLGFBQWEsQ0FBQ2MsSUFBSSxJQUFJLElBQUksQ0FBQ2QsYUFBYSxDQUFDYyxJQUFJLENBQUNJLFFBQVE7SUFDbko7SUFFQSxPQUFPLElBQUk7QUFDZjtBQUVBOzs7OztDQUtDLEdBRUQ7Ozs7OztDQU1DLEdBQ0RqQyxLQUFLa0MsUUFBUSxHQUFHLFNBQVNBLFNBQVN4QixJQUFJLEVBQUV5QixJQUFJO0lBQ3hDLElBQUlDLE1BQU0sSUFBSXBDLEtBQUtVLE1BQU15QixLQUFLeEIsTUFBTSxFQUFFd0IsS0FBS3ZCLE9BQU8sRUFBRXVCLEtBQUt0QixPQUFPLEVBQUVzQixLQUFLckIsUUFBUTtJQUMvRXNCLElBQUloQixRQUFRLEdBQUdlLEtBQUtmLFFBQVE7SUFDNUIsSUFBSWUsS0FBS1QsT0FBTyxFQUNaVSxJQUFJVCxRQUFRLEdBQUdRLEtBQUtULE9BQU87SUFDL0JVLElBQUlDLGVBQWUsR0FBRyxVQUFXLCtCQUErQjtJQUNoRSxPQUFPRDtBQUNYO0FBRUE7Ozs7Q0FJQyxHQUNEcEMsS0FBS0csU0FBUyxDQUFDbUMsTUFBTSxHQUFHLFNBQVNBLE9BQU9DLGFBQWE7SUFDakQsSUFBSUMsZUFBZUQsZ0JBQWdCRSxRQUFRRixjQUFjQyxZQUFZLElBQUk7SUFDekUsT0FBTy9CLEtBQUtpQyxRQUFRLENBQUM7UUFDakI7UUFBa0IsSUFBSSxDQUFDQyxjQUFjO1FBQ3JDO1FBQWtCLElBQUksQ0FBQy9CLE9BQU87UUFDOUI7UUFBa0IsSUFBSSxDQUFDRyxhQUFhO1FBQ3BDO1FBQWtCLElBQUksQ0FBQ0osTUFBTTtRQUM3QjtRQUFrQixJQUFJLENBQUNTLFFBQVEsSUFBSSxJQUFJLENBQUNBLFFBQVEsQ0FBQ0ksTUFBTSxHQUFHLElBQUksQ0FBQ0osUUFBUSxHQUFHQztRQUMxRTtRQUFrQm1CLGVBQWUsSUFBSSxDQUFDM0IsT0FBTyxHQUFHUTtRQUNoRDtRQUFrQm1CLGVBQWUsSUFBSSxDQUFDMUIsUUFBUSxHQUFHTztLQUNwRDtBQUNMO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0RyQixLQUFLRyxTQUFTLENBQUN5QyxHQUFHLEdBQUcsU0FBU0EsSUFBSWxDLElBQUksRUFBRW1DLEVBQUUsRUFBRWhDLE9BQU8sRUFBRUQsT0FBTztJQUN4RCw4Q0FBOEM7SUFFOUMsSUFBSSxDQUFDSCxLQUFLcUMsUUFBUSxDQUFDcEMsT0FDZixNQUFNTyxVQUFVO0lBRXBCLElBQUksQ0FBQ1IsS0FBS3NDLFNBQVMsQ0FBQ0YsS0FDaEIsTUFBTTVCLFVBQVU7SUFFcEIsSUFBSSxJQUFJLENBQUNOLE1BQU0sQ0FBQ0QsS0FBSyxLQUFLVyxXQUN0QixNQUFNMkIsTUFBTSxxQkFBcUJ0QyxPQUFPLFVBQVUsSUFBSTtJQUUxRCxJQUFJLElBQUksQ0FBQ3VDLFlBQVksQ0FBQ0osS0FDbEIsTUFBTUcsTUFBTSxRQUFRSCxLQUFLLHFCQUFxQixJQUFJO0lBRXRELElBQUksSUFBSSxDQUFDSyxjQUFjLENBQUN4QyxPQUNwQixNQUFNc0MsTUFBTSxXQUFXdEMsT0FBTyxzQkFBc0IsSUFBSTtJQUU1RCxJQUFJLElBQUksQ0FBQ1EsVUFBVSxDQUFDMkIsR0FBRyxLQUFLeEIsV0FBVztRQUNuQyxJQUFJLENBQUUsS0FBSSxDQUFDVCxPQUFPLElBQUksSUFBSSxDQUFDQSxPQUFPLENBQUN1QyxXQUFXLEdBQzFDLE1BQU1ILE1BQU0sa0JBQWtCSCxLQUFLLFNBQVMsSUFBSTtRQUNwRCxJQUFJLENBQUNsQyxNQUFNLENBQUNELEtBQUssR0FBR21DO0lBQ3hCLE9BQ0ksSUFBSSxDQUFDM0IsVUFBVSxDQUFDLElBQUksQ0FBQ1AsTUFBTSxDQUFDRCxLQUFLLEdBQUdtQyxHQUFHLEdBQUduQztJQUU5QyxJQUFJRSxTQUFTO1FBQ1QsSUFBSSxJQUFJLENBQUNHLGFBQWEsS0FBS00sV0FDdkIsSUFBSSxDQUFDTixhQUFhLEdBQUcsQ0FBQztRQUMxQixJQUFJLENBQUNBLGFBQWEsQ0FBQ0wsS0FBSyxHQUFHRSxXQUFXO0lBQzFDO0lBRUEsSUFBSSxDQUFDRSxRQUFRLENBQUNKLEtBQUssR0FBR0csV0FBVztJQUNqQyxPQUFPLElBQUk7QUFDZjtBQUVBOzs7Ozs7Q0FNQyxHQUNEYixLQUFLRyxTQUFTLENBQUNpRCxNQUFNLEdBQUcsU0FBU0EsT0FBTzFDLElBQUk7SUFFeEMsSUFBSSxDQUFDRCxLQUFLcUMsUUFBUSxDQUFDcEMsT0FDZixNQUFNTyxVQUFVO0lBRXBCLElBQUlvQyxNQUFNLElBQUksQ0FBQzFDLE1BQU0sQ0FBQ0QsS0FBSztJQUMzQixJQUFJMkMsT0FBTyxNQUNQLE1BQU1MLE1BQU0sV0FBV3RDLE9BQU8seUJBQXlCLElBQUk7SUFFL0QsT0FBTyxJQUFJLENBQUNRLFVBQVUsQ0FBQ21DLElBQUk7SUFDM0IsT0FBTyxJQUFJLENBQUMxQyxNQUFNLENBQUNELEtBQUs7SUFDeEIsT0FBTyxJQUFJLENBQUNJLFFBQVEsQ0FBQ0osS0FBSztJQUMxQixJQUFJLElBQUksQ0FBQ0ssYUFBYSxFQUNsQixPQUFPLElBQUksQ0FBQ0EsYUFBYSxDQUFDTCxLQUFLO0lBRW5DLE9BQU8sSUFBSTtBQUNmO0FBRUE7Ozs7Q0FJQyxHQUNEVixLQUFLRyxTQUFTLENBQUM4QyxZQUFZLEdBQUcsU0FBU0EsYUFBYUosRUFBRTtJQUNsRCxPQUFPckMsVUFBVXlDLFlBQVksQ0FBQyxJQUFJLENBQUM3QixRQUFRLEVBQUV5QjtBQUNqRDtBQUVBOzs7O0NBSUMsR0FDRDdDLEtBQUtHLFNBQVMsQ0FBQytDLGNBQWMsR0FBRyxTQUFTQSxlQUFleEMsSUFBSTtJQUN4RCxPQUFPRixVQUFVMEMsY0FBYyxDQUFDLElBQUksQ0FBQzlCLFFBQVEsRUFBRVY7QUFDbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZW51bS5qcz9jNTJjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBFbnVtO1xuXG4vLyBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbnZhciBSZWZsZWN0aW9uT2JqZWN0ID0gcmVxdWlyZShcIi4vb2JqZWN0XCIpO1xuKChFbnVtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IEVudW0pLmNsYXNzTmFtZSA9IFwiRW51bVwiO1xuXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpLFxuICAgIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgZW51bSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIGVudW0uXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLG51bWJlcj59IFt2YWx1ZXNdIEVudW0gdmFsdWVzIGFzIGFuIG9iamVjdCwgYnkgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gVGhlIGNvbW1lbnQgZm9yIHRoaXMgZW51bVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZyxzdHJpbmc+fSBbY29tbWVudHNdIFRoZSB2YWx1ZSBjb21tZW50cyBmb3IgdGhpcyBlbnVtXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLE9iamVjdDxzdHJpbmcsKj4+fHVuZGVmaW5lZH0gW3ZhbHVlc09wdGlvbnNdIFRoZSB2YWx1ZSBvcHRpb25zIGZvciB0aGlzIGVudW1cbiAqL1xuZnVuY3Rpb24gRW51bShuYW1lLCB2YWx1ZXMsIG9wdGlvbnMsIGNvbW1lbnQsIGNvbW1lbnRzLCB2YWx1ZXNPcHRpb25zKSB7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHZhbHVlcyAmJiB0eXBlb2YgdmFsdWVzICE9PSBcIm9iamVjdFwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJ2YWx1ZXMgbXVzdCBiZSBhbiBvYmplY3RcIik7XG5cbiAgICAvKipcbiAgICAgKiBFbnVtIHZhbHVlcyBieSBpZC5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxudW1iZXIsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnZhbHVlc0J5SWQgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEVudW0gdmFsdWVzIGJ5IG5hbWUuXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXMgPSBPYmplY3QuY3JlYXRlKHRoaXMudmFsdWVzQnlJZCk7IC8vIHRvSlNPTiwgbWFya2VyXG5cbiAgICAvKipcbiAgICAgKiBFbnVtIGNvbW1lbnQgdGV4dC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcblxuICAgIC8qKlxuICAgICAqIFZhbHVlIGNvbW1lbnQgdGV4dHMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnRzID0gY29tbWVudHMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZXMgb3B0aW9ucywgaWYgYW55XG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsICo+Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy52YWx1ZXNPcHRpb25zID0gdmFsdWVzT3B0aW9ucztcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIHZhbHVlcyBmZWF0dXJlcywgaWYgYW55XG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsIE9iamVjdDxzdHJpbmcsICo+Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5fdmFsdWVzRmVhdHVyZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlc2VydmVkIHJhbmdlcywgaWYgYW55LlxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyW118c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc2VydmVkID0gdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8vIE5vdGUgdGhhdCB2YWx1ZXMgaW5oZXJpdCB2YWx1ZXNCeUlkIG9uIHRoZWlyIHByb3RvdHlwZSB3aGljaCBtYWtlcyB0aGVtIGEgVHlwZVNjcmlwdC1cbiAgICAvLyBjb21wYXRpYmxlIGVudW0uIFRoaXMgaXMgdXNlZCBieSBwYnRzIHRvIHdyaXRlIGFjdHVhbCBlbnVtIGRlZmluaXRpb25zIHRoYXQgd29yayBmb3JcbiAgICAvLyBzdGF0aWMgYW5kIHJlZmxlY3Rpb24gY29kZSBhbGlrZSBpbnN0ZWFkIG9mIGVtaXR0aW5nIGdlbmVyaWMgb2JqZWN0IGRlZmluaXRpb25zLlxuXG4gICAgaWYgKHZhbHVlcylcbiAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlcyksIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzW2tleXNbaV1dID09PSBcIm51bWJlclwiKSAvLyB1c2UgZm9yd2FyZCBlbnRyaWVzIG9ubHlcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlc0J5SWRbIHRoaXMudmFsdWVzW2tleXNbaV1dID0gdmFsdWVzW2tleXNbaV1dIF0gPSBrZXlzW2ldO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5FbnVtLnByb3RvdHlwZS5fcmVzb2x2ZUZlYXR1cmVzID0gZnVuY3Rpb24gX3Jlc29sdmVGZWF0dXJlcyhlZGl0aW9uKSB7XG4gICAgZWRpdGlvbiA9IHRoaXMuX2VkaXRpb24gfHwgZWRpdGlvbjtcbiAgICBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5fcmVzb2x2ZUZlYXR1cmVzLmNhbGwodGhpcywgZWRpdGlvbik7XG5cbiAgICBPYmplY3Qua2V5cyh0aGlzLnZhbHVlcykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICB2YXIgcGFyZW50RmVhdHVyZXNDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fZmVhdHVyZXMpO1xuICAgICAgICB0aGlzLl92YWx1ZXNGZWF0dXJlc1trZXldID0gT2JqZWN0LmFzc2lnbihwYXJlbnRGZWF0dXJlc0NvcHksIHRoaXMudmFsdWVzT3B0aW9ucyAmJiB0aGlzLnZhbHVlc09wdGlvbnNba2V5XSAmJiB0aGlzLnZhbHVlc09wdGlvbnNba2V5XS5mZWF0dXJlcyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW51bSBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRW51bVxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxudW1iZXI+fSB2YWx1ZXMgRW51bSB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBFbnVtIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bSBmcm9tIGFuIGVudW0gZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEVudW0gbmFtZVxuICogQHBhcmFtIHtJRW51bX0ganNvbiBFbnVtIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtFbnVtfSBDcmVhdGVkIGVudW1cbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbkVudW0uZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgdmFyIGVubSA9IG5ldyBFbnVtKG5hbWUsIGpzb24udmFsdWVzLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCwganNvbi5jb21tZW50cyk7XG4gICAgZW5tLnJlc2VydmVkID0ganNvbi5yZXNlcnZlZDtcbiAgICBpZiAoanNvbi5lZGl0aW9uKVxuICAgICAgICBlbm0uX2VkaXRpb24gPSBqc29uLmVkaXRpb247XG4gICAgZW5tLl9kZWZhdWx0RWRpdGlvbiA9IFwicHJvdG8zXCI7ICAvLyBGb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkuXG4gICAgcmV0dXJuIGVubTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBlbnVtIHRvIGFuIGVudW0gZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lFbnVtfSBFbnVtIGRlc2NyaXB0b3JcbiAqL1xuRW51bS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcImVkaXRpb25cIiAgICAgICAsIHRoaXMuX2VkaXRpb25Ub0pTT04oKSxcbiAgICAgICAgXCJvcHRpb25zXCIgICAgICAgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwidmFsdWVzT3B0aW9uc1wiICwgdGhpcy52YWx1ZXNPcHRpb25zLFxuICAgICAgICBcInZhbHVlc1wiICAgICAgICAsIHRoaXMudmFsdWVzLFxuICAgICAgICBcInJlc2VydmVkXCIgICAgICAsIHRoaXMucmVzZXJ2ZWQgJiYgdGhpcy5yZXNlcnZlZC5sZW5ndGggPyB0aGlzLnJlc2VydmVkIDogdW5kZWZpbmVkLFxuICAgICAgICBcImNvbW1lbnRcIiAgICAgICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50c1wiICAgICAgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnRzIDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSB2YWx1ZSB0byB0aGlzIGVudW0uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBWYWx1ZSBuYW1lXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVmFsdWUgaWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gQ29tbWVudCwgaWYgYW55XG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPnx1bmRlZmluZWR9IFtvcHRpb25zXSBPcHRpb25zLCBpZiBhbnlcbiAqIEByZXR1cm5zIHtFbnVtfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgYWxyZWFkeSBhIHZhbHVlIHdpdGggdGhpcyBuYW1lIG9yIGlkXG4gKi9cbkVudW0ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChuYW1lLCBpZCwgY29tbWVudCwgb3B0aW9ucykge1xuICAgIC8vIHV0aWxpemVkIGJ5IHRoZSBwYXJzZXIgYnV0IG5vdCBieSAuZnJvbUpTT05cblxuICAgIGlmICghdXRpbC5pc1N0cmluZyhuYW1lKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpZCkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImlkIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcblxuICAgIGlmICh0aGlzLnZhbHVlc1tuYW1lXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBuYW1lICdcIiArIG5hbWUgKyBcIicgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWRJZChpZCkpXG4gICAgICAgIHRocm93IEVycm9yKFwiaWQgXCIgKyBpZCArIFwiIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAodGhpcy5pc1Jlc2VydmVkTmFtZShuYW1lKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJuYW1lICdcIiArIG5hbWUgKyBcIicgaXMgcmVzZXJ2ZWQgaW4gXCIgKyB0aGlzKTtcblxuICAgIGlmICh0aGlzLnZhbHVlc0J5SWRbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9ucy5hbGxvd19hbGlhcykpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBpZCBcIiArIGlkICsgXCIgaW4gXCIgKyB0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZXNbbmFtZV0gPSBpZDtcbiAgICB9IGVsc2VcbiAgICAgICAgdGhpcy52YWx1ZXNCeUlkW3RoaXMudmFsdWVzW25hbWVdID0gaWRdID0gbmFtZTtcblxuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlc09wdGlvbnMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMudmFsdWVzT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnZhbHVlc09wdGlvbnNbbmFtZV0gPSBvcHRpb25zIHx8IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5jb21tZW50c1tuYW1lXSA9IGNvbW1lbnQgfHwgbnVsbDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIHZhbHVlIGZyb20gdGhpcyBlbnVtXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBWYWx1ZSBuYW1lXG4gKiBAcmV0dXJucyB7RW51bX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBuYW1lYCBpcyBub3QgYSBuYW1lIG9mIHRoaXMgZW51bVxuICovXG5FbnVtLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICB2YXIgdmFsID0gdGhpcy52YWx1ZXNbbmFtZV07XG4gICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5hbWUgJ1wiICsgbmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdCBpbiBcIiArIHRoaXMpO1xuXG4gICAgZGVsZXRlIHRoaXMudmFsdWVzQnlJZFt2YWxdO1xuICAgIGRlbGV0ZSB0aGlzLnZhbHVlc1tuYW1lXTtcbiAgICBkZWxldGUgdGhpcy5jb21tZW50c1tuYW1lXTtcbiAgICBpZiAodGhpcy52YWx1ZXNPcHRpb25zKVxuICAgICAgICBkZWxldGUgdGhpcy52YWx1ZXNPcHRpb25zW25hbWVdO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgSWQgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuRW51bS5wcm90b3R5cGUuaXNSZXNlcnZlZElkID0gZnVuY3Rpb24gaXNSZXNlcnZlZElkKGlkKSB7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5pc1Jlc2VydmVkSWQodGhpcy5yZXNlcnZlZCwgaWQpO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbkVudW0ucHJvdG90eXBlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUobmFtZSkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZE5hbWUodGhpcy5yZXNlcnZlZCwgbmFtZSk7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJFbnVtIiwiUmVmbGVjdGlvbk9iamVjdCIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsIk5hbWVzcGFjZSIsInV0aWwiLCJuYW1lIiwidmFsdWVzIiwib3B0aW9ucyIsImNvbW1lbnQiLCJjb21tZW50cyIsInZhbHVlc09wdGlvbnMiLCJjYWxsIiwiVHlwZUVycm9yIiwidmFsdWVzQnlJZCIsIl92YWx1ZXNGZWF0dXJlcyIsInJlc2VydmVkIiwidW5kZWZpbmVkIiwia2V5cyIsImkiLCJsZW5ndGgiLCJfcmVzb2x2ZUZlYXR1cmVzIiwiZWRpdGlvbiIsIl9lZGl0aW9uIiwiZm9yRWFjaCIsImtleSIsInBhcmVudEZlYXR1cmVzQ29weSIsImFzc2lnbiIsIl9mZWF0dXJlcyIsImZlYXR1cmVzIiwiZnJvbUpTT04iLCJqc29uIiwiZW5tIiwiX2RlZmF1bHRFZGl0aW9uIiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImtlZXBDb21tZW50cyIsIkJvb2xlYW4iLCJ0b09iamVjdCIsIl9lZGl0aW9uVG9KU09OIiwiYWRkIiwiaWQiLCJpc1N0cmluZyIsImlzSW50ZWdlciIsIkVycm9yIiwiaXNSZXNlcnZlZElkIiwiaXNSZXNlcnZlZE5hbWUiLCJhbGxvd19hbGlhcyIsInJlbW92ZSIsInZhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Field;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\n((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = \"Field\";\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\nvar Type; // cyclic\nvar ruleRe = /^required|optional|repeated$/;\n/**\n * Constructs a new message field instance. Note that {@link MapField|map fields} have their own class.\n * @name Field\n * @classdesc Reflected message field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n */ /**\n * Constructs a field from a field descriptor.\n * @param {string} name Field name\n * @param {IField} json Field descriptor\n * @returns {Field} Created field\n * @throws {TypeError} If arguments are invalid\n */ Field.fromJSON = function fromJSON(name, json) {\n    var field = new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);\n    if (json.edition) field._edition = json.edition;\n    field._defaultEdition = \"proto3\"; // For backwards-compatibility.\n    return field;\n};\n/**\n * Not an actual constructor. Use {@link Field} instead.\n * @classdesc Base class of all reflected message fields. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports FieldBase\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} type Value type\n * @param {string|Object.<string,*>} [rule=\"optional\"] Field rule\n * @param {string|Object.<string,*>} [extend] Extended type if different from parent\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function Field(name, id, type, rule, extend, options, comment) {\n    if (util.isObject(rule)) {\n        comment = extend;\n        options = rule;\n        rule = extend = undefined;\n    } else if (util.isObject(extend)) {\n        comment = options;\n        options = extend;\n        extend = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n    if (!util.isInteger(id) || id < 0) throw TypeError(\"id must be a non-negative integer\");\n    if (!util.isString(type)) throw TypeError(\"type must be a string\");\n    if (rule !== undefined && !ruleRe.test(rule = rule.toString().toLowerCase())) throw TypeError(\"rule must be a string rule\");\n    if (extend !== undefined && !util.isString(extend)) throw TypeError(\"extend must be a string\");\n    /**\n     * Field rule, if any.\n     * @type {string|undefined}\n     */ if (rule === \"proto3_optional\") {\n        rule = \"optional\";\n    }\n    this.rule = rule && rule !== \"optional\" ? rule : undefined; // toJSON\n    /**\n     * Field type.\n     * @type {string}\n     */ this.type = type; // toJSON\n    /**\n     * Unique field id.\n     * @type {number}\n     */ this.id = id; // toJSON, marker\n    /**\n     * Extended type if different from parent.\n     * @type {string|undefined}\n     */ this.extend = extend || undefined; // toJSON\n    /**\n     * Whether this field is repeated.\n     * @type {boolean}\n     */ this.repeated = rule === \"repeated\";\n    /**\n     * Whether this field is a map or not.\n     * @type {boolean}\n     */ this.map = false;\n    /**\n     * Message this field belongs to.\n     * @type {Type|null}\n     */ this.message = null;\n    /**\n     * OneOf this field belongs to, if any,\n     * @type {OneOf|null}\n     */ this.partOf = null;\n    /**\n     * The field type's default value.\n     * @type {*}\n     */ this.typeDefault = null;\n    /**\n     * The field's default value on prototypes.\n     * @type {*}\n     */ this.defaultValue = null;\n    /**\n     * Whether this field's value should be treated as a long.\n     * @type {boolean}\n     */ this.long = util.Long ? types.long[type] !== undefined : /* istanbul ignore next */ false;\n    /**\n     * Whether this field's value is a buffer.\n     * @type {boolean}\n     */ this.bytes = type === \"bytes\";\n    /**\n     * Resolved type if not a basic type.\n     * @type {Type|Enum|null}\n     */ this.resolvedType = null;\n    /**\n     * Sister-field within the extended type if a declaring extension field.\n     * @type {Field|null}\n     */ this.extensionField = null;\n    /**\n     * Sister-field within the declaring namespace if an extended field.\n     * @type {Field|null}\n     */ this.declaringField = null;\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */ this.comment = comment;\n}\n/**\n * Determines whether this field is required.\n * @name Field#required\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"required\", {\n    get: function() {\n        return this._features.field_presence === \"LEGACY_REQUIRED\";\n    }\n});\n/**\n * Determines whether this field is not required.\n * @name Field#optional\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"optional\", {\n    get: function() {\n        return !this.required;\n    }\n});\n/**\n * Determines whether this field uses tag-delimited encoding.  In proto2 this\n * corresponded to group syntax.\n * @name Field#delimited\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"delimited\", {\n    get: function() {\n        return this.resolvedType instanceof Type && this._features.message_encoding === \"DELIMITED\";\n    }\n});\n/**\n * Determines whether this field is packed. Only relevant when repeated.\n * @name Field#packed\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"packed\", {\n    get: function() {\n        return this._features.repeated_field_encoding === \"PACKED\";\n    }\n});\n/**\n * Determines whether this field tracks presence.\n * @name Field#hasPresence\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(Field.prototype, \"hasPresence\", {\n    get: function() {\n        if (this.repeated || this.map) {\n            return false;\n        }\n        return this.partOf || // oneofs\n        this.declaringField || this.extensionField || // extensions\n        this._features.field_presence !== \"IMPLICIT\";\n    }\n});\n/**\n * @override\n */ Field.prototype.setOption = function setOption(name, value, ifNotSet) {\n    return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);\n};\n/**\n * Field descriptor.\n * @interface IField\n * @property {string} [rule=\"optional\"] Field rule\n * @property {string} type Field type\n * @property {number} id Field id\n * @property {Object.<string,*>} [options] Field options\n */ /**\n * Extension field descriptor.\n * @interface IExtensionField\n * @extends IField\n * @property {string} extend Extended type\n */ /**\n * Converts this field to a field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IField} Field descriptor\n */ Field.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"edition\",\n        this._editionToJSON(),\n        \"rule\",\n        this.rule !== \"optional\" && this.rule || undefined,\n        \"type\",\n        this.type,\n        \"id\",\n        this.id,\n        \"extend\",\n        this.extend,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Resolves this field's type references.\n * @returns {Field} `this`\n * @throws {Error} If any reference cannot be resolved\n */ Field.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    if ((this.typeDefault = types.defaults[this.type]) === undefined) {\n        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);\n        if (this.resolvedType instanceof Type) this.typeDefault = null;\n        else this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]; // first defined\n    } else if (this.options && this.options.proto3_optional) {\n        // proto3 scalar value marked optional; should default to null\n        this.typeDefault = null;\n    }\n    // use explicitly set default value if present\n    if (this.options && this.options[\"default\"] != null) {\n        this.typeDefault = this.options[\"default\"];\n        if (this.resolvedType instanceof Enum && typeof this.typeDefault === \"string\") this.typeDefault = this.resolvedType.values[this.typeDefault];\n    }\n    // remove unnecessary options\n    if (this.options) {\n        if (this.options.packed !== undefined && this.resolvedType && !(this.resolvedType instanceof Enum)) delete this.options.packed;\n        if (!Object.keys(this.options).length) this.options = undefined;\n    }\n    // convert to internal data type if necesssary\n    if (this.long) {\n        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === \"u\");\n        /* istanbul ignore else */ if (Object.freeze) Object.freeze(this.typeDefault); // long instances are meant to be immutable anyway (i.e. use small int cache that even requires it)\n    } else if (this.bytes && typeof this.typeDefault === \"string\") {\n        var buf;\n        if (util.base64.test(this.typeDefault)) util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);\n        else util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);\n        this.typeDefault = buf;\n    }\n    // take special care of maps and repeated fields\n    if (this.map) this.defaultValue = util.emptyObject;\n    else if (this.repeated) this.defaultValue = util.emptyArray;\n    else this.defaultValue = this.typeDefault;\n    // ensure proper value on prototype\n    if (this.parent instanceof Type) this.parent.ctor.prototype[this.name] = this.defaultValue;\n    return ReflectionObject.prototype.resolve.call(this);\n};\n/**\n * Infers field features from legacy syntax that may have been specified differently.\n * in older editions.\n * @param {string|undefined} edition The edition this proto is on, or undefined if pre-editions\n * @returns {object} The feature values to override\n */ Field.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures(edition) {\n    if (edition !== \"proto2\" && edition !== \"proto3\") {\n        return {};\n    }\n    var features = {};\n    if (this.rule === \"required\") {\n        features.field_presence = \"LEGACY_REQUIRED\";\n    }\n    if (this.parent && types.defaults[this.type] === undefined) {\n        // We can't use resolvedType because types may not have been resolved yet.  However,\n        // legacy groups are always in the same scope as the field so we don't have to do a\n        // full scan of the tree.\n        var type = this.parent.get(this.type.split(\".\").pop());\n        if (type && type instanceof Type && type.group) {\n            features.message_encoding = \"DELIMITED\";\n        }\n    }\n    if (this.getOption(\"packed\") === true) {\n        features.repeated_field_encoding = \"PACKED\";\n    } else if (this.getOption(\"packed\") === false) {\n        features.repeated_field_encoding = \"EXPANDED\";\n    }\n    return features;\n};\n/**\n * @override\n */ Field.prototype._resolveFeatures = function _resolveFeatures(edition) {\n    return ReflectionObject.prototype._resolveFeatures.call(this, this._edition || edition);\n};\n/**\n * Decorator function as returned by {@link Field.d} and {@link MapField.d} (TypeScript).\n * @typedef FieldDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} fieldName Field name\n * @returns {undefined}\n */ /**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"string\"|\"bool\"|\"bytes\"|Object} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @param {T} [defaultValue] Default value\n * @returns {FieldDecorator} Decorator function\n * @template T extends number | number[] | Long | Long[] | string | string[] | boolean | boolean[] | Uint8Array | Uint8Array[] | Buffer | Buffer[]\n */ Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {\n    // submessage: decorate the submessage and use its name as the type\n    if (typeof fieldType === \"function\") fieldType = util.decorateType(fieldType).name;\n    else if (fieldType && typeof fieldType === \"object\") fieldType = util.decorateEnum(fieldType).name;\n    return function fieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, {\n            \"default\": defaultValue\n        }));\n    };\n};\n/**\n * Field decorator (TypeScript).\n * @name Field.d\n * @function\n * @param {number} fieldId Field id\n * @param {Constructor<T>|string} fieldType Field type\n * @param {\"optional\"|\"required\"|\"repeated\"} [fieldRule=\"optional\"] Field rule\n * @returns {FieldDecorator} Decorator function\n * @template T extends Message<T>\n * @variation 2\n */ // like Field.d but without a default value\n// Sets up cyclic dependencies (called in index-light)\nField._configure = function configure(Type_) {\n    Type = Type_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvZmllbGQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQiwyQkFBMkI7QUFDM0IsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQywwRkFBVTtBQUN4QyxFQUFDRixNQUFNRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osaUJBQWlCRSxTQUFTLEdBQUdHLFdBQVcsR0FBR04sS0FBSSxFQUFHTyxTQUFTLEdBQUc7QUFFaEcsSUFBSUMsT0FBUU4sbUJBQU9BLENBQUMsc0ZBQVEsR0FDeEJPLFFBQVFQLG1CQUFPQSxDQUFDLHdGQUFTLEdBQ3pCUSxPQUFRUixtQkFBT0EsQ0FBQyxzRkFBUTtBQUU1QixJQUFJUyxNQUFNLFNBQVM7QUFFbkIsSUFBSUMsU0FBUztBQUViOzs7Ozs7Ozs7Ozs7Q0FZQyxHQUVEOzs7Ozs7Q0FNQyxHQUNEWixNQUFNYSxRQUFRLEdBQUcsU0FBU0EsU0FBU0MsSUFBSSxFQUFFQyxJQUFJO0lBQ3pDLElBQUlDLFFBQVEsSUFBSWhCLE1BQU1jLE1BQU1DLEtBQUtFLEVBQUUsRUFBRUYsS0FBS0csSUFBSSxFQUFFSCxLQUFLSSxJQUFJLEVBQUVKLEtBQUtLLE1BQU0sRUFBRUwsS0FBS00sT0FBTyxFQUFFTixLQUFLTyxPQUFPO0lBQ2xHLElBQUlQLEtBQUtRLE9BQU8sRUFDWlAsTUFBTVEsUUFBUSxHQUFHVCxLQUFLUSxPQUFPO0lBQ2pDUCxNQUFNUyxlQUFlLEdBQUcsVUFBVywrQkFBK0I7SUFDbEUsT0FBT1Q7QUFDWDtBQUVBOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRCxTQUFTaEIsTUFBTWMsSUFBSSxFQUFFRyxFQUFFLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLE9BQU8sRUFBRUMsT0FBTztJQUV6RCxJQUFJWixLQUFLZ0IsUUFBUSxDQUFDUCxPQUFPO1FBQ3JCRyxV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QyxzREFBc0Q7QUFDdER4QyxNQUFNc0csVUFBVSxHQUFHLFNBQVNDLFVBQVVDLEtBQUs7SUFDdkM3RixPQUFPNkY7QUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9maWVsZC5qcz82NDZlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBGaWVsZDtcblxuLy8gZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG52YXIgUmVmbGVjdGlvbk9iamVjdCA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcbigoRmllbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gRmllbGQpLmNsYXNzTmFtZSA9IFwiRmllbGRcIjtcblxudmFyIEVudW0gID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB0eXBlcyA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpLFxuICAgIHV0aWwgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIFR5cGU7IC8vIGN5Y2xpY1xuXG52YXIgcnVsZVJlID0gL15yZXF1aXJlZHxvcHRpb25hbHxyZXBlYXRlZCQvO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbWVzc2FnZSBmaWVsZCBpbnN0YW5jZS4gTm90ZSB0aGF0IHtAbGluayBNYXBGaWVsZHxtYXAgZmllbGRzfSBoYXZlIHRoZWlyIG93biBjbGFzcy5cbiAqIEBuYW1lIEZpZWxkXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBtZXNzYWdlIGZpZWxkLlxuICogQGV4dGVuZHMgRmllbGRCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFVuaXF1ZSBuYW1lIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgVW5pcXVlIGlkIHdpdGhpbiBpdHMgbmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBWYWx1ZSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW3J1bGU9XCJvcHRpb25hbFwiXSBGaWVsZCBydWxlXG4gKiBAcGFyYW0ge3N0cmluZ3xPYmplY3QuPHN0cmluZywqPn0gW2V4dGVuZF0gRXh0ZW5kZWQgdHlwZSBpZiBkaWZmZXJlbnQgZnJvbSBwYXJlbnRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgZmllbGQgZnJvbSBhIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGaWVsZCBuYW1lXG4gKiBAcGFyYW0ge0lGaWVsZH0ganNvbiBGaWVsZCBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7RmllbGR9IENyZWF0ZWQgZmllbGRcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbkZpZWxkLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHZhciBmaWVsZCA9IG5ldyBGaWVsZChuYW1lLCBqc29uLmlkLCBqc29uLnR5cGUsIGpzb24ucnVsZSwganNvbi5leHRlbmQsIGpzb24ub3B0aW9ucywganNvbi5jb21tZW50KTtcbiAgICBpZiAoanNvbi5lZGl0aW9uKVxuICAgICAgICBmaWVsZC5fZWRpdGlvbiA9IGpzb24uZWRpdGlvbjtcbiAgICBmaWVsZC5fZGVmYXVsdEVkaXRpb24gPSBcInByb3RvM1wiOyAgLy8gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LlxuICAgIHJldHVybiBmaWVsZDtcbn07XG5cbi8qKlxuICogTm90IGFuIGFjdHVhbCBjb25zdHJ1Y3Rvci4gVXNlIHtAbGluayBGaWVsZH0gaW5zdGVhZC5cbiAqIEBjbGFzc2Rlc2MgQmFzZSBjbGFzcyBvZiBhbGwgcmVmbGVjdGVkIG1lc3NhZ2UgZmllbGRzLiBUaGlzIGlzIG5vdCBhbiBhY3R1YWwgY2xhc3MgYnV0IGhlcmUgZm9yIHRoZSBzYWtlIG9mIGhhdmluZyBjb25zaXN0ZW50IHR5cGUgZGVmaW5pdGlvbnMuXG4gKiBAZXhwb3J0cyBGaWVsZEJhc2VcbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVW5pcXVlIG5hbWUgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZCBVbmlxdWUgaWQgd2l0aGluIGl0cyBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFZhbHVlIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdC48c3RyaW5nLCo+fSBbcnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdC48c3RyaW5nLCo+fSBbZXh0ZW5kXSBFeHRlbmRlZCB0eXBlIGlmIGRpZmZlcmVudCBmcm9tIHBhcmVudFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gQ29tbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWVsZFxuICovXG5mdW5jdGlvbiBGaWVsZChuYW1lLCBpZCwgdHlwZSwgcnVsZSwgZXh0ZW5kLCBvcHRpb25zLCBjb21tZW50KSB7XG5cbiAgICBpZiAodXRpbC5pc09iamVjdChydWxlKSkge1xuICAgICAgICBjb21tZW50ID0gZXh0ZW5kO1xuICAgICAgICBvcHRpb25zID0gcnVsZTtcbiAgICAgICAgcnVsZSA9IGV4dGVuZCA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoZXh0ZW5kKSkge1xuICAgICAgICBjb21tZW50ID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IGV4dGVuZDtcbiAgICAgICAgZXh0ZW5kID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIFJlZmxlY3Rpb25PYmplY3QuY2FsbCh0aGlzLCBuYW1lLCBvcHRpb25zKTtcblxuICAgIGlmICghdXRpbC5pc0ludGVnZXIoaWQpIHx8IGlkIDwgMClcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiaWQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyXCIpO1xuXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKHR5cGUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJ0eXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICBpZiAocnVsZSAhPT0gdW5kZWZpbmVkICYmICFydWxlUmUudGVzdChydWxlID0gcnVsZS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJydWxlIG11c3QgYmUgYSBzdHJpbmcgcnVsZVwiKTtcblxuICAgIGlmIChleHRlbmQgIT09IHVuZGVmaW5lZCAmJiAhdXRpbC5pc1N0cmluZyhleHRlbmQpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJleHRlbmQgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIC8qKlxuICAgICAqIEZpZWxkIHJ1bGUsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBpZiAocnVsZSA9PT0gXCJwcm90bzNfb3B0aW9uYWxcIikge1xuICAgICAgICBydWxlID0gXCJvcHRpb25hbFwiO1xuICAgIH1cbiAgICB0aGlzLnJ1bGUgPSBydWxlICYmIHJ1bGUgIT09IFwib3B0aW9uYWxcIiA/IHJ1bGUgOiB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogRmllbGQgdHlwZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGU7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogVW5pcXVlIGZpZWxkIGlkLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IGlkOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5kZWQgdHlwZSBpZiBkaWZmZXJlbnQgZnJvbSBwYXJlbnQuXG4gICAgICogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5leHRlbmQgPSBleHRlbmQgfHwgdW5kZWZpbmVkOyAvLyB0b0pTT05cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCBpcyByZXBlYXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcGVhdGVkID0gcnVsZSA9PT0gXCJyZXBlYXRlZFwiO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGZpZWxkIGlzIGEgbWFwIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm1hcCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTWVzc2FnZSB0aGlzIGZpZWxkIGJlbG9uZ3MgdG8uXG4gICAgICogQHR5cGUge1R5cGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm1lc3NhZ2UgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogT25lT2YgdGhpcyBmaWVsZCBiZWxvbmdzIHRvLCBpZiBhbnksXG4gICAgICogQHR5cGUge09uZU9mfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJ0T2YgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkIHR5cGUncyBkZWZhdWx0IHZhbHVlLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMudHlwZURlZmF1bHQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZpZWxkJ3MgZGVmYXVsdCB2YWx1ZSBvbiBwcm90b3R5cGVzLlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCdzIHZhbHVlIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgbG9uZy5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmxvbmcgPSB1dGlsLkxvbmcgPyB0eXBlcy5sb25nW3R5cGVdICE9PSB1bmRlZmluZWQgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBmaWVsZCdzIHZhbHVlIGlzIGEgYnVmZmVyLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYnl0ZXMgPSB0eXBlID09PSBcImJ5dGVzXCI7XG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCB0eXBlIGlmIG5vdCBhIGJhc2ljIHR5cGUuXG4gICAgICogQHR5cGUge1R5cGV8RW51bXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZWRUeXBlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNpc3Rlci1maWVsZCB3aXRoaW4gdGhlIGV4dGVuZGVkIHR5cGUgaWYgYSBkZWNsYXJpbmcgZXh0ZW5zaW9uIGZpZWxkLlxuICAgICAqIEB0eXBlIHtGaWVsZHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW5zaW9uRmllbGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogU2lzdGVyLWZpZWxkIHdpdGhpbiB0aGUgZGVjbGFyaW5nIG5hbWVzcGFjZSBpZiBhbiBleHRlbmRlZCBmaWVsZC5cbiAgICAgKiBAdHlwZSB7RmllbGR8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRlY2xhcmluZ0ZpZWxkID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgZm9yIHRoaXMgZmllbGQuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgZmllbGQgaXMgcmVxdWlyZWQuXG4gKiBAbmFtZSBGaWVsZCNyZXF1aXJlZFxuICogQHR5cGUge2Jvb2xlYW59XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpZWxkLnByb3RvdHlwZSwgXCJyZXF1aXJlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVzLmZpZWxkX3ByZXNlbmNlID09PSBcIkxFR0FDWV9SRVFVSVJFRFwiO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGlzIGZpZWxkIGlzIG5vdCByZXF1aXJlZC5cbiAqIEBuYW1lIEZpZWxkI29wdGlvbmFsXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRmllbGQucHJvdG90eXBlLCBcIm9wdGlvbmFsXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMucmVxdWlyZWQ7XG4gICAgfVxufSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgZmllbGQgdXNlcyB0YWctZGVsaW1pdGVkIGVuY29kaW5nLiAgSW4gcHJvdG8yIHRoaXNcbiAqIGNvcnJlc3BvbmRlZCB0byBncm91cCBzeW50YXguXG4gKiBAbmFtZSBGaWVsZCNkZWxpbWl0ZWRcbiAqIEB0eXBlIHtib29sZWFufVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShGaWVsZC5wcm90b3R5cGUsIFwiZGVsaW1pdGVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFR5cGUgaW5zdGFuY2VvZiBUeXBlICYmXG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlcy5tZXNzYWdlX2VuY29kaW5nID09PSBcIkRFTElNSVRFRFwiO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGlzIGZpZWxkIGlzIHBhY2tlZC4gT25seSByZWxldmFudCB3aGVuIHJlcGVhdGVkLlxuICogQG5hbWUgRmllbGQjcGFja2VkXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRmllbGQucHJvdG90eXBlLCBcInBhY2tlZFwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZlYXR1cmVzLnJlcGVhdGVkX2ZpZWxkX2VuY29kaW5nID09PSBcIlBBQ0tFRFwiO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGlzIGZpZWxkIHRyYWNrcyBwcmVzZW5jZS5cbiAqIEBuYW1lIEZpZWxkI2hhc1ByZXNlbmNlXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRmllbGQucHJvdG90eXBlLCBcImhhc1ByZXNlbmNlXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yZXBlYXRlZCB8fCB0aGlzLm1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRPZiB8fCAvLyBvbmVvZnNcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyaW5nRmllbGQgfHwgdGhpcy5leHRlbnNpb25GaWVsZCB8fCAvLyBleHRlbnNpb25zXG4gICAgICAgICAgICB0aGlzLl9mZWF0dXJlcy5maWVsZF9wcmVzZW5jZSAhPT0gXCJJTVBMSUNJVFwiO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5GaWVsZC5wcm90b3R5cGUuc2V0T3B0aW9uID0gZnVuY3Rpb24gc2V0T3B0aW9uKG5hbWUsIHZhbHVlLCBpZk5vdFNldCkge1xuICAgIHJldHVybiBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5zZXRPcHRpb24uY2FsbCh0aGlzLCBuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpO1xufTtcblxuLyoqXG4gKiBGaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRmllbGRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlIEZpZWxkIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCBGaWVsZCBpZFxuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIEZpZWxkIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIEV4dGVuc2lvbiBmaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRXh0ZW5zaW9uRmllbGRcbiAqIEBleHRlbmRzIElGaWVsZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV4dGVuZCBFeHRlbmRlZCB0eXBlXG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGZpZWxkIHRvIGEgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7SVRvSlNPTk9wdGlvbnN9IFt0b0pTT05PcHRpb25zXSBKU09OIGNvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge0lGaWVsZH0gRmllbGQgZGVzY3JpcHRvclxuICovXG5GaWVsZC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcImVkaXRpb25cIiAsIHRoaXMuX2VkaXRpb25Ub0pTT04oKSxcbiAgICAgICAgXCJydWxlXCIgICAgLCB0aGlzLnJ1bGUgIT09IFwib3B0aW9uYWxcIiAmJiB0aGlzLnJ1bGUgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcInR5cGVcIiAgICAsIHRoaXMudHlwZSxcbiAgICAgICAgXCJpZFwiICAgICAgLCB0aGlzLmlkLFxuICAgICAgICBcImV4dGVuZFwiICAsIHRoaXMuZXh0ZW5kLFxuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJjb21tZW50XCIgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhpcyBmaWVsZCdzIHR5cGUgcmVmZXJlbmNlcy5cbiAqIEByZXR1cm5zIHtGaWVsZH0gYHRoaXNgXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYW55IHJlZmVyZW5jZSBjYW5ub3QgYmUgcmVzb2x2ZWRcbiAqL1xuRmllbGQucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuXG4gICAgaWYgKHRoaXMucmVzb2x2ZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCh0aGlzLnR5cGVEZWZhdWx0ID0gdHlwZXMuZGVmYXVsdHNbdGhpcy50eXBlXSkgPT09IHVuZGVmaW5lZCkgeyAvLyBpZiBub3QgYSBiYXNpYyB0eXBlLCByZXNvbHZlIGl0XG4gICAgICAgIHRoaXMucmVzb2x2ZWRUeXBlID0gKHRoaXMuZGVjbGFyaW5nRmllbGQgPyB0aGlzLmRlY2xhcmluZ0ZpZWxkLnBhcmVudCA6IHRoaXMucGFyZW50KS5sb29rdXBUeXBlT3JFbnVtKHRoaXMudHlwZSk7XG4gICAgICAgIGlmICh0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIFR5cGUpXG4gICAgICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gbnVsbDtcbiAgICAgICAgZWxzZSAvLyBpbnN0YW5jZW9mIEVudW1cbiAgICAgICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXNbT2JqZWN0LmtleXModGhpcy5yZXNvbHZlZFR5cGUudmFsdWVzKVswXV07IC8vIGZpcnN0IGRlZmluZWRcbiAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucHJvdG8zX29wdGlvbmFsKSB7XG4gICAgICAgIC8vIHByb3RvMyBzY2FsYXIgdmFsdWUgbWFya2VkIG9wdGlvbmFsOyBzaG91bGQgZGVmYXVsdCB0byBudWxsXG4gICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIHVzZSBleHBsaWNpdGx5IHNldCBkZWZhdWx0IHZhbHVlIGlmIHByZXNlbnRcbiAgICBpZiAodGhpcy5vcHRpb25zICYmIHRoaXMub3B0aW9uc1tcImRlZmF1bHRcIl0gIT0gbnVsbCkge1xuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gdGhpcy5vcHRpb25zW1wiZGVmYXVsdFwiXTtcbiAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSAmJiB0eXBlb2YgdGhpcy50eXBlRGVmYXVsdCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRoaXMudHlwZURlZmF1bHQgPSB0aGlzLnJlc29sdmVkVHlwZS52YWx1ZXNbdGhpcy50eXBlRGVmYXVsdF07XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIHVubmVjZXNzYXJ5IG9wdGlvbnNcbiAgICBpZiAodGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGFja2VkICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yZXNvbHZlZFR5cGUgJiYgISh0aGlzLnJlc29sdmVkVHlwZSBpbnN0YW5jZW9mIEVudW0pKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMub3B0aW9ucy5wYWNrZWQ7XG4gICAgICAgIGlmICghT2JqZWN0LmtleXModGhpcy5vcHRpb25zKS5sZW5ndGgpXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gY29udmVydCB0byBpbnRlcm5hbCBkYXRhIHR5cGUgaWYgbmVjZXNzc2FyeVxuICAgIGlmICh0aGlzLmxvbmcpIHtcbiAgICAgICAgdGhpcy50eXBlRGVmYXVsdCA9IHV0aWwuTG9uZy5mcm9tTnVtYmVyKHRoaXMudHlwZURlZmF1bHQsIHRoaXMudHlwZS5jaGFyQXQoMCkgPT09IFwidVwiKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSlcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUodGhpcy50eXBlRGVmYXVsdCk7IC8vIGxvbmcgaW5zdGFuY2VzIGFyZSBtZWFudCB0byBiZSBpbW11dGFibGUgYW55d2F5IChpLmUuIHVzZSBzbWFsbCBpbnQgY2FjaGUgdGhhdCBldmVuIHJlcXVpcmVzIGl0KVxuXG4gICAgfSBlbHNlIGlmICh0aGlzLmJ5dGVzICYmIHR5cGVvZiB0aGlzLnR5cGVEZWZhdWx0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhciBidWY7XG4gICAgICAgIGlmICh1dGlsLmJhc2U2NC50ZXN0KHRoaXMudHlwZURlZmF1bHQpKVxuICAgICAgICAgICAgdXRpbC5iYXNlNjQuZGVjb2RlKHRoaXMudHlwZURlZmF1bHQsIGJ1ZiA9IHV0aWwubmV3QnVmZmVyKHV0aWwuYmFzZTY0Lmxlbmd0aCh0aGlzLnR5cGVEZWZhdWx0KSksIDApO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB1dGlsLnV0Zjgud3JpdGUodGhpcy50eXBlRGVmYXVsdCwgYnVmID0gdXRpbC5uZXdCdWZmZXIodXRpbC51dGY4Lmxlbmd0aCh0aGlzLnR5cGVEZWZhdWx0KSksIDApO1xuICAgICAgICB0aGlzLnR5cGVEZWZhdWx0ID0gYnVmO1xuICAgIH1cblxuICAgIC8vIHRha2Ugc3BlY2lhbCBjYXJlIG9mIG1hcHMgYW5kIHJlcGVhdGVkIGZpZWxkc1xuICAgIGlmICh0aGlzLm1hcClcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB1dGlsLmVtcHR5T2JqZWN0O1xuICAgIGVsc2UgaWYgKHRoaXMucmVwZWF0ZWQpXG4gICAgICAgIHRoaXMuZGVmYXVsdFZhbHVlID0gdXRpbC5lbXB0eUFycmF5O1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5kZWZhdWx0VmFsdWUgPSB0aGlzLnR5cGVEZWZhdWx0O1xuXG4gICAgLy8gZW5zdXJlIHByb3BlciB2YWx1ZSBvbiBwcm90b3R5cGVcbiAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBUeXBlKVxuICAgICAgICB0aGlzLnBhcmVudC5jdG9yLnByb3RvdHlwZVt0aGlzLm5hbWVdID0gdGhpcy5kZWZhdWx0VmFsdWU7XG5cbiAgICByZXR1cm4gUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUucmVzb2x2ZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBJbmZlcnMgZmllbGQgZmVhdHVyZXMgZnJvbSBsZWdhY3kgc3ludGF4IHRoYXQgbWF5IGhhdmUgYmVlbiBzcGVjaWZpZWQgZGlmZmVyZW50bHkuXG4gKiBpbiBvbGRlciBlZGl0aW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZWRpdGlvbiBUaGUgZWRpdGlvbiB0aGlzIHByb3RvIGlzIG9uLCBvciB1bmRlZmluZWQgaWYgcHJlLWVkaXRpb25zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgZmVhdHVyZSB2YWx1ZXMgdG8gb3ZlcnJpZGVcbiAqL1xuRmllbGQucHJvdG90eXBlLl9pbmZlckxlZ2FjeVByb3RvRmVhdHVyZXMgPSBmdW5jdGlvbiBfaW5mZXJMZWdhY3lQcm90b0ZlYXR1cmVzKGVkaXRpb24pIHtcbiAgICBpZiAoZWRpdGlvbiAhPT0gXCJwcm90bzJcIiAmJiBlZGl0aW9uICE9PSBcInByb3RvM1wiKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG5cbiAgICB2YXIgZmVhdHVyZXMgPSB7fTtcblxuICAgIGlmICh0aGlzLnJ1bGUgPT09IFwicmVxdWlyZWRcIikge1xuICAgICAgICBmZWF0dXJlcy5maWVsZF9wcmVzZW5jZSA9IFwiTEVHQUNZX1JFUVVJUkVEXCI7XG4gICAgfVxuICAgIGlmICh0aGlzLnBhcmVudCAmJiB0eXBlcy5kZWZhdWx0c1t0aGlzLnR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gV2UgY2FuJ3QgdXNlIHJlc29sdmVkVHlwZSBiZWNhdXNlIHR5cGVzIG1heSBub3QgaGF2ZSBiZWVuIHJlc29sdmVkIHlldC4gIEhvd2V2ZXIsXG4gICAgICAgIC8vIGxlZ2FjeSBncm91cHMgYXJlIGFsd2F5cyBpbiB0aGUgc2FtZSBzY29wZSBhcyB0aGUgZmllbGQgc28gd2UgZG9uJ3QgaGF2ZSB0byBkbyBhXG4gICAgICAgIC8vIGZ1bGwgc2NhbiBvZiB0aGUgdHJlZS5cbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnBhcmVudC5nZXQodGhpcy50eXBlLnNwbGl0KFwiLlwiKS5wb3AoKSk7XG4gICAgICAgIGlmICh0eXBlICYmIHR5cGUgaW5zdGFuY2VvZiBUeXBlICYmIHR5cGUuZ3JvdXApIHtcbiAgICAgICAgICAgIGZlYXR1cmVzLm1lc3NhZ2VfZW5jb2RpbmcgPSBcIkRFTElNSVRFRFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmdldE9wdGlvbihcInBhY2tlZFwiKSA9PT0gdHJ1ZSkge1xuICAgICAgICBmZWF0dXJlcy5yZXBlYXRlZF9maWVsZF9lbmNvZGluZyA9IFwiUEFDS0VEXCI7XG4gICAgfSBlbHNlIGlmICh0aGlzLmdldE9wdGlvbihcInBhY2tlZFwiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZmVhdHVyZXMucmVwZWF0ZWRfZmllbGRfZW5jb2RpbmcgPSBcIkVYUEFOREVEXCI7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlcztcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkZpZWxkLnByb3RvdHlwZS5fcmVzb2x2ZUZlYXR1cmVzID0gZnVuY3Rpb24gX3Jlc29sdmVGZWF0dXJlcyhlZGl0aW9uKSB7XG4gICAgcmV0dXJuIFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLl9yZXNvbHZlRmVhdHVyZXMuY2FsbCh0aGlzLCB0aGlzLl9lZGl0aW9uIHx8IGVkaXRpb24pO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gYXMgcmV0dXJuZWQgYnkge0BsaW5rIEZpZWxkLmR9IGFuZCB7QGxpbmsgTWFwRmllbGQuZH0gKFR5cGVTY3JpcHQpLlxuICogQHR5cGVkZWYgRmllbGREZWNvcmF0b3JcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGFyZ2V0IHByb3RvdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZSBGaWVsZCBuYW1lXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogRmllbGQgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBuYW1lIEZpZWxkLmRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgRmllbGQgaWRcbiAqIEBwYXJhbSB7XCJkb3VibGVcInxcImZsb2F0XCJ8XCJpbnQzMlwifFwidWludDMyXCJ8XCJzaW50MzJcInxcImZpeGVkMzJcInxcInNmaXhlZDMyXCJ8XCJpbnQ2NFwifFwidWludDY0XCJ8XCJzaW50NjRcInxcImZpeGVkNjRcInxcInNmaXhlZDY0XCJ8XCJzdHJpbmdcInxcImJvb2xcInxcImJ5dGVzXCJ8T2JqZWN0fSBmaWVsZFR5cGUgRmllbGQgdHlwZVxuICogQHBhcmFtIHtcIm9wdGlvbmFsXCJ8XCJyZXF1aXJlZFwifFwicmVwZWF0ZWRcIn0gW2ZpZWxkUnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEBwYXJhbSB7VH0gW2RlZmF1bHRWYWx1ZV0gRGVmYXVsdCB2YWx1ZVxuICogQHJldHVybnMge0ZpZWxkRGVjb3JhdG9yfSBEZWNvcmF0b3IgZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgbnVtYmVyIHwgbnVtYmVyW10gfCBMb25nIHwgTG9uZ1tdIHwgc3RyaW5nIHwgc3RyaW5nW10gfCBib29sZWFuIHwgYm9vbGVhbltdIHwgVWludDhBcnJheSB8IFVpbnQ4QXJyYXlbXSB8IEJ1ZmZlciB8IEJ1ZmZlcltdXG4gKi9cbkZpZWxkLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZUZpZWxkKGZpZWxkSWQsIGZpZWxkVHlwZSwgZmllbGRSdWxlLCBkZWZhdWx0VmFsdWUpIHtcblxuICAgIC8vIHN1Ym1lc3NhZ2U6IGRlY29yYXRlIHRoZSBzdWJtZXNzYWdlIGFuZCB1c2UgaXRzIG5hbWUgYXMgdGhlIHR5cGVcbiAgICBpZiAodHlwZW9mIGZpZWxkVHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmaWVsZFR5cGUgPSB1dGlsLmRlY29yYXRlVHlwZShmaWVsZFR5cGUpLm5hbWU7XG5cbiAgICAvLyBlbnVtIHJlZmVyZW5jZTogY3JlYXRlIGEgcmVmbGVjdGVkIGNvcHkgb2YgdGhlIGVudW0gYW5kIGtlZXAgcmV1c2VpbmcgaXRcbiAgICBlbHNlIGlmIChmaWVsZFR5cGUgJiYgdHlwZW9mIGZpZWxkVHlwZSA9PT0gXCJvYmplY3RcIilcbiAgICAgICAgZmllbGRUeXBlID0gdXRpbC5kZWNvcmF0ZUVudW0oZmllbGRUeXBlKS5uYW1lO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZpZWxkRGVjb3JhdG9yKHByb3RvdHlwZSwgZmllbGROYW1lKSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHByb3RvdHlwZS5jb25zdHJ1Y3RvcilcbiAgICAgICAgICAgIC5hZGQobmV3IEZpZWxkKGZpZWxkTmFtZSwgZmllbGRJZCwgZmllbGRUeXBlLCBmaWVsZFJ1bGUsIHsgXCJkZWZhdWx0XCI6IGRlZmF1bHRWYWx1ZSB9KSk7XG4gICAgfTtcbn07XG5cbi8qKlxuICogRmllbGQgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBuYW1lIEZpZWxkLmRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgRmllbGQgaWRcbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VD58c3RyaW5nfSBmaWVsZFR5cGUgRmllbGQgdHlwZVxuICogQHBhcmFtIHtcIm9wdGlvbmFsXCJ8XCJyZXF1aXJlZFwifFwicmVwZWF0ZWRcIn0gW2ZpZWxkUnVsZT1cIm9wdGlvbmFsXCJdIEZpZWxkIHJ1bGVcbiAqIEByZXR1cm5zIHtGaWVsZERlY29yYXRvcn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBsaWtlIEZpZWxkLmQgYnV0IHdpdGhvdXQgYSBkZWZhdWx0IHZhbHVlXG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuRmllbGQuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uIGNvbmZpZ3VyZShUeXBlXykge1xuICAgIFR5cGUgPSBUeXBlXztcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkZpZWxkIiwiUmVmbGVjdGlvbk9iamVjdCIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsIkVudW0iLCJ0eXBlcyIsInV0aWwiLCJUeXBlIiwicnVsZVJlIiwiZnJvbUpTT04iLCJuYW1lIiwianNvbiIsImZpZWxkIiwiaWQiLCJ0eXBlIiwicnVsZSIsImV4dGVuZCIsIm9wdGlvbnMiLCJjb21tZW50IiwiZWRpdGlvbiIsIl9lZGl0aW9uIiwiX2RlZmF1bHRFZGl0aW9uIiwiaXNPYmplY3QiLCJ1bmRlZmluZWQiLCJjYWxsIiwiaXNJbnRlZ2VyIiwiVHlwZUVycm9yIiwiaXNTdHJpbmciLCJ0ZXN0IiwidG9TdHJpbmciLCJ0b0xvd2VyQ2FzZSIsInJlcGVhdGVkIiwibWFwIiwibWVzc2FnZSIsInBhcnRPZiIsInR5cGVEZWZhdWx0IiwiZGVmYXVsdFZhbHVlIiwibG9uZyIsIkxvbmciLCJieXRlcyIsInJlc29sdmVkVHlwZSIsImV4dGVuc2lvbkZpZWxkIiwiZGVjbGFyaW5nRmllbGQiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsIl9mZWF0dXJlcyIsImZpZWxkX3ByZXNlbmNlIiwicmVxdWlyZWQiLCJtZXNzYWdlX2VuY29kaW5nIiwicmVwZWF0ZWRfZmllbGRfZW5jb2RpbmciLCJzZXRPcHRpb24iLCJ2YWx1ZSIsImlmTm90U2V0IiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImtlZXBDb21tZW50cyIsIkJvb2xlYW4iLCJ0b09iamVjdCIsIl9lZGl0aW9uVG9KU09OIiwicmVzb2x2ZSIsInJlc29sdmVkIiwiZGVmYXVsdHMiLCJwYXJlbnQiLCJsb29rdXBUeXBlT3JFbnVtIiwidmFsdWVzIiwia2V5cyIsInByb3RvM19vcHRpb25hbCIsInBhY2tlZCIsImxlbmd0aCIsImZyb21OdW1iZXIiLCJjaGFyQXQiLCJmcmVlemUiLCJidWYiLCJiYXNlNjQiLCJkZWNvZGUiLCJuZXdCdWZmZXIiLCJ1dGY4Iiwid3JpdGUiLCJlbXB0eU9iamVjdCIsImVtcHR5QXJyYXkiLCJjdG9yIiwiX2luZmVyTGVnYWN5UHJvdG9GZWF0dXJlcyIsImZlYXR1cmVzIiwic3BsaXQiLCJwb3AiLCJncm91cCIsImdldE9wdGlvbiIsIl9yZXNvbHZlRmVhdHVyZXMiLCJkIiwiZGVjb3JhdGVGaWVsZCIsImZpZWxkSWQiLCJmaWVsZFR5cGUiLCJmaWVsZFJ1bGUiLCJkZWNvcmF0ZVR5cGUiLCJkZWNvcmF0ZUVudW0iLCJmaWVsZERlY29yYXRvciIsImZpZWxkTmFtZSIsImFkZCIsIl9jb25maWd1cmUiLCJjb25maWd1cmUiLCJUeXBlXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-light.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-light.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar protobuf = module.exports = __webpack_require__(/*! ./index-minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-minimal.js\");\nprotobuf.build = \"light\";\n/**\n * A node-style callback as used by {@link load} and {@link Root#load}.\n * @typedef LoadCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Root} [root] Root, if there hasn't been an error\n * @returns {undefined}\n */ /**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} root Root namespace, defaults to create a new one if omitted.\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n */ function load(filename, root, callback) {\n    if (typeof root === \"function\") {\n        callback = root;\n        root = new protobuf.Root();\n    } else if (!root) root = new protobuf.Root();\n    return root.load(filename, callback);\n}\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and calls the callback.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @see {@link Root#load}\n * @variation 2\n */ // function load(filename:string, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into a common root namespace and returns a promise.\n * @name load\n * @function\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Promise<Root>} Promise\n * @see {@link Root#load}\n * @variation 3\n */ // function load(filename:string, [root:Root]):Promise<Root>\nprotobuf.load = load;\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into a common root namespace (node only).\n * @param {string|string[]} filename One or multiple files to load\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n * @see {@link Root#loadSync}\n */ function loadSync(filename, root) {\n    if (!root) root = new protobuf.Root();\n    return root.loadSync(filename);\n}\nprotobuf.loadSync = loadSync;\n// Serialization\nprotobuf.encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/encoder.js\");\nprotobuf.decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/decoder.js\");\nprotobuf.verifier = __webpack_require__(/*! ./verifier */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/verifier.js\");\nprotobuf.converter = __webpack_require__(/*! ./converter */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/converter.js\");\n// Reflection\nprotobuf.ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\nprotobuf.Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\");\nprotobuf.Root = __webpack_require__(/*! ./root */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js\");\nprotobuf.Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\");\nprotobuf.Type = __webpack_require__(/*! ./type */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js\");\nprotobuf.Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\");\nprotobuf.OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\");\nprotobuf.MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js\");\nprotobuf.Service = __webpack_require__(/*! ./service */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js\");\nprotobuf.Method = __webpack_require__(/*! ./method */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js\");\n// Runtime\nprotobuf.Message = __webpack_require__(/*! ./message */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js\");\nprotobuf.wrappers = __webpack_require__(/*! ./wrappers */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/wrappers.js\");\n// Utility\nprotobuf.types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\");\nprotobuf.util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\n// Set up possibly cyclic reflection dependencies\nprotobuf.ReflectionObject._configure(protobuf.Root);\nprotobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);\nprotobuf.Root._configure(protobuf.Type);\nprotobuf.Field._configure(protobuf.Type);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbGlnaHQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxXQUFXQyw4SUFBMkM7QUFFMURELFNBQVNJLEtBQUssR0FBRztBQUVqQjs7Ozs7OztDQU9DLEdBRUQ7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNDLEtBQUtDLFFBQVEsRUFBRUMsSUFBSSxFQUFFQyxRQUFRO0lBQ2xDLElBQUksT0FBT0QsU0FBUyxZQUFZO1FBQzVCQyxXQUFXRDtRQUNYQSxPQUFPLElBQUlQLFNBQVNTLElBQUk7SUFDNUIsT0FBTyxJQUFJLENBQUNGLE1BQ1JBLE9BQU8sSUFBSVAsU0FBU1MsSUFBSTtJQUM1QixPQUFPRixLQUFLRixJQUFJLENBQUNDLFVBQVVFO0FBQy9CO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0Qsa0VBQWtFO0FBRWxFOzs7Ozs7Ozs7Q0FTQyxHQUNELDREQUE0RDtBQUU1RFIsU0FBU0ssSUFBSSxHQUFHQTtBQUVoQjs7Ozs7OztDQU9DLEdBQ0QsU0FBU0ssU0FBU0osUUFBUSxFQUFFQyxJQUFJO0lBQzVCLElBQUksQ0FBQ0EsTUFDREEsT0FBTyxJQUFJUCxTQUFTUyxJQUFJO0lBQzVCLE9BQU9GLEtBQUtHLFFBQVEsQ0FBQ0o7QUFDekI7QUFFQU4sU0FBU1UsUUFBUSxHQUFHQTtBQUVwQixnQkFBZ0I7QUFDaEJWLFNBQVNXLE9BQU8sR0FBWVIsbUJBQU9BLENBQUMsNEZBQVc7QUFDL0NILFNBQVNZLE9BQU8sR0FBWVQsbUJBQU9BLENBQUMsNEZBQVc7QUFDL0NILFNBQVNhLFFBQVEsR0FBV1YsbUJBQU9BLENBQUMsOEZBQVk7QUFDaERILFNBQVNjLFNBQVMsR0FBVVgsbUJBQU9BLENBQUMsZ0dBQWE7QUFFakQsYUFBYTtBQUNiSCxTQUFTZSxnQkFBZ0IsR0FBR1osbUJBQU9BLENBQUMsMEZBQVU7QUFDOUNILFNBQVNnQixTQUFTLEdBQVViLG1CQUFPQSxDQUFDLGdHQUFhO0FBQ2pESCxTQUFTUyxJQUFJLEdBQWVOLG1CQUFPQSxDQUFDLHNGQUFRO0FBQzVDSCxTQUFTaUIsSUFBSSxHQUFlZCxtQkFBT0EsQ0FBQyxzRkFBUTtBQUM1Q0gsU0FBU2tCLElBQUksR0FBZWYsbUJBQU9BLENBQUMsc0ZBQVE7QUFDNUNILFNBQVNtQixLQUFLLEdBQWNoQixtQkFBT0EsQ0FBQyx3RkFBUztBQUM3Q0gsU0FBU29CLEtBQUssR0FBY2pCLG1CQUFPQSxDQUFDLHdGQUFTO0FBQzdDSCxTQUFTcUIsUUFBUSxHQUFXbEIsbUJBQU9BLENBQUMsOEZBQVk7QUFDaERILFNBQVNzQixPQUFPLEdBQVluQixtQkFBT0EsQ0FBQyw0RkFBVztBQUMvQ0gsU0FBU3VCLE1BQU0sR0FBYXBCLG1CQUFPQSxDQUFDLDBGQUFVO0FBRTlDLFVBQVU7QUFDVkgsU0FBU3dCLE9BQU8sR0FBWXJCLG1CQUFPQSxDQUFDLDRGQUFXO0FBQy9DSCxTQUFTeUIsUUFBUSxHQUFXdEIsbUJBQU9BLENBQUMsOEZBQVk7QUFFaEQsVUFBVTtBQUNWSCxTQUFTMEIsS0FBSyxHQUFjdkIsbUJBQU9BLENBQUMsd0ZBQVM7QUFDN0NILFNBQVMyQixJQUFJLEdBQWV4QixtQkFBT0EsQ0FBQyxzRkFBUTtBQUU1QyxpREFBaUQ7QUFDakRILFNBQVNlLGdCQUFnQixDQUFDYSxVQUFVLENBQUM1QixTQUFTUyxJQUFJO0FBQ2xEVCxTQUFTZ0IsU0FBUyxDQUFDWSxVQUFVLENBQUM1QixTQUFTa0IsSUFBSSxFQUFFbEIsU0FBU3NCLE9BQU8sRUFBRXRCLFNBQVNpQixJQUFJO0FBQzVFakIsU0FBU1MsSUFBSSxDQUFDbUIsVUFBVSxDQUFDNUIsU0FBU2tCLElBQUk7QUFDdENsQixTQUFTbUIsS0FBSyxDQUFDUyxVQUFVLENBQUM1QixTQUFTa0IsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1saWdodC5qcz84YmZiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIHByb3RvYnVmID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9pbmRleC1taW5pbWFsXCIpO1xuXG5wcm90b2J1Zi5idWlsZCA9IFwibGlnaHRcIjtcblxuLyoqXG4gKiBBIG5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgbG9hZH0gYW5kIHtAbGluayBSb290I2xvYWR9LlxuICogQHR5cGVkZWYgTG9hZENhbGxiYWNrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge0Vycm9yfG51bGx9IGVycm9yIEVycm9yLCBpZiBhbnksIG90aGVyd2lzZSBgbnVsbGBcbiAqIEBwYXJhbSB7Um9vdH0gW3Jvb3RdIFJvb3QsIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byBhIGNvbW1vbiByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge1Jvb3R9IHJvb3QgUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZC5cbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBzZWUge0BsaW5rIFJvb3QjbG9hZH1cbiAqL1xuZnVuY3Rpb24gbG9hZChmaWxlbmFtZSwgcm9vdCwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHJvb3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IHJvb3Q7XG4gICAgICAgIHJvb3QgPSBuZXcgcHJvdG9idWYuUm9vdCgpO1xuICAgIH0gZWxzZSBpZiAoIXJvb3QpXG4gICAgICAgIHJvb3QgPSBuZXcgcHJvdG9idWYuUm9vdCgpO1xuICAgIHJldHVybiByb290LmxvYWQoZmlsZW5hbWUsIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIGEgY29tbW9uIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXG4gKiBAbmFtZSBsb2FkXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBmaWxlbmFtZSBPbmUgb3IgbXVsdGlwbGUgZmlsZXMgdG8gbG9hZFxuICogQHBhcmFtIHtMb2FkQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkfVxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBjYWxsYmFjazpMb2FkQ2FsbGJhY2spOnVuZGVmaW5lZFxuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQG5hbWUgbG9hZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7Um9vdH0gW3Jvb3RdIFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxSb290Pn0gUHJvbWlzZVxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkfVxuICogQHZhcmlhdGlvbiAzXG4gKi9cbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBbcm9vdDpSb290XSk6UHJvbWlzZTxSb290PlxuXG5wcm90b2J1Zi5sb2FkID0gbG9hZDtcblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGxvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gYSBjb21tb24gcm9vdCBuYW1lc3BhY2UgKG5vZGUgb25seSkuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7Um9vdH0gW3Jvb3RdIFJvb3QgbmFtZXNwYWNlLCBkZWZhdWx0cyB0byBjcmVhdGUgYSBuZXcgb25lIGlmIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7Um9vdH0gUm9vdCBuYW1lc3BhY2VcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBzeW5jaHJvbm91cyBmZXRjaGluZyBpcyBub3Qgc3VwcG9ydGVkIChpLmUuIGluIGJyb3dzZXJzKSBvciBpZiBhIGZpbGUncyBzeW50YXggaXMgaW52YWxpZFxuICogQHNlZSB7QGxpbmsgUm9vdCNsb2FkU3luY31cbiAqL1xuZnVuY3Rpb24gbG9hZFN5bmMoZmlsZW5hbWUsIHJvb3QpIHtcbiAgICBpZiAoIXJvb3QpXG4gICAgICAgIHJvb3QgPSBuZXcgcHJvdG9idWYuUm9vdCgpO1xuICAgIHJldHVybiByb290LmxvYWRTeW5jKGZpbGVuYW1lKTtcbn1cblxucHJvdG9idWYubG9hZFN5bmMgPSBsb2FkU3luYztcblxuLy8gU2VyaWFsaXphdGlvblxucHJvdG9idWYuZW5jb2RlciAgICAgICAgICA9IHJlcXVpcmUoXCIuL2VuY29kZXJcIik7XG5wcm90b2J1Zi5kZWNvZGVyICAgICAgICAgID0gcmVxdWlyZShcIi4vZGVjb2RlclwiKTtcbnByb3RvYnVmLnZlcmlmaWVyICAgICAgICAgPSByZXF1aXJlKFwiLi92ZXJpZmllclwiKTtcbnByb3RvYnVmLmNvbnZlcnRlciAgICAgICAgPSByZXF1aXJlKFwiLi9jb252ZXJ0ZXJcIik7XG5cbi8vIFJlZmxlY3Rpb25cbnByb3RvYnVmLlJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG5wcm90b2J1Zi5OYW1lc3BhY2UgICAgICAgID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xucHJvdG9idWYuUm9vdCAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RcIik7XG5wcm90b2J1Zi5FbnVtICAgICAgICAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKTtcbnByb3RvYnVmLlR5cGUgICAgICAgICAgICAgPSByZXF1aXJlKFwiLi90eXBlXCIpO1xucHJvdG9idWYuRmllbGQgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpO1xucHJvdG9idWYuT25lT2YgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xucHJvdG9idWYuTWFwRmllbGQgICAgICAgICA9IHJlcXVpcmUoXCIuL21hcGZpZWxkXCIpO1xucHJvdG9idWYuU2VydmljZSAgICAgICAgICA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIik7XG5wcm90b2J1Zi5NZXRob2QgICAgICAgICAgID0gcmVxdWlyZShcIi4vbWV0aG9kXCIpO1xuXG4vLyBSdW50aW1lXG5wcm90b2J1Zi5NZXNzYWdlICAgICAgICAgID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKTtcbnByb3RvYnVmLndyYXBwZXJzICAgICAgICAgPSByZXF1aXJlKFwiLi93cmFwcGVyc1wiKTtcblxuLy8gVXRpbGl0eVxucHJvdG9idWYudHlwZXMgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xucHJvdG9idWYudXRpbCAgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbi8vIFNldCB1cCBwb3NzaWJseSBjeWNsaWMgcmVmbGVjdGlvbiBkZXBlbmRlbmNpZXNcbnByb3RvYnVmLlJlZmxlY3Rpb25PYmplY3QuX2NvbmZpZ3VyZShwcm90b2J1Zi5Sb290KTtcbnByb3RvYnVmLk5hbWVzcGFjZS5fY29uZmlndXJlKHByb3RvYnVmLlR5cGUsIHByb3RvYnVmLlNlcnZpY2UsIHByb3RvYnVmLkVudW0pO1xucHJvdG9idWYuUm9vdC5fY29uZmlndXJlKHByb3RvYnVmLlR5cGUpO1xucHJvdG9idWYuRmllbGQuX2NvbmZpZ3VyZShwcm90b2J1Zi5UeXBlKTtcbiJdLCJuYW1lcyI6WyJwcm90b2J1ZiIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiYnVpbGQiLCJsb2FkIiwiZmlsZW5hbWUiLCJyb290IiwiY2FsbGJhY2siLCJSb290IiwibG9hZFN5bmMiLCJlbmNvZGVyIiwiZGVjb2RlciIsInZlcmlmaWVyIiwiY29udmVydGVyIiwiUmVmbGVjdGlvbk9iamVjdCIsIk5hbWVzcGFjZSIsIkVudW0iLCJUeXBlIiwiRmllbGQiLCJPbmVPZiIsIk1hcEZpZWxkIiwiU2VydmljZSIsIk1ldGhvZCIsIk1lc3NhZ2UiLCJ3cmFwcGVycyIsInR5cGVzIiwidXRpbCIsIl9jb25maWd1cmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-light.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-minimal.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-minimal.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar protobuf = exports;\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */ protobuf.build = \"minimal\";\n// Serialization\nprotobuf.Writer = __webpack_require__(/*! ./writer */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js\");\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer_buffer.js\");\nprotobuf.Reader = __webpack_require__(/*! ./reader */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js\");\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader_buffer.js\");\n// Utility\nprotobuf.util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\nprotobuf.rpc = __webpack_require__(/*! ./rpc */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc.js\");\nprotobuf.roots = __webpack_require__(/*! ./roots */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/roots.js\");\nprotobuf.configure = configure;\n/* istanbul ignore next */ /**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */ function configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n// Set up buffer utility according to the environment\nconfigure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXgtbWluaW1hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFdBQVdDO0FBRWY7Ozs7O0NBS0MsR0FDREQsU0FBU0UsS0FBSyxHQUFHO0FBRWpCLGdCQUFnQjtBQUNoQkYsU0FBU0csTUFBTSxHQUFTQyxtQkFBT0EsQ0FBQywwRkFBVTtBQUMxQ0osU0FBU0ssWUFBWSxHQUFHRCxtQkFBT0EsQ0FBQyx3R0FBaUI7QUFDakRKLFNBQVNNLE1BQU0sR0FBU0YsbUJBQU9BLENBQUMsMEZBQVU7QUFDMUNKLFNBQVNPLFlBQVksR0FBR0gsbUJBQU9BLENBQUMsd0dBQWlCO0FBRWpELFVBQVU7QUFDVkosU0FBU1EsSUFBSSxHQUFXSixtQkFBT0EsQ0FBQyxzR0FBZ0I7QUFDaERKLFNBQVNTLEdBQUcsR0FBWUwsbUJBQU9BLENBQUMsb0ZBQU87QUFDdkNKLFNBQVNVLEtBQUssR0FBVU4sbUJBQU9BLENBQUMsd0ZBQVM7QUFDekNKLFNBQVNXLFNBQVMsR0FBTUE7QUFFeEIsd0JBQXdCLEdBQ3hCOzs7Q0FHQyxHQUNELFNBQVNBO0lBQ0xYLFNBQVNRLElBQUksQ0FBQ0ksVUFBVTtJQUN4QlosU0FBU0csTUFBTSxDQUFDUyxVQUFVLENBQUNaLFNBQVNLLFlBQVk7SUFDaERMLFNBQVNNLE1BQU0sQ0FBQ00sVUFBVSxDQUFDWixTQUFTTyxZQUFZO0FBQ3BEO0FBRUEscURBQXFEO0FBQ3JESSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9pbmRleC1taW5pbWFsLmpzP2VjYzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgcHJvdG9idWYgPSBleHBvcnRzO1xuXG4vKipcbiAqIEJ1aWxkIHR5cGUsIG9uZSBvZiBgXCJmdWxsXCJgLCBgXCJsaWdodFwiYCBvciBgXCJtaW5pbWFsXCJgLlxuICogQG5hbWUgYnVpbGRcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKiBAY29uc3RcbiAqL1xucHJvdG9idWYuYnVpbGQgPSBcIm1pbmltYWxcIjtcblxuLy8gU2VyaWFsaXphdGlvblxucHJvdG9idWYuV3JpdGVyICAgICAgID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpO1xucHJvdG9idWYuQnVmZmVyV3JpdGVyID0gcmVxdWlyZShcIi4vd3JpdGVyX2J1ZmZlclwiKTtcbnByb3RvYnVmLlJlYWRlciAgICAgICA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbnByb3RvYnVmLkJ1ZmZlclJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlcl9idWZmZXJcIik7XG5cbi8vIFV0aWxpdHlcbnByb3RvYnVmLnV0aWwgICAgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcbnByb3RvYnVmLnJwYyAgICAgICAgICA9IHJlcXVpcmUoXCIuL3JwY1wiKTtcbnByb3RvYnVmLnJvb3RzICAgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RzXCIpO1xucHJvdG9idWYuY29uZmlndXJlICAgID0gY29uZmlndXJlO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuLyoqXG4gKiBSZWNvbmZpZ3VyZXMgdGhlIGxpYnJhcnkgYWNjb3JkaW5nIHRvIHRoZSBlbnZpcm9ubWVudC5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZSgpIHtcbiAgICBwcm90b2J1Zi51dGlsLl9jb25maWd1cmUoKTtcbiAgICBwcm90b2J1Zi5Xcml0ZXIuX2NvbmZpZ3VyZShwcm90b2J1Zi5CdWZmZXJXcml0ZXIpO1xuICAgIHByb3RvYnVmLlJlYWRlci5fY29uZmlndXJlKHByb3RvYnVmLkJ1ZmZlclJlYWRlcik7XG59XG5cbi8vIFNldCB1cCBidWZmZXIgdXRpbGl0eSBhY2NvcmRpbmcgdG8gdGhlIGVudmlyb25tZW50XG5jb25maWd1cmUoKTtcbiJdLCJuYW1lcyI6WyJwcm90b2J1ZiIsImV4cG9ydHMiLCJidWlsZCIsIldyaXRlciIsInJlcXVpcmUiLCJCdWZmZXJXcml0ZXIiLCJSZWFkZXIiLCJCdWZmZXJSZWFkZXIiLCJ1dGlsIiwicnBjIiwicm9vdHMiLCJjb25maWd1cmUiLCJfY29uZmlndXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-minimal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar protobuf = module.exports = __webpack_require__(/*! ./index-light */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index-light.js\");\nprotobuf.build = \"full\";\n// Parser\nprotobuf.tokenize = __webpack_require__(/*! ./tokenize */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/tokenize.js\");\nprotobuf.parse = __webpack_require__(/*! ./parse */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/parse.js\");\nprotobuf.common = __webpack_require__(/*! ./common */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/common.js\");\n// Configure parser\nprotobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxXQUFXQywwSUFBeUM7QUFFeERELFNBQVNJLEtBQUssR0FBRztBQUVqQixTQUFTO0FBQ1RKLFNBQVNLLFFBQVEsR0FBV0YsbUJBQU9BLENBQUMsOEZBQVk7QUFDaERILFNBQVNNLEtBQUssR0FBY0gsbUJBQU9BLENBQUMsd0ZBQVM7QUFDN0NILFNBQVNPLE1BQU0sR0FBYUosbUJBQU9BLENBQUMsMEZBQVU7QUFFOUMsbUJBQW1CO0FBQ25CSCxTQUFTUSxJQUFJLENBQUNDLFVBQVUsQ0FBQ1QsU0FBU1UsSUFBSSxFQUFFVixTQUFTTSxLQUFLLEVBQUVOLFNBQVNPLE1BQU0iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvaW5kZXguanM/YWE2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBwcm90b2J1ZiA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaW5kZXgtbGlnaHRcIik7XG5cbnByb3RvYnVmLmJ1aWxkID0gXCJmdWxsXCI7XG5cbi8vIFBhcnNlclxucHJvdG9idWYudG9rZW5pemUgICAgICAgICA9IHJlcXVpcmUoXCIuL3Rva2VuaXplXCIpO1xucHJvdG9idWYucGFyc2UgICAgICAgICAgICA9IHJlcXVpcmUoXCIuL3BhcnNlXCIpO1xucHJvdG9idWYuY29tbW9uICAgICAgICAgICA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcblxuLy8gQ29uZmlndXJlIHBhcnNlclxucHJvdG9idWYuUm9vdC5fY29uZmlndXJlKHByb3RvYnVmLlR5cGUsIHByb3RvYnVmLnBhcnNlLCBwcm90b2J1Zi5jb21tb24pO1xuIl0sIm5hbWVzIjpbInByb3RvYnVmIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJidWlsZCIsInRva2VuaXplIiwicGFyc2UiLCJjb21tb24iLCJSb290IiwiX2NvbmZpZ3VyZSIsIlR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = MapField;\n// extends Field\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\");\n((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = \"MapField\";\nvar types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new map field instance.\n * @classdesc Reflected map field.\n * @extends FieldBase\n * @constructor\n * @param {string} name Unique name within its namespace\n * @param {number} id Unique id within its namespace\n * @param {string} keyType Key type\n * @param {string} type Value type\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function MapField(name, id, keyType, type, options, comment) {\n    Field.call(this, name, id, type, undefined, undefined, options, comment);\n    /* istanbul ignore if */ if (!util.isString(keyType)) throw TypeError(\"keyType must be a string\");\n    /**\n     * Key type.\n     * @type {string}\n     */ this.keyType = keyType; // toJSON, marker\n    /**\n     * Resolved key type if not a basic type.\n     * @type {ReflectionObject|null}\n     */ this.resolvedKeyType = null;\n    // Overrides Field#map\n    this.map = true;\n}\n/**\n * Map field descriptor.\n * @interface IMapField\n * @extends {IField}\n * @property {string} keyType Key type\n */ /**\n * Extension map field descriptor.\n * @interface IExtensionMapField\n * @extends IMapField\n * @property {string} extend Extended type\n */ /**\n * Constructs a map field from a map field descriptor.\n * @param {string} name Field name\n * @param {IMapField} json Map field descriptor\n * @returns {MapField} Created map field\n * @throws {TypeError} If arguments are invalid\n */ MapField.fromJSON = function fromJSON(name, json) {\n    return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);\n};\n/**\n * Converts this map field to a map field descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMapField} Map field descriptor\n */ MapField.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"keyType\",\n        this.keyType,\n        \"type\",\n        this.type,\n        \"id\",\n        this.id,\n        \"extend\",\n        this.extend,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * @override\n */ MapField.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    // Besides a value type, map fields have a key type that may be \"any scalar type except for floating point types and bytes\"\n    if (types.mapKey[this.keyType] === undefined) throw Error(\"invalid key type: \" + this.keyType);\n    return Field.prototype.resolve.call(this);\n};\n/**\n * Map field decorator (TypeScript).\n * @name MapField.d\n * @function\n * @param {number} fieldId Field id\n * @param {\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"} fieldKeyType Field key type\n * @param {\"double\"|\"float\"|\"int32\"|\"uint32\"|\"sint32\"|\"fixed32\"|\"sfixed32\"|\"int64\"|\"uint64\"|\"sint64\"|\"fixed64\"|\"sfixed64\"|\"bool\"|\"string\"|\"bytes\"|Object|Constructor<{}>} fieldValueType Field value type\n * @returns {FieldDecorator} Decorator function\n * @template T extends { [key: string]: number | Long | string | boolean | Uint8Array | Buffer | number[] | Message<{}> }\n */ MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {\n    // submessage value: decorate the submessage and use its name as the type\n    if (typeof fieldValueType === \"function\") fieldValueType = util.decorateType(fieldValueType).name;\n    else if (fieldValueType && typeof fieldValueType === \"object\") fieldValueType = util.decorateEnum(fieldValueType).name;\n    return function mapFieldDecorator(prototype, fieldName) {\n        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWFwZmllbGQuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixnQkFBZ0I7QUFDaEIsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsd0ZBQVM7QUFDNUIsRUFBQ0YsU0FBU0csU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLE1BQU1FLFNBQVMsR0FBR0csV0FBVyxHQUFHTixRQUFPLEVBQUdPLFNBQVMsR0FBRztBQUUzRixJQUFJQyxRQUFVTixtQkFBT0EsQ0FBQyx3RkFBUyxHQUMzQk8sT0FBVVAsbUJBQU9BLENBQUMsc0ZBQVE7QUFFOUI7Ozs7Ozs7Ozs7O0NBV0MsR0FDRCxTQUFTRixTQUFTVSxJQUFJLEVBQUVDLEVBQUUsRUFBRUMsT0FBTyxFQUFFQyxJQUFJLEVBQUVDLE9BQU8sRUFBRUMsT0FBTztJQUN2RGQsTUFBTWUsSUFBSSxDQUFDLElBQUksRUFBRU4sTUFBTUMsSUFBSUUsTUFBTUksV0FBV0EsV0FBV0gsU0FBU0M7SUFFaEUsc0JBQXNCLEdBQ3RCLElBQUksQ0FBQ04sS0FBS1MsUUFBUSxDQUFDTixVQUNmLE1BQU1PLFVBQVU7SUFFcEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDUCxPQUFPLEdBQUdBLFNBQVMsaUJBQWlCO0lBRXpDOzs7S0FHQyxHQUNELElBQUksQ0FBQ1EsZUFBZSxHQUFHO0lBRXZCLHNCQUFzQjtJQUN0QixJQUFJLENBQUNDLEdBQUcsR0FBRztBQUNmO0FBRUE7Ozs7O0NBS0MsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7Ozs7Q0FNQyxHQUNEckIsU0FBU3NCLFFBQVEsR0FBRyxTQUFTQSxTQUFTWixJQUFJLEVBQUVhLElBQUk7SUFDNUMsT0FBTyxJQUFJdkIsU0FBU1UsTUFBTWEsS0FBS1osRUFBRSxFQUFFWSxLQUFLWCxPQUFPLEVBQUVXLEtBQUtWLElBQUksRUFBRVUsS0FBS1QsT0FBTyxFQUFFUyxLQUFLUixPQUFPO0FBQzFGO0FBRUE7Ozs7Q0FJQyxHQUNEZixTQUFTRyxTQUFTLENBQUNxQixNQUFNLEdBQUcsU0FBU0EsT0FBT0MsYUFBYTtJQUNyRCxJQUFJQyxlQUFlRCxnQkFBZ0JFLFFBQVFGLGNBQWNDLFlBQVksSUFBSTtJQUN6RSxPQUFPakIsS0FBS21CLFFBQVEsQ0FBQztRQUNqQjtRQUFZLElBQUksQ0FBQ2hCLE9BQU87UUFDeEI7UUFBWSxJQUFJLENBQUNDLElBQUk7UUFDckI7UUFBWSxJQUFJLENBQUNGLEVBQUU7UUFDbkI7UUFBWSxJQUFJLENBQUNrQixNQUFNO1FBQ3ZCO1FBQVksSUFBSSxDQUFDZixPQUFPO1FBQ3hCO1FBQVlZLGVBQWUsSUFBSSxDQUFDWCxPQUFPLEdBQUdFO0tBQzdDO0FBQ0w7QUFFQTs7Q0FFQyxHQUNEakIsU0FBU0csU0FBUyxDQUFDMkIsT0FBTyxHQUFHLFNBQVNBO0lBQ2xDLElBQUksSUFBSSxDQUFDQyxRQUFRLEVBQ2IsT0FBTyxJQUFJO0lBRWYsMkhBQTJIO0lBQzNILElBQUl2QixNQUFNd0IsTUFBTSxDQUFDLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQyxLQUFLSyxXQUMvQixNQUFNZ0IsTUFBTSx1QkFBdUIsSUFBSSxDQUFDckIsT0FBTztJQUVuRCxPQUFPWCxNQUFNRSxTQUFTLENBQUMyQixPQUFPLENBQUNkLElBQUksQ0FBQyxJQUFJO0FBQzVDO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ0RoQixTQUFTa0MsQ0FBQyxHQUFHLFNBQVNDLGlCQUFpQkMsT0FBTyxFQUFFQyxZQUFZLEVBQUVDLGNBQWM7SUFFeEUseUVBQXlFO0lBQ3pFLElBQUksT0FBT0EsbUJBQW1CLFlBQzFCQSxpQkFBaUI3QixLQUFLOEIsWUFBWSxDQUFDRCxnQkFBZ0I1QixJQUFJO1NBR3RELElBQUk0QixrQkFBa0IsT0FBT0EsbUJBQW1CLFVBQ2pEQSxpQkFBaUI3QixLQUFLK0IsWUFBWSxDQUFDRixnQkFBZ0I1QixJQUFJO0lBRTNELE9BQU8sU0FBUytCLGtCQUFrQnRDLFNBQVMsRUFBRXVDLFNBQVM7UUFDbERqQyxLQUFLOEIsWUFBWSxDQUFDcEMsVUFBVUcsV0FBVyxFQUNsQ3FDLEdBQUcsQ0FBQyxJQUFJM0MsU0FBUzBDLFdBQVdOLFNBQVNDLGNBQWNDO0lBQzVEO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWFwZmllbGQuanM/N2NiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTWFwRmllbGQ7XG5cbi8vIGV4dGVuZHMgRmllbGRcbnZhciBGaWVsZCA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpO1xuKChNYXBGaWVsZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEZpZWxkLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gTWFwRmllbGQpLmNsYXNzTmFtZSA9IFwiTWFwRmllbGRcIjtcblxudmFyIHR5cGVzICAgPSByZXF1aXJlKFwiLi90eXBlc1wiKSxcbiAgICB1dGlsICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG1hcCBmaWVsZCBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUmVmbGVjdGVkIG1hcCBmaWVsZC5cbiAqIEBleHRlbmRzIEZpZWxkQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtudW1iZXJ9IGlkIFVuaXF1ZSBpZCB3aXRoaW4gaXRzIG5hbWVzcGFjZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleVR5cGUgS2V5IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFZhbHVlIHR5cGVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIENvbW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZmllbGRcbiAqL1xuZnVuY3Rpb24gTWFwRmllbGQobmFtZSwgaWQsIGtleVR5cGUsIHR5cGUsIG9wdGlvbnMsIGNvbW1lbnQpIHtcbiAgICBGaWVsZC5jYWxsKHRoaXMsIG5hbWUsIGlkLCB0eXBlLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucywgY29tbWVudCk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcoa2V5VHlwZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImtleVR5cGUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIC8qKlxuICAgICAqIEtleSB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5rZXlUeXBlID0ga2V5VHlwZTsgLy8gdG9KU09OLCBtYXJrZXJcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVkIGtleSB0eXBlIGlmIG5vdCBhIGJhc2ljIHR5cGUuXG4gICAgICogQHR5cGUge1JlZmxlY3Rpb25PYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkS2V5VHlwZSA9IG51bGw7XG5cbiAgICAvLyBPdmVycmlkZXMgRmllbGQjbWFwXG4gICAgdGhpcy5tYXAgPSB0cnVlO1xufVxuXG4vKipcbiAqIE1hcCBmaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJTWFwRmllbGRcbiAqIEBleHRlbmRzIHtJRmllbGR9XG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5VHlwZSBLZXkgdHlwZVxuICovXG5cbi8qKlxuICogRXh0ZW5zaW9uIG1hcCBmaWVsZCBkZXNjcmlwdG9yLlxuICogQGludGVyZmFjZSBJRXh0ZW5zaW9uTWFwRmllbGRcbiAqIEBleHRlbmRzIElNYXBGaWVsZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV4dGVuZCBFeHRlbmRlZCB0eXBlXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbWFwIGZpZWxkIGZyb20gYSBtYXAgZmllbGQgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcbiAqIEBwYXJhbSB7SU1hcEZpZWxkfSBqc29uIE1hcCBmaWVsZCBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7TWFwRmllbGR9IENyZWF0ZWQgbWFwIGZpZWxkXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICovXG5NYXBGaWVsZC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICByZXR1cm4gbmV3IE1hcEZpZWxkKG5hbWUsIGpzb24uaWQsIGpzb24ua2V5VHlwZSwganNvbi50eXBlLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbWFwIGZpZWxkIHRvIGEgbWFwIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJTWFwRmllbGR9IE1hcCBmaWVsZCBkZXNjcmlwdG9yXG4gKi9cbk1hcEZpZWxkLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwia2V5VHlwZVwiICwgdGhpcy5rZXlUeXBlLFxuICAgICAgICBcInR5cGVcIiAgICAsIHRoaXMudHlwZSxcbiAgICAgICAgXCJpZFwiICAgICAgLCB0aGlzLmlkLFxuICAgICAgICBcImV4dGVuZFwiICAsIHRoaXMuZXh0ZW5kLFxuICAgICAgICBcIm9wdGlvbnNcIiAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJjb21tZW50XCIgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbk1hcEZpZWxkLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgICBpZiAodGhpcy5yZXNvbHZlZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyBCZXNpZGVzIGEgdmFsdWUgdHlwZSwgbWFwIGZpZWxkcyBoYXZlIGEga2V5IHR5cGUgdGhhdCBtYXkgYmUgXCJhbnkgc2NhbGFyIHR5cGUgZXhjZXB0IGZvciBmbG9hdGluZyBwb2ludCB0eXBlcyBhbmQgYnl0ZXNcIlxuICAgIGlmICh0eXBlcy5tYXBLZXlbdGhpcy5rZXlUeXBlXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQga2V5IHR5cGU6IFwiICsgdGhpcy5rZXlUeXBlKTtcblxuICAgIHJldHVybiBGaWVsZC5wcm90b3R5cGUucmVzb2x2ZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBNYXAgZmllbGQgZGVjb3JhdG9yIChUeXBlU2NyaXB0KS5cbiAqIEBuYW1lIE1hcEZpZWxkLmRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IGZpZWxkSWQgRmllbGQgaWRcbiAqIEBwYXJhbSB7XCJpbnQzMlwifFwidWludDMyXCJ8XCJzaW50MzJcInxcImZpeGVkMzJcInxcInNmaXhlZDMyXCJ8XCJpbnQ2NFwifFwidWludDY0XCJ8XCJzaW50NjRcInxcImZpeGVkNjRcInxcInNmaXhlZDY0XCJ8XCJib29sXCJ8XCJzdHJpbmdcIn0gZmllbGRLZXlUeXBlIEZpZWxkIGtleSB0eXBlXG4gKiBAcGFyYW0ge1wiZG91YmxlXCJ8XCJmbG9hdFwifFwiaW50MzJcInxcInVpbnQzMlwifFwic2ludDMyXCJ8XCJmaXhlZDMyXCJ8XCJzZml4ZWQzMlwifFwiaW50NjRcInxcInVpbnQ2NFwifFwic2ludDY0XCJ8XCJmaXhlZDY0XCJ8XCJzZml4ZWQ2NFwifFwiYm9vbFwifFwic3RyaW5nXCJ8XCJieXRlc1wifE9iamVjdHxDb25zdHJ1Y3Rvcjx7fT59IGZpZWxkVmFsdWVUeXBlIEZpZWxkIHZhbHVlIHR5cGVcbiAqIEByZXR1cm5zIHtGaWVsZERlY29yYXRvcn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIHsgW2tleTogc3RyaW5nXTogbnVtYmVyIHwgTG9uZyB8IHN0cmluZyB8IGJvb2xlYW4gfCBVaW50OEFycmF5IHwgQnVmZmVyIHwgbnVtYmVyW10gfCBNZXNzYWdlPHt9PiB9XG4gKi9cbk1hcEZpZWxkLmQgPSBmdW5jdGlvbiBkZWNvcmF0ZU1hcEZpZWxkKGZpZWxkSWQsIGZpZWxkS2V5VHlwZSwgZmllbGRWYWx1ZVR5cGUpIHtcblxuICAgIC8vIHN1Ym1lc3NhZ2UgdmFsdWU6IGRlY29yYXRlIHRoZSBzdWJtZXNzYWdlIGFuZCB1c2UgaXRzIG5hbWUgYXMgdGhlIHR5cGVcbiAgICBpZiAodHlwZW9mIGZpZWxkVmFsdWVUeXBlID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZpZWxkVmFsdWVUeXBlID0gdXRpbC5kZWNvcmF0ZVR5cGUoZmllbGRWYWx1ZVR5cGUpLm5hbWU7XG5cbiAgICAvLyBlbnVtIHJlZmVyZW5jZSB2YWx1ZTogY3JlYXRlIGEgcmVmbGVjdGVkIGNvcHkgb2YgdGhlIGVudW0gYW5kIGtlZXAgcmV1c2VpbmcgaXRcbiAgICBlbHNlIGlmIChmaWVsZFZhbHVlVHlwZSAmJiB0eXBlb2YgZmllbGRWYWx1ZVR5cGUgPT09IFwib2JqZWN0XCIpXG4gICAgICAgIGZpZWxkVmFsdWVUeXBlID0gdXRpbC5kZWNvcmF0ZUVudW0oZmllbGRWYWx1ZVR5cGUpLm5hbWU7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWFwRmllbGREZWNvcmF0b3IocHJvdG90eXBlLCBmaWVsZE5hbWUpIHtcbiAgICAgICAgdXRpbC5kZWNvcmF0ZVR5cGUocHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLmFkZChuZXcgTWFwRmllbGQoZmllbGROYW1lLCBmaWVsZElkLCBmaWVsZEtleVR5cGUsIGZpZWxkVmFsdWVUeXBlKSk7XG4gICAgfTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIk1hcEZpZWxkIiwiRmllbGQiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJ0eXBlcyIsInV0aWwiLCJuYW1lIiwiaWQiLCJrZXlUeXBlIiwidHlwZSIsIm9wdGlvbnMiLCJjb21tZW50IiwiY2FsbCIsInVuZGVmaW5lZCIsImlzU3RyaW5nIiwiVHlwZUVycm9yIiwicmVzb2x2ZWRLZXlUeXBlIiwibWFwIiwiZnJvbUpTT04iLCJqc29uIiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImtlZXBDb21tZW50cyIsIkJvb2xlYW4iLCJ0b09iamVjdCIsImV4dGVuZCIsInJlc29sdmUiLCJyZXNvbHZlZCIsIm1hcEtleSIsIkVycm9yIiwiZCIsImRlY29yYXRlTWFwRmllbGQiLCJmaWVsZElkIiwiZmllbGRLZXlUeXBlIiwiZmllbGRWYWx1ZVR5cGUiLCJkZWNvcmF0ZVR5cGUiLCJkZWNvcmF0ZUVudW0iLCJtYXBGaWVsZERlY29yYXRvciIsImZpZWxkTmFtZSIsImFkZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Message;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new message instance.\n * @classdesc Abstract runtime message.\n * @constructor\n * @param {Properties<T>} [properties] Properties to set\n * @template T extends object = object\n */ function Message(properties) {\n    // not used internally\n    if (properties) for(var keys = Object.keys(properties), i = 0; i < keys.length; ++i)this[keys[i]] = properties[keys[i]];\n}\n/**\n * Reference to the reflected type.\n * @name Message.$type\n * @type {Type}\n * @readonly\n */ /**\n * Reference to the reflected type.\n * @name Message#$type\n * @type {Type}\n * @readonly\n */ /*eslint-disable valid-jsdoc*/ /**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<T>} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.create = function create(properties) {\n    return this.$type.create(properties);\n};\n/**\n * Encodes a message of this type.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.encode = function encode(message, writer) {\n    return this.$type.encode(message, writer);\n};\n/**\n * Encodes a message of this type preceeded by its length as a varint.\n * @param {T|Object.<string,*>} message Message to encode\n * @param {Writer} [writer] Writer to use\n * @returns {Writer} Writer\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.$type.encodeDelimited(message, writer);\n};\n/**\n * Decodes a message of this type.\n * @name Message.decode\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.decode = function decode(reader) {\n    return this.$type.decode(reader);\n};\n/**\n * Decodes a message of this type preceeded by its length as a varint.\n * @name Message.decodeDelimited\n * @function\n * @param {Reader|Uint8Array} reader Reader or buffer to decode\n * @returns {T} Decoded message\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.decodeDelimited = function decodeDelimited(reader) {\n    return this.$type.decodeDelimited(reader);\n};\n/**\n * Verifies a message of this type.\n * @name Message.verify\n * @function\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {string|null} `null` if valid, otherwise the reason why it is not\n */ Message.verify = function verify(message) {\n    return this.$type.verify(message);\n};\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object\n * @returns {T} Message instance\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.fromObject = function fromObject(object) {\n    return this.$type.fromObject(object);\n};\n/**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {T} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @template T extends Message<T>\n * @this Constructor<T>\n */ Message.toObject = function toObject(message, options) {\n    return this.$type.toObject(message, options);\n};\n/**\n * Converts this message to JSON.\n * @returns {Object.<string,*>} JSON object\n */ Message.prototype.toJSON = function toJSON() {\n    return this.$type.toObject(this, util.toJSONOptions);\n}; /*eslint-enable valid-jsdoc*/ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWVzc2FnZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDLHNHQUFnQjtBQUVuQzs7Ozs7O0NBTUMsR0FDRCxTQUFTRixRQUFRRyxVQUFVO0lBQ3ZCLHNCQUFzQjtJQUN0QixJQUFJQSxZQUNBLElBQUssSUFBSUMsT0FBT0MsT0FBT0QsSUFBSSxDQUFDRCxhQUFhRyxJQUFJLEdBQUdBLElBQUlGLEtBQUtHLE1BQU0sRUFBRSxFQUFFRCxFQUMvRCxJQUFJLENBQUNGLElBQUksQ0FBQ0UsRUFBRSxDQUFDLEdBQUdILFVBQVUsQ0FBQ0MsSUFBSSxDQUFDRSxFQUFFLENBQUM7QUFDL0M7QUFFQTs7Ozs7Q0FLQyxHQUVEOzs7OztDQUtDLEdBRUQsNEJBQTRCLEdBRTVCOzs7Ozs7Q0FNQyxHQUNETixRQUFRUSxNQUFNLEdBQUcsU0FBU0EsT0FBT0wsVUFBVTtJQUN2QyxPQUFPLElBQUksQ0FBQ00sS0FBSyxDQUFDRCxNQUFNLENBQUNMO0FBQzdCO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNESCxRQUFRVSxNQUFNLEdBQUcsU0FBU0EsT0FBT0MsT0FBTyxFQUFFQyxNQUFNO0lBQzVDLE9BQU8sSUFBSSxDQUFDSCxLQUFLLENBQUNDLE1BQU0sQ0FBQ0MsU0FBU0M7QUFDdEM7QUFFQTs7Ozs7OztDQU9DLEdBQ0RaLFFBQVFhLGVBQWUsR0FBRyxTQUFTQSxnQkFBZ0JGLE9BQU8sRUFBRUMsTUFBTTtJQUM5RCxPQUFPLElBQUksQ0FBQ0gsS0FBSyxDQUFDSSxlQUFlLENBQUNGLFNBQVNDO0FBQy9DO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRFosUUFBUWMsTUFBTSxHQUFHLFNBQVNBLE9BQU9DLE1BQU07SUFDbkMsT0FBTyxJQUFJLENBQUNOLEtBQUssQ0FBQ0ssTUFBTSxDQUFDQztBQUM3QjtBQUVBOzs7Ozs7OztDQVFDLEdBQ0RmLFFBQVFnQixlQUFlLEdBQUcsU0FBU0EsZ0JBQWdCRCxNQUFNO0lBQ3JELE9BQU8sSUFBSSxDQUFDTixLQUFLLENBQUNPLGVBQWUsQ0FBQ0Q7QUFDdEM7QUFFQTs7Ozs7O0NBTUMsR0FDRGYsUUFBUWlCLE1BQU0sR0FBRyxTQUFTQSxPQUFPTixPQUFPO0lBQ3BDLE9BQU8sSUFBSSxDQUFDRixLQUFLLENBQUNRLE1BQU0sQ0FBQ047QUFDN0I7QUFFQTs7Ozs7O0NBTUMsR0FDRFgsUUFBUWtCLFVBQVUsR0FBRyxTQUFTQSxXQUFXQyxNQUFNO0lBQzNDLE9BQU8sSUFBSSxDQUFDVixLQUFLLENBQUNTLFVBQVUsQ0FBQ0M7QUFDakM7QUFFQTs7Ozs7OztDQU9DLEdBQ0RuQixRQUFRb0IsUUFBUSxHQUFHLFNBQVNBLFNBQVNULE9BQU8sRUFBRVUsT0FBTztJQUNqRCxPQUFPLElBQUksQ0FBQ1osS0FBSyxDQUFDVyxRQUFRLENBQUNULFNBQVNVO0FBQ3hDO0FBRUE7OztDQUdDLEdBQ0RyQixRQUFRc0IsU0FBUyxDQUFDQyxNQUFNLEdBQUcsU0FBU0E7SUFDaEMsT0FBTyxJQUFJLENBQUNkLEtBQUssQ0FBQ1csUUFBUSxDQUFDLElBQUksRUFBRW5CLEtBQUt1QixhQUFhO0FBQ3ZELEdBRUEsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21lc3NhZ2UuanM/MzEyMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gTWVzc2FnZTtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyBtZXNzYWdlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBBYnN0cmFjdCBydW50aW1lIG1lc3NhZ2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UHJvcGVydGllczxUPn0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIG9iamVjdCA9IG9iamVjdFxuICovXG5mdW5jdGlvbiBNZXNzYWdlKHByb3BlcnRpZXMpIHtcbiAgICAvLyBub3QgdXNlZCBpbnRlcm5hbGx5XG4gICAgaWYgKHByb3BlcnRpZXMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdGhpc1trZXlzW2ldXSA9IHByb3BlcnRpZXNba2V5c1tpXV07XG59XG5cbi8qKlxuICogUmVmZXJlbmNlIHRvIHRoZSByZWZsZWN0ZWQgdHlwZS5cbiAqIEBuYW1lIE1lc3NhZ2UuJHR5cGVcbiAqIEB0eXBlIHtUeXBlfVxuICogQHJlYWRvbmx5XG4gKi9cblxuLyoqXG4gKiBSZWZlcmVuY2UgdG8gdGhlIHJlZmxlY3RlZCB0eXBlLlxuICogQG5hbWUgTWVzc2FnZSMkdHlwZVxuICogQHR5cGUge1R5cGV9XG4gKiBAcmVhZG9ubHlcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBQcm9wZXJ0aWVzIHRvIHNldFxuICogQHJldHVybnMge01lc3NhZ2U8VD59IE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocHJvcGVydGllcykge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmNyZWF0ZShwcm9wZXJ0aWVzKTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLlxuICogQHBhcmFtIHtUfE9iamVjdC48c3RyaW5nLCo+fSBtZXNzYWdlIE1lc3NhZ2UgdG8gZW5jb2RlXG4gKiBAcGFyYW0ge1dyaXRlcn0gW3dyaXRlcl0gV3JpdGVyIHRvIHVzZVxuICogQHJldHVybnMge1dyaXRlcn0gV3JpdGVyXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKG1lc3NhZ2UsIHdyaXRlcikge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmVuY29kZShtZXNzYWdlLCB3cml0ZXIpO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge1R8T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgTWVzc2FnZSB0byBlbmNvZGVcbiAqIEBwYXJhbSB7V3JpdGVyfSBbd3JpdGVyXSBXcml0ZXIgdG8gdXNlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBXcml0ZXJcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUuZW5jb2RlRGVsaW1pdGVkKG1lc3NhZ2UsIHdyaXRlcik7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBuYW1lIE1lc3NhZ2UuZGVjb2RlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZVxuICogQHJldHVybnMge1R9IERlY29kZWQgbWVzc2FnZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmRlY29kZSA9IGZ1bmN0aW9uIGRlY29kZShyZWFkZXIpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS5kZWNvZGUocmVhZGVyKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQG5hbWUgTWVzc2FnZS5kZWNvZGVEZWxpbWl0ZWRcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtSZWFkZXJ8VWludDhBcnJheX0gcmVhZGVyIFJlYWRlciBvciBidWZmZXIgdG8gZGVjb2RlXG4gKiBAcmV0dXJucyB7VH0gRGVjb2RlZCBtZXNzYWdlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEB0aGlzIENvbnN0cnVjdG9yPFQ+XG4gKi9cbk1lc3NhZ2UuZGVjb2RlRGVsaW1pdGVkID0gZnVuY3Rpb24gZGVjb2RlRGVsaW1pdGVkKHJlYWRlcikge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmRlY29kZURlbGltaXRlZChyZWFkZXIpO1xufTtcblxuLyoqXG4gKiBWZXJpZmllcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLlxuICogQG5hbWUgTWVzc2FnZS52ZXJpZnlcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBQbGFpbiBvYmplY3QgdG8gdmVyaWZ5XG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IGBudWxsYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIHRoZSByZWFzb24gd2h5IGl0IGlzIG5vdFxuICovXG5NZXNzYWdlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuJHR5cGUudmVyaWZ5KG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1lc3NhZ2Ugb2YgdGhpcyB0eXBlIGZyb20gYSBwbGFpbiBvYmplY3QuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIHRoZWlyIHJlc3BlY3RpdmUgaW50ZXJuYWwgdHlwZXMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvYmplY3QgUGxhaW4gb2JqZWN0XG4gKiBAcmV0dXJucyB7VH0gTWVzc2FnZSBpbnN0YW5jZVxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAdGhpcyBDb25zdHJ1Y3RvcjxUPlxuICovXG5NZXNzYWdlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLiR0eXBlLmZyb21PYmplY3Qob2JqZWN0KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHBsYWluIG9iamVjdCBmcm9tIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUuIEFsc28gY29udmVydHMgdmFsdWVzIHRvIG90aGVyIHR5cGVzIGlmIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7VH0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0lDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICogQHRoaXMgQ29uc3RydWN0b3I8VD5cbiAqL1xuTWVzc2FnZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS50b09iamVjdChtZXNzYWdlLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhpcyBtZXNzYWdlIHRvIEpTT04uXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IEpTT04gb2JqZWN0XG4gKi9cbk1lc3NhZ2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy4kdHlwZS50b09iamVjdCh0aGlzLCB1dGlsLnRvSlNPTk9wdGlvbnMpO1xufTtcblxuLyplc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jKi8iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIk1lc3NhZ2UiLCJ1dGlsIiwicmVxdWlyZSIsInByb3BlcnRpZXMiLCJrZXlzIiwiT2JqZWN0IiwiaSIsImxlbmd0aCIsImNyZWF0ZSIsIiR0eXBlIiwiZW5jb2RlIiwibWVzc2FnZSIsIndyaXRlciIsImVuY29kZURlbGltaXRlZCIsImRlY29kZSIsInJlYWRlciIsImRlY29kZURlbGltaXRlZCIsInZlcmlmeSIsImZyb21PYmplY3QiLCJvYmplY3QiLCJ0b09iamVjdCIsIm9wdGlvbnMiLCJwcm90b3R5cGUiLCJ0b0pTT04iLCJ0b0pTT05PcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Method;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\n((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = \"Method\";\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new service method instance.\n * @classdesc Reflected service method.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Method name\n * @param {string|undefined} type Method type, usually `\"rpc\"`\n * @param {string} requestType Request message type\n * @param {string} responseType Response message type\n * @param {boolean|Object.<string,*>} [requestStream] Whether the request is streamed\n * @param {boolean|Object.<string,*>} [responseStream] Whether the response is streamed\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] The comment for this method\n * @param {Object.<string,*>} [parsedOptions] Declared options, properly parsed into an object\n */ function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {\n    /* istanbul ignore next */ if (util.isObject(requestStream)) {\n        options = requestStream;\n        requestStream = responseStream = undefined;\n    } else if (util.isObject(responseStream)) {\n        options = responseStream;\n        responseStream = undefined;\n    }\n    /* istanbul ignore if */ if (!(type === undefined || util.isString(type))) throw TypeError(\"type must be a string\");\n    /* istanbul ignore if */ if (!util.isString(requestType)) throw TypeError(\"requestType must be a string\");\n    /* istanbul ignore if */ if (!util.isString(responseType)) throw TypeError(\"responseType must be a string\");\n    ReflectionObject.call(this, name, options);\n    /**\n     * Method type.\n     * @type {string}\n     */ this.type = type || \"rpc\"; // toJSON\n    /**\n     * Request type.\n     * @type {string}\n     */ this.requestType = requestType; // toJSON, marker\n    /**\n     * Whether requests are streamed or not.\n     * @type {boolean|undefined}\n     */ this.requestStream = requestStream ? true : undefined; // toJSON\n    /**\n     * Response type.\n     * @type {string}\n     */ this.responseType = responseType; // toJSON\n    /**\n     * Whether responses are streamed or not.\n     * @type {boolean|undefined}\n     */ this.responseStream = responseStream ? true : undefined; // toJSON\n    /**\n     * Resolved request type.\n     * @type {Type|null}\n     */ this.resolvedRequestType = null;\n    /**\n     * Resolved response type.\n     * @type {Type|null}\n     */ this.resolvedResponseType = null;\n    /**\n     * Comment for this method\n     * @type {string|null}\n     */ this.comment = comment;\n    /**\n     * Options properly parsed into an object\n     */ this.parsedOptions = parsedOptions;\n}\n/**\n * Method descriptor.\n * @interface IMethod\n * @property {string} [type=\"rpc\"] Method type\n * @property {string} requestType Request type\n * @property {string} responseType Response type\n * @property {boolean} [requestStream=false] Whether requests are streamed\n * @property {boolean} [responseStream=false] Whether responses are streamed\n * @property {Object.<string,*>} [options] Method options\n * @property {string} comment Method comments\n * @property {Object.<string,*>} [parsedOptions] Method options properly parsed into an object\n */ /**\n * Constructs a method from a method descriptor.\n * @param {string} name Method name\n * @param {IMethod} json Method descriptor\n * @returns {Method} Created method\n * @throws {TypeError} If arguments are invalid\n */ Method.fromJSON = function fromJSON(name, json) {\n    return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);\n};\n/**\n * Converts this method to a method descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IMethod} Method descriptor\n */ Method.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"type\",\n        this.type !== \"rpc\" && /* istanbul ignore next */ this.type || undefined,\n        \"requestType\",\n        this.requestType,\n        \"requestStream\",\n        this.requestStream,\n        \"responseType\",\n        this.responseType,\n        \"responseStream\",\n        this.responseStream,\n        \"options\",\n        this.options,\n        \"comment\",\n        keepComments ? this.comment : undefined,\n        \"parsedOptions\",\n        this.parsedOptions\n    ]);\n};\n/**\n * @override\n */ Method.prototype.resolve = function resolve() {\n    /* istanbul ignore if */ if (this.resolved) return this;\n    this.resolvedRequestType = this.parent.lookupType(this.requestType);\n    this.resolvedResponseType = this.parent.lookupType(this.responseType);\n    return ReflectionObject.prototype.resolve.call(this);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbWV0aG9kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsMkJBQTJCO0FBQzNCLElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUMsMEZBQVU7QUFDeEMsRUFBQ0YsT0FBT0csU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLGlCQUFpQkUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLE1BQUssRUFBR08sU0FBUyxHQUFHO0FBRWxHLElBQUlDLE9BQU9OLG1CQUFPQSxDQUFDLHNGQUFRO0FBRTNCOzs7Ozs7Ozs7Ozs7OztDQWNDLEdBQ0QsU0FBU0YsT0FBT1MsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLFdBQVcsRUFBRUMsWUFBWSxFQUFFQyxhQUFhLEVBQUVDLGNBQWMsRUFBRUMsT0FBTyxFQUFFQyxPQUFPLEVBQUVDLGFBQWE7SUFFakgsd0JBQXdCLEdBQ3hCLElBQUlULEtBQUtVLFFBQVEsQ0FBQ0wsZ0JBQWdCO1FBQzlCRSxVQUFVRjtRQUNWQSxnQkFBZ0JDLGlCQUFpQks7SUFDckMsT0FBTyxJQUFJWCxLQUFLVSxRQUFRLENBQUNKLGlCQUFpQjtRQUN0Q0MsVUFBVUQ7UUFDVkEsaUJBQWlCSztJQUNyQjtJQUVBLHNCQUFzQixHQUN0QixJQUFJLENBQUVULENBQUFBLFNBQVNTLGFBQWFYLEtBQUtZLFFBQVEsQ0FBQ1YsS0FBSSxHQUMxQyxNQUFNVyxVQUFVO0lBRXBCLHNCQUFzQixHQUN0QixJQUFJLENBQUNiLEtBQUtZLFFBQVEsQ0FBQ1QsY0FDZixNQUFNVSxVQUFVO0lBRXBCLHNCQUFzQixHQUN0QixJQUFJLENBQUNiLEtBQUtZLFFBQVEsQ0FBQ1IsZUFDZixNQUFNUyxVQUFVO0lBRXBCcEIsaUJBQWlCcUIsSUFBSSxDQUFDLElBQUksRUFBRWIsTUFBTU07SUFFbEM7OztLQUdDLEdBQ0QsSUFBSSxDQUFDTCxJQUFJLEdBQUdBLFFBQVEsT0FBTyxTQUFTO0lBRXBDOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsV0FBVyxHQUFHQSxhQUFhLGlCQUFpQjtJQUVqRDs7O0tBR0MsR0FDRCxJQUFJLENBQUNFLGFBQWEsR0FBR0EsZ0JBQWdCLE9BQU9NLFdBQVcsU0FBUztJQUVoRTs7O0tBR0MsR0FDRCxJQUFJLENBQUNQLFlBQVksR0FBR0EsY0FBYyxTQUFTO0lBRTNDOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsY0FBYyxHQUFHQSxpQkFBaUIsT0FBT0ssV0FBVyxTQUFTO0lBRWxFOzs7S0FHQyxHQUNELElBQUksQ0FBQ0ksbUJBQW1CLEdBQUc7SUFFM0I7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxvQkFBb0IsR0FBRztJQUU1Qjs7O0tBR0MsR0FDRCxJQUFJLENBQUNSLE9BQU8sR0FBR0E7SUFFZjs7S0FFQyxHQUNELElBQUksQ0FBQ0MsYUFBYSxHQUFHQTtBQUN6QjtBQUVBOzs7Ozs7Ozs7OztDQVdDLEdBRUQ7Ozs7OztDQU1DLEdBQ0RqQixPQUFPeUIsUUFBUSxHQUFHLFNBQVNBLFNBQVNoQixJQUFJLEVBQUVpQixJQUFJO0lBQzFDLE9BQU8sSUFBSTFCLE9BQU9TLE1BQU1pQixLQUFLaEIsSUFBSSxFQUFFZ0IsS0FBS2YsV0FBVyxFQUFFZSxLQUFLZCxZQUFZLEVBQUVjLEtBQUtiLGFBQWEsRUFBRWEsS0FBS1osY0FBYyxFQUFFWSxLQUFLWCxPQUFPLEVBQUVXLEtBQUtWLE9BQU8sRUFBRVUsS0FBS1QsYUFBYTtBQUNuSztBQUVBOzs7O0NBSUMsR0FDRGpCLE9BQU9HLFNBQVMsQ0FBQ3dCLE1BQU0sR0FBRyxTQUFTQSxPQUFPQyxhQUFhO0lBQ25ELElBQUlDLGVBQWVELGdCQUFnQkUsUUFBUUYsY0FBY0MsWUFBWSxJQUFJO0lBQ3pFLE9BQU9yQixLQUFLdUIsUUFBUSxDQUFDO1FBQ2pCO1FBQW1CLElBQUksQ0FBQ3JCLElBQUksS0FBSyxTQUFTLHdCQUF3QixHQUFHLElBQUksQ0FBQ0EsSUFBSSxJQUFJUztRQUNsRjtRQUFtQixJQUFJLENBQUNSLFdBQVc7UUFDbkM7UUFBbUIsSUFBSSxDQUFDRSxhQUFhO1FBQ3JDO1FBQW1CLElBQUksQ0FBQ0QsWUFBWTtRQUNwQztRQUFtQixJQUFJLENBQUNFLGNBQWM7UUFDdEM7UUFBbUIsSUFBSSxDQUFDQyxPQUFPO1FBQy9CO1FBQW1CYyxlQUFlLElBQUksQ0FBQ2IsT0FBTyxHQUFHRztRQUNqRDtRQUFtQixJQUFJLENBQUNGLGFBQWE7S0FDeEM7QUFDTDtBQUVBOztDQUVDLEdBQ0RqQixPQUFPRyxTQUFTLENBQUM2QixPQUFPLEdBQUcsU0FBU0E7SUFFaEMsc0JBQXNCLEdBQ3RCLElBQUksSUFBSSxDQUFDQyxRQUFRLEVBQ2IsT0FBTyxJQUFJO0lBRWYsSUFBSSxDQUFDVixtQkFBbUIsR0FBRyxJQUFJLENBQUNXLE1BQU0sQ0FBQ0MsVUFBVSxDQUFDLElBQUksQ0FBQ3hCLFdBQVc7SUFDbEUsSUFBSSxDQUFDYSxvQkFBb0IsR0FBRyxJQUFJLENBQUNVLE1BQU0sQ0FBQ0MsVUFBVSxDQUFDLElBQUksQ0FBQ3ZCLFlBQVk7SUFFcEUsT0FBT1gsaUJBQWlCRSxTQUFTLENBQUM2QixPQUFPLENBQUNWLElBQUksQ0FBQyxJQUFJO0FBQ3ZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL21ldGhvZC5qcz83ZmQwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBNZXRob2Q7XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKE1ldGhvZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBNZXRob2QpLmNsYXNzTmFtZSA9IFwiTWV0aG9kXCI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHNlcnZpY2UgbWV0aG9kIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgc2VydmljZSBtZXRob2QuXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1ldGhvZCBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHR5cGUgTWV0aG9kIHR5cGUsIHVzdWFsbHkgYFwicnBjXCJgXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdFR5cGUgUmVxdWVzdCBtZXNzYWdlIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSByZXNwb25zZVR5cGUgUmVzcG9uc2UgbWVzc2FnZSB0eXBlXG4gKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0LjxzdHJpbmcsKj59IFtyZXF1ZXN0U3RyZWFtXSBXaGV0aGVyIHRoZSByZXF1ZXN0IGlzIHN0cmVhbWVkXG4gKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0LjxzdHJpbmcsKj59IFtyZXNwb25zZVN0cmVhbV0gV2hldGhlciB0aGUgcmVzcG9uc2UgaXMgc3RyZWFtZWRcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvbW1lbnRdIFRoZSBjb21tZW50IGZvciB0aGlzIG1ldGhvZFxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3BhcnNlZE9wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnMsIHByb3Blcmx5IHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5mdW5jdGlvbiBNZXRob2QobmFtZSwgdHlwZSwgcmVxdWVzdFR5cGUsIHJlc3BvbnNlVHlwZSwgcmVxdWVzdFN0cmVhbSwgcmVzcG9uc2VTdHJlYW0sIG9wdGlvbnMsIGNvbW1lbnQsIHBhcnNlZE9wdGlvbnMpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgaWYgKHV0aWwuaXNPYmplY3QocmVxdWVzdFN0cmVhbSkpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJlcXVlc3RTdHJlYW07XG4gICAgICAgIHJlcXVlc3RTdHJlYW0gPSByZXNwb25zZVN0cmVhbSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHV0aWwuaXNPYmplY3QocmVzcG9uc2VTdHJlYW0pKSB7XG4gICAgICAgIG9wdGlvbnMgPSByZXNwb25zZVN0cmVhbTtcbiAgICAgICAgcmVzcG9uc2VTdHJlYW0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCEodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHV0aWwuaXNTdHJpbmcodHlwZSkpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJ0eXBlIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcocmVxdWVzdFR5cGUpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJyZXF1ZXN0VHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF1dGlsLmlzU3RyaW5nKHJlc3BvbnNlVHlwZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlc3BvbnNlVHlwZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuXG4gICAgUmVmbGVjdGlvbk9iamVjdC5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHR5cGUuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSB0eXBlIHx8IFwicnBjXCI7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdCB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXF1ZXN0VHlwZSA9IHJlcXVlc3RUeXBlOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgc3RyZWFtZWQgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3RTdHJlYW0gPSByZXF1ZXN0U3RyZWFtID8gdHJ1ZSA6IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBSZXNwb25zZSB0eXBlLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIHN0cmVhbWVkIG9yIG5vdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZVN0cmVhbSA9IHJlc3BvbnNlU3RyZWFtID8gdHJ1ZSA6IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlZCByZXF1ZXN0IHR5cGUuXG4gICAgICogQHR5cGUge1R5cGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlc29sdmVkUmVxdWVzdFR5cGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgcmVzcG9uc2UgdHlwZS5cbiAgICAgKiBAdHlwZSB7VHlwZXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZWRSZXNwb25zZVR5cGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ29tbWVudCBmb3IgdGhpcyBtZXRob2RcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jb21tZW50ID0gY29tbWVudDtcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbnMgcHJvcGVybHkgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gICAgICovXG4gICAgdGhpcy5wYXJzZWRPcHRpb25zID0gcGFyc2VkT3B0aW9ucztcbn1cblxuLyoqXG4gKiBNZXRob2QgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSU1ldGhvZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0eXBlPVwicnBjXCJdIE1ldGhvZCB0eXBlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVxdWVzdFR5cGUgUmVxdWVzdCB0eXBlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVzcG9uc2VUeXBlIFJlc3BvbnNlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3JlcXVlc3RTdHJlYW09ZmFsc2VdIFdoZXRoZXIgcmVxdWVzdHMgYXJlIHN0cmVhbWVkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtyZXNwb25zZVN0cmVhbT1mYWxzZV0gV2hldGhlciByZXNwb25zZXMgYXJlIHN0cmVhbWVkXG4gKiBAcHJvcGVydHkge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gTWV0aG9kIG9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb21tZW50IE1ldGhvZCBjb21tZW50c1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW3BhcnNlZE9wdGlvbnNdIE1ldGhvZCBvcHRpb25zIHByb3Blcmx5IHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG1ldGhvZCBmcm9tIGEgbWV0aG9kIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBNZXRob2QgbmFtZVxuICogQHBhcmFtIHtJTWV0aG9kfSBqc29uIE1ldGhvZCBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7TWV0aG9kfSBDcmVhdGVkIG1ldGhvZFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuTWV0aG9kLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgTWV0aG9kKG5hbWUsIGpzb24udHlwZSwganNvbi5yZXF1ZXN0VHlwZSwganNvbi5yZXNwb25zZVR5cGUsIGpzb24ucmVxdWVzdFN0cmVhbSwganNvbi5yZXNwb25zZVN0cmVhbSwganNvbi5vcHRpb25zLCBqc29uLmNvbW1lbnQsIGpzb24ucGFyc2VkT3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbWV0aG9kIHRvIGEgbWV0aG9kIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJTWV0aG9kfSBNZXRob2QgZGVzY3JpcHRvclxuICovXG5NZXRob2QucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJ0eXBlXCIgICAgICAgICAgICwgdGhpcy50eXBlICE9PSBcInJwY1wiICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHRoaXMudHlwZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwicmVxdWVzdFR5cGVcIiAgICAsIHRoaXMucmVxdWVzdFR5cGUsXG4gICAgICAgIFwicmVxdWVzdFN0cmVhbVwiICAsIHRoaXMucmVxdWVzdFN0cmVhbSxcbiAgICAgICAgXCJyZXNwb25zZVR5cGVcIiAgICwgdGhpcy5yZXNwb25zZVR5cGUsXG4gICAgICAgIFwicmVzcG9uc2VTdHJlYW1cIiAsIHRoaXMucmVzcG9uc2VTdHJlYW0sXG4gICAgICAgIFwib3B0aW9uc1wiICAgICAgICAsIHRoaXMub3B0aW9ucyxcbiAgICAgICAgXCJjb21tZW50XCIgICAgICAgICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkLFxuICAgICAgICBcInBhcnNlZE9wdGlvbnNcIiAgLCB0aGlzLnBhcnNlZE9wdGlvbnMsXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5NZXRob2QucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucmVzb2x2ZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgdGhpcy5yZXNvbHZlZFJlcXVlc3RUeXBlID0gdGhpcy5wYXJlbnQubG9va3VwVHlwZSh0aGlzLnJlcXVlc3RUeXBlKTtcbiAgICB0aGlzLnJlc29sdmVkUmVzcG9uc2VUeXBlID0gdGhpcy5wYXJlbnQubG9va3VwVHlwZSh0aGlzLnJlc3BvbnNlVHlwZSk7XG5cbiAgICByZXR1cm4gUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUucmVzb2x2ZS5jYWxsKHRoaXMpO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiTWV0aG9kIiwiUmVmbGVjdGlvbk9iamVjdCIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsInV0aWwiLCJuYW1lIiwidHlwZSIsInJlcXVlc3RUeXBlIiwicmVzcG9uc2VUeXBlIiwicmVxdWVzdFN0cmVhbSIsInJlc3BvbnNlU3RyZWFtIiwib3B0aW9ucyIsImNvbW1lbnQiLCJwYXJzZWRPcHRpb25zIiwiaXNPYmplY3QiLCJ1bmRlZmluZWQiLCJpc1N0cmluZyIsIlR5cGVFcnJvciIsImNhbGwiLCJyZXNvbHZlZFJlcXVlc3RUeXBlIiwicmVzb2x2ZWRSZXNwb25zZVR5cGUiLCJmcm9tSlNPTiIsImpzb24iLCJ0b0pTT04iLCJ0b0pTT05PcHRpb25zIiwia2VlcENvbW1lbnRzIiwiQm9vbGVhbiIsInRvT2JqZWN0IiwicmVzb2x2ZSIsInJlc29sdmVkIiwicGFyZW50IiwibG9va3VwVHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Namespace;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\n((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = \"Namespace\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\");\nvar Type, Service, Enum;\n/**\n * Constructs a new namespace instance.\n * @name Namespace\n * @classdesc Reflected namespace.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n */ /**\n * Constructs a namespace from JSON.\n * @memberof Namespace\n * @function\n * @param {string} name Namespace name\n * @param {Object.<string,*>} json JSON object\n * @returns {Namespace} Created namespace\n * @throws {TypeError} If arguments are invalid\n */ Namespace.fromJSON = function fromJSON(name, json) {\n    return new Namespace(name, json.options).addJSON(json.nested);\n};\n/**\n * Converts an array of reflection objects to JSON.\n * @memberof Namespace\n * @param {ReflectionObject[]} array Object array\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {Object.<string,*>|undefined} JSON object or `undefined` when array is empty\n */ function arrayToJSON(array, toJSONOptions) {\n    if (!(array && array.length)) return undefined;\n    var obj = {};\n    for(var i = 0; i < array.length; ++i)obj[array[i].name] = array[i].toJSON(toJSONOptions);\n    return obj;\n}\nNamespace.arrayToJSON = arrayToJSON;\n/**\n * Tests if the specified id is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Namespace.isReservedId = function isReservedId(reserved, id) {\n    if (reserved) {\n        for(var i = 0; i < reserved.length; ++i)if (typeof reserved[i] !== \"string\" && reserved[i][0] <= id && reserved[i][1] > id) return true;\n    }\n    return false;\n};\n/**\n * Tests if the specified name is reserved.\n * @param {Array.<number[]|string>|undefined} reserved Array of reserved ranges and names\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Namespace.isReservedName = function isReservedName(reserved, name) {\n    if (reserved) {\n        for(var i = 0; i < reserved.length; ++i)if (reserved[i] === name) return true;\n    }\n    return false;\n};\n/**\n * Not an actual constructor. Use {@link Namespace} instead.\n * @classdesc Base class of all reflection objects containing nested objects. This is not an actual class but here for the sake of having consistent type definitions.\n * @exports NamespaceBase\n * @extends ReflectionObject\n * @abstract\n * @constructor\n * @param {string} name Namespace name\n * @param {Object.<string,*>} [options] Declared options\n * @see {@link Namespace}\n */ function Namespace(name, options) {\n    ReflectionObject.call(this, name, options);\n    /**\n     * Nested objects by name.\n     * @type {Object.<string,ReflectionObject>|undefined}\n     */ this.nested = undefined; // toJSON\n    /**\n     * Cached nested objects as an array.\n     * @type {ReflectionObject[]|null}\n     * @private\n     */ this._nestedArray = null;\n    /**\n     * Cache lookup calls for any objects contains anywhere under this namespace.\n     * This drastically speeds up resolve for large cross-linked protos where the same\n     * types are looked up repeatedly.\n     * @type {Object.<string,ReflectionObject|null>}\n     * @private\n     */ this._lookupCache = {};\n    /**\n     * Whether or not objects contained in this namespace need feature resolution.\n     * @type {boolean}\n     * @protected\n     */ this._needsRecursiveFeatureResolution = true;\n    /**\n     * Whether or not objects contained in this namespace need a resolve.\n     * @type {boolean}\n     * @protected\n     */ this._needsRecursiveResolve = true;\n}\nfunction clearCache(namespace) {\n    namespace._nestedArray = null;\n    namespace._lookupCache = {};\n    // Also clear parent caches, since they include nested lookups.\n    var parent = namespace;\n    while(parent = parent.parent){\n        parent._lookupCache = {};\n    }\n    return namespace;\n}\n/**\n * Nested objects of this namespace as an array for iteration.\n * @name NamespaceBase#nestedArray\n * @type {ReflectionObject[]}\n * @readonly\n */ Object.defineProperty(Namespace.prototype, \"nestedArray\", {\n    get: function() {\n        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));\n    }\n});\n/**\n * Namespace descriptor.\n * @interface INamespace\n * @property {Object.<string,*>} [options] Namespace options\n * @property {Object.<string,AnyNestedObject>} [nested] Nested object descriptors\n */ /**\n * Any extension field descriptor.\n * @typedef AnyExtensionField\n * @type {IExtensionField|IExtensionMapField}\n */ /**\n * Any nested object descriptor.\n * @typedef AnyNestedObject\n * @type {IEnum|IType|IService|AnyExtensionField|INamespace|IOneOf}\n */ /**\n * Converts this namespace to a namespace descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {INamespace} Namespace descriptor\n */ Namespace.prototype.toJSON = function toJSON(toJSONOptions) {\n    return util.toObject([\n        \"options\",\n        this.options,\n        \"nested\",\n        arrayToJSON(this.nestedArray, toJSONOptions)\n    ]);\n};\n/**\n * Adds nested objects to this namespace from nested object descriptors.\n * @param {Object.<string,AnyNestedObject>} nestedJson Any nested object descriptors\n * @returns {Namespace} `this`\n */ Namespace.prototype.addJSON = function addJSON(nestedJson) {\n    var ns = this;\n    /* istanbul ignore else */ if (nestedJson) {\n        for(var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i){\n            nested = nestedJson[names[i]];\n            ns.add((nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : nested.id !== undefined ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));\n        }\n    }\n    return this;\n};\n/**\n * Gets the nested object of the specified name.\n * @param {string} name Nested object name\n * @returns {ReflectionObject|null} The reflection object or `null` if it doesn't exist\n */ Namespace.prototype.get = function get(name) {\n    return this.nested && this.nested[name] || null;\n};\n/**\n * Gets the values of the nested {@link Enum|enum} of the specified name.\n * This methods differs from {@link Namespace#get|get} in that it returns an enum's values directly and throws instead of returning `null`.\n * @param {string} name Nested enum name\n * @returns {Object.<string,number>} Enum values\n * @throws {Error} If there is no such enum\n */ Namespace.prototype.getEnum = function getEnum(name) {\n    if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;\n    throw Error(\"no such enum: \" + name);\n};\n/**\n * Adds a nested object to this namespace.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name\n */ Namespace.prototype.add = function add(object) {\n    if (!(object instanceof Field && object.extend !== undefined || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError(\"object must be a valid nested object\");\n    if (!this.nested) this.nested = {};\n    else {\n        var prev = this.get(object.name);\n        if (prev) {\n            if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {\n                // replace plain namespace but keep existing nested elements and options\n                var nested = prev.nestedArray;\n                for(var i = 0; i < nested.length; ++i)object.add(nested[i]);\n                this.remove(prev);\n                if (!this.nested) this.nested = {};\n                object.setOptions(prev.options, true);\n            } else throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n        }\n    }\n    this.nested[object.name] = object;\n    if (!(this instanceof Type || this instanceof Service || this instanceof Enum || this instanceof Field)) {\n        // This is a package or a root namespace.\n        if (!object._edition) {\n            // Make sure that some edition is set if it hasn't already been specified.\n            object._edition = object._defaultEdition;\n        }\n    }\n    this._needsRecursiveFeatureResolution = true;\n    this._needsRecursiveResolve = true;\n    // Also clear parent caches, since they need to recurse down.\n    var parent = this;\n    while(parent = parent.parent){\n        parent._needsRecursiveFeatureResolution = true;\n        parent._needsRecursiveResolve = true;\n    }\n    object.onAdd(this);\n    return clearCache(this);\n};\n/**\n * Removes a nested object from this namespace.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Namespace} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this namespace\n */ Namespace.prototype.remove = function remove(object) {\n    if (!(object instanceof ReflectionObject)) throw TypeError(\"object must be a ReflectionObject\");\n    if (object.parent !== this) throw Error(object + \" is not a member of \" + this);\n    delete this.nested[object.name];\n    if (!Object.keys(this.nested).length) this.nested = undefined;\n    object.onRemove(this);\n    return clearCache(this);\n};\n/**\n * Defines additial namespaces within this one if not yet existing.\n * @param {string|string[]} path Path to create\n * @param {*} [json] Nested types to create from JSON\n * @returns {Namespace} Pointer to the last namespace created or `this` if path is empty\n */ Namespace.prototype.define = function define(path, json) {\n    if (util.isString(path)) path = path.split(\".\");\n    else if (!Array.isArray(path)) throw TypeError(\"illegal path\");\n    if (path && path.length && path[0] === \"\") throw Error(\"path must be relative\");\n    var ptr = this;\n    while(path.length > 0){\n        var part = path.shift();\n        if (ptr.nested && ptr.nested[part]) {\n            ptr = ptr.nested[part];\n            if (!(ptr instanceof Namespace)) throw Error(\"path conflicts with non-namespace objects\");\n        } else ptr.add(ptr = new Namespace(part));\n    }\n    if (json) ptr.addJSON(json);\n    return ptr;\n};\n/**\n * Resolves this namespace's and all its nested objects' type references. Useful to validate a reflection tree, but comes at a cost.\n * @returns {Namespace} `this`\n */ Namespace.prototype.resolveAll = function resolveAll() {\n    if (!this._needsRecursiveResolve) return this;\n    this._resolveFeaturesRecursive(this._edition);\n    var nested = this.nestedArray, i = 0;\n    this.resolve();\n    while(i < nested.length)if (nested[i] instanceof Namespace) nested[i++].resolveAll();\n    else nested[i++].resolve();\n    this._needsRecursiveResolve = false;\n    return this;\n};\n/**\n * @override\n */ Namespace.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n    if (!this._needsRecursiveFeatureResolution) return this;\n    this._needsRecursiveFeatureResolution = false;\n    edition = this._edition || edition;\n    ReflectionObject.prototype._resolveFeaturesRecursive.call(this, edition);\n    this.nestedArray.forEach((nested)=>{\n        nested._resolveFeaturesRecursive(edition);\n    });\n    return this;\n};\n/**\n * Recursively looks up the reflection object matching the specified path in the scope of this namespace.\n * @param {string|string[]} path Path to look up\n * @param {*|Array.<*>} filterTypes Filter types, any combination of the constructors of `protobuf.Type`, `protobuf.Enum`, `protobuf.Service` etc.\n * @param {boolean} [parentAlreadyChecked=false] If known, whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n */ Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {\n    /* istanbul ignore next */ if (typeof filterTypes === \"boolean\") {\n        parentAlreadyChecked = filterTypes;\n        filterTypes = undefined;\n    } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [\n        filterTypes\n    ];\n    if (util.isString(path) && path.length) {\n        if (path === \".\") return this.root;\n        path = path.split(\".\");\n    } else if (!path.length) return this;\n    var flatPath = path.join(\".\");\n    // Start at root if path is absolute\n    if (path[0] === \"\") return this.root.lookup(path.slice(1), filterTypes);\n    // Early bailout for objects with matching absolute paths\n    var found = this.root._fullyQualifiedObjects && this.root._fullyQualifiedObjects[\".\" + flatPath];\n    if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n        return found;\n    }\n    // Do a regular lookup at this namespace and below\n    found = this._lookupImpl(path, flatPath);\n    if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n        return found;\n    }\n    if (parentAlreadyChecked) return null;\n    // If there hasn't been a match, walk up the tree and look more broadly\n    var current = this;\n    while(current.parent){\n        found = current.parent._lookupImpl(path, flatPath);\n        if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {\n            return found;\n        }\n        current = current.parent;\n    }\n    return null;\n};\n/**\n * Internal helper for lookup that handles searching just at this namespace and below along with caching.\n * @param {string[]} path Path to look up\n * @param {string} flatPath Flattened version of the path to use as a cache key\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @private\n */ Namespace.prototype._lookupImpl = function lookup(path, flatPath) {\n    if (Object.prototype.hasOwnProperty.call(this._lookupCache, flatPath)) {\n        return this._lookupCache[flatPath];\n    }\n    // Test if the first part matches any nested object, and if so, traverse if path contains more\n    var found = this.get(path[0]);\n    var exact = null;\n    if (found) {\n        if (path.length === 1) {\n            exact = found;\n        } else if (found instanceof Namespace) {\n            path = path.slice(1);\n            exact = found._lookupImpl(path, path.join(\".\"));\n        }\n    // Otherwise try each nested namespace\n    } else {\n        for(var i = 0; i < this.nestedArray.length; ++i)if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i]._lookupImpl(path, flatPath))) exact = found;\n    }\n    // Set this even when null, so that when we walk up the tree we can quickly bail on repeated checks back down.\n    this._lookupCache[flatPath] = exact;\n    return exact;\n};\n/**\n * Looks up the reflection object at the specified path, relative to this namespace.\n * @name NamespaceBase#lookup\n * @function\n * @param {string|string[]} path Path to look up\n * @param {boolean} [parentAlreadyChecked=false] Whether the parent has already been checked\n * @returns {ReflectionObject|null} Looked up object or `null` if none could be found\n * @variation 2\n */ // lookup(path: string, [parentAlreadyChecked: boolean])\n/**\n * Looks up the {@link Type|type} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type\n * @throws {Error} If `path` does not point to a type\n */ Namespace.prototype.lookupType = function lookupType(path) {\n    var found = this.lookup(path, [\n        Type\n    ]);\n    if (!found) throw Error(\"no such type: \" + path);\n    return found;\n};\n/**\n * Looks up the values of the {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Enum} Looked up enum\n * @throws {Error} If `path` does not point to an enum\n */ Namespace.prototype.lookupEnum = function lookupEnum(path) {\n    var found = this.lookup(path, [\n        Enum\n    ]);\n    if (!found) throw Error(\"no such Enum '\" + path + \"' in \" + this);\n    return found;\n};\n/**\n * Looks up the {@link Type|type} or {@link Enum|enum} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Type} Looked up type or enum\n * @throws {Error} If `path` does not point to a type or enum\n */ Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {\n    var found = this.lookup(path, [\n        Type,\n        Enum\n    ]);\n    if (!found) throw Error(\"no such Type or Enum '\" + path + \"' in \" + this);\n    return found;\n};\n/**\n * Looks up the {@link Service|service} at the specified path, relative to this namespace.\n * Besides its signature, this methods differs from {@link Namespace#lookup|lookup} in that it throws instead of returning `null`.\n * @param {string|string[]} path Path to look up\n * @returns {Service} Looked up service\n * @throws {Error} If `path` does not point to a service\n */ Namespace.prototype.lookupService = function lookupService(path) {\n    var found = this.lookup(path, [\n        Service\n    ]);\n    if (!found) throw Error(\"no such Service '\" + path + \"' in \" + this);\n    return found;\n};\n// Sets up cyclic dependencies (called in index-light)\nNamespace._configure = function(Type_, Service_, Enum_) {\n    Type = Type_;\n    Service = Service_;\n    Enum = Enum_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvbmFtZXNwYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsMkJBQTJCO0FBQzNCLElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUMsMEZBQVU7QUFDeEMsRUFBQ0YsVUFBVUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLGlCQUFpQkUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLFNBQVEsRUFBR08sU0FBUyxHQUFHO0FBRXhHLElBQUlDLFFBQVdOLG1CQUFPQSxDQUFDLHdGQUFTLEdBQzVCTyxPQUFXUCxtQkFBT0EsQ0FBQyxzRkFBUSxHQUMzQlEsUUFBV1IsbUJBQU9BLENBQUMsd0ZBQVM7QUFFaEMsSUFBSVMsTUFDQUMsU0FDQUM7QUFFSjs7Ozs7Ozs7Q0FRQyxHQUVEOzs7Ozs7OztDQVFDLEdBQ0RiLFVBQVVjLFFBQVEsR0FBRyxTQUFTQSxTQUFTQyxJQUFJLEVBQUVDLElBQUk7SUFDN0MsT0FBTyxJQUFJaEIsVUFBVWUsTUFBTUMsS0FBS0MsT0FBTyxFQUFFQyxPQUFPLENBQUNGLEtBQUtHLE1BQU07QUFDaEU7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxZQUFZQyxLQUFLLEVBQUVDLGFBQWE7SUFDckMsSUFBSSxDQUFFRCxDQUFBQSxTQUFTQSxNQUFNRSxNQUFNLEdBQ3ZCLE9BQU9DO0lBQ1gsSUFBSUMsTUFBTSxDQUFDO0lBQ1gsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlMLE1BQU1FLE1BQU0sRUFBRSxFQUFFRyxFQUNoQ0QsR0FBRyxDQUFDSixLQUFLLENBQUNLLEVBQUUsQ0FBQ1gsSUFBSSxDQUFDLEdBQUdNLEtBQUssQ0FBQ0ssRUFBRSxDQUFDQyxNQUFNLENBQUNMO0lBQ3pDLE9BQU9HO0FBQ1g7QUFFQXpCLFVBQVVvQixXQUFXLEdBQUdBO0FBRXhCOzs7OztDQUtDLEdBQ0RwQixVQUFV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RixVQUFVaUcsVUFBVSxHQUFHLFNBQVNDLEtBQUssRUFBRUMsUUFBUSxFQUFFQyxLQUFLO0lBQ2xEekYsT0FBVXVGO0lBQ1Z0RixVQUFVdUY7SUFDVnRGLE9BQVV1RjtBQUNkIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL25hbWVzcGFjZS5qcz8wOGMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBOYW1lc3BhY2U7XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKE5hbWVzcGFjZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBOYW1lc3BhY2UpLmNsYXNzTmFtZSA9IFwiTmFtZXNwYWNlXCI7XG5cbnZhciBGaWVsZCAgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIHV0aWwgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKSxcbiAgICBPbmVPZiAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpO1xuXG52YXIgVHlwZSwgICAgLy8gY3ljbGljXG4gICAgU2VydmljZSxcbiAgICBFbnVtO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgbmFtZXNwYWNlIGluc3RhbmNlLlxuICogQG5hbWUgTmFtZXNwYWNlXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBuYW1lc3BhY2UuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBbb3B0aW9uc10gRGVjbGFyZWQgb3B0aW9uc1xuICovXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5hbWVzcGFjZSBmcm9tIEpTT04uXG4gKiBAbWVtYmVyb2YgTmFtZXNwYWNlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWVzcGFjZSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBqc29uIEpTT04gb2JqZWN0XG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBDcmVhdGVkIG5hbWVzcGFjZVxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuTmFtZXNwYWNlLmZyb21KU09OID0gZnVuY3Rpb24gZnJvbUpTT04obmFtZSwganNvbikge1xuICAgIHJldHVybiBuZXcgTmFtZXNwYWNlKG5hbWUsIGpzb24ub3B0aW9ucykuYWRkSlNPTihqc29uLm5lc3RlZCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFycmF5IG9mIHJlZmxlY3Rpb24gb2JqZWN0cyB0byBKU09OLlxuICogQG1lbWJlcm9mIE5hbWVzcGFjZVxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0W119IGFycmF5IE9iamVjdCBhcnJheVxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj58dW5kZWZpbmVkfSBKU09OIG9iamVjdCBvciBgdW5kZWZpbmVkYCB3aGVuIGFycmF5IGlzIGVtcHR5XG4gKi9cbmZ1bmN0aW9uIGFycmF5VG9KU09OKGFycmF5LCB0b0pTT05PcHRpb25zKSB7XG4gICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSlcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgb2JqID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgb2JqW2FycmF5W2ldLm5hbWVdID0gYXJyYXlbaV0udG9KU09OKHRvSlNPTk9wdGlvbnMpO1xuICAgIHJldHVybiBvYmo7XG59XG5cbk5hbWVzcGFjZS5hcnJheVRvSlNPTiA9IGFycmF5VG9KU09OO1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fHVuZGVmaW5lZH0gcmVzZXJ2ZWQgQXJyYXkgb2YgcmVzZXJ2ZWQgcmFuZ2VzIGFuZCBuYW1lc1xuICogQHBhcmFtIHtudW1iZXJ9IGlkIElkIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbk5hbWVzcGFjZS5pc1Jlc2VydmVkSWQgPSBmdW5jdGlvbiBpc1Jlc2VydmVkSWQocmVzZXJ2ZWQsIGlkKSB7XG4gICAgaWYgKHJlc2VydmVkKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2VydmVkLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNlcnZlZFtpXSAhPT0gXCJzdHJpbmdcIiAmJiByZXNlcnZlZFtpXVswXSA8PSBpZCAmJiByZXNlcnZlZFtpXVsxXSA+IGlkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgdGhlIHNwZWNpZmllZCBuYW1lIGlzIHJlc2VydmVkLlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyW118c3RyaW5nPnx1bmRlZmluZWR9IHJlc2VydmVkIEFycmF5IG9mIHJlc2VydmVkIHJhbmdlcyBhbmQgbmFtZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuTmFtZXNwYWNlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUocmVzZXJ2ZWQsIG5hbWUpIHtcbiAgICBpZiAocmVzZXJ2ZWQpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzZXJ2ZWQubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAocmVzZXJ2ZWRbaV0gPT09IG5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBOb3QgYW4gYWN0dWFsIGNvbnN0cnVjdG9yLiBVc2Uge0BsaW5rIE5hbWVzcGFjZX0gaW5zdGVhZC5cbiAqIEBjbGFzc2Rlc2MgQmFzZSBjbGFzcyBvZiBhbGwgcmVmbGVjdGlvbiBvYmplY3RzIGNvbnRhaW5pbmcgbmVzdGVkIG9iamVjdHMuIFRoaXMgaXMgbm90IGFuIGFjdHVhbCBjbGFzcyBidXQgaGVyZSBmb3IgdGhlIHNha2Ugb2YgaGF2aW5nIGNvbnNpc3RlbnQgdHlwZSBkZWZpbml0aW9ucy5cbiAqIEBleHBvcnRzIE5hbWVzcGFjZUJhc2VcbiAqIEBleHRlbmRzIFJlZmxlY3Rpb25PYmplY3RcbiAqIEBhYnN0cmFjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lc3BhY2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBzZWUge0BsaW5rIE5hbWVzcGFjZX1cbiAqL1xuZnVuY3Rpb24gTmFtZXNwYWNlKG5hbWUsIG9wdGlvbnMpIHtcbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBOZXN0ZWQgb2JqZWN0cyBieSBuYW1lLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxSZWZsZWN0aW9uT2JqZWN0Pnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5uZXN0ZWQgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIG5lc3RlZCBvYmplY3RzIGFzIGFuIGFycmF5LlxuICAgICAqIEB0eXBlIHtSZWZsZWN0aW9uT2JqZWN0W118bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX25lc3RlZEFycmF5ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhY2hlIGxvb2t1cCBjYWxscyBmb3IgYW55IG9iamVjdHMgY29udGFpbnMgYW55d2hlcmUgdW5kZXIgdGhpcyBuYW1lc3BhY2UuXG4gICAgICogVGhpcyBkcmFzdGljYWxseSBzcGVlZHMgdXAgcmVzb2x2ZSBmb3IgbGFyZ2UgY3Jvc3MtbGlua2VkIHByb3RvcyB3aGVyZSB0aGUgc2FtZVxuICAgICAqIHR5cGVzIGFyZSBsb29rZWQgdXAgcmVwZWF0ZWRseS5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUmVmbGVjdGlvbk9iamVjdHxudWxsPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2xvb2t1cENhY2hlID0ge307XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCBvYmplY3RzIGNvbnRhaW5lZCBpbiB0aGlzIG5hbWVzcGFjZSBuZWVkIGZlYXR1cmUgcmVzb2x1dGlvbi5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fbmVlZHNSZWN1cnNpdmVGZWF0dXJlUmVzb2x1dGlvbiA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCBvYmplY3RzIGNvbnRhaW5lZCBpbiB0aGlzIG5hbWVzcGFjZSBuZWVkIGEgcmVzb2x2ZS5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgdGhpcy5fbmVlZHNSZWN1cnNpdmVSZXNvbHZlID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2xlYXJDYWNoZShuYW1lc3BhY2UpIHtcbiAgICBuYW1lc3BhY2UuX25lc3RlZEFycmF5ID0gbnVsbDtcbiAgICBuYW1lc3BhY2UuX2xvb2t1cENhY2hlID0ge307XG5cbiAgICAvLyBBbHNvIGNsZWFyIHBhcmVudCBjYWNoZXMsIHNpbmNlIHRoZXkgaW5jbHVkZSBuZXN0ZWQgbG9va3Vwcy5cbiAgICB2YXIgcGFyZW50ID0gbmFtZXNwYWNlO1xuICAgIHdoaWxlKHBhcmVudCA9IHBhcmVudC5wYXJlbnQpIHtcbiAgICAgICAgcGFyZW50Ll9sb29rdXBDYWNoZSA9IHt9O1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXNwYWNlO1xufVxuXG4vKipcbiAqIE5lc3RlZCBvYmplY3RzIG9mIHRoaXMgbmFtZXNwYWNlIGFzIGFuIGFycmF5IGZvciBpdGVyYXRpb24uXG4gKiBAbmFtZSBOYW1lc3BhY2VCYXNlI25lc3RlZEFycmF5XG4gKiBAdHlwZSB7UmVmbGVjdGlvbk9iamVjdFtdfVxuICogQHJlYWRvbmx5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOYW1lc3BhY2UucHJvdG90eXBlLCBcIm5lc3RlZEFycmF5XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbmVzdGVkQXJyYXkgfHwgKHRoaXMuX25lc3RlZEFycmF5ID0gdXRpbC50b0FycmF5KHRoaXMubmVzdGVkKSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogTmFtZXNwYWNlIGRlc2NyaXB0b3IuXG4gKiBAaW50ZXJmYWNlIElOYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBOYW1lc3BhY2Ugb3B0aW9uc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZyxBbnlOZXN0ZWRPYmplY3Q+fSBbbmVzdGVkXSBOZXN0ZWQgb2JqZWN0IGRlc2NyaXB0b3JzXG4gKi9cblxuLyoqXG4gKiBBbnkgZXh0ZW5zaW9uIGZpZWxkIGRlc2NyaXB0b3IuXG4gKiBAdHlwZWRlZiBBbnlFeHRlbnNpb25GaWVsZFxuICogQHR5cGUge0lFeHRlbnNpb25GaWVsZHxJRXh0ZW5zaW9uTWFwRmllbGR9XG4gKi9cblxuLyoqXG4gKiBBbnkgbmVzdGVkIG9iamVjdCBkZXNjcmlwdG9yLlxuICogQHR5cGVkZWYgQW55TmVzdGVkT2JqZWN0XG4gKiBAdHlwZSB7SUVudW18SVR5cGV8SVNlcnZpY2V8QW55RXh0ZW5zaW9uRmllbGR8SU5hbWVzcGFjZXxJT25lT2Z9XG4gKi9cblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIG5hbWVzcGFjZSB0byBhIG5hbWVzcGFjZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU5hbWVzcGFjZX0gTmFtZXNwYWNlIGRlc2NyaXB0b3JcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJvcHRpb25zXCIgLCB0aGlzLm9wdGlvbnMsXG4gICAgICAgIFwibmVzdGVkXCIgICwgYXJyYXlUb0pTT04odGhpcy5uZXN0ZWRBcnJheSwgdG9KU09OT3B0aW9ucylcbiAgICBdKTtcbn07XG5cbi8qKlxuICogQWRkcyBuZXN0ZWQgb2JqZWN0cyB0byB0aGlzIG5hbWVzcGFjZSBmcm9tIG5lc3RlZCBvYmplY3QgZGVzY3JpcHRvcnMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLEFueU5lc3RlZE9iamVjdD59IG5lc3RlZEpzb24gQW55IG5lc3RlZCBvYmplY3QgZGVzY3JpcHRvcnNcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmFkZEpTT04gPSBmdW5jdGlvbiBhZGRKU09OKG5lc3RlZEpzb24pIHtcbiAgICB2YXIgbnMgPSB0aGlzO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKG5lc3RlZEpzb24pIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhuZXN0ZWRKc29uKSwgaSA9IDAsIG5lc3RlZDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRKc29uW25hbWVzW2ldXTtcbiAgICAgICAgICAgIG5zLmFkZCggLy8gbW9zdCB0byBsZWFzdCBsaWtlbHlcbiAgICAgICAgICAgICAgICAoIG5lc3RlZC5maWVsZHMgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gVHlwZS5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLnZhbHVlcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBFbnVtLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQubWV0aG9kcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBTZXJ2aWNlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQuaWQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gRmllbGQuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IE5hbWVzcGFjZS5mcm9tSlNPTiApKG5hbWVzW2ldLCBuZXN0ZWQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuZXN0ZWQgb2JqZWN0IG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5lc3RlZCBvYmplY3QgbmFtZVxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gVGhlIHJlZmxlY3Rpb24gb2JqZWN0IG9yIGBudWxsYCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5uZXN0ZWQgJiYgdGhpcy5uZXN0ZWRbbmFtZV1cbiAgICAgICAgfHwgbnVsbDtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWVzIG9mIHRoZSBuZXN0ZWQge0BsaW5rIEVudW18ZW51bX0gb2YgdGhlIHNwZWNpZmllZCBuYW1lLlxuICogVGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2dldHxnZXR9IGluIHRoYXQgaXQgcmV0dXJucyBhbiBlbnVtJ3MgdmFsdWVzIGRpcmVjdGx5IGFuZCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmVzdGVkIGVudW0gbmFtZVxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLG51bWJlcj59IEVudW0gdmFsdWVzXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlcmUgaXMgbm8gc3VjaCBlbnVtXG4gKi9cbk5hbWVzcGFjZS5wcm90b3R5cGUuZ2V0RW51bSA9IGZ1bmN0aW9uIGdldEVudW0obmFtZSkge1xuICAgIGlmICh0aGlzLm5lc3RlZCAmJiB0aGlzLm5lc3RlZFtuYW1lXSBpbnN0YW5jZW9mIEVudW0pXG4gICAgICAgIHJldHVybiB0aGlzLm5lc3RlZFtuYW1lXS52YWx1ZXM7XG4gICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIGVudW06IFwiICsgbmFtZSk7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXN0ZWQgb2JqZWN0IHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgTmVzdGVkIG9iamVjdCB0byBhZGRcbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgbmVzdGVkIG9iamVjdCB3aXRoIHRoaXMgbmFtZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChvYmplY3QpIHtcblxuICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkICYmIG9iamVjdC5leHRlbmQgIT09IHVuZGVmaW5lZCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUeXBlICB8fCBvYmplY3QgaW5zdGFuY2VvZiBPbmVPZiB8fCBvYmplY3QgaW5zdGFuY2VvZiBFbnVtIHx8IG9iamVjdCBpbnN0YW5jZW9mIFNlcnZpY2UgfHwgb2JqZWN0IGluc3RhbmNlb2YgTmFtZXNwYWNlKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwib2JqZWN0IG11c3QgYmUgYSB2YWxpZCBuZXN0ZWQgb2JqZWN0XCIpO1xuXG4gICAgaWYgKCF0aGlzLm5lc3RlZClcbiAgICAgICAgdGhpcy5uZXN0ZWQgPSB7fTtcbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHByZXYgPSB0aGlzLmdldChvYmplY3QubmFtZSk7XG4gICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICBpZiAocHJldiBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiBvYmplY3QgaW5zdGFuY2VvZiBOYW1lc3BhY2UgJiYgIShwcmV2IGluc3RhbmNlb2YgVHlwZSB8fCBwcmV2IGluc3RhbmNlb2YgU2VydmljZSkpIHtcbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHBsYWluIG5hbWVzcGFjZSBidXQga2VlcCBleGlzdGluZyBuZXN0ZWQgZWxlbWVudHMgYW5kIG9wdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgbmVzdGVkID0gcHJldi5uZXN0ZWRBcnJheTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5lc3RlZC5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0LmFkZChuZXN0ZWRbaV0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHByZXYpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVzdGVkID0ge307XG4gICAgICAgICAgICAgICAgb2JqZWN0LnNldE9wdGlvbnMocHJldi5vcHRpb25zLCB0cnVlKTtcblxuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMubmVzdGVkW29iamVjdC5uYW1lXSA9IG9iamVjdDtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUeXBlIHx8IHRoaXMgaW5zdGFuY2VvZiBTZXJ2aWNlIHx8IHRoaXMgaW5zdGFuY2VvZiBFbnVtIHx8IHRoaXMgaW5zdGFuY2VvZiBGaWVsZCkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHBhY2thZ2Ugb3IgYSByb290IG5hbWVzcGFjZS5cbiAgICAgICAgaWYgKCFvYmplY3QuX2VkaXRpb24pIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHNvbWUgZWRpdGlvbiBpcyBzZXQgaWYgaXQgaGFzbid0IGFscmVhZHkgYmVlbiBzcGVjaWZpZWQuXG4gICAgICAgICAgICBvYmplY3QuX2VkaXRpb24gPSBvYmplY3QuX2RlZmF1bHRFZGl0aW9uO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fbmVlZHNSZWN1cnNpdmVGZWF0dXJlUmVzb2x1dGlvbiA9IHRydWU7XG4gICAgdGhpcy5fbmVlZHNSZWN1cnNpdmVSZXNvbHZlID0gdHJ1ZTtcblxuICAgIC8vIEFsc28gY2xlYXIgcGFyZW50IGNhY2hlcywgc2luY2UgdGhleSBuZWVkIHRvIHJlY3Vyc2UgZG93bi5cbiAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICB3aGlsZShwYXJlbnQgPSBwYXJlbnQucGFyZW50KSB7XG4gICAgICAgIHBhcmVudC5fbmVlZHNSZWN1cnNpdmVGZWF0dXJlUmVzb2x1dGlvbiA9IHRydWU7XG4gICAgICAgIHBhcmVudC5fbmVlZHNSZWN1cnNpdmVSZXNvbHZlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBvYmplY3Qub25BZGQodGhpcyk7XG4gICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBuZXN0ZWQgb2JqZWN0IGZyb20gdGhpcyBuYW1lc3BhY2UuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IG9iamVjdCBOZXN0ZWQgb2JqZWN0IHRvIHJlbW92ZVxuICogQHJldHVybnMge05hbWVzcGFjZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBvYmplY3RgIGlzIG5vdCBhIG1lbWJlciBvZiB0aGlzIG5hbWVzcGFjZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcblxuICAgIGlmICghKG9iamVjdCBpbnN0YW5jZW9mIFJlZmxlY3Rpb25PYmplY3QpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJvYmplY3QgbXVzdCBiZSBhIFJlZmxlY3Rpb25PYmplY3RcIik7XG4gICAgaWYgKG9iamVjdC5wYXJlbnQgIT09IHRoaXMpXG4gICAgICAgIHRocm93IEVycm9yKG9iamVjdCArIFwiIGlzIG5vdCBhIG1lbWJlciBvZiBcIiArIHRoaXMpO1xuXG4gICAgZGVsZXRlIHRoaXMubmVzdGVkW29iamVjdC5uYW1lXTtcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMubmVzdGVkKS5sZW5ndGgpXG4gICAgICAgIHRoaXMubmVzdGVkID0gdW5kZWZpbmVkO1xuXG4gICAgb2JqZWN0Lm9uUmVtb3ZlKHRoaXMpO1xuICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIGFkZGl0aWFsIG5hbWVzcGFjZXMgd2l0aGluIHRoaXMgb25lIGlmIG5vdCB5ZXQgZXhpc3RpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGNyZWF0ZVxuICogQHBhcmFtIHsqfSBbanNvbl0gTmVzdGVkIHR5cGVzIHRvIGNyZWF0ZSBmcm9tIEpTT05cbiAqIEByZXR1cm5zIHtOYW1lc3BhY2V9IFBvaW50ZXIgdG8gdGhlIGxhc3QgbmFtZXNwYWNlIGNyZWF0ZWQgb3IgYHRoaXNgIGlmIHBhdGggaXMgZW1wdHlcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5kZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUocGF0aCwganNvbikge1xuXG4gICAgaWYgKHV0aWwuaXNTdHJpbmcocGF0aCkpXG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwYXRoKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiaWxsZWdhbCBwYXRoXCIpO1xuICAgIGlmIChwYXRoICYmIHBhdGgubGVuZ3RoICYmIHBhdGhbMF0gPT09IFwiXCIpXG4gICAgICAgIHRocm93IEVycm9yKFwicGF0aCBtdXN0IGJlIHJlbGF0aXZlXCIpO1xuXG4gICAgdmFyIHB0ciA9IHRoaXM7XG4gICAgd2hpbGUgKHBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgcGFydCA9IHBhdGguc2hpZnQoKTtcbiAgICAgICAgaWYgKHB0ci5uZXN0ZWQgJiYgcHRyLm5lc3RlZFtwYXJ0XSkge1xuICAgICAgICAgICAgcHRyID0gcHRyLm5lc3RlZFtwYXJ0XTtcbiAgICAgICAgICAgIGlmICghKHB0ciBpbnN0YW5jZW9mIE5hbWVzcGFjZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJwYXRoIGNvbmZsaWN0cyB3aXRoIG5vbi1uYW1lc3BhY2Ugb2JqZWN0c1wiKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBwdHIuYWRkKHB0ciA9IG5ldyBOYW1lc3BhY2UocGFydCkpO1xuICAgIH1cbiAgICBpZiAoanNvbilcbiAgICAgICAgcHRyLmFkZEpTT04oanNvbik7XG4gICAgcmV0dXJuIHB0cjtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhpcyBuYW1lc3BhY2UncyBhbmQgYWxsIGl0cyBuZXN0ZWQgb2JqZWN0cycgdHlwZSByZWZlcmVuY2VzLiBVc2VmdWwgdG8gdmFsaWRhdGUgYSByZWZsZWN0aW9uIHRyZWUsIGJ1dCBjb21lcyBhdCBhIGNvc3QuXG4gKiBAcmV0dXJucyB7TmFtZXNwYWNlfSBgdGhpc2BcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICBpZiAoIXRoaXMuX25lZWRzUmVjdXJzaXZlUmVzb2x2ZSkgcmV0dXJuIHRoaXM7XG5cbiAgICB0aGlzLl9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUodGhpcy5fZWRpdGlvbik7XG5cbiAgICB2YXIgbmVzdGVkID0gdGhpcy5uZXN0ZWRBcnJheSwgaSA9IDA7XG4gICAgdGhpcy5yZXNvbHZlKCk7XG4gICAgd2hpbGUgKGkgPCBuZXN0ZWQubGVuZ3RoKVxuICAgICAgICBpZiAobmVzdGVkW2ldIGluc3RhbmNlb2YgTmFtZXNwYWNlKVxuICAgICAgICAgICAgbmVzdGVkW2krK10ucmVzb2x2ZUFsbCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXN0ZWRbaSsrXS5yZXNvbHZlKCk7XG4gICAgdGhpcy5fbmVlZHNSZWN1cnNpdmVSZXNvbHZlID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLl9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUgPSBmdW5jdGlvbiBfcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlKGVkaXRpb24pIHtcbiAgICBpZiAoIXRoaXMuX25lZWRzUmVjdXJzaXZlRmVhdHVyZVJlc29sdXRpb24pIHJldHVybiB0aGlzO1xuICAgIHRoaXMuX25lZWRzUmVjdXJzaXZlRmVhdHVyZVJlc29sdXRpb24gPSBmYWxzZTtcblxuICAgIGVkaXRpb24gPSB0aGlzLl9lZGl0aW9uIHx8IGVkaXRpb247XG5cbiAgICBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5fcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlLmNhbGwodGhpcywgZWRpdGlvbik7XG4gICAgdGhpcy5uZXN0ZWRBcnJheS5mb3JFYWNoKG5lc3RlZCA9PiB7XG4gICAgICAgIG5lc3RlZC5fcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlKGVkaXRpb24pO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBsb29rcyB1cCB0aGUgcmVmbGVjdGlvbiBvYmplY3QgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCBwYXRoIGluIHRoZSBzY29wZSBvZiB0aGlzIG5hbWVzcGFjZS5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHBhcmFtIHsqfEFycmF5LjwqPn0gZmlsdGVyVHlwZXMgRmlsdGVyIHR5cGVzLCBhbnkgY29tYmluYXRpb24gb2YgdGhlIGNvbnN0cnVjdG9ycyBvZiBgcHJvdG9idWYuVHlwZWAsIGBwcm90b2J1Zi5FbnVtYCwgYHByb3RvYnVmLlNlcnZpY2VgIGV0Yy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmVudEFscmVhZHlDaGVja2VkPWZhbHNlXSBJZiBrbm93biwgd2hldGhlciB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gTG9va2VkIHVwIG9iamVjdCBvciBgbnVsbGAgaWYgbm9uZSBjb3VsZCBiZSBmb3VuZFxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cChwYXRoLCBmaWx0ZXJUeXBlcywgcGFyZW50QWxyZWFkeUNoZWNrZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICh0eXBlb2YgZmlsdGVyVHlwZXMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHBhcmVudEFscmVhZHlDaGVja2VkID0gZmlsdGVyVHlwZXM7XG4gICAgICAgIGZpbHRlclR5cGVzID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoZmlsdGVyVHlwZXMgJiYgIUFycmF5LmlzQXJyYXkoZmlsdGVyVHlwZXMpKVxuICAgICAgICBmaWx0ZXJUeXBlcyA9IFsgZmlsdGVyVHlwZXMgXTtcblxuICAgIGlmICh1dGlsLmlzU3RyaW5nKHBhdGgpICYmIHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIGlmIChwYXRoID09PSBcIi5cIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gICAgICAgIHBhdGggPSBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICB2YXIgZmxhdFBhdGggPSBwYXRoLmpvaW4oXCIuXCIpO1xuXG4gICAgLy8gU3RhcnQgYXQgcm9vdCBpZiBwYXRoIGlzIGFic29sdXRlXG4gICAgaWYgKHBhdGhbMF0gPT09IFwiXCIpXG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QubG9va3VwKHBhdGguc2xpY2UoMSksIGZpbHRlclR5cGVzKTtcblxuICAgIC8vIEVhcmx5IGJhaWxvdXQgZm9yIG9iamVjdHMgd2l0aCBtYXRjaGluZyBhYnNvbHV0ZSBwYXRoc1xuICAgIHZhciBmb3VuZCA9IHRoaXMucm9vdC5fZnVsbHlRdWFsaWZpZWRPYmplY3RzICYmIHRoaXMucm9vdC5fZnVsbHlRdWFsaWZpZWRPYmplY3RzW1wiLlwiICsgZmxhdFBhdGhdO1xuICAgIGlmIChmb3VuZCAmJiAoIWZpbHRlclR5cGVzIHx8IGZpbHRlclR5cGVzLmluZGV4T2YoZm91bmQuY29uc3RydWN0b3IpID4gLTEpKSB7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG5cbiAgICAvLyBEbyBhIHJlZ3VsYXIgbG9va3VwIGF0IHRoaXMgbmFtZXNwYWNlIGFuZCBiZWxvd1xuICAgIGZvdW5kID0gdGhpcy5fbG9va3VwSW1wbChwYXRoLCBmbGF0UGF0aCk7XG4gICAgaWYgKGZvdW5kICYmICghZmlsdGVyVHlwZXMgfHwgZmlsdGVyVHlwZXMuaW5kZXhPZihmb3VuZC5jb25zdHJ1Y3RvcikgPiAtMSkpIHtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnRBbHJlYWR5Q2hlY2tlZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAvLyBJZiB0aGVyZSBoYXNuJ3QgYmVlbiBhIG1hdGNoLCB3YWxrIHVwIHRoZSB0cmVlIGFuZCBsb29rIG1vcmUgYnJvYWRseVxuICAgIHZhciBjdXJyZW50ID0gdGhpcztcbiAgICB3aGlsZSAoY3VycmVudC5wYXJlbnQpIHtcbiAgICAgICAgZm91bmQgPSBjdXJyZW50LnBhcmVudC5fbG9va3VwSW1wbChwYXRoLCBmbGF0UGF0aCk7XG4gICAgICAgIGlmIChmb3VuZCAmJiAoIWZpbHRlclR5cGVzIHx8IGZpbHRlclR5cGVzLmluZGV4T2YoZm91bmQuY29uc3RydWN0b3IpID4gLTEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZvciBsb29rdXAgdGhhdCBoYW5kbGVzIHNlYXJjaGluZyBqdXN0IGF0IHRoaXMgbmFtZXNwYWNlIGFuZCBiZWxvdyBhbG9uZyB3aXRoIGNhY2hpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHBhcmFtIHtzdHJpbmd9IGZsYXRQYXRoIEZsYXR0ZW5lZCB2ZXJzaW9uIG9mIHRoZSBwYXRoIHRvIHVzZSBhcyBhIGNhY2hlIGtleVxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gTG9va2VkIHVwIG9iamVjdCBvciBgbnVsbGAgaWYgbm9uZSBjb3VsZCBiZSBmb3VuZFxuICogQHByaXZhdGVcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5fbG9va3VwSW1wbCA9IGZ1bmN0aW9uIGxvb2t1cChwYXRoLCBmbGF0UGF0aCkge1xuICAgIGlmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLl9sb29rdXBDYWNoZSwgZmxhdFBhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb29rdXBDYWNoZVtmbGF0UGF0aF07XG4gICAgfVxuXG4gICAgLy8gVGVzdCBpZiB0aGUgZmlyc3QgcGFydCBtYXRjaGVzIGFueSBuZXN0ZWQgb2JqZWN0LCBhbmQgaWYgc28sIHRyYXZlcnNlIGlmIHBhdGggY29udGFpbnMgbW9yZVxuICAgIHZhciBmb3VuZCA9IHRoaXMuZ2V0KHBhdGhbMF0pO1xuICAgIHZhciBleGFjdCA9IG51bGw7XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZXhhY3QgPSBmb3VuZDtcbiAgICAgICAgfSBlbHNlIGlmIChmb3VuZCBpbnN0YW5jZW9mIE5hbWVzcGFjZSkge1xuICAgICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG4gICAgICAgICAgICBleGFjdCA9IGZvdW5kLl9sb29rdXBJbXBsKHBhdGgsIHBhdGguam9pbihcIi5cIikpO1xuICAgICAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UgdHJ5IGVhY2ggbmVzdGVkIG5hbWVzcGFjZVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZXN0ZWRBcnJheVtpXSBpbnN0YW5jZW9mIE5hbWVzcGFjZSAmJiAoZm91bmQgPSB0aGlzLl9uZXN0ZWRBcnJheVtpXS5fbG9va3VwSW1wbChwYXRoLCBmbGF0UGF0aCkpKVxuICAgICAgICAgICAgICAgIGV4YWN0ID0gZm91bmQ7XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoaXMgZXZlbiB3aGVuIG51bGwsIHNvIHRoYXQgd2hlbiB3ZSB3YWxrIHVwIHRoZSB0cmVlIHdlIGNhbiBxdWlja2x5IGJhaWwgb24gcmVwZWF0ZWQgY2hlY2tzIGJhY2sgZG93bi5cbiAgICB0aGlzLl9sb29rdXBDYWNoZVtmbGF0UGF0aF0gPSBleGFjdDtcbiAgICByZXR1cm4gZXhhY3Q7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSByZWZsZWN0aW9uIG9iamVjdCBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQG5hbWUgTmFtZXNwYWNlQmFzZSNsb29rdXBcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJlbnRBbHJlYWR5Q2hlY2tlZD1mYWxzZV0gV2hldGhlciB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gY2hlY2tlZFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R8bnVsbH0gTG9va2VkIHVwIG9iamVjdCBvciBgbnVsbGAgaWYgbm9uZSBjb3VsZCBiZSBmb3VuZFxuICogQHZhcmlhdGlvbiAyXG4gKi9cbi8vIGxvb2t1cChwYXRoOiBzdHJpbmcsIFtwYXJlbnRBbHJlYWR5Q2hlY2tlZDogYm9vbGVhbl0pXG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHtAbGluayBUeXBlfHR5cGV9IGF0IHRoZSBzcGVjaWZpZWQgcGF0aCwgcmVsYXRpdmUgdG8gdGhpcyBuYW1lc3BhY2UuXG4gKiBCZXNpZGVzIGl0cyBzaWduYXR1cmUsIHRoaXMgbWV0aG9kcyBkaWZmZXJzIGZyb20ge0BsaW5rIE5hbWVzcGFjZSNsb29rdXB8bG9va3VwfSBpbiB0aGF0IGl0IHRocm93cyBpbnN0ZWFkIG9mIHJldHVybmluZyBgbnVsbGAuXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gcGF0aCBQYXRoIHRvIGxvb2sgdXBcbiAqIEByZXR1cm5zIHtUeXBlfSBMb29rZWQgdXAgdHlwZVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhIHR5cGVcbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBUeXBlID0gZnVuY3Rpb24gbG9va3VwVHlwZShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBUeXBlIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCB0eXBlOiBcIiArIHBhdGgpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIHZhbHVlcyBvZiB0aGUge0BsaW5rIEVudW18ZW51bX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge0VudW19IExvb2tlZCB1cCBlbnVtXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGFuIGVudW1cbiAqL1xuTmFtZXNwYWNlLnByb3RvdHlwZS5sb29rdXBFbnVtID0gZnVuY3Rpb24gbG9va3VwRW51bShwYXRoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5sb29rdXAocGF0aCwgWyBFbnVtIF0pO1xuICAgIGlmICghZm91bmQpXG4gICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBFbnVtICdcIiArIHBhdGggKyBcIicgaW4gXCIgKyB0aGlzKTtcbiAgICByZXR1cm4gZm91bmQ7XG59O1xuXG4vKipcbiAqIExvb2tzIHVwIHRoZSB7QGxpbmsgVHlwZXx0eXBlfSBvciB7QGxpbmsgRW51bXxlbnVtfSBhdCB0aGUgc3BlY2lmaWVkIHBhdGgsIHJlbGF0aXZlIHRvIHRoaXMgbmFtZXNwYWNlLlxuICogQmVzaWRlcyBpdHMgc2lnbmF0dXJlLCB0aGlzIG1ldGhvZHMgZGlmZmVycyBmcm9tIHtAbGluayBOYW1lc3BhY2UjbG9va3VwfGxvb2t1cH0gaW4gdGhhdCBpdCB0aHJvd3MgaW5zdGVhZCBvZiByZXR1cm5pbmcgYG51bGxgLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHBhdGggUGF0aCB0byBsb29rIHVwXG4gKiBAcmV0dXJucyB7VHlwZX0gTG9va2VkIHVwIHR5cGUgb3IgZW51bVxuICogQHRocm93cyB7RXJyb3J9IElmIGBwYXRoYCBkb2VzIG5vdCBwb2ludCB0byBhIHR5cGUgb3IgZW51bVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cFR5cGVPckVudW0gPSBmdW5jdGlvbiBsb29rdXBUeXBlT3JFbnVtKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIFR5cGUsIEVudW0gXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIFR5cGUgb3IgRW51bSAnXCIgKyBwYXRoICsgXCInIGluIFwiICsgdGhpcyk7XG4gICAgcmV0dXJuIGZvdW5kO1xufTtcblxuLyoqXG4gKiBMb29rcyB1cCB0aGUge0BsaW5rIFNlcnZpY2V8c2VydmljZX0gYXQgdGhlIHNwZWNpZmllZCBwYXRoLCByZWxhdGl2ZSB0byB0aGlzIG5hbWVzcGFjZS5cbiAqIEJlc2lkZXMgaXRzIHNpZ25hdHVyZSwgdGhpcyBtZXRob2RzIGRpZmZlcnMgZnJvbSB7QGxpbmsgTmFtZXNwYWNlI2xvb2t1cHxsb29rdXB9IGluIHRoYXQgaXQgdGhyb3dzIGluc3RlYWQgb2YgcmV0dXJuaW5nIGBudWxsYC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBwYXRoIFBhdGggdG8gbG9vayB1cFxuICogQHJldHVybnMge1NlcnZpY2V9IExvb2tlZCB1cCBzZXJ2aWNlXG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYHBhdGhgIGRvZXMgbm90IHBvaW50IHRvIGEgc2VydmljZVxuICovXG5OYW1lc3BhY2UucHJvdG90eXBlLmxvb2t1cFNlcnZpY2UgPSBmdW5jdGlvbiBsb29rdXBTZXJ2aWNlKHBhdGgpIHtcbiAgICB2YXIgZm91bmQgPSB0aGlzLmxvb2t1cChwYXRoLCBbIFNlcnZpY2UgXSk7XG4gICAgaWYgKCFmb3VuZClcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJubyBzdWNoIFNlcnZpY2UgJ1wiICsgcGF0aCArIFwiJyBpbiBcIiArIHRoaXMpO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuTmFtZXNwYWNlLl9jb25maWd1cmUgPSBmdW5jdGlvbihUeXBlXywgU2VydmljZV8sIEVudW1fKSB7XG4gICAgVHlwZSAgICA9IFR5cGVfO1xuICAgIFNlcnZpY2UgPSBTZXJ2aWNlXztcbiAgICBFbnVtICAgID0gRW51bV87XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJOYW1lc3BhY2UiLCJSZWZsZWN0aW9uT2JqZWN0IiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiY2xhc3NOYW1lIiwiRmllbGQiLCJ1dGlsIiwiT25lT2YiLCJUeXBlIiwiU2VydmljZSIsIkVudW0iLCJmcm9tSlNPTiIsIm5hbWUiLCJqc29uIiwib3B0aW9ucyIsImFkZEpTT04iLCJuZXN0ZWQiLCJhcnJheVRvSlNPTiIsImFycmF5IiwidG9KU09OT3B0aW9ucyIsImxlbmd0aCIsInVuZGVmaW5lZCIsIm9iaiIsImkiLCJ0b0pTT04iLCJpc1Jlc2VydmVkSWQiLCJyZXNlcnZlZCIsImlkIiwiaXNSZXNlcnZlZE5hbWUiLCJjYWxsIiwiX25lc3RlZEFycmF5IiwiX2xvb2t1cENhY2hlIiwiX25lZWRzUmVjdXJzaXZlRmVhdHVyZVJlc29sdXRpb24iLCJfbmVlZHNSZWN1cnNpdmVSZXNvbHZlIiwiY2xlYXJDYWNoZSIsIm5hbWVzcGFjZSIsInBhcmVudCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwidG9BcnJheSIsInRvT2JqZWN0IiwibmVzdGVkQXJyYXkiLCJuZXN0ZWRKc29uIiwibnMiLCJuYW1lcyIsImtleXMiLCJhZGQiLCJmaWVsZHMiLCJ2YWx1ZXMiLCJtZXRob2RzIiwiZ2V0RW51bSIsIkVycm9yIiwib2JqZWN0IiwiZXh0ZW5kIiwiVHlwZUVycm9yIiwicHJldiIsInJlbW92ZSIsInNldE9wdGlvbnMiLCJfZWRpdGlvbiIsIl9kZWZhdWx0RWRpdGlvbiIsIm9uQWRkIiwib25SZW1vdmUiLCJkZWZpbmUiLCJwYXRoIiwiaXNTdHJpbmciLCJzcGxpdCIsIkFycmF5IiwiaXNBcnJheSIsInB0ciIsInBhcnQiLCJzaGlmdCIsInJlc29sdmVBbGwiLCJfcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlIiwicmVzb2x2ZSIsImVkaXRpb24iLCJmb3JFYWNoIiwibG9va3VwIiwiZmlsdGVyVHlwZXMiLCJwYXJlbnRBbHJlYWR5Q2hlY2tlZCIsInJvb3QiLCJmbGF0UGF0aCIsImpvaW4iLCJzbGljZSIsImZvdW5kIiwiX2Z1bGx5UXVhbGlmaWVkT2JqZWN0cyIsImluZGV4T2YiLCJfbG9va3VwSW1wbCIsImN1cnJlbnQiLCJoYXNPd25Qcm9wZXJ0eSIsImV4YWN0IiwibG9va3VwVHlwZSIsImxvb2t1cEVudW0iLCJsb29rdXBUeXBlT3JFbnVtIiwibG9va3VwU2VydmljZSIsIl9jb25maWd1cmUiLCJUeXBlXyIsIlNlcnZpY2VfIiwiRW51bV8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = ReflectionObject;\nReflectionObject.className = \"ReflectionObject\";\nconst OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\");\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\nvar Root; // cyclic\n/* eslint-disable no-warning-comments */ // TODO: Replace with embedded proto.\nvar editions2023Defaults = {\n    enum_type: \"OPEN\",\n    field_presence: \"EXPLICIT\",\n    json_format: \"ALLOW\",\n    message_encoding: \"LENGTH_PREFIXED\",\n    repeated_field_encoding: \"PACKED\",\n    utf8_validation: \"VERIFY\"\n};\nvar proto2Defaults = {\n    enum_type: \"CLOSED\",\n    field_presence: \"EXPLICIT\",\n    json_format: \"LEGACY_BEST_EFFORT\",\n    message_encoding: \"LENGTH_PREFIXED\",\n    repeated_field_encoding: \"EXPANDED\",\n    utf8_validation: \"NONE\"\n};\nvar proto3Defaults = {\n    enum_type: \"OPEN\",\n    field_presence: \"IMPLICIT\",\n    json_format: \"ALLOW\",\n    message_encoding: \"LENGTH_PREFIXED\",\n    repeated_field_encoding: \"PACKED\",\n    utf8_validation: \"VERIFY\"\n};\n/**\n * Constructs a new reflection object instance.\n * @classdesc Base class of all reflection objects.\n * @constructor\n * @param {string} name Object name\n * @param {Object.<string,*>} [options] Declared options\n * @abstract\n */ function ReflectionObject(name, options) {\n    if (!util.isString(name)) throw TypeError(\"name must be a string\");\n    if (options && !util.isObject(options)) throw TypeError(\"options must be an object\");\n    /**\n     * Options.\n     * @type {Object.<string,*>|undefined}\n     */ this.options = options; // toJSON\n    /**\n     * Parsed Options.\n     * @type {Array.<Object.<string,*>>|undefined}\n     */ this.parsedOptions = null;\n    /**\n     * Unique name within its namespace.\n     * @type {string}\n     */ this.name = name;\n    /**\n     * The edition specified for this object.  Only relevant for top-level objects.\n     * @type {string}\n     * @private\n     */ this._edition = null;\n    /**\n     * The default edition to use for this object if none is specified.  For legacy reasons,\n     * this is proto2 except in the JSON parsing case where it was proto3.\n     * @type {string}\n     * @private\n     */ this._defaultEdition = \"proto2\";\n    /**\n     * Resolved Features.\n     * @type {object}\n     * @private\n     */ this._features = {};\n    /**\n     * Whether or not features have been resolved.\n     * @type {boolean}\n     * @private\n     */ this._featuresResolved = false;\n    /**\n     * Parent namespace.\n     * @type {Namespace|null}\n     */ this.parent = null;\n    /**\n     * Whether already resolved or not.\n     * @type {boolean}\n     */ this.resolved = false;\n    /**\n     * Comment text, if any.\n     * @type {string|null}\n     */ this.comment = null;\n    /**\n     * Defining file name.\n     * @type {string|null}\n     */ this.filename = null;\n}\nObject.defineProperties(ReflectionObject.prototype, {\n    /**\n     * Reference to the root namespace.\n     * @name ReflectionObject#root\n     * @type {Root}\n     * @readonly\n     */ root: {\n        get: function() {\n            var ptr = this;\n            while(ptr.parent !== null)ptr = ptr.parent;\n            return ptr;\n        }\n    },\n    /**\n     * Full name including leading dot.\n     * @name ReflectionObject#fullName\n     * @type {string}\n     * @readonly\n     */ fullName: {\n        get: function() {\n            var path = [\n                this.name\n            ], ptr = this.parent;\n            while(ptr){\n                path.unshift(ptr.name);\n                ptr = ptr.parent;\n            }\n            return path.join(\".\");\n        }\n    }\n});\n/**\n * Converts this reflection object to its descriptor representation.\n * @returns {Object.<string,*>} Descriptor\n * @abstract\n */ ReflectionObject.prototype.toJSON = /* istanbul ignore next */ function toJSON() {\n    throw Error(); // not implemented, shouldn't happen\n};\n/**\n * Called when this object is added to a parent.\n * @param {ReflectionObject} parent Parent added to\n * @returns {undefined}\n */ ReflectionObject.prototype.onAdd = function onAdd(parent) {\n    if (this.parent && this.parent !== parent) this.parent.remove(this);\n    this.parent = parent;\n    this.resolved = false;\n    var root = parent.root;\n    if (root instanceof Root) root._handleAdd(this);\n};\n/**\n * Called when this object is removed from a parent.\n * @param {ReflectionObject} parent Parent removed from\n * @returns {undefined}\n */ ReflectionObject.prototype.onRemove = function onRemove(parent) {\n    var root = parent.root;\n    if (root instanceof Root) root._handleRemove(this);\n    this.parent = null;\n    this.resolved = false;\n};\n/**\n * Resolves this objects type references.\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.resolve = function resolve() {\n    if (this.resolved) return this;\n    if (this.root instanceof Root) this.resolved = true; // only if part of a root\n    return this;\n};\n/**\n * Resolves this objects editions features.\n * @param {string} edition The edition we're currently resolving for.\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n    return this._resolveFeatures(this._edition || edition);\n};\n/**\n * Resolves child features from parent features\n * @param {string} edition The edition we're currently resolving for.\n * @returns {undefined}\n */ ReflectionObject.prototype._resolveFeatures = function _resolveFeatures(edition) {\n    if (this._featuresResolved) {\n        return;\n    }\n    var defaults = {};\n    /* istanbul ignore if */ if (!edition) {\n        throw new Error(\"Unknown edition for \" + this.fullName);\n    }\n    var protoFeatures = Object.assign(this.options ? Object.assign({}, this.options.features) : {}, this._inferLegacyProtoFeatures(edition));\n    if (this._edition) {\n        // For a namespace marked with a specific edition, reset defaults.\n        /* istanbul ignore else */ if (edition === \"proto2\") {\n            defaults = Object.assign({}, proto2Defaults);\n        } else if (edition === \"proto3\") {\n            defaults = Object.assign({}, proto3Defaults);\n        } else if (edition === \"2023\") {\n            defaults = Object.assign({}, editions2023Defaults);\n        } else {\n            throw new Error(\"Unknown edition: \" + edition);\n        }\n        this._features = Object.assign(defaults, protoFeatures || {});\n        this._featuresResolved = true;\n        return;\n    }\n    // fields in Oneofs aren't actually children of them, so we have to\n    // special-case it\n    /* istanbul ignore else */ if (this.partOf instanceof OneOf) {\n        var lexicalParentFeaturesCopy = Object.assign({}, this.partOf._features);\n        this._features = Object.assign(lexicalParentFeaturesCopy, protoFeatures || {});\n    } else if (this.declaringField) {\n    // Skip feature resolution of sister fields.\n    } else if (this.parent) {\n        var parentFeaturesCopy = Object.assign({}, this.parent._features);\n        this._features = Object.assign(parentFeaturesCopy, protoFeatures || {});\n    } else {\n        throw new Error(\"Unable to find a parent for \" + this.fullName);\n    }\n    if (this.extensionField) {\n        // Sister fields should have the same features as their extensions.\n        this.extensionField._features = this._features;\n    }\n    this._featuresResolved = true;\n};\n/**\n * Infers features from legacy syntax that may have been specified differently.\n * in older editions.\n * @param {string|undefined} edition The edition this proto is on, or undefined if pre-editions\n * @returns {object} The feature values to override\n */ ReflectionObject.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures() {\n    return {};\n};\n/**\n * Gets an option value.\n * @param {string} name Option name\n * @returns {*} Option value or `undefined` if not set\n */ ReflectionObject.prototype.getOption = function getOption(name) {\n    if (this.options) return this.options[name];\n    return undefined;\n};\n/**\n * Sets an option.\n * @param {string} name Option name\n * @param {*} value Option value\n * @param {boolean|undefined} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {\n    if (!this.options) this.options = {};\n    if (/^features\\./.test(name)) {\n        util.setProperty(this.options, name, value, ifNotSet);\n    } else if (!ifNotSet || this.options[name] === undefined) {\n        if (this.getOption(name) !== value) this.resolved = false;\n        this.options[name] = value;\n    }\n    return this;\n};\n/**\n * Sets a parsed option.\n * @param {string} name parsed Option name\n * @param {*} value Option value\n * @param {string} propName dot '.' delimited full path of property within the option to set. if undefined\\empty, will add a new option with that value\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {\n    if (!this.parsedOptions) {\n        this.parsedOptions = [];\n    }\n    var parsedOptions = this.parsedOptions;\n    if (propName) {\n        // If setting a sub property of an option then try to merge it\n        // with an existing option\n        var opt = parsedOptions.find(function(opt) {\n            return Object.prototype.hasOwnProperty.call(opt, name);\n        });\n        if (opt) {\n            // If we found an existing option - just merge the property value\n            // (If it's a feature, will just write over)\n            var newValue = opt[name];\n            util.setProperty(newValue, propName, value);\n        } else {\n            // otherwise, create a new option, set its property and add it to the list\n            opt = {};\n            opt[name] = util.setProperty({}, propName, value);\n            parsedOptions.push(opt);\n        }\n    } else {\n        // Always create a new option when setting the value of the option itself\n        var newOpt = {};\n        newOpt[name] = value;\n        parsedOptions.push(newOpt);\n    }\n    return this;\n};\n/**\n * Sets multiple options.\n * @param {Object.<string,*>} options Options to set\n * @param {boolean} [ifNotSet] Sets an option only if it isn't currently set\n * @returns {ReflectionObject} `this`\n */ ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {\n    if (options) for(var keys = Object.keys(options), i = 0; i < keys.length; ++i)this.setOption(keys[i], options[keys[i]], ifNotSet);\n    return this;\n};\n/**\n * Converts this instance to its string representation.\n * @returns {string} Class name[, space, full name]\n */ ReflectionObject.prototype.toString = function toString() {\n    var className = this.constructor.className, fullName = this.fullName;\n    if (fullName.length) return className + \" \" + fullName;\n    return className;\n};\n/**\n * Converts the edition this object is pinned to for JSON format.\n * @returns {string|undefined} The edition string for JSON representation\n */ ReflectionObject.prototype._editionToJSON = function _editionToJSON() {\n    if (!this._edition || this._edition === \"proto3\") {\n        // Avoid emitting proto3 since we need to default to it for backwards\n        // compatibility anyway.\n        return undefined;\n    }\n    return this._edition;\n};\n// Sets up cyclic dependencies (called in index-light)\nReflectionObject._configure = function(Root_) {\n    Root = Root_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvb2JqZWN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakJBLGlCQUFpQkMsU0FBUyxHQUFHO0FBRTdCLE1BQU1DLFFBQVFDLG1CQUFPQSxDQUFDLHdGQUFTO0FBQy9CLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDLHNGQUFRO0FBRTNCLElBQUlFLE1BQU0sU0FBUztBQUVuQixzQ0FBc0MsR0FDdEMscUNBQXFDO0FBQ3JDLElBQUlDLHVCQUF1QjtJQUFDQyxXQUFXO0lBQVFDLGdCQUFnQjtJQUFZQyxhQUFhO0lBQVNDLGtCQUFrQjtJQUFtQkMseUJBQXlCO0lBQVVDLGlCQUFpQjtBQUFRO0FBQ2xNLElBQUlDLGlCQUFpQjtJQUFDTixXQUFXO0lBQVVDLGdCQUFnQjtJQUFZQyxhQUFhO0lBQXNCQyxrQkFBa0I7SUFBbUJDLHlCQUF5QjtJQUFZQyxpQkFBaUI7QUFBTTtBQUMzTSxJQUFJRSxpQkFBaUI7SUFBQ1AsV0FBVztJQUFRQyxnQkFBZ0I7SUFBWUMsYUFBYTtJQUFTQyxrQkFBa0I7SUFBbUJDLHlCQUF5QjtJQUFVQyxpQkFBaUI7QUFBUTtBQUU1TDs7Ozs7OztDQU9DLEdBQ0QsU0FBU1osaUJBQWlCZSxJQUFJLEVBQUVDLE9BQU87SUFFbkMsSUFBSSxDQUFDWixLQUFLYSxRQUFRLENBQUNGLE9BQ2YsTUFBTUcsVUFBVTtJQUVwQixJQUFJRixXQUFXLENBQUNaLEtBQUtlLFFBQVEsQ0FBQ0gsVUFDMUIsTUFBTUUsVUFBVTtJQUVwQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNGLE9BQU8sR0FBR0EsU0FBUyxTQUFTO0lBRWpDOzs7S0FHQyxHQUNELElBQUksQ0FBQ0ksYUFBYSxHQUFHO0lBRXJCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0wsSUFBSSxHQUFHQTtJQUVaOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNNLFFBQVEs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SUFFQSxPQUFPLElBQUk7QUFDZjtBQUVBOzs7OztDQUtDLEdBQ0QzRSxpQkFBaUIrQixTQUFTLENBQUM2QyxVQUFVLEdBQUcsU0FBU0EsV0FBVzVELE9BQU8sRUFBRWdELFFBQVE7SUFDekUsSUFBSWhELFNBQ0EsSUFBSyxJQUFJNkQsT0FBT2hELE9BQU9nRCxJQUFJLENBQUM3RCxVQUFVOEQsSUFBSSxHQUFHQSxJQUFJRCxLQUFLRSxNQUFNLEVBQUUsRUFBRUQsRUFDNUQsSUFBSSxDQUFDaEIsU0FBUyxDQUFDZSxJQUFJLENBQUNDLEVBQUUsRUFBRTlELE9BQU8sQ0FBQzZELElBQUksQ0FBQ0MsRUFBRSxDQUFDLEVBQUVkO0lBQ2xELE9BQU8sSUFBSTtBQUNmO0FBRUE7OztDQUdDLEdBQ0RoRSxpQkFBaUIrQixTQUFTLENBQUNpRCxRQUFRLEdBQUcsU0FBU0E7SUFDM0MsSUFBSS9FLFlBQVksSUFBSSxDQUFDZ0YsV0FBVyxDQUFDaEYsU0FBUyxFQUN0Q2tDLFdBQVksSUFBSSxDQUFDQSxRQUFRO0lBQzdCLElBQUlBLFNBQVM0QyxNQUFNLEVBQ2YsT0FBTzlFLFlBQVksTUFBTWtDO0lBQzdCLE9BQU9sQztBQUNYO0FBRUE7OztDQUdDLEdBQ0RELGlCQUFpQitCLFNBQVMsQ0FBQ21ELGNBQWMsR0FBRyxTQUFTQTtJQUNqRCxJQUFJLENBQUMsSUFBSSxDQUFDN0QsUUFBUSxJQUFJLElBQUksQ0FBQ0EsUUFBUSxLQUFLLFVBQVU7UUFDOUMscUVBQXFFO1FBQ3JFLHdCQUF3QjtRQUN4QixPQUFPd0M7SUFDWDtJQUNBLE9BQU8sSUFBSSxDQUFDeEMsUUFBUTtBQUN4QjtBQUVBLHNEQUFzRDtBQUN0RHJCLGlCQUFpQm1GLFVBQVUsR0FBRyxTQUFTQyxLQUFLO0lBQ3hDL0UsT0FBTytFO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvb2JqZWN0LmpzP2Y0YjMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFJlZmxlY3Rpb25PYmplY3Q7XG5cblJlZmxlY3Rpb25PYmplY3QuY2xhc3NOYW1lID0gXCJSZWZsZWN0aW9uT2JqZWN0XCI7XG5cbmNvbnN0IE9uZU9mID0gcmVxdWlyZShcIi4vb25lb2ZcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBSb290OyAvLyBjeWNsaWNcblxuLyogZXNsaW50LWRpc2FibGUgbm8td2FybmluZy1jb21tZW50cyAqL1xuLy8gVE9ETzogUmVwbGFjZSB3aXRoIGVtYmVkZGVkIHByb3RvLlxudmFyIGVkaXRpb25zMjAyM0RlZmF1bHRzID0ge2VudW1fdHlwZTogXCJPUEVOXCIsIGZpZWxkX3ByZXNlbmNlOiBcIkVYUExJQ0lUXCIsIGpzb25fZm9ybWF0OiBcIkFMTE9XXCIsIG1lc3NhZ2VfZW5jb2Rpbmc6IFwiTEVOR1RIX1BSRUZJWEVEXCIsIHJlcGVhdGVkX2ZpZWxkX2VuY29kaW5nOiBcIlBBQ0tFRFwiLCB1dGY4X3ZhbGlkYXRpb246IFwiVkVSSUZZXCJ9O1xudmFyIHByb3RvMkRlZmF1bHRzID0ge2VudW1fdHlwZTogXCJDTE9TRURcIiwgZmllbGRfcHJlc2VuY2U6IFwiRVhQTElDSVRcIiwganNvbl9mb3JtYXQ6IFwiTEVHQUNZX0JFU1RfRUZGT1JUXCIsIG1lc3NhZ2VfZW5jb2Rpbmc6IFwiTEVOR1RIX1BSRUZJWEVEXCIsIHJlcGVhdGVkX2ZpZWxkX2VuY29kaW5nOiBcIkVYUEFOREVEXCIsIHV0ZjhfdmFsaWRhdGlvbjogXCJOT05FXCJ9O1xudmFyIHByb3RvM0RlZmF1bHRzID0ge2VudW1fdHlwZTogXCJPUEVOXCIsIGZpZWxkX3ByZXNlbmNlOiBcIklNUExJQ0lUXCIsIGpzb25fZm9ybWF0OiBcIkFMTE9XXCIsIG1lc3NhZ2VfZW5jb2Rpbmc6IFwiTEVOR1RIX1BSRUZJWEVEXCIsIHJlcGVhdGVkX2ZpZWxkX2VuY29kaW5nOiBcIlBBQ0tFRFwiLCB1dGY4X3ZhbGlkYXRpb246IFwiVkVSSUZZXCJ9O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVmbGVjdGlvbiBvYmplY3QgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEJhc2UgY2xhc3Mgb2YgYWxsIHJlZmxlY3Rpb24gb2JqZWN0cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT2JqZWN0IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBEZWNsYXJlZCBvcHRpb25zXG4gKiBAYWJzdHJhY3RcbiAqL1xuZnVuY3Rpb24gUmVmbGVjdGlvbk9iamVjdChuYW1lLCBvcHRpb25zKSB7XG5cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcobmFtZSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcIm5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICAgIGlmIChvcHRpb25zICYmICF1dGlsLmlzT2JqZWN0KG9wdGlvbnMpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuXG4gICAgLyoqXG4gICAgICogT3B0aW9ucy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsKj58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogUGFyc2VkIE9wdGlvbnMuXG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3QuPHN0cmluZywqPj58dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHRoaXMucGFyc2VkT3B0aW9ucyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBVbmlxdWUgbmFtZSB3aXRoaW4gaXRzIG5hbWVzcGFjZS5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWRpdGlvbiBzcGVjaWZpZWQgZm9yIHRoaXMgb2JqZWN0LiAgT25seSByZWxldmFudCBmb3IgdG9wLWxldmVsIG9iamVjdHMuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2VkaXRpb24gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZWRpdGlvbiB0byB1c2UgZm9yIHRoaXMgb2JqZWN0IGlmIG5vbmUgaXMgc3BlY2lmaWVkLiAgRm9yIGxlZ2FjeSByZWFzb25zLFxuICAgICAqIHRoaXMgaXMgcHJvdG8yIGV4Y2VwdCBpbiB0aGUgSlNPTiBwYXJzaW5nIGNhc2Ugd2hlcmUgaXQgd2FzIHByb3RvMy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGVmYXVsdEVkaXRpb24gPSBcInByb3RvMlwiO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgRmVhdHVyZXMuXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZlYXR1cmVzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCBmZWF0dXJlcyBoYXZlIGJlZW4gcmVzb2x2ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9mZWF0dXJlc1Jlc29sdmVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBQYXJlbnQgbmFtZXNwYWNlLlxuICAgICAqIEB0eXBlIHtOYW1lc3BhY2V8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIGFscmVhZHkgcmVzb2x2ZWQgb3Igbm90LlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgdGV4dCwgaWYgYW55LlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNvbW1lbnQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5pbmcgZmlsZSBuYW1lLlxuICAgICAqIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmZpbGVuYW1lID0gbnVsbDtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgcm9vdCBuYW1lc3BhY2UuXG4gICAgICogQG5hbWUgUmVmbGVjdGlvbk9iamVjdCNyb290XG4gICAgICogQHR5cGUge1Jvb3R9XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgcm9vdDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHB0ciA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAocHRyLnBhcmVudCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xuICAgICAgICAgICAgcmV0dXJuIHB0cjtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGdWxsIG5hbWUgaW5jbHVkaW5nIGxlYWRpbmcgZG90LlxuICAgICAqIEBuYW1lIFJlZmxlY3Rpb25PYmplY3QjZnVsbE5hbWVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEByZWFkb25seVxuICAgICAqL1xuICAgIGZ1bGxOYW1lOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IFsgdGhpcy5uYW1lIF0sXG4gICAgICAgICAgICAgICAgcHRyID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAocHRyKSB7XG4gICAgICAgICAgICAgICAgcGF0aC51bnNoaWZ0KHB0ci5uYW1lKTtcbiAgICAgICAgICAgICAgICBwdHIgPSBwdHIucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGguam9pbihcIi5cIik7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIHJlZmxlY3Rpb24gb2JqZWN0IHRvIGl0cyBkZXNjcmlwdG9yIHJlcHJlc2VudGF0aW9uLlxuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBEZXNjcmlwdG9yXG4gKiBAYWJzdHJhY3RcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUudG9KU09OID0gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHRocm93IEVycm9yKCk7IC8vIG5vdCBpbXBsZW1lbnRlZCwgc2hvdWxkbid0IGhhcHBlblxufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGlzIG9iamVjdCBpcyBhZGRlZCB0byBhIHBhcmVudC5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gcGFyZW50IFBhcmVudCBhZGRlZCB0b1xuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiBvbkFkZChwYXJlbnQpIHtcbiAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQgIT09IHBhcmVudClcbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlKHRoaXMpO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB2YXIgcm9vdCA9IHBhcmVudC5yb290O1xuICAgIGlmIChyb290IGluc3RhbmNlb2YgUm9vdClcbiAgICAgICAgcm9vdC5faGFuZGxlQWRkKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiB0aGlzIG9iamVjdCBpcyByZW1vdmVkIGZyb20gYSBwYXJlbnQuXG4gKiBAcGFyYW0ge1JlZmxlY3Rpb25PYmplY3R9IHBhcmVudCBQYXJlbnQgcmVtb3ZlZCBmcm9tXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uIG9uUmVtb3ZlKHBhcmVudCkge1xuICAgIHZhciByb290ID0gcGFyZW50LnJvb3Q7XG4gICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBSb290KVxuICAgICAgICByb290Ll9oYW5kbGVSZW1vdmUodGhpcyk7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgdGhpcyBvYmplY3RzIHR5cGUgcmVmZXJlbmNlcy5cbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gICAgaWYgKHRoaXMucmVzb2x2ZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLnJvb3QgaW5zdGFuY2VvZiBSb290KVxuICAgICAgICB0aGlzLnJlc29sdmVkID0gdHJ1ZTsgLy8gb25seSBpZiBwYXJ0IG9mIGEgcm9vdFxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyB0aGlzIG9iamVjdHMgZWRpdGlvbnMgZmVhdHVyZXMuXG4gKiBAcGFyYW0ge3N0cmluZ30gZWRpdGlvbiBUaGUgZWRpdGlvbiB3ZSdyZSBjdXJyZW50bHkgcmVzb2x2aW5nIGZvci5cbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuX3Jlc29sdmVGZWF0dXJlc1JlY3Vyc2l2ZSA9IGZ1bmN0aW9uIF9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUoZWRpdGlvbikge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlRmVhdHVyZXModGhpcy5fZWRpdGlvbiB8fCBlZGl0aW9uKTtcbn07XG5cbi8qKlxuICogUmVzb2x2ZXMgY2hpbGQgZmVhdHVyZXMgZnJvbSBwYXJlbnQgZmVhdHVyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBlZGl0aW9uIFRoZSBlZGl0aW9uIHdlJ3JlIGN1cnJlbnRseSByZXNvbHZpbmcgZm9yLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuX3Jlc29sdmVGZWF0dXJlcyA9IGZ1bmN0aW9uIF9yZXNvbHZlRmVhdHVyZXMoZWRpdGlvbikge1xuICAgIGlmICh0aGlzLl9mZWF0dXJlc1Jlc29sdmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdHMgPSB7fTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZWRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVkaXRpb24gZm9yIFwiICsgdGhpcy5mdWxsTmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvRmVhdHVyZXMgPSBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sICB0aGlzLm9wdGlvbnMuZmVhdHVyZXMpIDoge30sXG4gICAgICAgIHRoaXMuX2luZmVyTGVnYWN5UHJvdG9GZWF0dXJlcyhlZGl0aW9uKSk7XG5cbiAgICBpZiAodGhpcy5fZWRpdGlvbikge1xuICAgICAgICAvLyBGb3IgYSBuYW1lc3BhY2UgbWFya2VkIHdpdGggYSBzcGVjaWZpYyBlZGl0aW9uLCByZXNldCBkZWZhdWx0cy5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGVkaXRpb24gPT09IFwicHJvdG8yXCIpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvdG8yRGVmYXVsdHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGVkaXRpb24gPT09IFwicHJvdG8zXCIpIHtcbiAgICAgICAgICAgIGRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvdG8zRGVmYXVsdHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGVkaXRpb24gPT09IFwiMjAyM1wiKSB7XG4gICAgICAgICAgICBkZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oe30sIGVkaXRpb25zMjAyM0RlZmF1bHRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZWRpdGlvbjogXCIgKyBlZGl0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mZWF0dXJlcyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMsIHByb3RvRmVhdHVyZXMgfHwge30pO1xuICAgICAgICB0aGlzLl9mZWF0dXJlc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGZpZWxkcyBpbiBPbmVvZnMgYXJlbid0IGFjdHVhbGx5IGNoaWxkcmVuIG9mIHRoZW0sIHNvIHdlIGhhdmUgdG9cbiAgICAvLyBzcGVjaWFsLWNhc2UgaXRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh0aGlzLnBhcnRPZiBpbnN0YW5jZW9mIE9uZU9mKSB7XG4gICAgICAgIHZhciBsZXhpY2FsUGFyZW50RmVhdHVyZXNDb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wYXJ0T2YuX2ZlYXR1cmVzKTtcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSBPYmplY3QuYXNzaWduKGxleGljYWxQYXJlbnRGZWF0dXJlc0NvcHksIHByb3RvRmVhdHVyZXMgfHwge30pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5kZWNsYXJpbmdGaWVsZCkge1xuICAgICAgICAvLyBTa2lwIGZlYXR1cmUgcmVzb2x1dGlvbiBvZiBzaXN0ZXIgZmllbGRzLlxuICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgdmFyIHBhcmVudEZlYXR1cmVzQ29weSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucGFyZW50Ll9mZWF0dXJlcyk7XG4gICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gT2JqZWN0LmFzc2lnbihwYXJlbnRGZWF0dXJlc0NvcHksIHByb3RvRmVhdHVyZXMgfHwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGEgcGFyZW50IGZvciBcIiArIHRoaXMuZnVsbE5hbWUpO1xuICAgIH1cbiAgICBpZiAodGhpcy5leHRlbnNpb25GaWVsZCkge1xuICAgICAgICAvLyBTaXN0ZXIgZmllbGRzIHNob3VsZCBoYXZlIHRoZSBzYW1lIGZlYXR1cmVzIGFzIHRoZWlyIGV4dGVuc2lvbnMuXG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uRmllbGQuX2ZlYXR1cmVzID0gdGhpcy5fZmVhdHVyZXM7XG4gICAgfVxuICAgIHRoaXMuX2ZlYXR1cmVzUmVzb2x2ZWQgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBJbmZlcnMgZmVhdHVyZXMgZnJvbSBsZWdhY3kgc3ludGF4IHRoYXQgbWF5IGhhdmUgYmVlbiBzcGVjaWZpZWQgZGlmZmVyZW50bHkuXG4gKiBpbiBvbGRlciBlZGl0aW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gZWRpdGlvbiBUaGUgZWRpdGlvbiB0aGlzIHByb3RvIGlzIG9uLCBvciB1bmRlZmluZWQgaWYgcHJlLWVkaXRpb25zXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgZmVhdHVyZSB2YWx1ZXMgdG8gb3ZlcnJpZGVcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuX2luZmVyTGVnYWN5UHJvdG9GZWF0dXJlcyA9IGZ1bmN0aW9uIF9pbmZlckxlZ2FjeVByb3RvRmVhdHVyZXMoLyplZGl0aW9uKi8pIHtcbiAgICByZXR1cm4ge307XG59O1xuXG4vKipcbiAqIEdldHMgYW4gb3B0aW9uIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgT3B0aW9uIG5hbWVcbiAqIEByZXR1cm5zIHsqfSBPcHRpb24gdmFsdWUgb3IgYHVuZGVmaW5lZGAgaWYgbm90IHNldFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5nZXRPcHRpb24gPSBmdW5jdGlvbiBnZXRPcHRpb24obmFtZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMpXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnNbbmFtZV07XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBvcHRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBPcHRpb24gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBPcHRpb24gdmFsdWVcbiAqIEBwYXJhbSB7Ym9vbGVhbnx1bmRlZmluZWR9IFtpZk5vdFNldF0gU2V0cyB0aGUgb3B0aW9uIG9ubHkgaWYgaXQgaXNuJ3QgY3VycmVudGx5IHNldFxuICogQHJldHVybnMge1JlZmxlY3Rpb25PYmplY3R9IGB0aGlzYFxuICovXG5SZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5zZXRPcHRpb24gPSBmdW5jdGlvbiBzZXRPcHRpb24obmFtZSwgdmFsdWUsIGlmTm90U2V0KSB7XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMpXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIGlmICgvXmZlYXR1cmVzXFwuLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHV0aWwuc2V0UHJvcGVydHkodGhpcy5vcHRpb25zLCBuYW1lLCB2YWx1ZSwgaWZOb3RTZXQpO1xuICAgIH0gZWxzZSBpZiAoIWlmTm90U2V0IHx8IHRoaXMub3B0aW9uc1tuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0aGlzLmdldE9wdGlvbihuYW1lKSAhPT0gdmFsdWUpIHRoaXMucmVzb2x2ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zW25hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgYSBwYXJzZWQgb3B0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgcGFyc2VkIE9wdGlvbiBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlIE9wdGlvbiB2YWx1ZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BOYW1lIGRvdCAnLicgZGVsaW1pdGVkIGZ1bGwgcGF0aCBvZiBwcm9wZXJ0eSB3aXRoaW4gdGhlIG9wdGlvbiB0byBzZXQuIGlmIHVuZGVmaW5lZFxcZW1wdHksIHdpbGwgYWRkIGEgbmV3IG9wdGlvbiB3aXRoIHRoYXQgdmFsdWVcbiAqIEByZXR1cm5zIHtSZWZsZWN0aW9uT2JqZWN0fSBgdGhpc2BcbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0UGFyc2VkT3B0aW9uID0gZnVuY3Rpb24gc2V0UGFyc2VkT3B0aW9uKG5hbWUsIHZhbHVlLCBwcm9wTmFtZSkge1xuICAgIGlmICghdGhpcy5wYXJzZWRPcHRpb25zKSB7XG4gICAgICAgIHRoaXMucGFyc2VkT3B0aW9ucyA9IFtdO1xuICAgIH1cbiAgICB2YXIgcGFyc2VkT3B0aW9ucyA9IHRoaXMucGFyc2VkT3B0aW9ucztcbiAgICBpZiAocHJvcE5hbWUpIHtcbiAgICAgICAgLy8gSWYgc2V0dGluZyBhIHN1YiBwcm9wZXJ0eSBvZiBhbiBvcHRpb24gdGhlbiB0cnkgdG8gbWVyZ2UgaXRcbiAgICAgICAgLy8gd2l0aCBhbiBleGlzdGluZyBvcHRpb25cbiAgICAgICAgdmFyIG9wdCA9IHBhcnNlZE9wdGlvbnMuZmluZChmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdCwgbmFtZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob3B0KSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmb3VuZCBhbiBleGlzdGluZyBvcHRpb24gLSBqdXN0IG1lcmdlIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgICAgLy8gKElmIGl0J3MgYSBmZWF0dXJlLCB3aWxsIGp1c3Qgd3JpdGUgb3ZlcilcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IG9wdFtuYW1lXTtcbiAgICAgICAgICAgIHV0aWwuc2V0UHJvcGVydHkobmV3VmFsdWUsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIGNyZWF0ZSBhIG5ldyBvcHRpb24sIHNldCBpdHMgcHJvcGVydHkgYW5kIGFkZCBpdCB0byB0aGUgbGlzdFxuICAgICAgICAgICAgb3B0ID0ge307XG4gICAgICAgICAgICBvcHRbbmFtZV0gPSB1dGlsLnNldFByb3BlcnR5KHt9LCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgcGFyc2VkT3B0aW9ucy5wdXNoKG9wdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbHdheXMgY3JlYXRlIGEgbmV3IG9wdGlvbiB3aGVuIHNldHRpbmcgdGhlIHZhbHVlIG9mIHRoZSBvcHRpb24gaXRzZWxmXG4gICAgICAgIHZhciBuZXdPcHQgPSB7fTtcbiAgICAgICAgbmV3T3B0W25hbWVdID0gdmFsdWU7XG4gICAgICAgIHBhcnNlZE9wdGlvbnMucHVzaChuZXdPcHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIG11bHRpcGxlIG9wdGlvbnMuXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCo+fSBvcHRpb25zIE9wdGlvbnMgdG8gc2V0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldF0gU2V0cyBhbiBvcHRpb24gb25seSBpZiBpdCBpc24ndCBjdXJyZW50bHkgc2V0XG4gKiBAcmV0dXJucyB7UmVmbGVjdGlvbk9iamVjdH0gYHRoaXNgXG4gKi9cblJlZmxlY3Rpb25PYmplY3QucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMsIGlmTm90U2V0KSB7XG4gICAgaWYgKG9wdGlvbnMpXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdGhpcy5zZXRPcHRpb24oa2V5c1tpXSwgb3B0aW9uc1trZXlzW2ldXSwgaWZOb3RTZXQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIGluc3RhbmNlIHRvIGl0cyBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDbGFzcyBuYW1lWywgc3BhY2UsIGZ1bGwgbmFtZV1cbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5jbGFzc05hbWUsXG4gICAgICAgIGZ1bGxOYW1lICA9IHRoaXMuZnVsbE5hbWU7XG4gICAgaWYgKGZ1bGxOYW1lLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZSArIFwiIFwiICsgZnVsbE5hbWU7XG4gICAgcmV0dXJuIGNsYXNzTmFtZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGVkaXRpb24gdGhpcyBvYmplY3QgaXMgcGlubmVkIHRvIGZvciBKU09OIGZvcm1hdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBUaGUgZWRpdGlvbiBzdHJpbmcgZm9yIEpTT04gcmVwcmVzZW50YXRpb25cbiAqL1xuUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuX2VkaXRpb25Ub0pTT04gPSBmdW5jdGlvbiBfZWRpdGlvblRvSlNPTigpIHtcbiAgICBpZiAoIXRoaXMuX2VkaXRpb24gfHwgdGhpcy5fZWRpdGlvbiA9PT0gXCJwcm90bzNcIikge1xuICAgICAgICAvLyBBdm9pZCBlbWl0dGluZyBwcm90bzMgc2luY2Ugd2UgbmVlZCB0byBkZWZhdWx0IHRvIGl0IGZvciBiYWNrd2FyZHNcbiAgICAgICAgLy8gY29tcGF0aWJpbGl0eSBhbnl3YXkuXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lZGl0aW9uO1xufTtcblxuLy8gU2V0cyB1cCBjeWNsaWMgZGVwZW5kZW5jaWVzIChjYWxsZWQgaW4gaW5kZXgtbGlnaHQpXG5SZWZsZWN0aW9uT2JqZWN0Ll9jb25maWd1cmUgPSBmdW5jdGlvbihSb290Xykge1xuICAgIFJvb3QgPSBSb290Xztcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlJlZmxlY3Rpb25PYmplY3QiLCJjbGFzc05hbWUiLCJPbmVPZiIsInJlcXVpcmUiLCJ1dGlsIiwiUm9vdCIsImVkaXRpb25zMjAyM0RlZmF1bHRzIiwiZW51bV90eXBlIiwiZmllbGRfcHJlc2VuY2UiLCJqc29uX2Zvcm1hdCIsIm1lc3NhZ2VfZW5jb2RpbmciLCJyZXBlYXRlZF9maWVsZF9lbmNvZGluZyIsInV0ZjhfdmFsaWRhdGlvbiIsInByb3RvMkRlZmF1bHRzIiwicHJvdG8zRGVmYXVsdHMiLCJuYW1lIiwib3B0aW9ucyIsImlzU3RyaW5nIiwiVHlwZUVycm9yIiwiaXNPYmplY3QiLCJwYXJzZWRPcHRpb25zIiwiX2VkaXRpb24iLCJfZGVmYXVsdEVkaXRpb24iLCJfZmVhdHVyZXMiLCJfZmVhdHVyZXNSZXNvbHZlZCIsInBhcmVudCIsInJlc29sdmVkIiwiY29tbWVudCIsImZpbGVuYW1lIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsInByb3RvdHlwZSIsInJvb3QiLCJnZXQiLCJwdHIiLCJmdWxsTmFtZSIsInBhdGgiLCJ1bnNoaWZ0Iiwiam9pbiIsInRvSlNPTiIsIkVycm9yIiwib25BZGQiLCJyZW1vdmUiLCJfaGFuZGxlQWRkIiwib25SZW1vdmUiLCJfaGFuZGxlUmVtb3ZlIiwicmVzb2x2ZSIsIl9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUiLCJlZGl0aW9uIiwiX3Jlc29sdmVGZWF0dXJlcyIsImRlZmF1bHRzIiwicHJvdG9GZWF0dXJlcyIsImFzc2lnbiIsImZlYXR1cmVzIiwiX2luZmVyTGVnYWN5UHJvdG9GZWF0dXJlcyIsInBhcnRPZiIsImxleGljYWxQYXJlbnRGZWF0dXJlc0NvcHkiLCJkZWNsYXJpbmdGaWVsZCIsInBhcmVudEZlYXR1cmVzQ29weSIsImV4dGVuc2lvbkZpZWxkIiwiZ2V0T3B0aW9uIiwidW5kZWZpbmVkIiwic2V0T3B0aW9uIiwidmFsdWUiLCJpZk5vdFNldCIsInRlc3QiLCJzZXRQcm9wZXJ0eSIsInNldFBhcnNlZE9wdGlvbiIsInByb3BOYW1lIiwib3B0IiwiZmluZCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsIm5ld1ZhbHVlIiwicHVzaCIsIm5ld09wdCIsInNldE9wdGlvbnMiLCJrZXlzIiwiaSIsImxlbmd0aCIsInRvU3RyaW5nIiwiY29uc3RydWN0b3IiLCJfZWRpdGlvblRvSlNPTiIsIl9jb25maWd1cmUiLCJSb290XyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = OneOf;\n// extends ReflectionObject\nvar ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\");\n((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = \"OneOf\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\n/**\n * Constructs a new oneof instance.\n * @classdesc Reflected oneof.\n * @extends ReflectionObject\n * @constructor\n * @param {string} name Oneof name\n * @param {string[]|Object.<string,*>} [fieldNames] Field names\n * @param {Object.<string,*>} [options] Declared options\n * @param {string} [comment] Comment associated with this field\n */ function OneOf(name, fieldNames, options, comment) {\n    if (!Array.isArray(fieldNames)) {\n        options = fieldNames;\n        fieldNames = undefined;\n    }\n    ReflectionObject.call(this, name, options);\n    /* istanbul ignore if */ if (!(fieldNames === undefined || Array.isArray(fieldNames))) throw TypeError(\"fieldNames must be an Array\");\n    /**\n     * Field names that belong to this oneof.\n     * @type {string[]}\n     */ this.oneof = fieldNames || []; // toJSON, marker\n    /**\n     * Fields that belong to this oneof as an array for iteration.\n     * @type {Field[]}\n     * @readonly\n     */ this.fieldsArray = []; // declared readonly for conformance, possibly not yet added to parent\n    /**\n     * Comment for this field.\n     * @type {string|null}\n     */ this.comment = comment;\n}\n/**\n * Oneof descriptor.\n * @interface IOneOf\n * @property {Array.<string>} oneof Oneof field names\n * @property {Object.<string,*>} [options] Oneof options\n */ /**\n * Constructs a oneof from a oneof descriptor.\n * @param {string} name Oneof name\n * @param {IOneOf} json Oneof descriptor\n * @returns {OneOf} Created oneof\n * @throws {TypeError} If arguments are invalid\n */ OneOf.fromJSON = function fromJSON(name, json) {\n    return new OneOf(name, json.oneof, json.options, json.comment);\n};\n/**\n * Converts this oneof to a oneof descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IOneOf} Oneof descriptor\n */ OneOf.prototype.toJSON = function toJSON(toJSONOptions) {\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"options\",\n        this.options,\n        \"oneof\",\n        this.oneof,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Adds the fields of the specified oneof to the parent if not already done so.\n * @param {OneOf} oneof The oneof\n * @returns {undefined}\n * @inner\n * @ignore\n */ function addFieldsToParent(oneof) {\n    if (oneof.parent) {\n        for(var i = 0; i < oneof.fieldsArray.length; ++i)if (!oneof.fieldsArray[i].parent) oneof.parent.add(oneof.fieldsArray[i]);\n    }\n}\n/**\n * Adds a field to this oneof and removes it from its current parent, if any.\n * @param {Field} field Field to add\n * @returns {OneOf} `this`\n */ OneOf.prototype.add = function add(field) {\n    /* istanbul ignore if */ if (!(field instanceof Field)) throw TypeError(\"field must be a Field\");\n    if (field.parent && field.parent !== this.parent) field.parent.remove(field);\n    this.oneof.push(field.name);\n    this.fieldsArray.push(field);\n    field.partOf = this; // field.parent remains null\n    addFieldsToParent(this);\n    return this;\n};\n/**\n * Removes a field from this oneof and puts it back to the oneof's parent.\n * @param {Field} field Field to remove\n * @returns {OneOf} `this`\n */ OneOf.prototype.remove = function remove(field) {\n    /* istanbul ignore if */ if (!(field instanceof Field)) throw TypeError(\"field must be a Field\");\n    var index = this.fieldsArray.indexOf(field);\n    /* istanbul ignore if */ if (index < 0) throw Error(field + \" is not a member of \" + this);\n    this.fieldsArray.splice(index, 1);\n    index = this.oneof.indexOf(field.name);\n    /* istanbul ignore else */ if (index > -1) this.oneof.splice(index, 1);\n    field.partOf = null;\n    return this;\n};\n/**\n * @override\n */ OneOf.prototype.onAdd = function onAdd(parent) {\n    ReflectionObject.prototype.onAdd.call(this, parent);\n    var self = this;\n    // Collect present fields\n    for(var i = 0; i < this.oneof.length; ++i){\n        var field = parent.get(this.oneof[i]);\n        if (field && !field.partOf) {\n            field.partOf = self;\n            self.fieldsArray.push(field);\n        }\n    }\n    // Add not yet present fields\n    addFieldsToParent(this);\n};\n/**\n * @override\n */ OneOf.prototype.onRemove = function onRemove(parent) {\n    for(var i = 0, field; i < this.fieldsArray.length; ++i)if ((field = this.fieldsArray[i]).parent) field.parent.remove(field);\n    ReflectionObject.prototype.onRemove.call(this, parent);\n};\n/**\n * Determines whether this field corresponds to a synthetic oneof created for\n * a proto3 optional field.  No behavioral logic should depend on this, but it\n * can be relevant for reflection.\n * @name OneOf#isProto3Optional\n * @type {boolean}\n * @readonly\n */ Object.defineProperty(OneOf.prototype, \"isProto3Optional\", {\n    get: function() {\n        if (this.fieldsArray == null || this.fieldsArray.length !== 1) {\n            return false;\n        }\n        var field = this.fieldsArray[0];\n        return field.options != null && field.options[\"proto3_optional\"] === true;\n    }\n});\n/**\n * Decorator function as returned by {@link OneOf.d} (TypeScript).\n * @typedef OneOfDecorator\n * @type {function}\n * @param {Object} prototype Target prototype\n * @param {string} oneofName OneOf name\n * @returns {undefined}\n */ /**\n * OneOf decorator (TypeScript).\n * @function\n * @param {...string} fieldNames Field names\n * @returns {OneOfDecorator} Decorator function\n * @template T extends string\n */ OneOf.d = function decorateOneOf() {\n    var fieldNames = new Array(arguments.length), index = 0;\n    while(index < arguments.length)fieldNames[index] = arguments[index++];\n    return function oneOfDecorator(prototype, oneofName) {\n        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));\n        Object.defineProperty(prototype, oneofName, {\n            get: util.oneOfGetter(fieldNames),\n            set: util.oneOfSetter(fieldNames)\n        });\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvb25lb2YuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQiwyQkFBMkI7QUFDM0IsSUFBSUMsbUJBQW1CQyxtQkFBT0EsQ0FBQywwRkFBVTtBQUN4QyxFQUFDRixNQUFNRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osaUJBQWlCRSxTQUFTLEdBQUdHLFdBQVcsR0FBR04sS0FBSSxFQUFHTyxTQUFTLEdBQUc7QUFFaEcsSUFBSUMsUUFBUU4sbUJBQU9BLENBQUMsd0ZBQVMsR0FDekJPLE9BQVFQLG1CQUFPQSxDQUFDLHNGQUFRO0FBRTVCOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNGLE1BQU1VLElBQUksRUFBRUMsVUFBVSxFQUFFQyxPQUFPLEVBQUVDLE9BQU87SUFDN0MsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNKLGFBQWE7UUFDNUJDLFVBQVVEO1FBQ1ZBLGFBQWFLO0lBQ2pCO0lBQ0FmLGlCQUFpQmdCLElBQUksQ0FBQyxJQUFJLEVBQUVQLE1BQU1FO0lBRWxDLHNCQUFzQixHQUN0QixJQUFJLENBQUVELENBQUFBLGVBQWVLLGFBQWFGLE1BQU1DLE9BQU8sQ0FBQ0osV0FBVSxHQUN0RCxNQUFNTyxVQUFVO0lBRXBCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsS0FBSyxHQUFHUixjQUFjLEVBQUUsRUFBRSxpQkFBaUI7SUFFaEQ7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ1MsV0FBVyxHQUFHLEVBQUUsRUFBRSxzRUFBc0U7SUFFN0Y7OztLQUdDLEdBQ0QsSUFBSSxDQUFDUCxPQUFPLEdBQUdBO0FBQ25CO0FBRUE7Ozs7O0NBS0MsR0FFRDs7Ozs7O0NBTUMsR0FDRGIsTUFBTXFCLFFBQVEsR0FBRyxTQUFTQSxTQUFTWCxJQUFJLEVBQUVZLElBQUk7SUFDekMsT0FBTyxJQUFJdEIsTUFBTVUsTUFBTVksS0FB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WSxDQUFDaEQsVUFBVUcsV0FBVyxFQUNsQzBCLEdBQUcsQ0FBQyxJQUFJaEMsTUFBTWtELFdBQVd2QztRQUM5QlAsT0FBT3lDLGNBQWMsQ0FBQzFDLFdBQVcrQyxXQUFXO1lBQ3hDUCxLQUFLbEMsS0FBSzJDLFdBQVcsQ0FBQ3pDO1lBQ3RCMEMsS0FBSzVDLEtBQUs2QyxXQUFXLENBQUMzQztRQUMxQjtJQUNKO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvb25lb2YuanM/MTBhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gT25lT2Y7XG5cbi8vIGV4dGVuZHMgUmVmbGVjdGlvbk9iamVjdFxudmFyIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIik7XG4oKE9uZU9mLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUpKS5jb25zdHJ1Y3RvciA9IE9uZU9mKS5jbGFzc05hbWUgPSBcIk9uZU9mXCI7XG5cbnZhciBGaWVsZCA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIHV0aWwgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IG9uZW9mIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBSZWZsZWN0ZWQgb25lb2YuXG4gKiBAZXh0ZW5kcyBSZWZsZWN0aW9uT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9uZW9mIG5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nW118T2JqZWN0LjxzdHJpbmcsKj59IFtmaWVsZE5hbWVzXSBGaWVsZCBuYW1lc1xuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29tbWVudF0gQ29tbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWVsZFxuICovXG5mdW5jdGlvbiBPbmVPZihuYW1lLCBmaWVsZE5hbWVzLCBvcHRpb25zLCBjb21tZW50KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZpZWxkTmFtZXMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBmaWVsZE5hbWVzO1xuICAgICAgICBmaWVsZE5hbWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBSZWZsZWN0aW9uT2JqZWN0LmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIShmaWVsZE5hbWVzID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShmaWVsZE5hbWVzKSkpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcImZpZWxkTmFtZXMgbXVzdCBiZSBhbiBBcnJheVwiKTtcblxuICAgIC8qKlxuICAgICAqIEZpZWxkIG5hbWVzIHRoYXQgYmVsb25nIHRvIHRoaXMgb25lb2YuXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRoaXMub25lb2YgPSBmaWVsZE5hbWVzIHx8IFtdOyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogRmllbGRzIHRoYXQgYmVsb25nIHRvIHRoaXMgb25lb2YgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7RmllbGRbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICB0aGlzLmZpZWxkc0FycmF5ID0gW107IC8vIGRlY2xhcmVkIHJlYWRvbmx5IGZvciBjb25mb3JtYW5jZSwgcG9zc2libHkgbm90IHlldCBhZGRlZCB0byBwYXJlbnRcblxuICAgIC8qKlxuICAgICAqIENvbW1lbnQgZm9yIHRoaXMgZmllbGQuXG4gICAgICogQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAqL1xuICAgIHRoaXMuY29tbWVudCA9IGNvbW1lbnQ7XG59XG5cbi8qKlxuICogT25lb2YgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSU9uZU9mXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBvbmVvZiBPbmVvZiBmaWVsZCBuYW1lc1xuICogQHByb3BlcnR5IHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIE9uZW9mIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBvbmVvZiBmcm9tIGEgb25lb2YgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE9uZW9mIG5hbWVcbiAqIEBwYXJhbSB7SU9uZU9mfSBqc29uIE9uZW9mIGRlc2NyaXB0b3JcbiAqIEByZXR1cm5zIHtPbmVPZn0gQ3JlYXRlZCBvbmVvZlxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuT25lT2YuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBPbmVPZihuYW1lLCBqc29uLm9uZW9mLCBqc29uLm9wdGlvbnMsIGpzb24uY29tbWVudCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgb25lb2YgdG8gYSBvbmVvZiBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtJVG9KU09OT3B0aW9uc30gW3RvSlNPTk9wdGlvbnNdIEpTT04gY29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7SU9uZU9mfSBPbmVvZiBkZXNjcmlwdG9yXG4gKi9cbk9uZU9mLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04odG9KU09OT3B0aW9ucykge1xuICAgIHZhciBrZWVwQ29tbWVudHMgPSB0b0pTT05PcHRpb25zID8gQm9vbGVhbih0b0pTT05PcHRpb25zLmtlZXBDb21tZW50cykgOiBmYWxzZTtcbiAgICByZXR1cm4gdXRpbC50b09iamVjdChbXG4gICAgICAgIFwib3B0aW9uc1wiICwgdGhpcy5vcHRpb25zLFxuICAgICAgICBcIm9uZW9mXCIgICAsIHRoaXMub25lb2YsXG4gICAgICAgIFwiY29tbWVudFwiICwga2VlcENvbW1lbnRzID8gdGhpcy5jb21tZW50IDogdW5kZWZpbmVkXG4gICAgXSk7XG59O1xuXG4vKipcbiAqIEFkZHMgdGhlIGZpZWxkcyBvZiB0aGUgc3BlY2lmaWVkIG9uZW9mIHRvIHRoZSBwYXJlbnQgaWYgbm90IGFscmVhZHkgZG9uZSBzby5cbiAqIEBwYXJhbSB7T25lT2Z9IG9uZW9mIFRoZSBvbmVvZlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBpbm5lclxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBhZGRGaWVsZHNUb1BhcmVudChvbmVvZikge1xuICAgIGlmIChvbmVvZi5wYXJlbnQpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb25lb2YuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAoIW9uZW9mLmZpZWxkc0FycmF5W2ldLnBhcmVudClcbiAgICAgICAgICAgICAgICBvbmVvZi5wYXJlbnQuYWRkKG9uZW9mLmZpZWxkc0FycmF5W2ldKTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgZmllbGQgdG8gdGhpcyBvbmVvZiBhbmQgcmVtb3ZlcyBpdCBmcm9tIGl0cyBjdXJyZW50IHBhcmVudCwgaWYgYW55LlxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgRmllbGQgdG8gYWRkXG4gKiBAcmV0dXJucyB7T25lT2Z9IGB0aGlzYFxuICovXG5PbmVPZi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKGZpZWxkKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIShmaWVsZCBpbnN0YW5jZW9mIEZpZWxkKSlcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiZmllbGQgbXVzdCBiZSBhIEZpZWxkXCIpO1xuXG4gICAgaWYgKGZpZWxkLnBhcmVudCAmJiBmaWVsZC5wYXJlbnQgIT09IHRoaXMucGFyZW50KVxuICAgICAgICBmaWVsZC5wYXJlbnQucmVtb3ZlKGZpZWxkKTtcbiAgICB0aGlzLm9uZW9mLnB1c2goZmllbGQubmFtZSk7XG4gICAgdGhpcy5maWVsZHNBcnJheS5wdXNoKGZpZWxkKTtcbiAgICBmaWVsZC5wYXJ0T2YgPSB0aGlzOyAvLyBmaWVsZC5wYXJlbnQgcmVtYWlucyBudWxsXG4gICAgYWRkRmllbGRzVG9QYXJlbnQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBmaWVsZCBmcm9tIHRoaXMgb25lb2YgYW5kIHB1dHMgaXQgYmFjayB0byB0aGUgb25lb2YncyBwYXJlbnQuXG4gKiBAcGFyYW0ge0ZpZWxkfSBmaWVsZCBGaWVsZCB0byByZW1vdmVcbiAqIEByZXR1cm5zIHtPbmVPZn0gYHRoaXNgXG4gKi9cbk9uZU9mLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoZmllbGQpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghKGZpZWxkIGluc3RhbmNlb2YgRmllbGQpKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJmaWVsZCBtdXN0IGJlIGEgRmllbGRcIik7XG5cbiAgICB2YXIgaW5kZXggPSB0aGlzLmZpZWxkc0FycmF5LmluZGV4T2YoZmllbGQpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgdGhyb3cgRXJyb3IoZmllbGQgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgIHRoaXMuZmllbGRzQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpbmRleCA9IHRoaXMub25lb2YuaW5kZXhPZihmaWVsZC5uYW1lKTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGluZGV4ID4gLTEpIC8vIHRoZW9yZXRpY2FsXG4gICAgICAgIHRoaXMub25lb2Yuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgIGZpZWxkLnBhcnRPZiA9IG51bGw7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5PbmVPZi5wcm90b3R5cGUub25BZGQgPSBmdW5jdGlvbiBvbkFkZChwYXJlbnQpIHtcbiAgICBSZWZsZWN0aW9uT2JqZWN0LnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIHBhcmVudCk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIC8vIENvbGxlY3QgcHJlc2VudCBmaWVsZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub25lb2YubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gcGFyZW50LmdldCh0aGlzLm9uZW9mW2ldKTtcbiAgICAgICAgaWYgKGZpZWxkICYmICFmaWVsZC5wYXJ0T2YpIHtcbiAgICAgICAgICAgIGZpZWxkLnBhcnRPZiA9IHNlbGY7XG4gICAgICAgICAgICBzZWxmLmZpZWxkc0FycmF5LnB1c2goZmllbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEFkZCBub3QgeWV0IHByZXNlbnQgZmllbGRzXG4gICAgYWRkRmllbGRzVG9QYXJlbnQodGhpcyk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5PbmVPZi5wcm90b3R5cGUub25SZW1vdmUgPSBmdW5jdGlvbiBvblJlbW92ZShwYXJlbnQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZmllbGQ7IGkgPCB0aGlzLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoKGZpZWxkID0gdGhpcy5maWVsZHNBcnJheVtpXSkucGFyZW50KVxuICAgICAgICAgICAgZmllbGQucGFyZW50LnJlbW92ZShmaWVsZCk7XG4gICAgUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBwYXJlbnQpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBmaWVsZCBjb3JyZXNwb25kcyB0byBhIHN5bnRoZXRpYyBvbmVvZiBjcmVhdGVkIGZvclxuICogYSBwcm90bzMgb3B0aW9uYWwgZmllbGQuICBObyBiZWhhdmlvcmFsIGxvZ2ljIHNob3VsZCBkZXBlbmQgb24gdGhpcywgYnV0IGl0XG4gKiBjYW4gYmUgcmVsZXZhbnQgZm9yIHJlZmxlY3Rpb24uXG4gKiBAbmFtZSBPbmVPZiNpc1Byb3RvM09wdGlvbmFsXG4gKiBAdHlwZSB7Ym9vbGVhbn1cbiAqIEByZWFkb25seVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoT25lT2YucHJvdG90eXBlLCBcImlzUHJvdG8zT3B0aW9uYWxcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZpZWxkc0FycmF5ID09IG51bGwgfHwgdGhpcy5maWVsZHNBcnJheS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzQXJyYXlbMF07XG4gICAgICAgIHJldHVybiBmaWVsZC5vcHRpb25zICE9IG51bGwgJiYgZmllbGQub3B0aW9uc1tcInByb3RvM19vcHRpb25hbFwiXSA9PT0gdHJ1ZTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gYXMgcmV0dXJuZWQgYnkge0BsaW5rIE9uZU9mLmR9IChUeXBlU2NyaXB0KS5cbiAqIEB0eXBlZGVmIE9uZU9mRGVjb3JhdG9yXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRhcmdldCBwcm90b3R5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBvbmVvZk5hbWUgT25lT2YgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIE9uZU9mIGRlY29yYXRvciAoVHlwZVNjcmlwdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7Li4uc3RyaW5nfSBmaWVsZE5hbWVzIEZpZWxkIG5hbWVzXG4gKiBAcmV0dXJucyB7T25lT2ZEZWNvcmF0b3J9IERlY29yYXRvciBmdW5jdGlvblxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBzdHJpbmdcbiAqL1xuT25lT2YuZCA9IGZ1bmN0aW9uIGRlY29yYXRlT25lT2YoKSB7XG4gICAgdmFyIGZpZWxkTmFtZXMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCksXG4gICAgICAgIGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICBmaWVsZE5hbWVzW2luZGV4XSA9IGFyZ3VtZW50c1tpbmRleCsrXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gb25lT2ZEZWNvcmF0b3IocHJvdG90eXBlLCBvbmVvZk5hbWUpIHtcbiAgICAgICAgdXRpbC5kZWNvcmF0ZVR5cGUocHJvdG90eXBlLmNvbnN0cnVjdG9yKVxuICAgICAgICAgICAgLmFkZChuZXcgT25lT2Yob25lb2ZOYW1lLCBmaWVsZE5hbWVzKSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG9uZW9mTmFtZSwge1xuICAgICAgICAgICAgZ2V0OiB1dGlsLm9uZU9mR2V0dGVyKGZpZWxkTmFtZXMpLFxuICAgICAgICAgICAgc2V0OiB1dGlsLm9uZU9mU2V0dGVyKGZpZWxkTmFtZXMpXG4gICAgICAgIH0pO1xuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJPbmVPZiIsIlJlZmxlY3Rpb25PYmplY3QiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJjbGFzc05hbWUiLCJGaWVsZCIsInV0aWwiLCJuYW1lIiwiZmllbGROYW1lcyIsIm9wdGlvbnMiLCJjb21tZW50IiwiQXJyYXkiLCJpc0FycmF5IiwidW5kZWZpbmVkIiwiY2FsbCIsIlR5cGVFcnJvciIsIm9uZW9mIiwiZmllbGRzQXJyYXkiLCJmcm9tSlNPTiIsImpzb24iLCJ0b0pTT04iLCJ0b0pTT05PcHRpb25zIiwia2VlcENvbW1lbnRzIiwiQm9vbGVhbiIsInRvT2JqZWN0IiwiYWRkRmllbGRzVG9QYXJlbnQiLCJwYXJlbnQiLCJpIiwibGVuZ3RoIiwiYWRkIiwiZmllbGQiLCJyZW1vdmUiLCJwdXNoIiwicGFydE9mIiwiaW5kZXgiLCJpbmRleE9mIiwiRXJyb3IiLCJzcGxpY2UiLCJvbkFkZCIsInNlbGYiLCJnZXQiLCJvblJlbW92ZSIsImRlZmluZVByb3BlcnR5IiwiZCIsImRlY29yYXRlT25lT2YiLCJhcmd1bWVudHMiLCJvbmVPZkRlY29yYXRvciIsIm9uZW9mTmFtZSIsImRlY29yYXRlVHlwZSIsIm9uZU9mR2V0dGVyIiwic2V0Iiwib25lT2ZTZXR0ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/parse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/parse.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = parse;\nparse.filename = null;\nparse.defaults = {\n    keepCase: false\n};\nvar tokenize = __webpack_require__(/*! ./tokenize */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/tokenize.js\"), Root = __webpack_require__(/*! ./root */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js\"), Type = __webpack_require__(/*! ./type */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js\"), Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\"), MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\"), Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"), Service = __webpack_require__(/*! ./service */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js\"), Method = __webpack_require__(/*! ./method */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js\"), ReflectionObject = __webpack_require__(/*! ./object */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/object.js\"), types = __webpack_require__(/*! ./types */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\nvar base10Re = /^[1-9][0-9]*$/, base10NegRe = /^-?[1-9][0-9]*$/, base16Re = /^0[x][0-9a-fA-F]+$/, base16NegRe = /^-?0[x][0-9a-fA-F]+$/, base8Re = /^0[0-7]+$/, base8NegRe = /^-?0[0-7]+$/, numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/, nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/, typeRefRe = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;\n/**\n * Result object returned from {@link parse}.\n * @interface IParserResult\n * @property {string|undefined} package Package name, if declared\n * @property {string[]|undefined} imports Imports, if any\n * @property {string[]|undefined} weakImports Weak imports, if any\n * @property {Root} root Populated root instance\n */ /**\n * Options modifying the behavior of {@link parse}.\n * @interface IParseOptions\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\n * @property {boolean} [preferTrailingComment=false] Use trailing comment when both leading comment and trailing comment exist.\n */ /**\n * Options modifying the behavior of JSON serialization.\n * @interface IToJSONOptions\n * @property {boolean} [keepComments=false] Serializes comments.\n */ /**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @param {string} source Source contents\n * @param {Root} root Root to populate\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n */ function parse(source, root, options) {\n    /* eslint-disable callback-return */ if (!(root instanceof Root)) {\n        options = root;\n        root = new Root();\n    }\n    if (!options) options = parse.defaults;\n    var preferTrailingComment = options.preferTrailingComment || false;\n    var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;\n    var head = true, pkg, imports, weakImports, edition = \"proto2\";\n    var ptr = root;\n    var topLevelObjects = [];\n    var topLevelOptions = {};\n    var applyCase = options.keepCase ? function(name) {\n        return name;\n    } : util.camelCase;\n    function resolveFileFeatures() {\n        topLevelObjects.forEach((obj)=>{\n            obj._edition = edition;\n            Object.keys(topLevelOptions).forEach((opt)=>{\n                if (obj.getOption(opt) !== undefined) return;\n                obj.setOption(opt, topLevelOptions[opt], true);\n            });\n        });\n    }\n    /* istanbul ignore next */ function illegal(token, name, insideTryCatch) {\n        var filename = parse.filename;\n        if (!insideTryCatch) parse.filename = null;\n        return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n    }\n    function readString() {\n        var values = [], token;\n        do {\n            /* istanbul ignore if */ if ((token = next()) !== '\"' && token !== \"'\") throw illegal(token);\n            values.push(next());\n            skip(token);\n            token = peek();\n        }while (token === '\"' || token === \"'\");\n        return values.join(\"\");\n    }\n    function readValue(acceptTypeRef) {\n        var token = next();\n        switch(token){\n            case \"'\":\n            case '\"':\n                push(token);\n                return readString();\n            case \"true\":\n            case \"TRUE\":\n                return true;\n            case \"false\":\n            case \"FALSE\":\n                return false;\n        }\n        try {\n            return parseNumber(token, /* insideTryCatch */ true);\n        } catch (e) {\n            /* istanbul ignore else */ if (acceptTypeRef && typeRefRe.test(token)) return token;\n            /* istanbul ignore next */ throw illegal(token, \"value\");\n        }\n    }\n    function readRanges(target, acceptStrings) {\n        var token, start;\n        do {\n            if (acceptStrings && ((token = peek()) === '\"' || token === \"'\")) {\n                var str = readString();\n                target.push(str);\n                if (edition >= 2023) {\n                    throw illegal(str, \"id\");\n                }\n            } else {\n                try {\n                    target.push([\n                        start = parseId(next()),\n                        skip(\"to\", true) ? parseId(next()) : start\n                    ]);\n                } catch (err) {\n                    if (acceptStrings && typeRefRe.test(token) && edition >= 2023) {\n                        target.push(token);\n                    } else {\n                        throw err;\n                    }\n                }\n            }\n        }while (skip(\",\", true));\n        var dummy = {\n            options: undefined\n        };\n        dummy.setOption = function(name, value) {\n            if (this.options === undefined) this.options = {};\n            this.options[name] = value;\n        };\n        ifBlock(dummy, function parseRange_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(dummy, token); // skip\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseRange_line() {\n            parseInlineOptions(dummy); // skip\n        });\n    }\n    function parseNumber(token, insideTryCatch) {\n        var sign = 1;\n        if (token.charAt(0) === \"-\") {\n            sign = -1;\n            token = token.substring(1);\n        }\n        switch(token){\n            case \"inf\":\n            case \"INF\":\n            case \"Inf\":\n                return sign * Infinity;\n            case \"nan\":\n            case \"NAN\":\n            case \"Nan\":\n            case \"NaN\":\n                return NaN;\n            case \"0\":\n                return 0;\n        }\n        if (base10Re.test(token)) return sign * parseInt(token, 10);\n        if (base16Re.test(token)) return sign * parseInt(token, 16);\n        if (base8Re.test(token)) return sign * parseInt(token, 8);\n        /* istanbul ignore else */ if (numberRe.test(token)) return sign * parseFloat(token);\n        /* istanbul ignore next */ throw illegal(token, \"number\", insideTryCatch);\n    }\n    function parseId(token, acceptNegative) {\n        switch(token){\n            case \"max\":\n            case \"MAX\":\n            case \"Max\":\n                return 536870911;\n            case \"0\":\n                return 0;\n        }\n        /* istanbul ignore if */ if (!acceptNegative && token.charAt(0) === \"-\") throw illegal(token, \"id\");\n        if (base10NegRe.test(token)) return parseInt(token, 10);\n        if (base16NegRe.test(token)) return parseInt(token, 16);\n        /* istanbul ignore else */ if (base8NegRe.test(token)) return parseInt(token, 8);\n        /* istanbul ignore next */ throw illegal(token, \"id\");\n    }\n    function parsePackage() {\n        /* istanbul ignore if */ if (pkg !== undefined) throw illegal(\"package\");\n        pkg = next();\n        /* istanbul ignore if */ if (!typeRefRe.test(pkg)) throw illegal(pkg, \"name\");\n        ptr = ptr.define(pkg);\n        skip(\";\");\n    }\n    function parseImport() {\n        var token = peek();\n        var whichImports;\n        switch(token){\n            case \"weak\":\n                whichImports = weakImports || (weakImports = []);\n                next();\n                break;\n            case \"public\":\n                next();\n            // eslint-disable-next-line no-fallthrough\n            default:\n                whichImports = imports || (imports = []);\n                break;\n        }\n        token = readString();\n        skip(\";\");\n        whichImports.push(token);\n    }\n    function parseSyntax() {\n        skip(\"=\");\n        edition = readString();\n        /* istanbul ignore if */ if (edition < 2023) throw illegal(edition, \"syntax\");\n        skip(\";\");\n    }\n    function parseEdition() {\n        skip(\"=\");\n        edition = readString();\n        const supportedEditions = [\n            \"2023\"\n        ];\n        /* istanbul ignore if */ if (!supportedEditions.includes(edition)) throw illegal(edition, \"edition\");\n        skip(\";\");\n    }\n    function parseCommon(parent, token) {\n        switch(token){\n            case \"option\":\n                parseOption(parent, token);\n                skip(\";\");\n                return true;\n            case \"message\":\n                parseType(parent, token);\n                return true;\n            case \"enum\":\n                parseEnum(parent, token);\n                return true;\n            case \"service\":\n                parseService(parent, token);\n                return true;\n            case \"extend\":\n                parseExtension(parent, token);\n                return true;\n        }\n        return false;\n    }\n    function ifBlock(obj, fnIf, fnElse) {\n        var trailingLine = tn.line;\n        if (obj) {\n            if (typeof obj.comment !== \"string\") {\n                obj.comment = cmnt(); // try block-type comment\n            }\n            obj.filename = parse.filename;\n        }\n        if (skip(\"{\", true)) {\n            var token;\n            while((token = next()) !== \"}\")fnIf(token);\n            skip(\";\", true);\n        } else {\n            if (fnElse) fnElse();\n            skip(\";\");\n            if (obj && (typeof obj.comment !== \"string\" || preferTrailingComment)) obj.comment = cmnt(trailingLine) || obj.comment; // try line-type comment\n        }\n    }\n    function parseType(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"type name\");\n        var type = new Type(token);\n        ifBlock(type, function parseType_block(token) {\n            if (parseCommon(type, token)) return;\n            switch(token){\n                case \"map\":\n                    parseMapField(type, token);\n                    break;\n                case \"required\":\n                    if (edition !== \"proto2\") throw illegal(token);\n                /* eslint-disable no-fallthrough */ case \"repeated\":\n                    parseField(type, token);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (edition === \"proto3\") {\n                        parseField(type, \"proto3_optional\");\n                    } else if (edition !== \"proto2\") {\n                        throw illegal(token);\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n                case \"oneof\":\n                    parseOneOf(type, token);\n                    break;\n                case \"extensions\":\n                    readRanges(type.extensions || (type.extensions = []));\n                    break;\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n                default:\n                    /* istanbul ignore if */ if (edition === \"proto2\" || !typeRefRe.test(token)) {\n                        throw illegal(token);\n                    }\n                    push(token);\n                    parseField(type, \"optional\");\n                    break;\n            }\n        });\n        parent.add(type);\n        if (parent === ptr) {\n            topLevelObjects.push(type);\n        }\n    }\n    function parseField(parent, rule, extend) {\n        var type = next();\n        if (type === \"group\") {\n            parseGroup(parent, rule);\n            return;\n        }\n        // Type names can consume multiple tokens, in multiple variants:\n        //    package.subpackage   field       tokens: \"package.subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package . subpackage field       tokens: \"package\" \".\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package.  subpackage field       tokens: \"package.\" \"subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        //    package  .subpackage field       tokens: \"package\" \".subpackage\" [TYPE NAME ENDS HERE] \"field\"\n        // Keep reading tokens until we get a type name with no period at the end,\n        // and the next token does not start with a period.\n        while(type.endsWith(\".\") || peek().startsWith(\".\")){\n            type += next();\n        }\n        /* istanbul ignore if */ if (!typeRefRe.test(type)) throw illegal(type, \"type\");\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        name = applyCase(name);\n        skip(\"=\");\n        var field = new Field(name, parseId(next()), type, rule, extend);\n        ifBlock(field, function parseField_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseField_line() {\n            parseInlineOptions(field);\n        });\n        if (rule === \"proto3_optional\") {\n            // for proto3 optional fields, we create a single-member Oneof to mimic \"optional\" behavior\n            var oneof = new OneOf(\"_\" + name);\n            field.setOption(\"proto3_optional\", true);\n            oneof.add(field);\n            parent.add(oneof);\n        } else {\n            parent.add(field);\n        }\n        if (parent === ptr) {\n            topLevelObjects.push(field);\n        }\n    }\n    function parseGroup(parent, rule) {\n        if (edition >= 2023) {\n            throw illegal(\"group\");\n        }\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        var fieldName = util.lcFirst(name);\n        if (name === fieldName) name = util.ucFirst(name);\n        skip(\"=\");\n        var id = parseId(next());\n        var type = new Type(name);\n        type.group = true;\n        var field = new Field(fieldName, id, name, rule);\n        field.filename = parse.filename;\n        ifBlock(type, function parseGroup_block(token) {\n            switch(token){\n                case \"option\":\n                    parseOption(type, token);\n                    skip(\";\");\n                    break;\n                case \"required\":\n                case \"repeated\":\n                    parseField(type, token);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (edition === \"proto3\") {\n                        parseField(type, \"proto3_optional\");\n                    } else {\n                        parseField(type, \"optional\");\n                    }\n                    break;\n                case \"message\":\n                    parseType(type, token);\n                    break;\n                case \"enum\":\n                    parseEnum(type, token);\n                    break;\n                case \"reserved\":\n                    readRanges(type.reserved || (type.reserved = []), true);\n                    break;\n                /* istanbul ignore next */ default:\n                    throw illegal(token); // there are no groups with proto3 semantics\n            }\n        });\n        parent.add(type).add(field);\n    }\n    function parseMapField(parent) {\n        skip(\"<\");\n        var keyType = next();\n        /* istanbul ignore if */ if (types.mapKey[keyType] === undefined) throw illegal(keyType, \"type\");\n        skip(\",\");\n        var valueType = next();\n        /* istanbul ignore if */ if (!typeRefRe.test(valueType)) throw illegal(valueType, \"type\");\n        skip(\">\");\n        var name = next();\n        /* istanbul ignore if */ if (!nameRe.test(name)) throw illegal(name, \"name\");\n        skip(\"=\");\n        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n        ifBlock(field, function parseMapField_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(field, token);\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseMapField_line() {\n            parseInlineOptions(field);\n        });\n        parent.add(field);\n    }\n    function parseOneOf(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var oneof = new OneOf(applyCase(token));\n        ifBlock(oneof, function parseOneOf_block(token) {\n            if (token === \"option\") {\n                parseOption(oneof, token);\n                skip(\";\");\n            } else {\n                push(token);\n                parseField(oneof, \"optional\");\n            }\n        });\n        parent.add(oneof);\n    }\n    function parseEnum(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var enm = new Enum(token);\n        ifBlock(enm, function parseEnum_block(token) {\n            switch(token){\n                case \"option\":\n                    parseOption(enm, token);\n                    skip(\";\");\n                    break;\n                case \"reserved\":\n                    readRanges(enm.reserved || (enm.reserved = []), true);\n                    if (enm.reserved === undefined) enm.reserved = [];\n                    break;\n                default:\n                    parseEnumValue(enm, token);\n            }\n        });\n        parent.add(enm);\n        if (parent === ptr) {\n            topLevelObjects.push(enm);\n        }\n    }\n    function parseEnumValue(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token)) throw illegal(token, \"name\");\n        skip(\"=\");\n        var value = parseId(next(), true), dummy = {\n            options: undefined\n        };\n        dummy.getOption = function(name) {\n            return this.options[name];\n        };\n        dummy.setOption = function(name, value) {\n            ReflectionObject.prototype.setOption.call(dummy, name, value);\n        };\n        dummy.setParsedOption = function() {\n            return undefined;\n        };\n        ifBlock(dummy, function parseEnumValue_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(dummy, token); // skip\n                skip(\";\");\n            } else throw illegal(token);\n        }, function parseEnumValue_line() {\n            parseInlineOptions(dummy); // skip\n        });\n        parent.add(token, value, dummy.comment, dummy.parsedOptions || dummy.options);\n    }\n    function parseOption(parent, token) {\n        var option;\n        var propName;\n        var isOption = true;\n        if (token === \"option\") {\n            token = next();\n        }\n        while(token !== \"=\"){\n            if (token === \"(\") {\n                var parensValue = next();\n                skip(\")\");\n                token = \"(\" + parensValue + \")\";\n            }\n            if (isOption) {\n                isOption = false;\n                if (token.includes(\".\") && !token.includes(\"(\")) {\n                    var tokens = token.split(\".\");\n                    option = tokens[0] + \".\";\n                    token = tokens[1];\n                    continue;\n                }\n                option = token;\n            } else {\n                propName = propName ? propName += token : token;\n            }\n            token = next();\n        }\n        var name = propName ? option.concat(propName) : option;\n        var optionValue = parseOptionValue(parent, name);\n        propName = propName && propName[0] === \".\" ? propName.slice(1) : propName;\n        option = option && option[option.length - 1] === \".\" ? option.slice(0, -1) : option;\n        setParsedOption(parent, option, optionValue, propName);\n    }\n    function parseOptionValue(parent, name) {\n        // { a: \"foo\" b { c: \"bar\" } }\n        if (skip(\"{\", true)) {\n            var objectResult = {};\n            while(!skip(\"}\", true)){\n                /* istanbul ignore if */ if (!nameRe.test(token = next())) {\n                    throw illegal(token, \"name\");\n                }\n                if (token === null) {\n                    throw illegal(token, \"end of input\");\n                }\n                var value;\n                var propName = token;\n                skip(\":\", true);\n                if (peek() === \"{\") {\n                    // option (my_option) = {\n                    //     repeated_value: [ \"foo\", \"bar\" ]\n                    // };\n                    value = parseOptionValue(parent, name + \".\" + token);\n                } else if (peek() === \"[\") {\n                    value = [];\n                    var lastValue;\n                    if (skip(\"[\", true)) {\n                        do {\n                            lastValue = readValue(true);\n                            value.push(lastValue);\n                        }while (skip(\",\", true));\n                        skip(\"]\");\n                        if (typeof lastValue !== \"undefined\") {\n                            setOption(parent, name + \".\" + token, lastValue);\n                        }\n                    }\n                } else {\n                    value = readValue(true);\n                    setOption(parent, name + \".\" + token, value);\n                }\n                var prevValue = objectResult[propName];\n                if (prevValue) value = [].concat(prevValue).concat(value);\n                objectResult[propName] = value;\n                // Semicolons and commas can be optional\n                skip(\",\", true);\n                skip(\";\", true);\n            }\n            return objectResult;\n        }\n        var simpleValue = readValue(true);\n        setOption(parent, name, simpleValue);\n        return simpleValue;\n    // Does not enforce a delimiter to be universal\n    }\n    function setOption(parent, name, value) {\n        if (ptr === parent && /^features\\./.test(name)) {\n            topLevelOptions[name] = value;\n            return;\n        }\n        if (parent.setOption) parent.setOption(name, value);\n    }\n    function setParsedOption(parent, name, value, propName) {\n        if (parent.setParsedOption) parent.setParsedOption(name, value, propName);\n    }\n    function parseInlineOptions(parent) {\n        if (skip(\"[\", true)) {\n            do {\n                parseOption(parent, \"option\");\n            }while (skip(\",\", true));\n            skip(\"]\");\n        }\n        return parent;\n    }\n    function parseService(parent, token) {\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"service name\");\n        var service = new Service(token);\n        ifBlock(service, function parseService_block(token) {\n            if (parseCommon(service, token)) {\n                return;\n            }\n            /* istanbul ignore else */ if (token === \"rpc\") parseMethod(service, token);\n            else throw illegal(token);\n        });\n        parent.add(service);\n        if (parent === ptr) {\n            topLevelObjects.push(service);\n        }\n    }\n    function parseMethod(parent, token) {\n        // Get the comment of the preceding line now (if one exists) in case the\n        // method is defined across multiple lines.\n        var commentText = cmnt();\n        var type = token;\n        /* istanbul ignore if */ if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        var name = token, requestType, requestStream, responseType, responseStream;\n        skip(\"(\");\n        if (skip(\"stream\", true)) requestStream = true;\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token);\n        requestType = token;\n        skip(\")\");\n        skip(\"returns\");\n        skip(\"(\");\n        if (skip(\"stream\", true)) responseStream = true;\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token);\n        responseType = token;\n        skip(\")\");\n        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n        method.comment = commentText;\n        ifBlock(method, function parseMethod_block(token) {\n            /* istanbul ignore else */ if (token === \"option\") {\n                parseOption(method, token);\n                skip(\";\");\n            } else throw illegal(token);\n        });\n        parent.add(method);\n    }\n    function parseExtension(parent, token) {\n        /* istanbul ignore if */ if (!typeRefRe.test(token = next())) throw illegal(token, \"reference\");\n        var reference = token;\n        ifBlock(null, function parseExtension_block(token) {\n            switch(token){\n                case \"required\":\n                case \"repeated\":\n                    parseField(parent, token, reference);\n                    break;\n                case \"optional\":\n                    /* istanbul ignore if */ if (edition === \"proto3\") {\n                        parseField(parent, \"proto3_optional\", reference);\n                    } else {\n                        parseField(parent, \"optional\", reference);\n                    }\n                    break;\n                default:\n                    /* istanbul ignore if */ if (edition === \"proto2\" || !typeRefRe.test(token)) throw illegal(token);\n                    push(token);\n                    parseField(parent, \"optional\", reference);\n                    break;\n            }\n        });\n    }\n    var token;\n    while((token = next()) !== null){\n        switch(token){\n            case \"package\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parsePackage();\n                break;\n            case \"import\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parseImport();\n                break;\n            case \"syntax\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parseSyntax();\n                break;\n            case \"edition\":\n                /* istanbul ignore if */ if (!head) throw illegal(token);\n                parseEdition();\n                break;\n            case \"option\":\n                parseOption(ptr, token);\n                skip(\";\", true);\n                break;\n            default:\n                /* istanbul ignore else */ if (parseCommon(ptr, token)) {\n                    head = false;\n                    continue;\n                }\n                /* istanbul ignore next */ throw illegal(token);\n        }\n    }\n    resolveFileFeatures();\n    parse.filename = null;\n    return {\n        \"package\": pkg,\n        \"imports\": imports,\n        weakImports: weakImports,\n        root: root\n    };\n} /**\n * Parses the given .proto source and returns an object with the parsed contents.\n * @name parse\n * @function\n * @param {string} source Source contents\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {IParserResult} Parser result\n * @property {string} filename=null Currently processing file name for error reporting, if known\n * @property {IParseOptions} defaults Default {@link IParseOptions}\n * @variation 2\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcGFyc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQkEsTUFBTUMsUUFBUSxHQUFHO0FBQ2pCRCxNQUFNRSxRQUFRLEdBQUc7SUFBRUMsVUFBVTtBQUFNO0FBRW5DLElBQUlDLFdBQVlDLG1CQUFPQSxDQUFDLDhGQUFZLEdBQ2hDQyxPQUFZRCxtQkFBT0EsQ0FBQyxzRkFBUSxHQUM1QkUsT0FBWUYsbUJBQU9BLENBQUMsc0ZBQVEsR0FDNUJHLFFBQVlILG1CQUFPQSxDQUFDLHdGQUFTLEdBQzdCSSxXQUFZSixtQkFBT0EsQ0FBQyw4RkFBWSxHQUNoQ0ssUUFBWUwsbUJBQU9BLENBQUMsd0ZBQVMsR0FDN0JNLE9BQVlOLG1CQUFPQSxDQUFDLHNGQUFRLEdBQzVCTyxVQUFZUCxtQkFBT0EsQ0FBQyw0RkFBVyxHQUMvQlEsU0FBWVIsbUJBQU9BLENBQUMsMEZBQVUsR0FDOUJTLG1CQUFtQlQsbUJBQU9BLENBQUMsMEZBQVUsR0FDckNVLFFBQVlWLG1CQUFPQSxDQUFDLHdGQUFTLEdBQzdCVyxPQUFZWCxtQkFBT0EsQ0FBQyxzRkFBUTtBQUVoQyxJQUFJWSxXQUFjLGlCQUNkQyxjQUFjLG1CQUNkQyxXQUFjLHNCQUNkQyxjQUFjLHdCQUNkQyxVQUFjLGFBQ2RDLGFBQWMsZUFDZEMsV0FBYyxxREFDZEMsU0FBYyw0QkFDZEMsWUFBYztBQUVsQjs7Ozs7OztDQU9DLEdBRUQ7Ozs7OztDQU1DLEdBRUQ7Ozs7Q0FJQyxHQUVEOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU3pCLE1BQU0wQixNQUFNLEVBQUVDLElBQUksRUFBRUMsT0FBTztJQUNoQyxrQ0FBa0MsR0FDbEMsSUFBSSxDQUFFRCxDQUFBQSxnQkFBZ0JyQixJQUFHLEdBQUk7UUFDekJzQixVQUFVRDtRQUNWQSxPQUFPLElBQUlyQjtJQUNmO0lBQ0EsSUFBSSxDQUFD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QVFDO2dCQUNsQnVDO2dCQUNBO1lBRUosS0FBSztnQkFDRGhCLFlBQVl4QyxLQUFLaUI7Z0JBQ2pCeEIsS0FBSyxLQUFLO2dCQUNWO1lBRUo7Z0JBRUksd0JBQXdCLEdBQ3hCLElBQUlrRSxZQUFZM0QsS0FBS2lCLFFBQVE7b0JBQ3pCdEIsT0FBTztvQkFDUDtnQkFDSjtnQkFFQSx3QkFBd0IsR0FDeEIsTUFBTXFCLFFBQVFDO1FBQ3RCO0lBQ0o7SUFFQVg7SUFFQWhELE1BQU1DLFFBQVEsR0FBRztJQUNqQixPQUFPO1FBQ0gsV0FBZ0JxQztRQUNoQixXQUFnQkM7UUFDZkMsYUFBZUE7UUFDZmIsTUFBZUE7SUFDcEI7QUFDSixFQUVBOzs7Ozs7Ozs7O0NBVUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcGFyc2UuanM/NDk2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gcGFyc2U7XG5cbnBhcnNlLmZpbGVuYW1lID0gbnVsbDtcbnBhcnNlLmRlZmF1bHRzID0geyBrZWVwQ2FzZTogZmFsc2UgfTtcblxudmFyIHRva2VuaXplICA9IHJlcXVpcmUoXCIuL3Rva2VuaXplXCIpLFxuICAgIFJvb3QgICAgICA9IHJlcXVpcmUoXCIuL3Jvb3RcIiksXG4gICAgVHlwZSAgICAgID0gcmVxdWlyZShcIi4vdHlwZVwiKSxcbiAgICBGaWVsZCAgICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICBNYXBGaWVsZCAgPSByZXF1aXJlKFwiLi9tYXBmaWVsZFwiKSxcbiAgICBPbmVPZiAgICAgPSByZXF1aXJlKFwiLi9vbmVvZlwiKSxcbiAgICBFbnVtICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIFNlcnZpY2UgICA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIiksXG4gICAgTWV0aG9kICAgID0gcmVxdWlyZShcIi4vbWV0aG9kXCIpLFxuICAgIFJlZmxlY3Rpb25PYmplY3QgPSByZXF1aXJlKFwiLi9vYmplY3RcIiksXG4gICAgdHlwZXMgICAgID0gcmVxdWlyZShcIi4vdHlwZXNcIiksXG4gICAgdXRpbCAgICAgID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIGJhc2UxMFJlICAgID0gL15bMS05XVswLTldKiQvLFxuICAgIGJhc2UxME5lZ1JlID0gL14tP1sxLTldWzAtOV0qJC8sXG4gICAgYmFzZTE2UmUgICAgPSAvXjBbeF1bMC05YS1mQS1GXSskLyxcbiAgICBiYXNlMTZOZWdSZSA9IC9eLT8wW3hdWzAtOWEtZkEtRl0rJC8sXG4gICAgYmFzZThSZSAgICAgPSAvXjBbMC03XSskLyxcbiAgICBiYXNlOE5lZ1JlICA9IC9eLT8wWzAtN10rJC8sXG4gICAgbnVtYmVyUmUgICAgPSAvXig/IVtlRV0pWzAtOV0qKD86XFwuWzAtOV0qKT8oPzpbZUVdWystXT9bMC05XSspPyQvLFxuICAgIG5hbWVSZSAgICAgID0gL15bYS16QS1aX11bYS16QS1aXzAtOV0qJC8sXG4gICAgdHlwZVJlZlJlICAgPSAvXig/OlxcLj9bYS16QS1aX11bYS16QS1aXzAtOV0qKSg/OlxcLlthLXpBLVpfXVthLXpBLVpfMC05XSopKiQvO1xuXG4vKipcbiAqIFJlc3VsdCBvYmplY3QgcmV0dXJuZWQgZnJvbSB7QGxpbmsgcGFyc2V9LlxuICogQGludGVyZmFjZSBJUGFyc2VyUmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ3x1bmRlZmluZWR9IHBhY2thZ2UgUGFja2FnZSBuYW1lLCBpZiBkZWNsYXJlZFxuICogQHByb3BlcnR5IHtzdHJpbmdbXXx1bmRlZmluZWR9IGltcG9ydHMgSW1wb3J0cywgaWYgYW55XG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfHVuZGVmaW5lZH0gd2Vha0ltcG9ydHMgV2VhayBpbXBvcnRzLCBpZiBhbnlcbiAqIEBwcm9wZXJ0eSB7Um9vdH0gcm9vdCBQb3B1bGF0ZWQgcm9vdCBpbnN0YW5jZVxuICovXG5cbi8qKlxuICogT3B0aW9ucyBtb2RpZnlpbmcgdGhlIGJlaGF2aW9yIG9mIHtAbGluayBwYXJzZX0uXG4gKiBAaW50ZXJmYWNlIElQYXJzZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2tlZXBDYXNlPWZhbHNlXSBLZWVwcyBmaWVsZCBjYXNpbmcgaW5zdGVhZCBvZiBjb252ZXJ0aW5nIHRvIGNhbWVsIGNhc2VcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2FsdGVybmF0ZUNvbW1lbnRNb2RlPWZhbHNlXSBSZWNvZ25pemUgZG91YmxlLXNsYXNoIGNvbW1lbnRzIGluIGFkZGl0aW9uIHRvIGRvYy1ibG9jayBjb21tZW50cy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3ByZWZlclRyYWlsaW5nQ29tbWVudD1mYWxzZV0gVXNlIHRyYWlsaW5nIGNvbW1lbnQgd2hlbiBib3RoIGxlYWRpbmcgY29tbWVudCBhbmQgdHJhaWxpbmcgY29tbWVudCBleGlzdC5cbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgbW9kaWZ5aW5nIHRoZSBiZWhhdmlvciBvZiBKU09OIHNlcmlhbGl6YXRpb24uXG4gKiBAaW50ZXJmYWNlIElUb0pTT05PcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtrZWVwQ29tbWVudHM9ZmFsc2VdIFNlcmlhbGl6ZXMgY29tbWVudHMuXG4gKi9cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIC5wcm90byBzb3VyY2UgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBjb250ZW50cy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlIGNvbnRlbnRzXG4gKiBAcGFyYW0ge1Jvb3R9IHJvb3QgUm9vdCB0byBwb3B1bGF0ZVxuICogQHBhcmFtIHtJUGFyc2VPcHRpb25zfSBbb3B0aW9uc10gUGFyc2Ugb3B0aW9ucy4gRGVmYXVsdHMgdG8ge0BsaW5rIHBhcnNlLmRlZmF1bHRzfSB3aGVuIG9taXR0ZWQuXG4gKiBAcmV0dXJucyB7SVBhcnNlclJlc3VsdH0gUGFyc2VyIHJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGZpbGVuYW1lPW51bGwgQ3VycmVudGx5IHByb2Nlc3NpbmcgZmlsZSBuYW1lIGZvciBlcnJvciByZXBvcnRpbmcsIGlmIGtub3duXG4gKiBAcHJvcGVydHkge0lQYXJzZU9wdGlvbnN9IGRlZmF1bHRzIERlZmF1bHQge0BsaW5rIElQYXJzZU9wdGlvbnN9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlKHNvdXJjZSwgcm9vdCwgb3B0aW9ucykge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIGNhbGxiYWNrLXJldHVybiAqL1xuICAgIGlmICghKHJvb3QgaW5zdGFuY2VvZiBSb290KSkge1xuICAgICAgICBvcHRpb25zID0gcm9vdDtcbiAgICAgICAgcm9vdCA9IG5ldyBSb290KCk7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucylcbiAgICAgICAgb3B0aW9ucyA9IHBhcnNlLmRlZmF1bHRzO1xuXG4gICAgdmFyIHByZWZlclRyYWlsaW5nQ29tbWVudCA9IG9wdGlvbnMucHJlZmVyVHJhaWxpbmdDb21tZW50IHx8IGZhbHNlO1xuICAgIHZhciB0biA9IHRva2VuaXplKHNvdXJjZSwgb3B0aW9ucy5hbHRlcm5hdGVDb21tZW50TW9kZSB8fCBmYWxzZSksXG4gICAgICAgIG5leHQgPSB0bi5uZXh0LFxuICAgICAgICBwdXNoID0gdG4ucHVzaCxcbiAgICAgICAgcGVlayA9IHRuLnBlZWssXG4gICAgICAgIHNraXAgPSB0bi5za2lwLFxuICAgICAgICBjbW50ID0gdG4uY21udDtcblxuICAgIHZhciBoZWFkID0gdHJ1ZSxcbiAgICAgICAgcGtnLFxuICAgICAgICBpbXBvcnRzLFxuICAgICAgICB3ZWFrSW1wb3J0cyxcbiAgICAgICAgZWRpdGlvbiA9IFwicHJvdG8yXCI7XG5cbiAgICB2YXIgcHRyID0gcm9vdDtcblxuICAgIHZhciB0b3BMZXZlbE9iamVjdHMgPSBbXTtcbiAgICB2YXIgdG9wTGV2ZWxPcHRpb25zID0ge307XG5cbiAgICB2YXIgYXBwbHlDYXNlID0gb3B0aW9ucy5rZWVwQ2FzZSA/IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIG5hbWU7IH0gOiB1dGlsLmNhbWVsQ2FzZTtcblxuICAgIGZ1bmN0aW9uIHJlc29sdmVGaWxlRmVhdHVyZXMoKSB7XG4gICAgICAgIHRvcExldmVsT2JqZWN0cy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICAgICAgICBvYmouX2VkaXRpb24gPSBlZGl0aW9uO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModG9wTGV2ZWxPcHRpb25zKS5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5nZXRPcHRpb24ob3B0KSAhPT0gdW5kZWZpbmVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgb2JqLnNldE9wdGlvbihvcHQsIHRvcExldmVsT3B0aW9uc1tvcHRdLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGZ1bmN0aW9uIGlsbGVnYWwodG9rZW4sIG5hbWUsIGluc2lkZVRyeUNhdGNoKSB7XG4gICAgICAgIHZhciBmaWxlbmFtZSA9IHBhcnNlLmZpbGVuYW1lO1xuICAgICAgICBpZiAoIWluc2lkZVRyeUNhdGNoKVxuICAgICAgICAgICAgcGFyc2UuZmlsZW5hbWUgPSBudWxsO1xuICAgICAgICByZXR1cm4gRXJyb3IoXCJpbGxlZ2FsIFwiICsgKG5hbWUgfHwgXCJ0b2tlblwiKSArIFwiICdcIiArIHRva2VuICsgXCInIChcIiArIChmaWxlbmFtZSA/IGZpbGVuYW1lICsgXCIsIFwiIDogXCJcIikgKyBcImxpbmUgXCIgKyB0bi5saW5lICsgXCIpXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRTdHJpbmcoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBbXSxcbiAgICAgICAgICAgIHRva2VuO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICgodG9rZW4gPSBuZXh0KCkpICE9PSBcIlxcXCJcIiAmJiB0b2tlbiAhPT0gXCInXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKG5leHQoKSk7XG4gICAgICAgICAgICBza2lwKHRva2VuKTtcbiAgICAgICAgICAgIHRva2VuID0gcGVlaygpO1xuICAgICAgICB9IHdoaWxlICh0b2tlbiA9PT0gXCJcXFwiXCIgfHwgdG9rZW4gPT09IFwiJ1wiKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcy5qb2luKFwiXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlYWRWYWx1ZShhY2NlcHRUeXBlUmVmKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IG5leHQoKTtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIidcIjpcbiAgICAgICAgICAgIGNhc2UgXCJcXFwiXCI6XG4gICAgICAgICAgICAgICAgcHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRTdHJpbmcoKTtcbiAgICAgICAgICAgIGNhc2UgXCJ0cnVlXCI6IGNhc2UgXCJUUlVFXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBjYXNlIFwiZmFsc2VcIjogY2FzZSBcIkZBTFNFXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1iZXIodG9rZW4sIC8qIGluc2lkZVRyeUNhdGNoICovIHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGFjY2VwdFR5cGVSZWYgJiYgdHlwZVJlZlJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcblxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwidmFsdWVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWFkUmFuZ2VzKHRhcmdldCwgYWNjZXB0U3RyaW5ncykge1xuICAgICAgICB2YXIgdG9rZW4sIHN0YXJ0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAoYWNjZXB0U3RyaW5ncyAmJiAoKHRva2VuID0gcGVlaygpKSA9PT0gXCJcXFwiXCIgfHwgdG9rZW4gPT09IFwiJ1wiKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdHIgPSByZWFkU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goc3RyKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdGlvbiA+PSAyMDIzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwoc3RyLCBcImlkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnB1c2goWyBzdGFydCA9IHBhcnNlSWQobmV4dCgpKSwgc2tpcChcInRvXCIsIHRydWUpID8gcGFyc2VJZChuZXh0KCkpIDogc3RhcnQgXSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY2NlcHRTdHJpbmdzICYmIHR5cGVSZWZSZS50ZXN0KHRva2VuKSAmJiBlZGl0aW9uID49IDIwMjMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoc2tpcChcIixcIiwgdHJ1ZSkpO1xuICAgICAgICB2YXIgZHVtbXkgPSB7b3B0aW9uczogdW5kZWZpbmVkfTtcbiAgICAgICAgZHVtbXkuc2V0T3B0aW9uID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zID09PSB1bmRlZmluZWQpIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICAgIHRoaXMub3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBpZkJsb2NrKFxuICAgICAgICAgICAgZHVtbXksXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZVJhbmdlX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKGR1bW15LCB0b2tlbik7ICAvLyBza2lwXG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlUmFuZ2VfbGluZSgpIHtcbiAgICAgICAgICAgICAgcGFyc2VJbmxpbmVPcHRpb25zKGR1bW15KTsgIC8vIHNraXBcbiAgICAgICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTnVtYmVyKHRva2VuLCBpbnNpZGVUcnlDYXRjaCkge1xuICAgICAgICB2YXIgc2lnbiA9IDE7XG4gICAgICAgIGlmICh0b2tlbi5jaGFyQXQoMCkgPT09IFwiLVwiKSB7XG4gICAgICAgICAgICBzaWduID0gLTE7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnN1YnN0cmluZygxKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW5mXCI6IGNhc2UgXCJJTkZcIjogY2FzZSBcIkluZlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBzaWduICogSW5maW5pdHk7XG4gICAgICAgICAgICBjYXNlIFwibmFuXCI6IGNhc2UgXCJOQU5cIjogY2FzZSBcIk5hblwiOiBjYXNlIFwiTmFOXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2UxMFJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh0b2tlbiwgMTApO1xuICAgICAgICBpZiAoYmFzZTE2UmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIHBhcnNlSW50KHRva2VuLCAxNik7XG4gICAgICAgIGlmIChiYXNlOFJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUludCh0b2tlbiwgOCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKG51bWJlclJlLnRlc3QodG9rZW4pKVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKiBwYXJzZUZsb2F0KHRva2VuKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm51bWJlclwiLCBpbnNpZGVUcnlDYXRjaCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VJZCh0b2tlbiwgYWNjZXB0TmVnYXRpdmUpIHtcbiAgICAgICAgc3dpdGNoICh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIm1heFwiOiBjYXNlIFwiTUFYXCI6IGNhc2UgXCJNYXhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gNTM2ODcwOTExO1xuICAgICAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIWFjY2VwdE5lZ2F0aXZlICYmIHRva2VuLmNoYXJBdCgwKSA9PT0gXCItXCIpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcImlkXCIpO1xuXG4gICAgICAgIGlmIChiYXNlMTBOZWdSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0b2tlbiwgMTApO1xuICAgICAgICBpZiAoYmFzZTE2TmVnUmUudGVzdCh0b2tlbikpXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodG9rZW4sIDE2KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoYmFzZThOZWdSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCh0b2tlbiwgOCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJpZFwiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVBhY2thZ2UoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocGtnICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwicGFja2FnZVwiKTtcblxuICAgICAgICBwa2cgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QocGtnKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwocGtnLCBcIm5hbWVcIik7XG5cbiAgICAgICAgcHRyID0gcHRyLmRlZmluZShwa2cpO1xuXG4gICAgICAgIHNraXAoXCI7XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW1wb3J0KCkge1xuICAgICAgICB2YXIgdG9rZW4gPSBwZWVrKCk7XG4gICAgICAgIHZhciB3aGljaEltcG9ydHM7XG4gICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWFrXCI6XG4gICAgICAgICAgICAgICAgd2hpY2hJbXBvcnRzID0gd2Vha0ltcG9ydHMgfHwgKHdlYWtJbXBvcnRzID0gW10pO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwdWJsaWNcIjpcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHdoaWNoSW1wb3J0cyA9IGltcG9ydHMgfHwgKGltcG9ydHMgPSBbXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdG9rZW4gPSByZWFkU3RyaW5nKCk7XG4gICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICB3aGljaEltcG9ydHMucHVzaCh0b2tlbik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTeW50YXgoKSB7XG4gICAgICAgIHNraXAoXCI9XCIpO1xuICAgICAgICBlZGl0aW9uID0gcmVhZFN0cmluZygpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoZWRpdGlvbiA8IDIwMjMpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKGVkaXRpb24sIFwic3ludGF4XCIpO1xuXG4gICAgICAgIHNraXAoXCI7XCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlRWRpdGlvbigpIHtcbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIGVkaXRpb24gPSByZWFkU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZEVkaXRpb25zID0gW1wiMjAyM1wiXTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFzdXBwb3J0ZWRFZGl0aW9ucy5pbmNsdWRlcyhlZGl0aW9uKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoZWRpdGlvbiwgXCJlZGl0aW9uXCIpO1xuXG4gICAgICAgIHNraXAoXCI7XCIpO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcGFyc2VDb21tb24ocGFyZW50LCB0b2tlbikge1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjpcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBwYXJzZVR5cGUocGFyZW50LCB0b2tlbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VFbnVtKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIFwic2VydmljZVwiOlxuICAgICAgICAgICAgICAgIHBhcnNlU2VydmljZShwYXJlbnQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBcImV4dGVuZFwiOlxuICAgICAgICAgICAgICAgIHBhcnNlRXh0ZW5zaW9uKHBhcmVudCwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpZkJsb2NrKG9iaiwgZm5JZiwgZm5FbHNlKSB7XG4gICAgICAgIHZhciB0cmFpbGluZ0xpbmUgPSB0bi5saW5lO1xuICAgICAgICBpZiAob2JqKSB7XG4gICAgICAgICAgICBpZih0eXBlb2Ygb2JqLmNvbW1lbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgb2JqLmNvbW1lbnQgPSBjbW50KCk7IC8vIHRyeSBibG9jay10eXBlIGNvbW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iai5maWxlbmFtZSA9IHBhcnNlLmZpbGVuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChza2lwKFwie1wiLCB0cnVlKSkge1xuICAgICAgICAgICAgdmFyIHRva2VuO1xuICAgICAgICAgICAgd2hpbGUgKCh0b2tlbiA9IG5leHQoKSkgIT09IFwifVwiKVxuICAgICAgICAgICAgICAgIGZuSWYodG9rZW4pO1xuICAgICAgICAgICAgc2tpcChcIjtcIiwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoZm5FbHNlKVxuICAgICAgICAgICAgICAgIGZuRWxzZSgpO1xuICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICBpZiAob2JqICYmICh0eXBlb2Ygb2JqLmNvbW1lbnQgIT09IFwic3RyaW5nXCIgfHwgcHJlZmVyVHJhaWxpbmdDb21tZW50KSlcbiAgICAgICAgICAgICAgICBvYmouY29tbWVudCA9IGNtbnQodHJhaWxpbmdMaW5lKSB8fCBvYmouY29tbWVudDsgLy8gdHJ5IGxpbmUtdHlwZSBjb21tZW50XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZVR5cGUocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwidHlwZSBuYW1lXCIpO1xuXG4gICAgICAgIHZhciB0eXBlID0gbmV3IFR5cGUodG9rZW4pO1xuICAgICAgICBpZkJsb2NrKHR5cGUsIGZ1bmN0aW9uIHBhcnNlVHlwZV9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgaWYgKHBhcnNlQ29tbW9uKHR5cGUsIHRva2VuKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VNYXBGaWVsZCh0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGl0aW9uICE9PSBcInByb3RvMlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZmFsbHRocm91Z2ggKi9cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVwZWF0ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvbmFsXCI6XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdGlvbiA9PT0gXCJwcm90bzNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcInByb3RvM19vcHRpb25hbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlZGl0aW9uICE9PSBcInByb3RvMlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQodHlwZSwgXCJvcHRpb25hbFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJvbmVvZlwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZU9uZU9mKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiZXh0ZW5zaW9uc1wiOlxuICAgICAgICAgICAgICAgICAgICByZWFkUmFuZ2VzKHR5cGUuZXh0ZW5zaW9ucyB8fCAodHlwZS5leHRlbnNpb25zID0gW10pKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzZXJ2ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmVhZFJhbmdlcyh0eXBlLnJlc2VydmVkIHx8ICh0eXBlLnJlc2VydmVkID0gW10pLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRpb24gPT09IFwicHJvdG8yXCIgfHwgIXR5cGVSZWZSZS50ZXN0KHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQodHlwZSk7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IHB0cikge1xuICAgICAgICAgICAgdG9wTGV2ZWxPYmplY3RzLnB1c2godHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUZpZWxkKHBhcmVudCwgcnVsZSwgZXh0ZW5kKSB7XG4gICAgICAgIHZhciB0eXBlID0gbmV4dCgpO1xuICAgICAgICBpZiAodHlwZSA9PT0gXCJncm91cFwiKSB7XG4gICAgICAgICAgICBwYXJzZUdyb3VwKHBhcmVudCwgcnVsZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHlwZSBuYW1lcyBjYW4gY29uc3VtZSBtdWx0aXBsZSB0b2tlbnMsIGluIG11bHRpcGxlIHZhcmlhbnRzOlxuICAgICAgICAvLyAgICBwYWNrYWdlLnN1YnBhY2thZ2UgICBmaWVsZCAgICAgICB0b2tlbnM6IFwicGFja2FnZS5zdWJwYWNrYWdlXCIgW1RZUEUgTkFNRSBFTkRTIEhFUkVdIFwiZmllbGRcIlxuICAgICAgICAvLyAgICBwYWNrYWdlIC4gc3VicGFja2FnZSBmaWVsZCAgICAgICB0b2tlbnM6IFwicGFja2FnZVwiIFwiLlwiIFwic3VicGFja2FnZVwiIFtUWVBFIE5BTUUgRU5EUyBIRVJFXSBcImZpZWxkXCJcbiAgICAgICAgLy8gICAgcGFja2FnZS4gIHN1YnBhY2thZ2UgZmllbGQgICAgICAgdG9rZW5zOiBcInBhY2thZ2UuXCIgXCJzdWJwYWNrYWdlXCIgW1RZUEUgTkFNRSBFTkRTIEhFUkVdIFwiZmllbGRcIlxuICAgICAgICAvLyAgICBwYWNrYWdlICAuc3VicGFja2FnZSBmaWVsZCAgICAgICB0b2tlbnM6IFwicGFja2FnZVwiIFwiLnN1YnBhY2thZ2VcIiBbVFlQRSBOQU1FIEVORFMgSEVSRV0gXCJmaWVsZFwiXG4gICAgICAgIC8vIEtlZXAgcmVhZGluZyB0b2tlbnMgdW50aWwgd2UgZ2V0IGEgdHlwZSBuYW1lIHdpdGggbm8gcGVyaW9kIGF0IHRoZSBlbmQsXG4gICAgICAgIC8vIGFuZCB0aGUgbmV4dCB0b2tlbiBkb2VzIG5vdCBzdGFydCB3aXRoIGEgcGVyaW9kLlxuICAgICAgICB3aGlsZSAodHlwZS5lbmRzV2l0aChcIi5cIikgfHwgcGVlaygpLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICAgICAgICB0eXBlICs9IG5leHQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHR5cGUpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0eXBlLCBcInR5cGVcIik7XG5cbiAgICAgICAgdmFyIG5hbWUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdChuYW1lKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwobmFtZSwgXCJuYW1lXCIpO1xuXG4gICAgICAgIG5hbWUgPSBhcHBseUNhc2UobmFtZSk7XG4gICAgICAgIHNraXAoXCI9XCIpO1xuXG4gICAgICAgIHZhciBmaWVsZCA9IG5ldyBGaWVsZChuYW1lLCBwYXJzZUlkKG5leHQoKSksIHR5cGUsIHJ1bGUsIGV4dGVuZCk7XG5cbiAgICAgICAgaWZCbG9jayhmaWVsZCwgZnVuY3Rpb24gcGFyc2VGaWVsZF9ibG9jayh0b2tlbikge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZmllbGQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIH0sIGZ1bmN0aW9uIHBhcnNlRmllbGRfbGluZSgpIHtcbiAgICAgICAgICAgIHBhcnNlSW5saW5lT3B0aW9ucyhmaWVsZCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChydWxlID09PSBcInByb3RvM19vcHRpb25hbFwiKSB7XG4gICAgICAgICAgICAvLyBmb3IgcHJvdG8zIG9wdGlvbmFsIGZpZWxkcywgd2UgY3JlYXRlIGEgc2luZ2xlLW1lbWJlciBPbmVvZiB0byBtaW1pYyBcIm9wdGlvbmFsXCIgYmVoYXZpb3JcbiAgICAgICAgICAgIHZhciBvbmVvZiA9IG5ldyBPbmVPZihcIl9cIiArIG5hbWUpO1xuICAgICAgICAgICAgZmllbGQuc2V0T3B0aW9uKFwicHJvdG8zX29wdGlvbmFsXCIsIHRydWUpO1xuICAgICAgICAgICAgb25lb2YuYWRkKGZpZWxkKTtcbiAgICAgICAgICAgIHBhcmVudC5hZGQob25lb2YpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50LmFkZChmaWVsZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmVudCA9PT0gcHRyKSB7XG4gICAgICAgICAgICB0b3BMZXZlbE9iamVjdHMucHVzaChmaWVsZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZUdyb3VwKHBhcmVudCwgcnVsZSkge1xuICAgICAgICBpZiAoZWRpdGlvbiA+PSAyMDIzKSB7XG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwiZ3JvdXBcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKG5hbWUsIFwibmFtZVwiKTtcblxuICAgICAgICB2YXIgZmllbGROYW1lID0gdXRpbC5sY0ZpcnN0KG5hbWUpO1xuICAgICAgICBpZiAobmFtZSA9PT0gZmllbGROYW1lKVxuICAgICAgICAgICAgbmFtZSA9IHV0aWwudWNGaXJzdChuYW1lKTtcbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIHZhciBpZCA9IHBhcnNlSWQobmV4dCgpKTtcbiAgICAgICAgdmFyIHR5cGUgPSBuZXcgVHlwZShuYW1lKTtcbiAgICAgICAgdHlwZS5ncm91cCA9IHRydWU7XG4gICAgICAgIHZhciBmaWVsZCA9IG5ldyBGaWVsZChmaWVsZE5hbWUsIGlkLCBuYW1lLCBydWxlKTtcbiAgICAgICAgZmllbGQuZmlsZW5hbWUgPSBwYXJzZS5maWxlbmFtZTtcbiAgICAgICAgaWZCbG9jayh0eXBlLCBmdW5jdGlvbiBwYXJzZUdyb3VwX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9uKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXF1aXJlZFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXBlYXRlZFwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwib3B0aW9uYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGl0aW9uID09PSBcInByb3RvM1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHR5cGUsIFwicHJvdG8zX29wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZCh0eXBlLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VUeXBlKHR5cGUsIHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZUVudW0odHlwZSwgdG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNlcnZlZFwiOlxuICAgICAgICAgICAgICAgICAgICByZWFkUmFuZ2VzKHR5cGUucmVzZXJ2ZWQgfHwgKHR5cGUucmVzZXJ2ZWQgPSBbXSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7IC8vIHRoZXJlIGFyZSBubyBncm91cHMgd2l0aCBwcm90bzMgc2VtYW50aWNzXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKHR5cGUpXG4gICAgICAgICAgICAgIC5hZGQoZmllbGQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTWFwRmllbGQocGFyZW50KSB7XG4gICAgICAgIHNraXAoXCI8XCIpO1xuICAgICAgICB2YXIga2V5VHlwZSA9IG5leHQoKTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHR5cGVzLm1hcEtleVtrZXlUeXBlXSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChrZXlUeXBlLCBcInR5cGVcIik7XG5cbiAgICAgICAgc2tpcChcIixcIik7XG4gICAgICAgIHZhciB2YWx1ZVR5cGUgPSBuZXh0KCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodmFsdWVUeXBlKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodmFsdWVUeXBlLCBcInR5cGVcIik7XG5cbiAgICAgICAgc2tpcChcIj5cIik7XG4gICAgICAgIHZhciBuYW1lID0gbmV4dCgpO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChuYW1lLCBcIm5hbWVcIik7XG5cbiAgICAgICAgc2tpcChcIj1cIik7XG4gICAgICAgIHZhciBmaWVsZCA9IG5ldyBNYXBGaWVsZChhcHBseUNhc2UobmFtZSksIHBhcnNlSWQobmV4dCgpKSwga2V5VHlwZSwgdmFsdWVUeXBlKTtcbiAgICAgICAgaWZCbG9jayhmaWVsZCwgZnVuY3Rpb24gcGFyc2VNYXBGaWVsZF9ibG9jayh0b2tlbikge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZmllbGQsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIH0sIGZ1bmN0aW9uIHBhcnNlTWFwRmllbGRfbGluZSgpIHtcbiAgICAgICAgICAgIHBhcnNlSW5saW5lT3B0aW9ucyhmaWVsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKGZpZWxkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU9uZU9mKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIG9uZW9mID0gbmV3IE9uZU9mKGFwcGx5Q2FzZSh0b2tlbikpO1xuICAgICAgICBpZkJsb2NrKG9uZW9mLCBmdW5jdGlvbiBwYXJzZU9uZU9mX2Jsb2NrKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihvbmVvZiwgdG9rZW4pO1xuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKG9uZW9mLCBcIm9wdGlvbmFsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChvbmVvZik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFbnVtKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcIm5hbWVcIik7XG5cbiAgICAgICAgdmFyIGVubSA9IG5ldyBFbnVtKHRva2VuKTtcbiAgICAgICAgaWZCbG9jayhlbm0sIGZ1bmN0aW9uIHBhcnNlRW51bV9ibG9jayh0b2tlbikge1xuICAgICAgICAgIHN3aXRjaCh0b2tlbikge1xuICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOlxuICAgICAgICAgICAgICBwYXJzZU9wdGlvbihlbm0sIHRva2VuKTtcbiAgICAgICAgICAgICAgc2tpcChcIjtcIik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwicmVzZXJ2ZWRcIjpcbiAgICAgICAgICAgICAgcmVhZFJhbmdlcyhlbm0ucmVzZXJ2ZWQgfHwgKGVubS5yZXNlcnZlZCA9IFtdKSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIGlmKGVubS5yZXNlcnZlZCA9PT0gdW5kZWZpbmVkKSBlbm0ucmVzZXJ2ZWQgPSBbXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHBhcnNlRW51bVZhbHVlKGVubSwgdG9rZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQoZW5tKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gcHRyKSB7XG4gICAgICAgICAgICB0b3BMZXZlbE9iamVjdHMucHVzaChlbm0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWUocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIW5hbWVSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibmFtZVwiKTtcblxuICAgICAgICBza2lwKFwiPVwiKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyc2VJZChuZXh0KCksIHRydWUpLFxuICAgICAgICAgICAgZHVtbXkgPSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uczogdW5kZWZpbmVkXG4gICAgICAgICAgICB9O1xuICAgICAgICBkdW1teS5nZXRPcHRpb24gPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW25hbWVdO1xuICAgICAgICB9O1xuICAgICAgICBkdW1teS5zZXRPcHRpb24gPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgUmVmbGVjdGlvbk9iamVjdC5wcm90b3R5cGUuc2V0T3B0aW9uLmNhbGwoZHVtbXksIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZHVtbXkuc2V0UGFyc2VkT3B0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgICAgICBpZkJsb2NrKGR1bW15LCBmdW5jdGlvbiBwYXJzZUVudW1WYWx1ZV9ibG9jayh0b2tlbikge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24oZHVtbXksIHRva2VuKTsgLy8gc2tpcFxuICAgICAgICAgICAgICAgIHNraXAoXCI7XCIpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24gcGFyc2VFbnVtVmFsdWVfbGluZSgpIHtcbiAgICAgICAgICAgIHBhcnNlSW5saW5lT3B0aW9ucyhkdW1teSk7IC8vIHNraXBcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcmVudC5hZGQodG9rZW4sIHZhbHVlLCBkdW1teS5jb21tZW50LCBkdW1teS5wYXJzZWRPcHRpb25zIHx8IGR1bW15Lm9wdGlvbnMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlT3B0aW9uKHBhcmVudCwgdG9rZW4pIHtcbiAgICAgICAgICAgIHZhciBvcHRpb247XG4gICAgICAgICAgICB2YXIgcHJvcE5hbWU7XG4gICAgICAgICAgICB2YXIgaXNPcHRpb24gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRva2VuID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBuZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlICh0b2tlbiAhPT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnNWYWx1ZSA9IG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgc2tpcChcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gXCIoXCIgKyBwYXJlbnNWYWx1ZSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNPcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaXNPcHRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLmluY2x1ZGVzKFwiLlwiKSAmJiAhdG9rZW4uaW5jbHVkZXMoXCIoXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gdG9rZW4uc3BsaXQoXCIuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uID0gdG9rZW5zWzBdICsgXCIuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BOYW1lID0gcHJvcE5hbWUgPyBwcm9wTmFtZSArPSB0b2tlbiA6IHRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0b2tlbiA9IG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuYW1lID0gcHJvcE5hbWUgPyBvcHRpb24uY29uY2F0KHByb3BOYW1lKSA6IG9wdGlvbjtcbiAgICAgICAgICAgIHZhciBvcHRpb25WYWx1ZSA9IHBhcnNlT3B0aW9uVmFsdWUocGFyZW50LCBuYW1lKTtcbiAgICAgICAgICAgIHByb3BOYW1lID0gcHJvcE5hbWUgJiYgcHJvcE5hbWVbMF0gPT09IFwiLlwiID8gcHJvcE5hbWUuc2xpY2UoMSkgOiBwcm9wTmFtZTtcbiAgICAgICAgICAgIG9wdGlvbiA9IG9wdGlvbiAmJiBvcHRpb25bb3B0aW9uLmxlbmd0aCAtIDFdID09PSBcIi5cIiA/IG9wdGlvbi5zbGljZSgwLCAtMSkgOiBvcHRpb247XG4gICAgICAgICAgICBzZXRQYXJzZWRPcHRpb24ocGFyZW50LCBvcHRpb24sIG9wdGlvblZhbHVlLCBwcm9wTmFtZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VPcHRpb25WYWx1ZShwYXJlbnQsIG5hbWUpIHtcbiAgICAgICAgLy8geyBhOiBcImZvb1wiIGIgeyBjOiBcImJhclwiIH0gfVxuICAgICAgICBpZiAoc2tpcChcIntcIiwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3RSZXN1bHQgPSB7fTtcblxuICAgICAgICAgICAgd2hpbGUgKCFza2lwKFwifVwiLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwibmFtZVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcImVuZCBvZiBpbnB1dFwiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BOYW1lID0gdG9rZW47XG5cbiAgICAgICAgICAgICAgICBza2lwKFwiOlwiLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIGlmIChwZWVrKCkgPT09IFwie1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbiAobXlfb3B0aW9uKSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHJlcGVhdGVkX3ZhbHVlOiBbIFwiZm9vXCIsIFwiYmFyXCIgXVxuICAgICAgICAgICAgICAgICAgICAvLyB9O1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlT3B0aW9uVmFsdWUocGFyZW50LCBuYW1lICsgXCIuXCIgKyB0b2tlbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwZWVrKCkgPT09IFwiW1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChza2lwKFwiW1wiLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHJlYWRWYWx1ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKGxhc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChza2lwKFwiLFwiLCB0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwKFwiXVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdFZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKHBhcmVudCwgbmFtZSArIFwiLlwiICsgdG9rZW4sIGxhc3RWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJlYWRWYWx1ZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0T3B0aW9uKHBhcmVudCwgbmFtZSArIFwiLlwiICsgdG9rZW4sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gb2JqZWN0UmVzdWx0W3Byb3BOYW1lXTtcblxuICAgICAgICAgICAgICAgIGlmIChwcmV2VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gW10uY29uY2F0KHByZXZWYWx1ZSkuY29uY2F0KHZhbHVlKTtcblxuICAgICAgICAgICAgICAgIG9iamVjdFJlc3VsdFtwcm9wTmFtZV0gPSB2YWx1ZTtcblxuICAgICAgICAgICAgICAgIC8vIFNlbWljb2xvbnMgYW5kIGNvbW1hcyBjYW4gYmUgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICBza2lwKFwiLFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaW1wbGVWYWx1ZSA9IHJlYWRWYWx1ZSh0cnVlKTtcbiAgICAgICAgc2V0T3B0aW9uKHBhcmVudCwgbmFtZSwgc2ltcGxlVmFsdWUpO1xuICAgICAgICByZXR1cm4gc2ltcGxlVmFsdWU7XG4gICAgICAgIC8vIERvZXMgbm90IGVuZm9yY2UgYSBkZWxpbWl0ZXIgdG8gYmUgdW5pdmVyc2FsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T3B0aW9uKHBhcmVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHB0ciA9PT0gcGFyZW50ICYmIC9eZmVhdHVyZXNcXC4vLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgIHRvcExldmVsT3B0aW9uc1tuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQuc2V0T3B0aW9uKVxuICAgICAgICAgICAgcGFyZW50LnNldE9wdGlvbihuYW1lLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0UGFyc2VkT3B0aW9uKHBhcmVudCwgbmFtZSwgdmFsdWUsIHByb3BOYW1lKSB7XG4gICAgICAgIGlmIChwYXJlbnQuc2V0UGFyc2VkT3B0aW9uKVxuICAgICAgICAgICAgcGFyZW50LnNldFBhcnNlZE9wdGlvbihuYW1lLCB2YWx1ZSwgcHJvcE5hbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSW5saW5lT3B0aW9ucyhwYXJlbnQpIHtcbiAgICAgICAgaWYgKHNraXAoXCJbXCIsIHRydWUpKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24ocGFyZW50LCBcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKHNraXAoXCIsXCIsIHRydWUpKTtcbiAgICAgICAgICAgIHNraXAoXCJdXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VTZXJ2aWNlKHBhcmVudCwgdG9rZW4pIHtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFuYW1lUmUudGVzdCh0b2tlbiA9IG5leHQoKSkpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKHRva2VuLCBcInNlcnZpY2UgbmFtZVwiKTtcblxuICAgICAgICB2YXIgc2VydmljZSA9IG5ldyBTZXJ2aWNlKHRva2VuKTtcbiAgICAgICAgaWZCbG9jayhzZXJ2aWNlLCBmdW5jdGlvbiBwYXJzZVNlcnZpY2VfYmxvY2sodG9rZW4pIHtcbiAgICAgICAgICAgIGlmIChwYXJzZUNvbW1vbihzZXJ2aWNlLCB0b2tlbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwicnBjXCIpXG4gICAgICAgICAgICAgICAgcGFyc2VNZXRob2Qoc2VydmljZSwgdG9rZW4pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyZW50LmFkZChzZXJ2aWNlKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gcHRyKSB7XG4gICAgICAgICAgICB0b3BMZXZlbE9iamVjdHMucHVzaChzZXJ2aWNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlTWV0aG9kKHBhcmVudCwgdG9rZW4pIHtcbiAgICAgICAgLy8gR2V0IHRoZSBjb21tZW50IG9mIHRoZSBwcmVjZWRpbmcgbGluZSBub3cgKGlmIG9uZSBleGlzdHMpIGluIGNhc2UgdGhlXG4gICAgICAgIC8vIG1ldGhvZCBpcyBkZWZpbmVkIGFjcm9zcyBtdWx0aXBsZSBsaW5lcy5cbiAgICAgICAgdmFyIGNvbW1lbnRUZXh0ID0gY21udCgpO1xuXG4gICAgICAgIHZhciB0eXBlID0gdG9rZW47XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbmFtZVJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbiwgXCJuYW1lXCIpO1xuXG4gICAgICAgIHZhciBuYW1lID0gdG9rZW4sXG4gICAgICAgICAgICByZXF1ZXN0VHlwZSwgcmVxdWVzdFN0cmVhbSxcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZSwgcmVzcG9uc2VTdHJlYW07XG5cbiAgICAgICAgc2tpcChcIihcIik7XG4gICAgICAgIGlmIChza2lwKFwic3RyZWFtXCIsIHRydWUpKVxuICAgICAgICAgICAgcmVxdWVzdFN0cmVhbSA9IHRydWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgcmVxdWVzdFR5cGUgPSB0b2tlbjtcbiAgICAgICAgc2tpcChcIilcIik7IHNraXAoXCJyZXR1cm5zXCIpOyBza2lwKFwiKFwiKTtcbiAgICAgICAgaWYgKHNraXAoXCJzdHJlYW1cIiwgdHJ1ZSkpXG4gICAgICAgICAgICByZXNwb25zZVN0cmVhbSA9IHRydWU7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghdHlwZVJlZlJlLnRlc3QodG9rZW4gPSBuZXh0KCkpKVxuICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgcmVzcG9uc2VUeXBlID0gdG9rZW47XG4gICAgICAgIHNraXAoXCIpXCIpO1xuXG4gICAgICAgIHZhciBtZXRob2QgPSBuZXcgTWV0aG9kKG5hbWUsIHR5cGUsIHJlcXVlc3RUeXBlLCByZXNwb25zZVR5cGUsIHJlcXVlc3RTdHJlYW0sIHJlc3BvbnNlU3RyZWFtKTtcbiAgICAgICAgbWV0aG9kLmNvbW1lbnQgPSBjb21tZW50VGV4dDtcbiAgICAgICAgaWZCbG9jayhtZXRob2QsIGZ1bmN0aW9uIHBhcnNlTWV0aG9kX2Jsb2NrKHRva2VuKSB7XG5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodG9rZW4gPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbihtZXRob2QsIHRva2VuKTtcbiAgICAgICAgICAgICAgICBza2lwKFwiO1wiKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgIH0pO1xuICAgICAgICBwYXJlbnQuYWRkKG1ldGhvZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2VFeHRlbnNpb24ocGFyZW50LCB0b2tlbikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXR5cGVSZWZSZS50ZXN0KHRva2VuID0gbmV4dCgpKSlcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4sIFwicmVmZXJlbmNlXCIpO1xuXG4gICAgICAgIHZhciByZWZlcmVuY2UgPSB0b2tlbjtcbiAgICAgICAgaWZCbG9jayhudWxsLCBmdW5jdGlvbiBwYXJzZUV4dGVuc2lvbl9ibG9jayh0b2tlbikge1xuICAgICAgICAgICAgc3dpdGNoICh0b2tlbikge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcXVpcmVkXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlcGVhdGVkXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQocGFyZW50LCB0b2tlbiwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwib3B0aW9uYWxcIjpcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGl0aW9uID09PSBcInByb3RvM1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUZpZWxkKHBhcmVudCwgXCJwcm90bzNfb3B0aW9uYWxcIiwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRmllbGQocGFyZW50LCBcIm9wdGlvbmFsXCIsIHJlZmVyZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRpb24gPT09IFwicHJvdG8yXCIgfHwgIXR5cGVSZWZSZS50ZXN0KHRva2VuKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBwdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWVsZChwYXJlbnQsIFwib3B0aW9uYWxcIiwgcmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0b2tlbjtcbiAgICB3aGlsZSAoKHRva2VuID0gbmV4dCgpKSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG5cbiAgICAgICAgICAgIGNhc2UgXCJwYWNrYWdlXCI6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VQYWNrYWdlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCJpbXBvcnRcIjpcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghaGVhZClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG5cbiAgICAgICAgICAgICAgICBwYXJzZUltcG9ydCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwic3ludGF4XCI6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuXG4gICAgICAgICAgICAgICAgcGFyc2VTeW50YXgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcImVkaXRpb25cIjpcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAoIWhlYWQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IGlsbGVnYWwodG9rZW4pO1xuICAgICAgICAgICAgICAgIHBhcnNlRWRpdGlvbigpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwib3B0aW9uXCI6XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb24ocHRyLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgc2tpcChcIjtcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG5cbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZUNvbW1vbihwdHIsIHRva2VuKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbCh0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXNvbHZlRmlsZUZlYXR1cmVzKCk7XG5cbiAgICBwYXJzZS5maWxlbmFtZSA9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJwYWNrYWdlXCIgICAgIDogcGtnLFxuICAgICAgICBcImltcG9ydHNcIiAgICAgOiBpbXBvcnRzLFxuICAgICAgICAgd2Vha0ltcG9ydHMgIDogd2Vha0ltcG9ydHMsXG4gICAgICAgICByb290ICAgICAgICAgOiByb290XG4gICAgfTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgdGhlIGdpdmVuIC5wcm90byBzb3VyY2UgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIHBhcnNlZCBjb250ZW50cy5cbiAqIEBuYW1lIHBhcnNlXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlIGNvbnRlbnRzXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cbiAqIEByZXR1cm5zIHtJUGFyc2VyUmVzdWx0fSBQYXJzZXIgcmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gZmlsZW5hbWU9bnVsbCBDdXJyZW50bHkgcHJvY2Vzc2luZyBmaWxlIG5hbWUgZm9yIGVycm9yIHJlcG9ydGluZywgaWYga25vd25cbiAqIEBwcm9wZXJ0eSB7SVBhcnNlT3B0aW9uc30gZGVmYXVsdHMgRGVmYXVsdCB7QGxpbmsgSVBhcnNlT3B0aW9uc31cbiAqIEB2YXJpYXRpb24gMlxuICovXG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInBhcnNlIiwiZmlsZW5hbWUiLCJkZWZhdWx0cyIsImtlZXBDYXNlIiwidG9rZW5pemUiLCJyZXF1aXJlIiwiUm9vdCIsIlR5cGUiLCJGaWVsZCIsIk1hcEZpZWxkIiwiT25lT2YiLCJFbnVtIiwiU2VydmljZSIsIk1ldGhvZCIsIlJlZmxlY3Rpb25PYmplY3QiLCJ0eXBlcyIsInV0aWwiLCJiYXNlMTBSZSIsImJhc2UxME5lZ1JlIiwiYmFzZTE2UmUiLCJiYXNlMTZOZWdSZSIsImJhc2U4UmUiLCJiYXNlOE5lZ1JlIiwibnVtYmVyUmUiLCJuYW1lUmUiLCJ0eXBlUmVmUmUiLCJzb3VyY2UiLCJyb290Iiwib3B0aW9ucyIsInByZWZlclRyYWlsaW5nQ29tbWVudCIsInRuIiwiYWx0ZXJuYXRlQ29tbWVudE1vZGUiLCJuZXh0IiwicHVzaCIsInBlZWsiLCJza2lwIiwiY21udCIsImhlYWQiLCJwa2ciLCJpbXBvcnRzIiwid2Vha0ltcG9ydHMiLCJlZGl0aW9uIiwicHRyIiwidG9wTGV2ZWxPYmplY3RzIiwidG9wTGV2ZWxPcHRpb25zIiwiYXBwbHlDYXNlIiwibmFtZSIsImNhbWVsQ2FzZSIsInJlc29sdmVGaWxlRmVhdHVyZXMiLCJmb3JFYWNoIiwib2JqIiwiX2VkaXRpb24iLCJPYmplY3QiLCJrZXlzIiwib3B0IiwiZ2V0T3B0aW9uIiwidW5kZWZpbmVkIiwic2V0T3B0aW9uIiwiaWxsZWdhbCIsInRva2VuIiwiaW5zaWRlVHJ5Q2F0Y2giLCJFcnJvciIsImxpbmUiLCJyZWFkU3RyaW5nIiwidmFsdWVzIiwiam9pbiIsInJlYWRWYWx1ZSIsImFjY2VwdFR5cGVSZWYiLCJwYXJzZU51bWJlciIsImUiLCJ0ZXN0IiwicmVhZFJhbmdlcyIsInRhcmdldCIsImFjY2VwdFN0cmluZ3MiLCJzdGFydCIsInN0ciIsInBhcnNlSWQiLCJlcnIiLCJkdW1teSIsInZhbHVlIiwiaWZCbG9jayIsInBhcnNlUmFuZ2VfYmxvY2siLCJwYXJzZU9wdGlvbiIsInBhcnNlUmFuZ2VfbGluZSIsInBhcnNlSW5saW5lT3B0aW9ucyIsInNpZ24iLCJjaGFyQXQiLCJzdWJzdHJpbmciLCJJbmZpbml0eSIsIk5hTiIsInBhcnNlSW50IiwicGFyc2VGbG9hdCIsImFjY2VwdE5lZ2F0aXZlIiwicGFyc2VQYWNrYWdlIiwiZGVmaW5lIiwicGFyc2VJbXBvcnQiLCJ3aGljaEltcG9ydHMiLCJwYXJzZVN5bnRheCIsInBhcnNlRWRpdGlvbiIsInN1cHBvcnRlZEVkaXRpb25zIiwiaW5jbHVkZXMiLCJwYXJzZUNvbW1vbiIsInBhcmVudCIsInBhcnNlVHlwZSIsInBhcnNlRW51bSIsInBhcnNlU2VydmljZSIsInBhcnNlRXh0ZW5zaW9uIiwiZm5JZiIsImZuRWxzZSIsInRyYWlsaW5nTGluZSIsImNvbW1lbnQiLCJ0eXBlIiwicGFyc2VUeXBlX2Jsb2NrIiwicGFyc2VNYXBGaWVsZCIsInBhcnNlRmllbGQiLCJwYXJzZU9uZU9mIiwiZXh0ZW5zaW9ucyIsInJlc2VydmVkIiwiYWRkIiwicnVsZSIsImV4dGVuZCIsInBhcnNlR3JvdXAiLCJlbmRzV2l0aCIsInN0YXJ0c1dpdGgiLCJmaWVsZCIsInBhcnNlRmllbGRfYmxvY2siLCJwYXJzZUZpZWxkX2xpbmUiLCJvbmVvZiIsImZpZWxkTmFtZSIsImxjRmlyc3QiLCJ1Y0ZpcnN0IiwiaWQiLCJncm91cCIsInBhcnNlR3JvdXBfYmxvY2siLCJrZXlUeXBlIiwibWFwS2V5IiwidmFsdWVUeXBlIiwicGFyc2VNYXBGaWVsZF9ibG9jayIsInBhcnNlTWFwRmllbGRfbGluZSIsInBhcnNlT25lT2ZfYmxvY2siLCJlbm0iLCJwYXJzZUVudW1fYmxvY2siLCJwYXJzZUVudW1WYWx1ZSIsInByb3RvdHlwZSIsImNhbGwiLCJzZXRQYXJzZWRPcHRpb24iLCJwYXJzZUVudW1WYWx1ZV9ibG9jayIsInBhcnNlRW51bVZhbHVlX2xpbmUiLCJwYXJzZWRPcHRpb25zIiwib3B0aW9uIiwicHJvcE5hbWUiLCJpc09wdGlvbiIsInBhcmVuc1ZhbHVlIiwidG9rZW5zIiwic3BsaXQiLCJjb25jYXQiLCJvcHRpb25WYWx1ZSIsInBhcnNlT3B0aW9uVmFsdWUiLCJzbGljZSIsImxlbmd0aCIsIm9iamVjdFJlc3VsdCIsImxhc3RWYWx1ZSIsInByZXZWYWx1ZSIsInNpbXBsZVZhbHVlIiwic2VydmljZSIsInBhcnNlU2VydmljZV9ibG9jayIsInBhcnNlTWV0aG9kIiwiY29tbWVudFRleHQiLCJyZXF1ZXN0VHlwZSIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVN0cmVhbSIsIm1ldGhvZCIsInBhcnNlTWV0aG9kX2Jsb2NrIiwicmVmZXJlbmNlIiwicGFyc2VFeHRlbnNpb25fYmxvY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Reader;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\nvar BufferReader; // cyclic\nvar LongBits = util.LongBits, utf8 = util.utf8;\n/* istanbul ignore next */ function indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */ function Reader(buffer) {\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */ this.buf = buffer;\n    /**\n     * Read buffer position.\n     * @type {number}\n     */ this.pos = 0;\n    /**\n     * Read buffer length.\n     * @type {number}\n     */ this.len = buffer.length;\n}\nvar create_array = typeof Uint8Array !== \"undefined\" ? function create_typed_array(buffer) {\n    if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);\n    throw Error(\"illegal buffer\");\n} : function create_array(buffer) {\n    if (Array.isArray(buffer)) return new Reader(buffer);\n    throw Error(\"illegal buffer\");\n};\nvar create = function create() {\n    return util.Buffer ? function create_buffer_setup(buffer) {\n        return (Reader.create = function create_buffer(buffer) {\n            return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer);\n        })(buffer);\n    } : create_array;\n};\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */ Reader.create = create();\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.uint32 = function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (this.buf[this.pos] & 127) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;\n        if (this.buf[this.pos++] < 128) return value;\n        /* istanbul ignore if */ if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n}();\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */ Reader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */ Reader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n/* eslint-disable no-invalid-this */ function readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) {\n        for(; i < 4; ++i){\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;\n        if (this.buf[this.pos++] < 128) return bits;\n        i = 0;\n    } else {\n        for(; i < 3; ++i){\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) {\n        for(; i < 5; ++i){\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n    } else {\n        for(; i < 5; ++i){\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128) return bits;\n        }\n    }\n    /* istanbul ignore next */ throw Error(\"invalid varint encoding\");\n}\n/* eslint-enable no-invalid-this */ /**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */ Reader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\nfunction readFixed32_end(buf, end) {\n    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;\n}\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */ Reader.prototype.fixed32 = function read_fixed32() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */ Reader.prototype.sfixed32 = function read_sfixed32() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n/* eslint-disable no-invalid-this */ function readFixed64() {\n    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n/* eslint-enable no-invalid-this */ /**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */ /**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.float = function read_float() {\n    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */ Reader.prototype.double = function read_double() {\n    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */ Reader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(), start = this.pos, end = this.pos + length;\n    /* istanbul ignore if */ if (end > this.len) throw indexOutOfRange(this, length);\n    this.pos += length;\n    if (Array.isArray(this.buf)) return this.buf.slice(start, end);\n    if (start === end) {\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */ Reader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */ Reader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */ if (this.pos + length > this.len) throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);\n        }while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */ Reader.prototype.skipType = function(wireType) {\n    switch(wireType){\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while((wireType = this.uint32() & 7) !== 4){\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n        /* istanbul ignore next */ default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n    });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsT0FBWUMsbUJBQU9BLENBQUMsc0dBQWdCO0FBRXhDLElBQUlDLGNBQWMsU0FBUztBQUUzQixJQUFJQyxXQUFZSCxLQUFLRyxRQUFRLEVBQ3pCQyxPQUFZSixLQUFLSSxJQUFJO0FBRXpCLHdCQUF3QixHQUN4QixTQUFTQyxnQkFBZ0JDLE1BQU0sRUFBRUMsV0FBVztJQUN4QyxPQUFPQyxXQUFXLHlCQUF5QkYsT0FBT0csR0FBRyxHQUFHLFFBQVNGLENBQUFBLGVBQWUsS0FBSyxRQUFRRCxPQUFPSSxHQUFHO0FBQzNHO0FBRUE7Ozs7O0NBS0MsR0FDRCxTQUFTWCxPQUFPWSxNQUFNO0lBRWxCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsR0FBRyxHQUFHRDtJQUVYOzs7S0FHQyxHQUNELElBQUksQ0FBQ0YsR0FBRyxHQUFHO0lBRVg7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxHQUFHLEdBQUdDLE9BQU9FLE1BQU07QUFDNUI7QUFFQSxJQUFJQyxlQUFlLE9BQU9DLGVBQWUsY0FDbkMsU0FBU0MsbUJBQW1CTCxNQUFNO0lBQ2hDLElBQUlBLGtCQUFrQkksY0FBY0UsTUFBTUMsT0FBTyxDQUFDUCxTQUM5QyxPQUFPLElBQUlaLE9BQU9ZO0lBQ3RCLE1BQU1RLE1BQU07QUFDaEIsSUFFRSxTQUFTTCxhQUFhSCxNQUFNO0lBQzFCLElBQUlNLE1BQU1DLE9BQU8sQ0FBQ1AsU0FDZCxPQUFPLElBQUlaLE9BQU9ZO0lBQ3RCLE1BQU1RLE1BQU07QUFDaEI7QUFFSixJQUFJQyxTQUFTLFNBQVNBO0lBQ2xCLE9BQU9wQixLQUFLcUIsTUFBTSxHQUNaLFNBQVNDLG9CQUFvQlgsTUFBTTtRQUNqQyxPQUFPLENBQUNaLE9BQU9xQixNQUFNLEdBQUcsU0FBU0cs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RUFZLFVBQVUsU0FBU0M7WUFDZixPQUFPbkMsWUFBWWEsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDUyxHQUFHLENBQUM7UUFDdEM7SUFFSjtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlci5qcz84ODRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBSZWFkZXI7XG5cbnZhciB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsL21pbmltYWxcIik7XG5cbnZhciBCdWZmZXJSZWFkZXI7IC8vIGN5Y2xpY1xuXG52YXIgTG9uZ0JpdHMgID0gdXRpbC5Mb25nQml0cyxcbiAgICB1dGY4ICAgICAgPSB1dGlsLnV0Zjg7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBpbmRleE91dE9mUmFuZ2UocmVhZGVyLCB3cml0ZUxlbmd0aCkge1xuICAgIHJldHVybiBSYW5nZUVycm9yKFwiaW5kZXggb3V0IG9mIHJhbmdlOiBcIiArIHJlYWRlci5wb3MgKyBcIiArIFwiICsgKHdyaXRlTGVuZ3RoIHx8IDEpICsgXCIgPiBcIiArIHJlYWRlci5sZW4pO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgcmVhZGVyIGluc3RhbmNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCByZWFkZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gUmVhZGVyKGJ1ZmZlcikge1xuXG4gICAgLyoqXG4gICAgICogUmVhZCBidWZmZXIuXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5idWYgPSBidWZmZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlciBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucG9zID0gMDtcblxuICAgIC8qKlxuICAgICAqIFJlYWQgYnVmZmVyIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gYnVmZmVyLmxlbmd0aDtcbn1cblxudmFyIGNyZWF0ZV9hcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBmdW5jdGlvbiBjcmVhdGVfdHlwZWRfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChidWZmZXIgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IEFycmF5LmlzQXJyYXkoYnVmZmVyKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgICAgIHRocm93IEVycm9yKFwiaWxsZWdhbCBidWZmZXJcIik7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoYnVmZmVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1ZmZlcikpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgICAgICB0aHJvdyBFcnJvcihcImlsbGVnYWwgYnVmZmVyXCIpO1xuICAgIH07XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cChidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAoUmVhZGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuQnVmZmVyLmlzQnVmZmVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgPyBuZXcgQnVmZmVyUmVhZGVyKGJ1ZmZlcilcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICAgICAgOiBjcmVhdGVfYXJyYXkoYnVmZmVyKTtcbiAgICAgICAgICAgIH0pKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBjcmVhdGVfYXJyYXk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcmVhZGVyIHVzaW5nIHRoZSBzcGVjaWZpZWQgYnVmZmVyLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl8QnVmZmVyfSBidWZmZXIgQnVmZmVyIHRvIHJlYWQgZnJvbVxuICogQHJldHVybnMge1JlYWRlcnxCdWZmZXJSZWFkZXJ9IEEge0BsaW5rIEJ1ZmZlclJlYWRlcn0gaWYgYGJ1ZmZlcmAgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBhIHtAbGluayBSZWFkZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gSWYgYGJ1ZmZlcmAgaXMgbm90IGEgdmFsaWQgYnVmZmVyXG4gKi9cblJlYWRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuUmVhZGVyLnByb3RvdHlwZS5fc2xpY2UgPSB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLkFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS51aW50MzIgPSAoZnVuY3Rpb24gcmVhZF91aW50MzJfc2V0dXAoKSB7XG4gICAgdmFyIHZhbHVlID0gNDI5NDk2NzI5NTsgLy8gb3B0aW1pemVyIHR5cGUtaGludCwgdGVuZHMgdG8gZGVvcHQgb3RoZXJ3aXNlICg/ISlcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVhZF91aW50MzIoKSB7XG4gICAgICAgIHZhbHVlID0gKCAgICAgICAgIHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNyAgICAgICApID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCAgNykgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDE0KSA+Pj4gMDsgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KSByZXR1cm4gdmFsdWU7XG4gICAgICAgIHZhbHVlID0gKHZhbHVlIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgMjEpID4+PiAwOyBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgIDE1KSA8PCAyOCkgPj4+IDA7IGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOCkgcmV0dXJuIHZhbHVlO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoKHRoaXMucG9zICs9IDUpID4gdGhpcy5sZW4pIHtcbiAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5sZW47XG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgMTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhIHNpZ25lZCAzMiBiaXQgdmFsdWUuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuaW50MzIgPSBmdW5jdGlvbiByZWFkX2ludDMyKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbn07XG5cbi8qKlxuICogUmVhZHMgYSB6aWctemFnIGVuY29kZWQgdmFyaW50IGFzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5zaW50MzIgPSBmdW5jdGlvbiByZWFkX3NpbnQzMigpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLnVpbnQzMigpO1xuICAgIHJldHVybiB2YWx1ZSA+Pj4gMSBeIC0odmFsdWUgJiAxKSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZExvbmdWYXJpbnQoKSB7XG4gICAgLy8gdGVuZHMgdG8gZGVvcHQgd2l0aCBsb2NhbCB2YXJzIGZvciBvY3RldCBldGMuXG4gICAgdmFyIGJpdHMgPSBuZXcgTG9uZ0JpdHMoMCwgMCk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGlmICh0aGlzLmxlbiAtIHRoaXMucG9zID4gNCkgeyAvLyBmYXN0IHJvdXRlIChsbylcbiAgICAgICAgZm9yICg7IGkgPCA0OyArK2kpIHtcbiAgICAgICAgICAgIC8vIDFzdC4uNHRoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNXRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvc10gJiAxMjcpIDw8IDI4KSA+Pj4gMDtcbiAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPj4gIDQpID4+PiAwO1xuICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgaSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCAzOyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDFzdC4uM3RoXG4gICAgICAgICAgICBiaXRzLmxvID0gKGJpdHMubG8gfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNykgPj4+IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5idWZbdGhpcy5wb3MrK10gPCAxMjgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gNHRoXG4gICAgICAgIGJpdHMubG8gPSAoYml0cy5sbyB8ICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSAmIDEyNykgPDwgaSAqIDcpID4+PiAwO1xuICAgICAgICByZXR1cm4gYml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMubGVuIC0gdGhpcy5wb3MgPiA0KSB7IC8vIGZhc3Qgcm91dGUgKGhpKVxuICAgICAgICBmb3IgKDsgaSA8IDU7ICsraSkge1xuICAgICAgICAgICAgLy8gNnRoLi4xMHRoXG4gICAgICAgICAgICBiaXRzLmhpID0gKGJpdHMuaGkgfCAodGhpcy5idWZbdGhpcy5wb3NdICYgMTI3KSA8PCBpICogNyArIDMpID4+PiAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVmW3RoaXMucG9zKytdIDwgMTI4KVxuICAgICAgICAgICAgICAgIHJldHVybiBiaXRzO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCA1OyArK2kpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgICAgIC8vIDZ0aC4uMTB0aFxuICAgICAgICAgICAgYml0cy5oaSA9IChiaXRzLmhpIHwgKHRoaXMuYnVmW3RoaXMucG9zXSAmIDEyNykgPDwgaSAqIDcgKyAzKSA+Pj4gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zlt0aGlzLnBvcysrXSA8IDEyOClcbiAgICAgICAgICAgICAgICByZXR1cm4gYml0cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHRocm93IEVycm9yKFwiaW52YWxpZCB2YXJpbnQgZW5jb2RpbmdcIik7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI2ludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHZhcmludCBhcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUuXG4gKiBAbmFtZSBSZWFkZXIjdWludDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyBhIHppZy16YWcgZW5jb2RlZCB2YXJpbnQgYXMgYSBzaWduZWQgNjQgYml0IHZhbHVlLlxuICogQG5hbWUgUmVhZGVyI3NpbnQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSB2YXJpbnQgYXMgYSBib29sZWFuLlxuICogQHJldHVybnMge2Jvb2xlYW59IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gcmVhZF9ib29sKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpICE9PSAwO1xufTtcblxuZnVuY3Rpb24gcmVhZEZpeGVkMzJfZW5kKGJ1ZiwgZW5kKSB7IC8vIG5vdGUgdGhhdCB0aGlzIHVzZXMgYGVuZGAsIG5vdCBgcG9zYFxuICAgIHJldHVybiAoYnVmW2VuZCAtIDRdXG4gICAgICAgICAgfCBidWZbZW5kIC0gM10gPDwgOFxuICAgICAgICAgIHwgYnVmW2VuZCAtIDJdIDw8IDE2XG4gICAgICAgICAgfCBidWZbZW5kIC0gMV0gPDwgMjQpID4+PiAwO1xufVxuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHJlYWRfZml4ZWQzMigpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgcmV0dXJuIHJlYWRGaXhlZDMyX2VuZCh0aGlzLmJ1ZiwgdGhpcy5wb3MgKz0gNCk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGZpeGVkIDMyIGJpdHMgYXMgYSBzaWduZWQgMzIgYml0IGludGVnZXIuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBWYWx1ZSByZWFkXG4gKi9cblJlYWRlci5wcm90b3R5cGUuc2ZpeGVkMzIgPSBmdW5jdGlvbiByZWFkX3NmaXhlZDMyKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgNCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICByZXR1cm4gcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSB8IDA7XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1pbnZhbGlkLXRoaXMgKi9cblxuZnVuY3Rpb24gcmVhZEZpeGVkNjQoLyogdGhpczogUmVhZGVyICovKSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5wb3MgKyA4ID4gdGhpcy5sZW4pXG4gICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzLCA4KTtcblxuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMocmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSwgcmVhZEZpeGVkMzJfZW5kKHRoaXMuYnVmLCB0aGlzLnBvcyArPSA0KSk7XG59XG5cbi8qIGVzbGludC1lbmFibGUgbm8taW52YWxpZC10aGlzICovXG5cbi8qKlxuICogUmVhZHMgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNmaXhlZDY0XG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtMb25nfSBWYWx1ZSByZWFkXG4gKi9cblxuLyoqXG4gKiBSZWFkcyB6aWctemFnIGVuY29kZWQgZml4ZWQgNjQgYml0cy5cbiAqIEBuYW1lIFJlYWRlciNzZml4ZWQ2NFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7TG9uZ30gVmFsdWUgcmVhZFxuICovXG5cbi8qKlxuICogUmVhZHMgYSBmbG9hdCAoMzIgYml0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmZsb2F0ID0gZnVuY3Rpb24gcmVhZF9mbG9hdCgpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0aGlzLnBvcyArIDQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIDQpO1xuXG4gICAgdmFyIHZhbHVlID0gdXRpbC5mbG9hdC5yZWFkRmxvYXRMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDQ7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KSBhcyBhIG51bWJlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge251bWJlcn0gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLmRvdWJsZSA9IGZ1bmN0aW9uIHJlYWRfZG91YmxlKCkge1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHRoaXMucG9zICsgOCA+IHRoaXMubGVuKVxuICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgNCk7XG5cbiAgICB2YXIgdmFsdWUgPSB1dGlsLmZsb2F0LnJlYWREb3VibGVMRSh0aGlzLmJ1ZiwgdGhpcy5wb3MpO1xuICAgIHRoaXMucG9zICs9IDg7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHNlcXVlbmNlIG9mIGJ5dGVzIHByZWNlZWRlZCBieSBpdHMgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9IFZhbHVlIHJlYWRcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHJlYWRfYnl0ZXMoKSB7XG4gICAgdmFyIGxlbmd0aCA9IHRoaXMudWludDMyKCksXG4gICAgICAgIHN0YXJ0ICA9IHRoaXMucG9zLFxuICAgICAgICBlbmQgICAgPSB0aGlzLnBvcyArIGxlbmd0aDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChlbmQgPiB0aGlzLmxlbilcbiAgICAgICAgdGhyb3cgaW5kZXhPdXRPZlJhbmdlKHRoaXMsIGxlbmd0aCk7XG5cbiAgICB0aGlzLnBvcyArPSBsZW5ndGg7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5idWYpKSAvLyBwbGFpbiBhcnJheVxuICAgICAgICByZXR1cm4gdGhpcy5idWYuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICBpZiAoc3RhcnQgPT09IGVuZCkgeyAvLyBmaXggZm9yIElFIDEwL1dpbjggYW5kIG90aGVycycgc3ViYXJyYXkgcmV0dXJuaW5nIGFycmF5IG9mIHNpemUgMVxuICAgICAgICB2YXIgbmF0aXZlQnVmZmVyID0gdXRpbC5CdWZmZXI7XG4gICAgICAgIHJldHVybiBuYXRpdmVCdWZmZXJcbiAgICAgICAgICAgID8gbmF0aXZlQnVmZmVyLmFsbG9jKDApXG4gICAgICAgICAgICA6IG5ldyB0aGlzLmJ1Zi5jb25zdHJ1Y3RvcigwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3NsaWNlLmNhbGwodGhpcy5idWYsIHN0YXJ0LCBlbmQpO1xufTtcblxuLyoqXG4gKiBSZWFkcyBhIHN0cmluZyBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge3N0cmluZ30gVmFsdWUgcmVhZFxuICovXG5SZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nKCkge1xuICAgIHZhciBieXRlcyA9IHRoaXMuYnl0ZXMoKTtcbiAgICByZXR1cm4gdXRmOC5yZWFkKGJ5dGVzLCAwLCBieXRlcy5sZW5ndGgpO1xufTtcblxuLyoqXG4gKiBTa2lwcyB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiBieXRlcyBpZiBzcGVjaWZpZWQsIG90aGVyd2lzZSBza2lwcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoXSBMZW5ndGggaWYga25vd24sIG90aGVyd2lzZSBhIHZhcmludCBpcyBhc3N1bWVkXG4gKiBAcmV0dXJucyB7UmVhZGVyfSBgdGhpc2BcbiAqL1xuUmVhZGVyLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gc2tpcChsZW5ndGgpIHtcbiAgICBpZiAodHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHRoaXMucG9zICsgbGVuZ3RoID4gdGhpcy5sZW4pXG4gICAgICAgICAgICB0aHJvdyBpbmRleE91dE9mUmFuZ2UodGhpcywgbGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMubGVuKVxuICAgICAgICAgICAgICAgIHRocm93IGluZGV4T3V0T2ZSYW5nZSh0aGlzKTtcbiAgICAgICAgfSB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAxMjgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2tpcHMgdGhlIG5leHQgZWxlbWVudCBvZiB0aGUgc3BlY2lmaWVkIHdpcmUgdHlwZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB3aXJlVHlwZSBXaXJlIHR5cGUgcmVjZWl2ZWRcbiAqIEByZXR1cm5zIHtSZWFkZXJ9IGB0aGlzYFxuICovXG5SZWFkZXIucHJvdG90eXBlLnNraXBUeXBlID0gZnVuY3Rpb24od2lyZVR5cGUpIHtcbiAgICBzd2l0Y2ggKHdpcmVUeXBlKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICB0aGlzLnNraXAodGhpcy51aW50MzIoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgd2hpbGUgKCh3aXJlVHlwZSA9IHRoaXMudWludDMyKCkgJiA3KSAhPT0gNCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcFR5cGUod2lyZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHRoaXMuc2tpcCg0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImludmFsaWQgd2lyZSB0eXBlIFwiICsgd2lyZVR5cGUgKyBcIiBhdCBvZmZzZXQgXCIgKyB0aGlzLnBvcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbihCdWZmZXJSZWFkZXJfKSB7XG4gICAgQnVmZmVyUmVhZGVyID0gQnVmZmVyUmVhZGVyXztcbiAgICBSZWFkZXIuY3JlYXRlID0gY3JlYXRlKCk7XG4gICAgQnVmZmVyUmVhZGVyLl9jb25maWd1cmUoKTtcblxuICAgIHZhciBmbiA9IHV0aWwuTG9uZyA/IFwidG9Mb25nXCIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBcInRvTnVtYmVyXCI7XG4gICAgdXRpbC5tZXJnZShSZWFkZXIucHJvdG90eXBlLCB7XG5cbiAgICAgICAgaW50NjQ6IGZ1bmN0aW9uIHJlYWRfaW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVpbnQ2NDogZnVuY3Rpb24gcmVhZF91aW50NjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZExvbmdWYXJpbnQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ludDY0OiBmdW5jdGlvbiByZWFkX3NpbnQ2NCgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkTG9uZ1ZhcmludC5jYWxsKHRoaXMpLnp6RGVjb2RlKClbZm5dKGZhbHNlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBmaXhlZDY0OiBmdW5jdGlvbiByZWFkX2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0odHJ1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2ZpeGVkNjQ6IGZ1bmN0aW9uIHJlYWRfc2ZpeGVkNjQoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZEZpeGVkNjQuY2FsbCh0aGlzKVtmbl0oZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICB9KTtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIlJlYWRlciIsInV0aWwiLCJyZXF1aXJlIiwiQnVmZmVyUmVhZGVyIiwiTG9uZ0JpdHMiLCJ1dGY4IiwiaW5kZXhPdXRPZlJhbmdlIiwicmVhZGVyIiwid3JpdGVMZW5ndGgiLCJSYW5nZUVycm9yIiwicG9zIiwibGVuIiwiYnVmZmVyIiwiYnVmIiwibGVuZ3RoIiwiY3JlYXRlX2FycmF5IiwiVWludDhBcnJheSIsImNyZWF0ZV90eXBlZF9hcnJheSIsIkFycmF5IiwiaXNBcnJheSIsIkVycm9yIiwiY3JlYXRlIiwiQnVmZmVyIiwiY3JlYXRlX2J1ZmZlcl9zZXR1cCIsImNyZWF0ZV9idWZmZXIiLCJpc0J1ZmZlciIsInByb3RvdHlwZSIsIl9zbGljZSIsInN1YmFycmF5Iiwic2xpY2UiLCJ1aW50MzIiLCJyZWFkX3VpbnQzMl9zZXR1cCIsInZhbHVlIiwicmVhZF91aW50MzIiLCJpbnQzMiIsInJlYWRfaW50MzIiLCJzaW50MzIiLCJyZWFkX3NpbnQzMiIsInJlYWRMb25nVmFyaW50IiwiYml0cyIsImkiLCJsbyIsImhpIiwiYm9vbCIsInJlYWRfYm9vbCIsInJlYWRGaXhlZDMyX2VuZCIsImVuZCIsImZpeGVkMzIiLCJyZWFkX2ZpeGVkMzIiLCJzZml4ZWQzMiIsInJlYWRfc2ZpeGVkMzIiLCJyZWFkRml4ZWQ2NCIsImZsb2F0IiwicmVhZF9mbG9hdCIsInJlYWRGbG9hdExFIiwiZG91YmxlIiwicmVhZF9kb3VibGUiLCJyZWFkRG91YmxlTEUiLCJieXRlcyIsInJlYWRfYnl0ZXMiLCJzdGFydCIsIm5hdGl2ZUJ1ZmZlciIsImFsbG9jIiwiY29uc3RydWN0b3IiLCJjYWxsIiwic3RyaW5nIiwicmVhZF9zdHJpbmciLCJyZWFkIiwic2tpcCIsInNraXBUeXBlIiwid2lyZVR5cGUiLCJfY29uZmlndXJlIiwiQnVmZmVyUmVhZGVyXyIsImZuIiwiTG9uZyIsIm1lcmdlIiwiaW50NjQiLCJyZWFkX2ludDY0IiwidWludDY0IiwicmVhZF91aW50NjQiLCJzaW50NjQiLCJyZWFkX3NpbnQ2NCIsInp6RGVjb2RlIiwiZml4ZWQ2NCIsInJlYWRfZml4ZWQ2NCIsInNmaXhlZDY0IiwicmVhZF9zZml4ZWQ2NCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader_buffer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader_buffer.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = BufferReader;\n// extends Reader\nvar Reader = __webpack_require__(/*! ./reader */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */ function BufferReader(buffer) {\n    Reader.call(this, buffer);\n/**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */ }\nBufferReader._configure = function() {\n    /* istanbul ignore else */ if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n/**\n * @override\n */ BufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */ BufferReader._configure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcmVhZGVyX2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLGlCQUFpQjtBQUNqQixJQUFJQyxTQUFTQyxtQkFBT0EsQ0FBQywwRkFBVTtBQUM5QkYsQ0FBQUEsYUFBYUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLE9BQU9FLFNBQVMsR0FBR0csV0FBVyxHQUFHTjtBQUV6RSxJQUFJTyxPQUFPTCxtQkFBT0EsQ0FBQyxzR0FBZ0I7QUFFbkM7Ozs7OztDQU1DLEdBQ0QsU0FBU0YsYUFBYVEsTUFBTTtJQUN4QlAsT0FBT1EsSUFBSSxDQUFDLElBQUksRUFBRUQ7QUFFbEI7Ozs7S0FJQyxHQUNMO0FBRUFSLGFBQWFVLFVBQVUsR0FBRztJQUN0Qix3QkFBd0IsR0FDeEIsSUFBSUgsS0FBS0ksTUFBTSxFQUNYWCxhQUFhRyxTQUFTLENBQUNTLE1BQU0sR0FBR0wsS0FBS0ksTUFBTSxDQUFDUixTQUFTLENBQUNVLEtBQUs7QUFDbkU7QUFHQTs7Q0FFQyxHQUNEYixhQUFhRyxTQUFTLENBQUNXLE1BQU0sR0FBRyxTQUFTQztJQUNyQyxJQUFJQyxNQUFNLElBQUksQ0FBQ0MsTUFBTSxJQUFJLGVBQWU7SUFDeEMsT0FBTyxJQUFJLENBQUNDLEdBQUcsQ0FBQ0MsU0FBUyxHQUNuQixJQUFJLENBQUNELEdBQUcsQ0FBQ0MsU0FBUyxDQUFDLElBQUksQ0FBQ0MsR0FBRyxFQUFFLElBQUksQ0FBQ0EsR0FBRyxHQUFHQyxLQUFLQyxHQUFHLENBQUMsSUFBSSxDQUFDRixHQUFHLEdBQUdKLEtBQUssSUFBSSxDQUFDQSxHQUFHLEtBQ3pFLElBQUksQ0FBQ0UsR0FBRyxDQUFDSyxRQUFRLENBQUMsU0FBUyxJQUFJLENBQUNILEdBQUcsRUFBRSxJQUFJLENBQUNBLEdBQUcsR0FBR0MsS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQ0YsR0FBRyxHQUFHSixLQUFLLElBQUksQ0FBQ0EsR0FBRztBQUMzRjtBQUVBOzs7OztDQUtDLEdBRURoQixhQUFhVSxVQUFVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JlYWRlcl9idWZmZXIuanM/NGU1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyUmVhZGVyO1xuXG4vLyBleHRlbmRzIFJlYWRlclxudmFyIFJlYWRlciA9IHJlcXVpcmUoXCIuL3JlYWRlclwiKTtcbihCdWZmZXJSZWFkZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShSZWFkZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBCdWZmZXJSZWFkZXI7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbC9taW5pbWFsXCIpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgYnVmZmVyIHJlYWRlciBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgV2lyZSBmb3JtYXQgcmVhZGVyIHVzaW5nIG5vZGUgYnVmZmVycy5cbiAqIEBleHRlbmRzIFJlYWRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIEJ1ZmZlciB0byByZWFkIGZyb21cbiAqL1xuZnVuY3Rpb24gQnVmZmVyUmVhZGVyKGJ1ZmZlcikge1xuICAgIFJlYWRlci5jYWxsKHRoaXMsIGJ1ZmZlcik7XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGJ1ZmZlci5cbiAgICAgKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnVmXG4gICAgICogQHR5cGUge0J1ZmZlcn1cbiAgICAgKi9cbn1cblxuQnVmZmVyUmVhZGVyLl9jb25maWd1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAodXRpbC5CdWZmZXIpXG4gICAgICAgIEJ1ZmZlclJlYWRlci5wcm90b3R5cGUuX3NsaWNlID0gdXRpbC5CdWZmZXIucHJvdG90eXBlLnNsaWNlO1xufTtcblxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJSZWFkZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHJlYWRfc3RyaW5nX2J1ZmZlcigpIHtcbiAgICB2YXIgbGVuID0gdGhpcy51aW50MzIoKTsgLy8gbW9kaWZpZXMgcG9zXG4gICAgcmV0dXJuIHRoaXMuYnVmLnV0ZjhTbGljZVxuICAgICAgICA/IHRoaXMuYnVmLnV0ZjhTbGljZSh0aGlzLnBvcywgdGhpcy5wb3MgPSBNYXRoLm1pbih0aGlzLnBvcyArIGxlbiwgdGhpcy5sZW4pKVxuICAgICAgICA6IHRoaXMuYnVmLnRvU3RyaW5nKFwidXRmLThcIiwgdGhpcy5wb3MsIHRoaXMucG9zID0gTWF0aC5taW4odGhpcy5wb3MgKyBsZW4sIHRoaXMubGVuKSk7XG59O1xuXG4vKipcbiAqIFJlYWRzIGEgc2VxdWVuY2Ugb2YgYnl0ZXMgcHJlY2VlZGVkIGJ5IGl0cyBsZW5ndGggYXMgYSB2YXJpbnQuXG4gKiBAbmFtZSBCdWZmZXJSZWFkZXIjYnl0ZXNcbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcn0gVmFsdWUgcmVhZFxuICovXG5cbkJ1ZmZlclJlYWRlci5fY29uZmlndXJlKCk7XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkJ1ZmZlclJlYWRlciIsIlJlYWRlciIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsInV0aWwiLCJidWZmZXIiLCJjYWxsIiwiX2NvbmZpZ3VyZSIsIkJ1ZmZlciIsIl9zbGljZSIsInNsaWNlIiwic3RyaW5nIiwicmVhZF9zdHJpbmdfYnVmZmVyIiwibGVuIiwidWludDMyIiwiYnVmIiwidXRmOFNsaWNlIiwicG9zIiwiTWF0aCIsIm1pbiIsInRvU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader_buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Root;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\");\n((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = \"Root\";\nvar Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\"), Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\nvar Type, parse, common; // \"\n/**\n * Constructs a new root namespace instance.\n * @classdesc Root namespace wrapping all types, enums, services, sub-namespaces etc. that belong together.\n * @extends NamespaceBase\n * @constructor\n * @param {Object.<string,*>} [options] Top level options\n */ function Root(options) {\n    Namespace.call(this, \"\", options);\n    /**\n     * Deferred extension fields.\n     * @type {Field[]}\n     */ this.deferred = [];\n    /**\n     * Resolved file names of loaded files.\n     * @type {string[]}\n     */ this.files = [];\n    /**\n     * Edition, defaults to proto2 if unspecified.\n     * @type {string}\n     * @private\n     */ this._edition = \"proto2\";\n    /**\n     * Global lookup cache of fully qualified names.\n     * @type {Object.<string,ReflectionObject>}\n     * @private\n     */ this._fullyQualifiedObjects = {};\n}\n/**\n * Loads a namespace descriptor into a root namespace.\n * @param {INamespace} json Namespace descriptor\n * @param {Root} [root] Root namespace, defaults to create a new one if omitted\n * @returns {Root} Root namespace\n */ Root.fromJSON = function fromJSON(json, root) {\n    if (!root) root = new Root();\n    if (json.options) root.setOptions(json.options);\n    return root.addJSON(json.nested).resolveAll();\n};\n/**\n * Resolves the path of an imported file, relative to the importing origin.\n * This method exists so you can override it with your own logic in case your imports are scattered over multiple directories.\n * @function\n * @param {string} origin The file name of the importing file\n * @param {string} target The file name being imported\n * @returns {string|null} Resolved path to `target` or `null` to skip the file\n */ Root.prototype.resolvePath = util.path.resolve;\n/**\n * Fetch content from file path or url\n * This method exists so you can override it with your own logic.\n * @function\n * @param {string} path File path or url\n * @param {FetchCallback} callback Callback function\n * @returns {undefined}\n */ Root.prototype.fetch = util.fetch;\n// A symbol-like function to safely signal synchronous loading\n/* istanbul ignore next */ function SYNC() {} // eslint-disable-line no-empty-function\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} options Parse options\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n */ Root.prototype.load = function load(filename, options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = undefined;\n    }\n    var self = this;\n    if (!callback) {\n        return util.asPromise(load, self, filename, options);\n    }\n    var sync = callback === SYNC; // undocumented\n    // Finishes loading by calling the callback (exactly once)\n    function finish(err, root) {\n        /* istanbul ignore if */ if (!callback) {\n            return;\n        }\n        if (sync) {\n            throw err;\n        }\n        if (root) {\n            root.resolveAll();\n        }\n        var cb = callback;\n        callback = null;\n        cb(err, root);\n    }\n    // Bundled definition existence checking\n    function getBundledFileName(filename) {\n        var idx = filename.lastIndexOf(\"google/protobuf/\");\n        if (idx > -1) {\n            var altname = filename.substring(idx);\n            if (altname in common) return altname;\n        }\n        return null;\n    }\n    // Processes a single file\n    function process(filename, source) {\n        try {\n            if (util.isString(source) && source.charAt(0) === \"{\") source = JSON.parse(source);\n            if (!util.isString(source)) self.setOptions(source.options).addJSON(source.nested);\n            else {\n                parse.filename = filename;\n                var parsed = parse(source, self, options), resolved, i = 0;\n                if (parsed.imports) {\n                    for(; i < parsed.imports.length; ++i)if (resolved = getBundledFileName(parsed.imports[i]) || self.resolvePath(filename, parsed.imports[i])) fetch(resolved);\n                }\n                if (parsed.weakImports) {\n                    for(i = 0; i < parsed.weakImports.length; ++i)if (resolved = getBundledFileName(parsed.weakImports[i]) || self.resolvePath(filename, parsed.weakImports[i])) fetch(resolved, true);\n                }\n            }\n        } catch (err) {\n            finish(err);\n        }\n        if (!sync && !queued) {\n            finish(null, self); // only once anyway\n        }\n    }\n    // Fetches a single file\n    function fetch(filename, weak) {\n        filename = getBundledFileName(filename) || filename;\n        // Skip if already loaded / attempted\n        if (self.files.indexOf(filename) > -1) {\n            return;\n        }\n        self.files.push(filename);\n        // Shortcut bundled definitions\n        if (filename in common) {\n            if (sync) {\n                process(filename, common[filename]);\n            } else {\n                ++queued;\n                setTimeout(function() {\n                    --queued;\n                    process(filename, common[filename]);\n                });\n            }\n            return;\n        }\n        // Otherwise fetch from disk or network\n        if (sync) {\n            var source;\n            try {\n                source = util.fs.readFileSync(filename).toString(\"utf8\");\n            } catch (err) {\n                if (!weak) finish(err);\n                return;\n            }\n            process(filename, source);\n        } else {\n            ++queued;\n            self.fetch(filename, function(err, source) {\n                --queued;\n                /* istanbul ignore if */ if (!callback) {\n                    return; // terminated meanwhile\n                }\n                if (err) {\n                    /* istanbul ignore else */ if (!weak) finish(err);\n                    else if (!queued) finish(null, self);\n                    return;\n                }\n                process(filename, source);\n            });\n        }\n    }\n    var queued = 0;\n    // Assembling the root namespace doesn't require working type\n    // references anymore, so we can load everything in parallel\n    if (util.isString(filename)) {\n        filename = [\n            filename\n        ];\n    }\n    for(var i = 0, resolved; i < filename.length; ++i)if (resolved = self.resolvePath(\"\", filename[i])) fetch(resolved);\n    if (sync) {\n        self.resolveAll();\n        return self;\n    }\n    if (!queued) {\n        finish(null, self);\n    }\n    return self;\n};\n// function load(filename:string, options:IParseOptions, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and calls the callback.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {LoadCallback} callback Callback function\n * @returns {undefined}\n * @variation 2\n */ // function load(filename:string, callback:LoadCallback):undefined\n/**\n * Loads one or multiple .proto or preprocessed .json files into this root namespace and returns a promise.\n * @function Root#load\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Promise<Root>} Promise\n * @variation 3\n */ // function load(filename:string, [options:IParseOptions]):Promise<Root>\n/**\n * Synchronously loads one or multiple .proto or preprocessed .json files into this root namespace (node only).\n * @function Root#loadSync\n * @param {string|string[]} filename Names of one or multiple files to load\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\n * @returns {Root} Root namespace\n * @throws {Error} If synchronous fetching is not supported (i.e. in browsers) or if a file's syntax is invalid\n */ Root.prototype.loadSync = function loadSync(filename, options) {\n    if (!util.isNode) throw Error(\"not supported\");\n    return this.load(filename, options, SYNC);\n};\n/**\n * @override\n */ Root.prototype.resolveAll = function resolveAll() {\n    if (!this._needsRecursiveResolve) return this;\n    if (this.deferred.length) throw Error(\"unresolvable extensions: \" + this.deferred.map(function(field) {\n        return \"'extend \" + field.extend + \"' in \" + field.parent.fullName;\n    }).join(\", \"));\n    return Namespace.prototype.resolveAll.call(this);\n};\n// only uppercased (and thus conflict-free) children are exposed, see below\nvar exposeRe = /^[A-Z]/;\n/**\n * Handles a deferred declaring extension field by creating a sister field to represent it within its extended type.\n * @param {Root} root Root instance\n * @param {Field} field Declaring extension field witin the declaring type\n * @returns {boolean} `true` if successfully added to the extended type, `false` otherwise\n * @inner\n * @ignore\n */ function tryHandleExtension(root, field) {\n    var extendedType = field.parent.lookup(field.extend);\n    if (extendedType) {\n        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, undefined, field.options);\n        //do not allow to extend same field twice to prevent the error\n        if (extendedType.get(sisterField.name)) {\n            return true;\n        }\n        sisterField.declaringField = field;\n        field.extensionField = sisterField;\n        extendedType.add(sisterField);\n        return true;\n    }\n    return false;\n}\n/**\n * Called when any object is added to this root or its sub-namespaces.\n * @param {ReflectionObject} object Object added\n * @returns {undefined}\n * @private\n */ Root.prototype._handleAdd = function _handleAdd(object) {\n    if (object instanceof Field) {\n        if (/* an extension field (implies not part of a oneof) */ object.extend !== undefined && /* not already handled */ !object.extensionField) {\n            if (!tryHandleExtension(this, object)) this.deferred.push(object);\n        }\n    } else if (object instanceof Enum) {\n        if (exposeRe.test(object.name)) object.parent[object.name] = object.values; // expose enum values as property of its parent\n    } else if (!(object instanceof OneOf)) /* everything else is a namespace */ {\n        if (object instanceof Type) for(var i = 0; i < this.deferred.length;)if (tryHandleExtension(this, this.deferred[i])) this.deferred.splice(i, 1);\n        else ++i;\n        for(var j = 0; j < /* initializes */ object.nestedArray.length; ++j)this._handleAdd(object._nestedArray[j]);\n        if (exposeRe.test(object.name)) object.parent[object.name] = object; // expose namespace as property of its parent\n    }\n    if (object instanceof Type || object instanceof Enum || object instanceof Field) {\n        // Only store types and enums for quick lookup during resolve.\n        this._fullyQualifiedObjects[object.fullName] = object;\n    }\n// The above also adds uppercased (and thus conflict-free) nested types, services and enums as\n// properties of namespaces just like static code does. This allows using a .d.ts generated for\n// a static module with reflection-based solutions where the condition is met.\n};\n/**\n * Called when any object is removed from this root or its sub-namespaces.\n * @param {ReflectionObject} object Object removed\n * @returns {undefined}\n * @private\n */ Root.prototype._handleRemove = function _handleRemove(object) {\n    if (object instanceof Field) {\n        if (/* an extension field */ object.extend !== undefined) {\n            if (/* already handled */ object.extensionField) {\n                object.extensionField.parent.remove(object.extensionField);\n                object.extensionField = null;\n            } else {\n                var index = this.deferred.indexOf(object);\n                /* istanbul ignore else */ if (index > -1) this.deferred.splice(index, 1);\n            }\n        }\n    } else if (object instanceof Enum) {\n        if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose enum values\n    } else if (object instanceof Namespace) {\n        for(var i = 0; i < /* initializes */ object.nestedArray.length; ++i)this._handleRemove(object._nestedArray[i]);\n        if (exposeRe.test(object.name)) delete object.parent[object.name]; // unexpose namespaces\n    }\n    delete this._fullyQualifiedObjects[object.fullName];\n};\n// Sets up cyclic dependencies (called in index-light)\nRoot._configure = function(Type_, parse_, common_) {\n    Type = Type_;\n    parse = parse_;\n    common = common_;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLG9CQUFvQjtBQUNwQixJQUFJQyxZQUFZQyxtQkFBT0EsQ0FBQyxnR0FBYTtBQUNwQyxFQUFDRixLQUFLRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osVUFBVUUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLElBQUcsRUFBR08sU0FBUyxHQUFHO0FBRXZGLElBQUlDLFFBQVVOLG1CQUFPQSxDQUFDLHdGQUFTLEdBQzNCTyxPQUFVUCxtQkFBT0EsQ0FBQyxzRkFBUSxHQUMxQlEsUUFBVVIsbUJBQU9BLENBQUMsd0ZBQVMsR0FDM0JTLE9BQVVULG1CQUFPQSxDQUFDLHNGQUFRO0FBRTlCLElBQUlVLE1BQ0FDLE9BQ0FDLFFBQVEsSUFBSTtBQUVoQjs7Ozs7O0NBTUMsR0FDRCxTQUFTZCxLQUFLZSxPQUFPO0lBQ2pCZCxVQUFVZSxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUlEO0lBRXpCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsUUFBUSxHQUFHLEVBQUU7SUFFbEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtJQUVmOzs7O0tBSUMsR0FDRCxJQUFJLENBQUNDLFFBQVEsR0FBRztJQUVoQjs7OztLQUlDLEdBQ0QsSUFBSSxDQUFDQyxzQkFBc0IsR0FBRyxDQUFDO0FBQ25DO0FBRUE7Ozs7O0NBS0MsR0FDRHBCLEtBQUtxQixRQUFRLEdBQUcsU0FBU0EsU0FBU0MsSUFBSSxFQUFFQyxJQUFJO0lBQ3hDLElBQUksQ0FBQ0EsTUFDREEsT0FBTyxJQUFJdkI7SUFDZixJQUFJc0IsS0FBS1AsT0FBTyxFQUNaUSxLQUFLQyxVQUFVLENBQUNGLEtBQUtQLE9BQU87SUFDaEMsT0FBT1EsS0FBS0UsT0FBTyxDQUFDSCxLQUFLSSxNQUFNLEVBQUVDLFVBQVU7QUFDL0M7QUFFQTs7Ozs7OztDQU9DLEdBQ0QzQixLQUFLRyxTQUFTLENBQUN5QixXQUFXLEdBQUdqQixLQUFLa0IsSUFBSSxDQUFDQyxPQUFPO0FBRTlDOzs7Ozs7O0NBT0MsR0FDRDlCLEtBQUtHLFNBQVMsQ0FBQzRCLEtBQUssR0FBR3BCLEtBQUtvQixLQUFLO0FBRWpDLDhEQUE4RDtBQUM5RCx3QkFBd0IsR0FDeEIsU0FBU0MsUUFBUSxFQUFFLHdDQUF3QztBQUUzRDs7Ozs7O0NBTUMsR0FDRGhDLEtBQUtHLFNBQVMsQ0FBQzhCLElBQUksR0FBRyxTQUFTQSxLQUFLQyxRQUFRLEVBQUVuQixPQUFPLEVBQUVvQixRQUFRO0lBQzNELElBQUksT0FBT3BCLFlBQVksWUFBWTtRQUMvQm9CLFdBQVdwQjtRQUNYQSxVQUFVcUI7SUFDZDtJQUNBLElBQUlDLE9BQU8sSUFBSTtJQUNmLElBQUksQ0FBQ0YsVUFBVTtRQUNYLE9BQU94QixLQUFLMkIsU0FBUyxDQUFDTCxNQUFNSSxNQUFNSCxVQUFVbkI7SUFDaEQ7SUFFQSxJQUFJd0IsT0FBT0osYUFBYUgsTUFBTSxlQUFlO0lBRTdDLDBEQUEwRDtJQUMxRCxTQUFTUSxPQUFPQyxHQUFHLEVBQUVsQixJQUFJO1FBQ3JCLHNCQUFzQixHQUN0QixJQUFJLENBQUNZLFVBQVU7WUFDWDtRQUNKO1FBQ0EsSUFBSUksTUFBTTtZQUNOLE1BQU1FO1FBQ1Y7UUFDQSxJQUFJbEIsTUFBTTtZQUNOQSxLQUFLSSxVQUFVO1FBQ25CO1FBQ0EsSUFBSWUsS0FBS1A7UUFDVEEsV0FBVztRQUNYTyxHQUFHRCxLQUFLbEI7SUFDWjtJQUVBLHdDQUF3QztJQUN4QyxTQUFTb0IsbUJBQW1CVCxRQUFRO1FBQ2hDLElBQUlVLE1BQU1WLFNBQVNXLFdBQVcsQ0FBQztRQUMvQixJQUFJRCxNQUFNLENBQUMsR0FBRztZQUNWLElBQUlFLFVBQVVaLFNBQVNhLFNBQVMsQ0FBQ0g7WUFDakMsSUFBSUUsV0FBV2hDLFFBQVEsT0FBT2dDO1FBQ2xDO1FBQ0EsT0FBTztJQUNYO0lBRUEsMEJBQTBCO0lBQzFCLFNBQVNFLFFBQVFkLFFBQVEsRUFBRWUsTUFBTTtRQUM3QixJQUFJO1lBQ0EsSUFBSXRDLEtBQUt1QyxRQUFRLENBQUNELFdBQVdBLE9BQU9FLE1BQU0sQ0FBQyxPQUFPLEtBQzlDRixTQUFTRyxLQUFLdkMsS0FBSyxDQUFDb0M7WUFDeEIsSUFBSSxDQUFDdEMsS0FBS3VDLFFBQVEsQ0FBQ0QsU0FDZlosS0FBS2IsVUFBVSxDQUFDeUIsT0FBT2xDLE9BQU8sRUFBRVUsT0FBTyxDQUFDd0IsT0FBT3ZCLE1BQU07aUJBQ3BEO2dCQUNEYixNQUFNcUIsUUFBUSxHQUFHQTtnQkFDakIsSUFBSW1CLFNBQVN4QyxNQUFNb0MsUUFBUVosTUFBTXRCLFVBQzdCdUMsVUFDQUMsSUFBSTtnQkFDUixJQUFJRixPQUFPRyxPQUFPLEVBQ2Q7b0JBQUEsTUFBT0QsSUFBSUYsT0FBT0csT0FBTyxDQUFDQyxNQUFNLEVBQUUsRUFBRUYsRUFDaEMsSUFBSUQsV0FBV1gsbUJBQW1CVSxPQUFPRyxPQUFPLENBQUNELEVBQUUsS0FBS2xCLEtBQUtULFdBQVcsQ0FBQ00sVUFBVW1CLE9BQU9HLE9BQU8sQ0FBQ0QsRUFBRSxHQUNoR3hCLE1BQU11QjtnQkFBUztnQkFDM0IsSUFBSUQsT0FBT0ssV0FBVyxFQUNsQjtvQkFBQSxJQUFLSCxJQUFJLEdBQUdBLElBQUlGLE9BQU9LLFdBQVcsQ0FBQ0QsTUFBTSxFQUFFLEVBQUVGLEVBQ3pDLElBQUlELFdBQVdYLG1CQUFtQlUsT0FBT0ssV0FBVyxDQUFDSCxFQUFFLEtBQUtsQixLQUFLVCxXQUFXLENBQUNNLFVBQVVtQixPQUFPSyxXQUFXLENBQUNILEVBQUUsR0FDeEd4QixNQUFNdUIsVUFBVTtnQkFBSztZQUNyQztRQUNKLEVBQUUsT0FBT2IsS0FBSztZQUNWRCxPQUFPQztRQUNYO1FBQ0EsSUFBSSxDQUFDRixRQUFRLENBQUNvQixRQUFRO1lBQ2xCbkIsT0FBTyxNQUFNSCxPQUFPLG1CQUFtQjtRQUMzQztJQUNKO0lBRUEsd0JBQXdCO0lBQ3hCLFNBQVNOLE1BQU1HLFFBQVEsRUFBRTBCLElBQUk7UUFDekIxQixXQUFXUyxtQkFBbUJULGFBQWFBO1FBRTNDLHFDQUFxQztRQUNyQyxJQUFJRyxLQUFLbkIsS0FBSyxDQUFDMkMsT0FBTyxDQUFDM0IsWUFBWSxDQUFDLEdBQUc7WUFDbkM7UUFDSjtRQUNBRyxLQUFLbkIsS0FBSyxDQUFDNEMsSUFBSSxDQUFDNUI7UUFFaEIsK0JBQStCO1FBQy9CLElBQUlBLFlBQVlwQixRQUFRO1lBQ3BCLElBQUl5QixNQUFNO2dCQUNOUyxRQUFRZCxVQUFVcEIsTUFBTSxDQUFDb0IsU0FBUztZQUN0QyxPQUFPO2dCQUNILEVBQUV5QjtnQkFDRkksV0FBVztvQkFDUCxFQUFFSjtvQkFDRlgsUUFBUWQsVUFBVXBCLE1BQU0sQ0FBQ29CLFNBQVM7Z0JBQ3RDO1lBQ0o7WUFDQTtRQUNKO1FBRUEsdUNBQXVDO1FBQ3ZDLElBQUlLLE1BQU07WUFDTixJQUFJVTtZQUNKLElBQUk7Z0JBQ0FBLFNBQVN0QyxLQUFLcUQsRUFBRSxDQUFDQyxZQUFZLENBQUMvQixVQUFVZ0MsUUFBUSxDQUFDO1lBQ3JELEVBQUUsT0FBT3pCLEtBQUs7Z0JBQ1YsSUFBSSxDQUFDbUIsTUFDRHBCLE9BQU9DO2dCQUNYO1lBQ0o7WUFDQU8sUUFBUWQsVUFBVWU7UUFDdEIsT0FBTztZQUNILEVBQUVVO1lBQ0Z0QixLQUFLTixLQUFLLENBQUNHLFVBQVUsU0FBU08sR0FBRyxFQUFFUSxNQUFNO2dCQUNyQyxFQUFFVTtnQkFDRixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDeEIsVUFBVTtvQkFDWCxRQUFRLHVCQUF1QjtnQkFDbkM7Z0JBQ0EsSUFBSU0sS0FBSztvQkFDTCx3QkFBd0IsR0FDeEIsSUFBSSxDQUFDbUIsTUFDRHBCLE9BQU9DO3lCQUNOLElBQUksQ0FBQ2tCLFFBQ05uQixPQUFPLE1BQU1IO29CQUNqQjtnQkFDSjtnQkFDQVcsUUFBUWQsVUFBVWU7WUFDdEI7UUFDSjtJQUNKO0lBQ0EsSUFBSVUsU0FBUztJQUViLDZEQUE2RDtJQUM3RCw0REFBNEQ7SUFDNUQsSUFBSWhELEtBQUt1QyxRQUFRLENBQUNoQixXQUFXO1FBQ3pCQSxXQUFXO1lBQUVBO1NBQVU7SUFDM0I7SUFDQSxJQUFLLElBQUlxQixJQUFJLEdBQUdELFVBQVVDLElBQUlyQixTQUFTdUIsTUFBTSxFQUFFLEVBQUVGLEVBQzdDLElBQUlELFdBQVdqQixLQUFLVCxXQUFXLENBQUMsSUFBSU0sUUFBUSxDQUFDcUIsRUFBRSxHQUMzQ3hCLE1BQU11QjtJQUNkLElBQUlmLE1BQU07UUFDTkYsS0FBS1YsVUFBVTtRQUNmLE9BQU9VO0lBQ1g7SUFDQSxJQUFJLENBQUNzQixRQUFRO1FBQ1RuQixPQUFPLE1BQU1IO0lBQ2pCO0lBRUEsT0FBT0E7QUFDWDtBQUNBLHlGQUF5RjtBQUV6Rjs7Ozs7OztDQU9DLEdBQ0Qsa0VBQWtFO0FBRWxFOzs7Ozs7O0NBT0MsR0FDRCx3RUFBd0U7QUFFeEU7Ozs7Ozs7Q0FPQyxHQUNEckMsS0FBS0csU0FBUyxDQUFDZ0UsUUFBUSxHQUFHLFNBQVNBLFNBQVNqQyxRQUFRLEVBQUVuQixPQUFPO0lBQ3pELElBQUksQ0FBQ0osS0FBS3lELE1BQU0sRUFDWixNQUFNQyxNQUFNO0lBQ2hCLE9BQU8sSUFBSSxDQUFDcEMsSUFBSSxDQUFDQyxVQUFVbkIsU0FBU2lCO0FBQ3hDO0FBRUE7O0NBRUMsR0FDRGhDLEtBQUtHLFNBQVMsQ0FBQ3dCLFVBQVUsR0FBRyxTQUFTQTtJQUNqQyxJQUFJLENBQUMsSUFBSSxDQUFDMkMsc0JBQXNCLEVBQUUsT0FBTyxJQUFJO0lBRTdDLElBQUksSUFBSSxDQUFDckQsUUFBUSxDQUFDd0MsTUFBTSxFQUNwQixNQUFNWSxNQUFNLDhCQUE4QixJQUFJLENBQUNwRCxRQUFRLENBQUNzRCxHQUFHLENBQUMsU0FBU0MsS0FBSztRQUN0RSxPQUFPLGFBQWFBLE1BQU1DLE1BQU0sR0FBRyxVQUFVRCxNQUFNRSxNQUFNLENBQUNDLFFBQVE7SUFDdEUsR0FBR0MsSUFBSSxDQUFDO0lBQ1osT0FBTzNFLFVBQVVFLFNBQVMsQ0FBQ3dCLFVBQVUsQ0FBQ1gsSUFBSSxDQUFDLElBQUk7QUFDbkQ7QUFFQSwyRUFBMkU7QUFDM0UsSUFBSTZELFdBQVc7QUFFZjs7Ozs7OztDQU9DLEdBQ0QsU0FBU0MsbUJBQW1CdkQsSUFBSSxFQUFFaUQsS0FBSztJQUNuQyxJQUFJTyxlQUFlUCxNQUFNRSxNQUFNLENBQUNNLE1BQU0sQ0FBQ1IsTUFBTUMsTUFBTTtJQUNuRCxJQUFJTSxjQUFjO1FBQ2QsSUFBSUUsY0FBYyxJQUFJekUsTUFBTWdFLE1BQU1HLFFBQVEsRUFBRUgsTUFBTVUsRUFBRSxFQUFFVixNQUFNVyxJQUFJLEVBQUVYLE1BQU1ZLElBQUksRUFBRWhELFdBQVdvQyxNQUFNekQsT0FBTztRQUN0Ryw4REFBOEQ7UUFDOUQsSUFBSWdFLGFBQWFNLEdBQUcsQ0FBQ0osWUFBWUssSUFBSSxHQUFHO1lBQ3BDLE9BQU87UUFDWDtRQUNBTCxZQUFZTSxjQUFjLEdBQUdmO1FBQzdCQSxNQUFNZ0IsY0FBYyxHQUFHUDtRQUN2QkYsYUFBYVUsR0FBRyxDQUFDUjtRQUNqQixPQUFPO0lBQ1g7SUFDQSxPQUFPO0FBQ1g7QUFFQTs7Ozs7Q0FLQyxHQUNEakYsS0FBS0csU0FBUyxDQUFDdUYsVUFBVSxHQUFHLFNBQVNBLFdBQVdDLE1BQU07SUFDbEQsSUFBSUEsa0JBQWtCbkYsT0FBTztRQUV6QixJQUFJLG9EQUFvRCxHQUFHbUYsT0FBT2xCLE1BQU0sS0FBS3JDLGFBQWEsdUJBQXVCLEdBQUcsQ0FBQ3VELE9BQU9ILGNBQWMsRUFDdEk7WUFBQSxJQUFJLENBQUNWLG1CQUFtQixJQUFJLEVBQUVhLFNBQzFCLElBQUksQ0FBQzFFLFFBQVEsQ0FBQzZDLElBQUksQ0FBQzZCO1FBQU87SUFFdEMsT0FBTyxJQUFJQSxrQkFBa0JsRixNQUFNO1FBRS9CLElBQUlvRSxTQUFTZSxJQUFJLENBQUNELE9BQU9MLElBQUksR0FDekJLLE9BQU9qQixNQUFNLENBQUNpQixPQUFPTCxJQUFJLENBQUMsR0FBR0ssT0FBT0UsTUFBTSxFQUFFLCtDQUErQztJQUVuRyxPQUFPLElBQUksQ0FBRUYsQ0FBQUEsa0JBQWtCakYsS0FBSSxHQUFJLGtDQUFrQyxHQUFHO1FBRXhFLElBQUlpRixrQkFBa0IvRSxNQUNsQixJQUFLLElBQUkyQyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDdEMsUUFBUSxDQUFDd0MsTUFBTSxFQUNwQyxJQUFJcUIsbUJBQW1CLElBQUksRUFBRSxJQUFJLENBQUM3RCxRQUFRLENBQUNzQyxFQUFFLEdBQ3pDLElBQUksQ0FBQ3RDLFFBQVEsQ0FBQzZFLE1BQU0sQ0FBQ3ZDLEdBQUc7YUFFeEIsRUFBRUE7UUFDZCxJQUFLLElBQUl3QyxJQUFJLEdBQUdBLElBQUksZUFBZSxHQUFHSixPQUFPSyxXQUFXLENBQUN2QyxNQUFNLEVBQUUsRUFBRXNDLEVBQy9ELElBQUksQ0FBQ0wsVUFBVSxDQUFDQyxPQUFPTSxZQUFZLENBQUNGLEVBQUU7UUFDMUMsSUFBSWxCLFNBQVNlLElBQUksQ0FBQ0QsT0FBT0wsSUFBSSxHQUN6QkssT0FBT2pCLE1BQU0sQ0FBQ2lCLE9BQU9MLElBQUksQ0FBQyxHQUFHSyxRQUFRLDZDQUE2QztJQUMxRjtJQUVBLElBQUlBLGtCQUFrQi9FLFFBQVErRSxrQkFBa0JsRixRQUFRa0Ysa0JBQWtCbkYsT0FBTztRQUM3RSw4REFBOEQ7UUFDOUQsSUFBSSxDQUFDWSxzQkFBc0IsQ0FBQ3VFLE9BQU9oQixRQUFRLENBQUMsR0FBR2dCO0lBQ25EO0FBRUEsOEZBQThGO0FBQzlGLCtGQUErRjtBQUMvRiw4RUFBOEU7QUFDbEY7QUFFQTs7Ozs7Q0FLQyxHQUNEM0YsS0FBS0csU0FBUyxDQUFDK0YsYUFBYSxHQUFHLFNBQVNBLGNBQWNQLE1BQU07SUFDeEQsSUFBSUEsa0JBQWtCbkYsT0FBTztRQUV6QixJQUFJLHNCQUFzQixHQUFHbUYsT0FBT2xCLE1BQU0sS0FBS3JDLFdBQVc7WUFDdEQsSUFBSSxtQkFBbUIsR0FBR3VELE9BQU9ILGNBQWMsRUFBRTtnQkFDN0NHLE9BQU9ILGNBQWMsQ0FBQ2QsTUFBTSxDQUFDeUIsTUFBTSxDQUFDUixPQUFPSCxjQUFjO2dCQUN6REcsT0FBT0gsY0FBYyxHQUFHO1lBQzVCLE9BQU87Z0JBQ0gsSUFBSVksUUFBUSxJQUFJLENBQUNuRixRQUFRLENBQUM0QyxPQUFPLENBQUM4QjtnQkFDbEMsd0JBQXdCLEdBQ3hCLElBQUlTLFFBQVEsQ0FBQyxHQUNULElBQUksQ0FBQ25GLFFBQVEsQ0FBQzZFLE1BQU0sQ0FBQ00sT0FBTztZQUNwQztRQUNKO0lBRUosT0FBTyxJQUFJVCxrQkFBa0JsRixNQUFNO1FBRS9CLElBQUlvRSxTQUFTZSxJQUFJLENBQUNELE9BQU9MLElBQUksR0FDekIsT0FBT0ssT0FBT2pCLE1BQU0sQ0FBQ2lCLE9BQU9MLElBQUksQ0FBQyxFQUFFLHVCQUF1QjtJQUVsRSxPQUFPLElBQUlLLGtCQUFrQjFGLFdBQVc7UUFFcEMsSUFBSyxJQUFJc0QsSUFBSSxHQUFHQSxJQUFJLGVBQWUsR0FBR29DLE9BQU9LLFdBQVcsQ0FBQ3ZDLE1BQU0sRUFBRSxFQUFFRixFQUMvRCxJQUFJLENBQUMyQyxhQUFhLENBQUNQLE9BQU9NLFlBQVksQ0FBQzFDLEVBQUU7UUFFN0MsSUFBSXNCLFNBQVNlLElBQUksQ0FBQ0QsT0FBT0wsSUFBSSxHQUN6QixPQUFPSyxPQUFPakIsTUFBTSxDQUFDaUIsT0FBT0wsSUFBSSxDQUFDLEVBQUUsc0JBQXNCO0lBRWpFO0lBRUEsT0FBTyxJQUFJLENBQUNsRSxzQkFBc0IsQ0FBQ3VFLE9BQU9oQixRQUFRLENBQUM7QUFDdkQ7QUFFQSxzREFBc0Q7QUFDdEQzRSxLQUFLcUcsVUFBVSxHQUFHLFNBQVNDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxPQUFPO0lBQzdDNUYsT0FBUzBGO0lBQ1R6RixRQUFTMEY7SUFDVHpGLFNBQVMwRjtBQUNiIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Jvb3QuanM/NzFiOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gUm9vdDtcblxuLy8gZXh0ZW5kcyBOYW1lc3BhY2VcbnZhciBOYW1lc3BhY2UgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XG4oKFJvb3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBSb290KS5jbGFzc05hbWUgPSBcIlJvb3RcIjtcblxudmFyIEZpZWxkICAgPSByZXF1aXJlKFwiLi9maWVsZFwiKSxcbiAgICBFbnVtICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICBPbmVPZiAgID0gcmVxdWlyZShcIi4vb25lb2ZcIiksXG4gICAgdXRpbCAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBUeXBlLCAgIC8vIGN5Y2xpY1xuICAgIHBhcnNlLCAgLy8gbWlnaHQgYmUgZXhjbHVkZWRcbiAgICBjb21tb247IC8vIFwiXG5cbi8qKlxuICogQ29uc3RydWN0cyBhIG5ldyByb290IG5hbWVzcGFjZSBpbnN0YW5jZS5cbiAqIEBjbGFzc2Rlc2MgUm9vdCBuYW1lc3BhY2Ugd3JhcHBpbmcgYWxsIHR5cGVzLCBlbnVtcywgc2VydmljZXMsIHN1Yi1uYW1lc3BhY2VzIGV0Yy4gdGhhdCBiZWxvbmcgdG9nZXRoZXIuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBUb3AgbGV2ZWwgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBSb290KG9wdGlvbnMpIHtcbiAgICBOYW1lc3BhY2UuY2FsbCh0aGlzLCBcIlwiLCBvcHRpb25zKTtcblxuICAgIC8qKlxuICAgICAqIERlZmVycmVkIGV4dGVuc2lvbiBmaWVsZHMuXG4gICAgICogQHR5cGUge0ZpZWxkW119XG4gICAgICovXG4gICAgdGhpcy5kZWZlcnJlZCA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogUmVzb2x2ZWQgZmlsZSBuYW1lcyBvZiBsb2FkZWQgZmlsZXMuXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIHRoaXMuZmlsZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEVkaXRpb24sIGRlZmF1bHRzIHRvIHByb3RvMiBpZiB1bnNwZWNpZmllZC5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZWRpdGlvbiA9IFwicHJvdG8yXCI7XG5cbiAgICAvKipcbiAgICAgKiBHbG9iYWwgbG9va3VwIGNhY2hlIG9mIGZ1bGx5IHF1YWxpZmllZCBuYW1lcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsUmVmbGVjdGlvbk9iamVjdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9mdWxseVF1YWxpZmllZE9iamVjdHMgPSB7fTtcbn1cblxuLyoqXG4gKiBMb2FkcyBhIG5hbWVzcGFjZSBkZXNjcmlwdG9yIGludG8gYSByb290IG5hbWVzcGFjZS5cbiAqIEBwYXJhbSB7SU5hbWVzcGFjZX0ganNvbiBOYW1lc3BhY2UgZGVzY3JpcHRvclxuICogQHBhcmFtIHtSb290fSBbcm9vdF0gUm9vdCBuYW1lc3BhY2UsIGRlZmF1bHRzIHRvIGNyZWF0ZSBhIG5ldyBvbmUgaWYgb21pdHRlZFxuICogQHJldHVybnMge1Jvb3R9IFJvb3QgbmFtZXNwYWNlXG4gKi9cblJvb3QuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihqc29uLCByb290KSB7XG4gICAgaWYgKCFyb290KVxuICAgICAgICByb290ID0gbmV3IFJvb3QoKTtcbiAgICBpZiAoanNvbi5vcHRpb25zKVxuICAgICAgICByb290LnNldE9wdGlvbnMoanNvbi5vcHRpb25zKTtcbiAgICByZXR1cm4gcm9vdC5hZGRKU09OKGpzb24ubmVzdGVkKS5yZXNvbHZlQWxsKCk7XG59O1xuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBwYXRoIG9mIGFuIGltcG9ydGVkIGZpbGUsIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnRpbmcgb3JpZ2luLlxuICogVGhpcyBtZXRob2QgZXhpc3RzIHNvIHlvdSBjYW4gb3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93biBsb2dpYyBpbiBjYXNlIHlvdXIgaW1wb3J0cyBhcmUgc2NhdHRlcmVkIG92ZXIgbXVsdGlwbGUgZGlyZWN0b3JpZXMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gVGhlIGZpbGUgbmFtZSBvZiB0aGUgaW1wb3J0aW5nIGZpbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXQgVGhlIGZpbGUgbmFtZSBiZWluZyBpbXBvcnRlZFxuICogQHJldHVybnMge3N0cmluZ3xudWxsfSBSZXNvbHZlZCBwYXRoIHRvIGB0YXJnZXRgIG9yIGBudWxsYCB0byBza2lwIHRoZSBmaWxlXG4gKi9cblJvb3QucHJvdG90eXBlLnJlc29sdmVQYXRoID0gdXRpbC5wYXRoLnJlc29sdmU7XG5cbi8qKlxuICogRmV0Y2ggY29udGVudCBmcm9tIGZpbGUgcGF0aCBvciB1cmxcbiAqIFRoaXMgbWV0aG9kIGV4aXN0cyBzbyB5b3UgY2FuIG92ZXJyaWRlIGl0IHdpdGggeW91ciBvd24gbG9naWMuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIEZpbGUgcGF0aCBvciB1cmxcbiAqIEBwYXJhbSB7RmV0Y2hDYWxsYmFja30gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblJvb3QucHJvdG90eXBlLmZldGNoID0gdXRpbC5mZXRjaDtcblxuLy8gQSBzeW1ib2wtbGlrZSBmdW5jdGlvbiB0byBzYWZlbHkgc2lnbmFsIHN5bmNocm9ub3VzIGxvYWRpbmdcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBTWU5DKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxuXG4vKipcbiAqIExvYWRzIG9uZSBvciBtdWx0aXBsZSAucHJvdG8gb3IgcHJlcHJvY2Vzc2VkIC5qc29uIGZpbGVzIGludG8gdGhpcyByb290IG5hbWVzcGFjZSBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrLlxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE5hbWVzIG9mIG9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IG9wdGlvbnMgUGFyc2Ugb3B0aW9uc1xuICogQHBhcmFtIHtMb2FkQ2FsbGJhY2t9IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5Sb290LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gbG9hZChmaWxlbmFtZSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB1dGlsLmFzUHJvbWlzZShsb2FkLCBzZWxmLCBmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIHN5bmMgPSBjYWxsYmFjayA9PT0gU1lOQzsgLy8gdW5kb2N1bWVudGVkXG5cbiAgICAvLyBGaW5pc2hlcyBsb2FkaW5nIGJ5IGNhbGxpbmcgdGhlIGNhbGxiYWNrIChleGFjdGx5IG9uY2UpXG4gICAgZnVuY3Rpb24gZmluaXNoKGVyciwgcm9vdCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgIHJvb3QucmVzb2x2ZUFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYiA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgIGNiKGVyciwgcm9vdCk7XG4gICAgfVxuXG4gICAgLy8gQnVuZGxlZCBkZWZpbml0aW9uIGV4aXN0ZW5jZSBjaGVja2luZ1xuICAgIGZ1bmN0aW9uIGdldEJ1bmRsZWRGaWxlTmFtZShmaWxlbmFtZSkge1xuICAgICAgICB2YXIgaWR4ID0gZmlsZW5hbWUubGFzdEluZGV4T2YoXCJnb29nbGUvcHJvdG9idWYvXCIpO1xuICAgICAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgICAgICAgIHZhciBhbHRuYW1lID0gZmlsZW5hbWUuc3Vic3RyaW5nKGlkeCk7XG4gICAgICAgICAgICBpZiAoYWx0bmFtZSBpbiBjb21tb24pIHJldHVybiBhbHRuYW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFByb2Nlc3NlcyBhIHNpbmdsZSBmaWxlXG4gICAgZnVuY3Rpb24gcHJvY2VzcyhmaWxlbmFtZSwgc291cmNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1N0cmluZyhzb3VyY2UpICYmIHNvdXJjZS5jaGFyQXQoMCkgPT09IFwie1wiKVxuICAgICAgICAgICAgICAgIHNvdXJjZSA9IEpTT04ucGFyc2Uoc291cmNlKTtcbiAgICAgICAgICAgIGlmICghdXRpbC5pc1N0cmluZyhzb3VyY2UpKVxuICAgICAgICAgICAgICAgIHNlbGYuc2V0T3B0aW9ucyhzb3VyY2Uub3B0aW9ucykuYWRkSlNPTihzb3VyY2UubmVzdGVkKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlKHNvdXJjZSwgc2VsZiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkLFxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLmltcG9ydHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgcGFyc2VkLmltcG9ydHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWQgPSBnZXRCdW5kbGVkRmlsZU5hbWUocGFyc2VkLmltcG9ydHNbaV0pIHx8IHNlbGYucmVzb2x2ZVBhdGgoZmlsZW5hbWUsIHBhcnNlZC5pbXBvcnRzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZXRjaChyZXNvbHZlZCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC53ZWFrSW1wb3J0cylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnNlZC53ZWFrSW1wb3J0cy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCA9IGdldEJ1bmRsZWRGaWxlTmFtZShwYXJzZWQud2Vha0ltcG9ydHNbaV0pIHx8IHNlbGYucmVzb2x2ZVBhdGgoZmlsZW5hbWUsIHBhcnNlZC53ZWFrSW1wb3J0c1tpXSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2gocmVzb2x2ZWQsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGZpbmlzaChlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3luYyAmJiAhcXVldWVkKSB7XG4gICAgICAgICAgICBmaW5pc2gobnVsbCwgc2VsZik7IC8vIG9ubHkgb25jZSBhbnl3YXlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZldGNoZXMgYSBzaW5nbGUgZmlsZVxuICAgIGZ1bmN0aW9uIGZldGNoKGZpbGVuYW1lLCB3ZWFrKSB7XG4gICAgICAgIGZpbGVuYW1lID0gZ2V0QnVuZGxlZEZpbGVOYW1lKGZpbGVuYW1lKSB8fCBmaWxlbmFtZTtcblxuICAgICAgICAvLyBTa2lwIGlmIGFscmVhZHkgbG9hZGVkIC8gYXR0ZW1wdGVkXG4gICAgICAgIGlmIChzZWxmLmZpbGVzLmluZGV4T2YoZmlsZW5hbWUpID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmZpbGVzLnB1c2goZmlsZW5hbWUpO1xuXG4gICAgICAgIC8vIFNob3J0Y3V0IGJ1bmRsZWQgZGVmaW5pdGlvbnNcbiAgICAgICAgaWYgKGZpbGVuYW1lIGluIGNvbW1vbikge1xuICAgICAgICAgICAgaWYgKHN5bmMpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBjb21tb25bZmlsZW5hbWVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKytxdWV1ZWQ7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1xdWV1ZWQ7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoZmlsZW5hbWUsIGNvbW1vbltmaWxlbmFtZV0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGZldGNoIGZyb20gZGlzayBvciBuZXR3b3JrXG4gICAgICAgIGlmIChzeW5jKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzb3VyY2UgPSB1dGlsLmZzLnJlYWRGaWxlU3luYyhmaWxlbmFtZSkudG9TdHJpbmcoXCJ1dGY4XCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3ZWFrKVxuICAgICAgICAgICAgICAgICAgICBmaW5pc2goZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzKGZpbGVuYW1lLCBzb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgKytxdWV1ZWQ7XG4gICAgICAgICAgICBzZWxmLmZldGNoKGZpbGVuYW1lLCBmdW5jdGlvbihlcnIsIHNvdXJjZSkge1xuICAgICAgICAgICAgICAgIC0tcXVldWVkO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyB0ZXJtaW5hdGVkIG1lYW53aGlsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghd2VhaylcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghcXVldWVkKSAvLyBjYW4ndCBiZSBjb3ZlcmVkIHJlbGlhYmx5XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5pc2gobnVsbCwgc2VsZik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2VzcyhmaWxlbmFtZSwgc291cmNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBxdWV1ZWQgPSAwO1xuXG4gICAgLy8gQXNzZW1ibGluZyB0aGUgcm9vdCBuYW1lc3BhY2UgZG9lc24ndCByZXF1aXJlIHdvcmtpbmcgdHlwZVxuICAgIC8vIHJlZmVyZW5jZXMgYW55bW9yZSwgc28gd2UgY2FuIGxvYWQgZXZlcnl0aGluZyBpbiBwYXJhbGxlbFxuICAgIGlmICh1dGlsLmlzU3RyaW5nKGZpbGVuYW1lKSkge1xuICAgICAgICBmaWxlbmFtZSA9IFsgZmlsZW5hbWUgXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIHJlc29sdmVkOyBpIDwgZmlsZW5hbWUubGVuZ3RoOyArK2kpXG4gICAgICAgIGlmIChyZXNvbHZlZCA9IHNlbGYucmVzb2x2ZVBhdGgoXCJcIiwgZmlsZW5hbWVbaV0pKVxuICAgICAgICAgICAgZmV0Y2gocmVzb2x2ZWQpO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAgIHNlbGYucmVzb2x2ZUFsbCgpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gICAgaWYgKCFxdWV1ZWQpIHtcbiAgICAgICAgZmluaXNoKG51bGwsIHNlbGYpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xufTtcbi8vIGZ1bmN0aW9uIGxvYWQoZmlsZW5hbWU6c3RyaW5nLCBvcHRpb25zOklQYXJzZU9wdGlvbnMsIGNhbGxiYWNrOkxvYWRDYWxsYmFjayk6dW5kZWZpbmVkXG5cbi8qKlxuICogTG9hZHMgb25lIG9yIG11bHRpcGxlIC5wcm90byBvciBwcmVwcm9jZXNzZWQgLmpzb24gZmlsZXMgaW50byB0aGlzIHJvb3QgbmFtZXNwYWNlIGFuZCBjYWxscyB0aGUgY2FsbGJhY2suXG4gKiBAZnVuY3Rpb24gUm9vdCNsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gZmlsZW5hbWUgTmFtZXMgb2Ygb25lIG9yIG11bHRpcGxlIGZpbGVzIHRvIGxvYWRcbiAqIEBwYXJhbSB7TG9hZENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB2YXJpYXRpb24gMlxuICovXG4vLyBmdW5jdGlvbiBsb2FkKGZpbGVuYW1lOnN0cmluZywgY2FsbGJhY2s6TG9hZENhbGxiYWNrKTp1bmRlZmluZWRcblxuLyoqXG4gKiBMb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgYW5kIHJldHVybnMgYSBwcm9taXNlLlxuICogQGZ1bmN0aW9uIFJvb3QjbG9hZFxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE5hbWVzIG9mIG9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cbiAqIEByZXR1cm5zIHtQcm9taXNlPFJvb3Q+fSBQcm9taXNlXG4gKiBAdmFyaWF0aW9uIDNcbiAqL1xuLy8gZnVuY3Rpb24gbG9hZChmaWxlbmFtZTpzdHJpbmcsIFtvcHRpb25zOklQYXJzZU9wdGlvbnNdKTpQcm9taXNlPFJvb3Q+XG5cbi8qKlxuICogU3luY2hyb25vdXNseSBsb2FkcyBvbmUgb3IgbXVsdGlwbGUgLnByb3RvIG9yIHByZXByb2Nlc3NlZCAuanNvbiBmaWxlcyBpbnRvIHRoaXMgcm9vdCBuYW1lc3BhY2UgKG5vZGUgb25seSkuXG4gKiBAZnVuY3Rpb24gUm9vdCNsb2FkU3luY1xuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGZpbGVuYW1lIE5hbWVzIG9mIG9uZSBvciBtdWx0aXBsZSBmaWxlcyB0byBsb2FkXG4gKiBAcGFyYW0ge0lQYXJzZU9wdGlvbnN9IFtvcHRpb25zXSBQYXJzZSBvcHRpb25zLiBEZWZhdWx0cyB0byB7QGxpbmsgcGFyc2UuZGVmYXVsdHN9IHdoZW4gb21pdHRlZC5cbiAqIEByZXR1cm5zIHtSb290fSBSb290IG5hbWVzcGFjZVxuICogQHRocm93cyB7RXJyb3J9IElmIHN5bmNocm9ub3VzIGZldGNoaW5nIGlzIG5vdCBzdXBwb3J0ZWQgKGkuZS4gaW4gYnJvd3NlcnMpIG9yIGlmIGEgZmlsZSdzIHN5bnRheCBpcyBpbnZhbGlkXG4gKi9cblJvb3QucHJvdG90eXBlLmxvYWRTeW5jID0gZnVuY3Rpb24gbG9hZFN5bmMoZmlsZW5hbWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXV0aWwuaXNOb2RlKVxuICAgICAgICB0aHJvdyBFcnJvcihcIm5vdCBzdXBwb3J0ZWRcIik7XG4gICAgcmV0dXJuIHRoaXMubG9hZChmaWxlbmFtZSwgb3B0aW9ucywgU1lOQyk7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5Sb290LnByb3RvdHlwZS5yZXNvbHZlQWxsID0gZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICBpZiAoIXRoaXMuX25lZWRzUmVjdXJzaXZlUmVzb2x2ZSkgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAodGhpcy5kZWZlcnJlZC5sZW5ndGgpXG4gICAgICAgIHRocm93IEVycm9yKFwidW5yZXNvbHZhYmxlIGV4dGVuc2lvbnM6IFwiICsgdGhpcy5kZWZlcnJlZC5tYXAoZnVuY3Rpb24oZmllbGQpIHtcbiAgICAgICAgICAgIHJldHVybiBcIidleHRlbmQgXCIgKyBmaWVsZC5leHRlbmQgKyBcIicgaW4gXCIgKyBmaWVsZC5wYXJlbnQuZnVsbE5hbWU7XG4gICAgICAgIH0pLmpvaW4oXCIsIFwiKSk7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZUFsbC5jYWxsKHRoaXMpO1xufTtcblxuLy8gb25seSB1cHBlcmNhc2VkIChhbmQgdGh1cyBjb25mbGljdC1mcmVlKSBjaGlsZHJlbiBhcmUgZXhwb3NlZCwgc2VlIGJlbG93XG52YXIgZXhwb3NlUmUgPSAvXltBLVpdLztcblxuLyoqXG4gKiBIYW5kbGVzIGEgZGVmZXJyZWQgZGVjbGFyaW5nIGV4dGVuc2lvbiBmaWVsZCBieSBjcmVhdGluZyBhIHNpc3RlciBmaWVsZCB0byByZXByZXNlbnQgaXQgd2l0aGluIGl0cyBleHRlbmRlZCB0eXBlLlxuICogQHBhcmFtIHtSb290fSByb290IFJvb3QgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RmllbGR9IGZpZWxkIERlY2xhcmluZyBleHRlbnNpb24gZmllbGQgd2l0aW4gdGhlIGRlY2xhcmluZyB0eXBlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHN1Y2Nlc3NmdWxseSBhZGRlZCB0byB0aGUgZXh0ZW5kZWQgdHlwZSwgYGZhbHNlYCBvdGhlcndpc2VcbiAqIEBpbm5lclxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiB0cnlIYW5kbGVFeHRlbnNpb24ocm9vdCwgZmllbGQpIHtcbiAgICB2YXIgZXh0ZW5kZWRUeXBlID0gZmllbGQucGFyZW50Lmxvb2t1cChmaWVsZC5leHRlbmQpO1xuICAgIGlmIChleHRlbmRlZFR5cGUpIHtcbiAgICAgICAgdmFyIHNpc3RlckZpZWxkID0gbmV3IEZpZWxkKGZpZWxkLmZ1bGxOYW1lLCBmaWVsZC5pZCwgZmllbGQudHlwZSwgZmllbGQucnVsZSwgdW5kZWZpbmVkLCBmaWVsZC5vcHRpb25zKTtcbiAgICAgICAgLy9kbyBub3QgYWxsb3cgdG8gZXh0ZW5kIHNhbWUgZmllbGQgdHdpY2UgdG8gcHJldmVudCB0aGUgZXJyb3JcbiAgICAgICAgaWYgKGV4dGVuZGVkVHlwZS5nZXQoc2lzdGVyRmllbGQubmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHNpc3RlckZpZWxkLmRlY2xhcmluZ0ZpZWxkID0gZmllbGQ7XG4gICAgICAgIGZpZWxkLmV4dGVuc2lvbkZpZWxkID0gc2lzdGVyRmllbGQ7XG4gICAgICAgIGV4dGVuZGVkVHlwZS5hZGQoc2lzdGVyRmllbGQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENhbGxlZCB3aGVuIGFueSBvYmplY3QgaXMgYWRkZWQgdG8gdGhpcyByb290IG9yIGl0cyBzdWItbmFtZXNwYWNlcy5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE9iamVjdCBhZGRlZFxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBwcml2YXRlXG4gKi9cblJvb3QucHJvdG90eXBlLl9oYW5kbGVBZGQgPSBmdW5jdGlvbiBfaGFuZGxlQWRkKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCkge1xuXG4gICAgICAgIGlmICgvKiBhbiBleHRlbnNpb24gZmllbGQgKGltcGxpZXMgbm90IHBhcnQgb2YgYSBvbmVvZikgKi8gb2JqZWN0LmV4dGVuZCAhPT0gdW5kZWZpbmVkICYmIC8qIG5vdCBhbHJlYWR5IGhhbmRsZWQgKi8gIW9iamVjdC5leHRlbnNpb25GaWVsZClcbiAgICAgICAgICAgIGlmICghdHJ5SGFuZGxlRXh0ZW5zaW9uKHRoaXMsIG9iamVjdCkpXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5wdXNoKG9iamVjdCk7XG5cbiAgICB9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEVudW0pIHtcblxuICAgICAgICBpZiAoZXhwb3NlUmUudGVzdChvYmplY3QubmFtZSkpXG4gICAgICAgICAgICBvYmplY3QucGFyZW50W29iamVjdC5uYW1lXSA9IG9iamVjdC52YWx1ZXM7IC8vIGV4cG9zZSBlbnVtIHZhbHVlcyBhcyBwcm9wZXJ0eSBvZiBpdHMgcGFyZW50XG5cbiAgICB9IGVsc2UgaWYgKCEob2JqZWN0IGluc3RhbmNlb2YgT25lT2YpKSAvKiBldmVyeXRoaW5nIGVsc2UgaXMgYSBuYW1lc3BhY2UgKi8ge1xuXG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBUeXBlKSAvLyBUcnkgdG8gaGFuZGxlIGFueSBkZWZlcnJlZCBleHRlbnNpb25zXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGVmZXJyZWQubGVuZ3RoOylcbiAgICAgICAgICAgICAgICBpZiAodHJ5SGFuZGxlRXh0ZW5zaW9uKHRoaXMsIHRoaXMuZGVmZXJyZWRbaV0pKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmVycmVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAvKiBpbml0aWFsaXplcyAqLyBvYmplY3QubmVzdGVkQXJyYXkubGVuZ3RoOyArK2opIC8vIHJlY3Vyc2UgaW50byB0aGUgbmFtZXNwYWNlXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVBZGQob2JqZWN0Ll9uZXN0ZWRBcnJheVtqXSk7XG4gICAgICAgIGlmIChleHBvc2VSZS50ZXN0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdID0gb2JqZWN0OyAvLyBleHBvc2UgbmFtZXNwYWNlIGFzIHByb3BlcnR5IG9mIGl0cyBwYXJlbnRcbiAgICB9XG5cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgVHlwZSB8fCBvYmplY3QgaW5zdGFuY2VvZiBFbnVtIHx8IG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkKSB7XG4gICAgICAgIC8vIE9ubHkgc3RvcmUgdHlwZXMgYW5kIGVudW1zIGZvciBxdWljayBsb29rdXAgZHVyaW5nIHJlc29sdmUuXG4gICAgICAgIHRoaXMuX2Z1bGx5UXVhbGlmaWVkT2JqZWN0c1tvYmplY3QuZnVsbE5hbWVdID0gb2JqZWN0O1xuICAgIH1cblxuICAgIC8vIFRoZSBhYm92ZSBhbHNvIGFkZHMgdXBwZXJjYXNlZCAoYW5kIHRodXMgY29uZmxpY3QtZnJlZSkgbmVzdGVkIHR5cGVzLCBzZXJ2aWNlcyBhbmQgZW51bXMgYXNcbiAgICAvLyBwcm9wZXJ0aWVzIG9mIG5hbWVzcGFjZXMganVzdCBsaWtlIHN0YXRpYyBjb2RlIGRvZXMuIFRoaXMgYWxsb3dzIHVzaW5nIGEgLmQudHMgZ2VuZXJhdGVkIGZvclxuICAgIC8vIGEgc3RhdGljIG1vZHVsZSB3aXRoIHJlZmxlY3Rpb24tYmFzZWQgc29sdXRpb25zIHdoZXJlIHRoZSBjb25kaXRpb24gaXMgbWV0LlxufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhbnkgb2JqZWN0IGlzIHJlbW92ZWQgZnJvbSB0aGlzIHJvb3Qgb3IgaXRzIHN1Yi1uYW1lc3BhY2VzLlxuICogQHBhcmFtIHtSZWZsZWN0aW9uT2JqZWN0fSBvYmplY3QgT2JqZWN0IHJlbW92ZWRcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAcHJpdmF0ZVxuICovXG5Sb290LnByb3RvdHlwZS5faGFuZGxlUmVtb3ZlID0gZnVuY3Rpb24gX2hhbmRsZVJlbW92ZShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgRmllbGQpIHtcblxuICAgICAgICBpZiAoLyogYW4gZXh0ZW5zaW9uIGZpZWxkICovIG9iamVjdC5leHRlbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKC8qIGFscmVhZHkgaGFuZGxlZCAqLyBvYmplY3QuZXh0ZW5zaW9uRmllbGQpIHsgLy8gcmVtb3ZlIGl0cyBzaXN0ZXIgZmllbGRcbiAgICAgICAgICAgICAgICBvYmplY3QuZXh0ZW5zaW9uRmllbGQucGFyZW50LnJlbW92ZShvYmplY3QuZXh0ZW5zaW9uRmllbGQpO1xuICAgICAgICAgICAgICAgIG9iamVjdC5leHRlbnNpb25GaWVsZCA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBjYW5jZWwgdGhlIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZGVmZXJyZWQuaW5kZXhPZihvYmplY3QpO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBFbnVtKSB7XG5cbiAgICAgICAgaWYgKGV4cG9zZVJlLnRlc3Qob2JqZWN0Lm5hbWUpKVxuICAgICAgICAgICAgZGVsZXRlIG9iamVjdC5wYXJlbnRbb2JqZWN0Lm5hbWVdOyAvLyB1bmV4cG9zZSBlbnVtIHZhbHVlc1xuXG4gICAgfSBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBOYW1lc3BhY2UpIHtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIG9iamVjdC5uZXN0ZWRBcnJheS5sZW5ndGg7ICsraSkgLy8gcmVjdXJzZSBpbnRvIHRoZSBuYW1lc3BhY2VcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVJlbW92ZShvYmplY3QuX25lc3RlZEFycmF5W2ldKTtcblxuICAgICAgICBpZiAoZXhwb3NlUmUudGVzdChvYmplY3QubmFtZSkpXG4gICAgICAgICAgICBkZWxldGUgb2JqZWN0LnBhcmVudFtvYmplY3QubmFtZV07IC8vIHVuZXhwb3NlIG5hbWVzcGFjZXNcblxuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9mdWxseVF1YWxpZmllZE9iamVjdHNbb2JqZWN0LmZ1bGxOYW1lXTtcbn07XG5cbi8vIFNldHMgdXAgY3ljbGljIGRlcGVuZGVuY2llcyAoY2FsbGVkIGluIGluZGV4LWxpZ2h0KVxuUm9vdC5fY29uZmlndXJlID0gZnVuY3Rpb24oVHlwZV8sIHBhcnNlXywgY29tbW9uXykge1xuICAgIFR5cGUgICA9IFR5cGVfO1xuICAgIHBhcnNlICA9IHBhcnNlXztcbiAgICBjb21tb24gPSBjb21tb25fO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiUm9vdCIsIk5hbWVzcGFjZSIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsImNsYXNzTmFtZSIsIkZpZWxkIiwiRW51bSIsIk9uZU9mIiwidXRpbCIsIlR5cGUiLCJwYXJzZSIsImNvbW1vbiIsIm9wdGlvbnMiLCJjYWxsIiwiZGVmZXJyZWQiLCJmaWxlcyIsIl9lZGl0aW9uIiwiX2Z1bGx5UXVhbGlmaWVkT2JqZWN0cyIsImZyb21KU09OIiwianNvbiIsInJvb3QiLCJzZXRPcHRpb25zIiwiYWRkSlNPTiIsIm5lc3RlZCIsInJlc29sdmVBbGwiLCJyZXNvbHZlUGF0aCIsInBhdGgiLCJyZXNvbHZlIiwiZmV0Y2giLCJTWU5DIiwibG9hZCIsImZpbGVuYW1lIiwiY2FsbGJhY2siLCJ1bmRlZmluZWQiLCJzZWxmIiwiYXNQcm9taXNlIiwic3luYyIsImZpbmlzaCIsImVyciIsImNiIiwiZ2V0QnVuZGxlZEZpbGVOYW1lIiwiaWR4IiwibGFzdEluZGV4T2YiLCJhbHRuYW1lIiwic3Vic3RyaW5nIiwicHJvY2VzcyIsInNvdXJjZSIsImlzU3RyaW5nIiwiY2hhckF0IiwiSlNPTiIsInBhcnNlZCIsInJlc29sdmVkIiwiaSIsImltcG9ydHMiLCJsZW5ndGgiLCJ3ZWFrSW1wb3J0cyIsInF1ZXVlZCIsIndlYWsiLCJpbmRleE9mIiwicHVzaCIsInNldFRpbWVvdXQiLCJmcyIsInJlYWRGaWxlU3luYyIsInRvU3RyaW5nIiwibG9hZFN5bmMiLCJpc05vZGUiLCJFcnJvciIsIl9uZWVkc1JlY3Vyc2l2ZVJlc29sdmUiLCJtYXAiLCJmaWVsZCIsImV4dGVuZCIsInBhcmVudCIsImZ1bGxOYW1lIiwiam9pbiIsImV4cG9zZVJlIiwidHJ5SGFuZGxlRXh0ZW5zaW9uIiwiZXh0ZW5kZWRUeXBlIiwibG9va3VwIiwic2lzdGVyRmllbGQiLCJpZCIsInR5cGUiLCJydWxlIiwiZ2V0IiwibmFtZSIsImRlY2xhcmluZ0ZpZWxkIiwiZXh0ZW5zaW9uRmllbGQiLCJhZGQiLCJfaGFuZGxlQWRkIiwib2JqZWN0IiwidGVzdCIsInZhbHVlcyIsInNwbGljZSIsImoiLCJuZXN0ZWRBcnJheSIsIl9uZXN0ZWRBcnJheSIsIl9oYW5kbGVSZW1vdmUiLCJyZW1vdmUiLCJpbmRleCIsIl9jb25maWd1cmUiLCJUeXBlXyIsInBhcnNlXyIsImNvbW1vbl8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/roots.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/roots.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = {}; /**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */ \n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHLENBQUMsR0FFbEI7Ozs7Ozs7Ozs7Ozs7O0NBY0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcm9vdHMuanM/NjY3YyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKlxuICogTmFtZWQgcm9vdHMuXG4gKiBUaGlzIGlzIHdoZXJlIHBianMgc3RvcmVzIGdlbmVyYXRlZCBzdHJ1Y3R1cmVzICh0aGUgb3B0aW9uIGAtciwgLS1yb290YCBzcGVjaWZpZXMgYSBuYW1lKS5cbiAqIENhbiBhbHNvIGJlIHVzZWQgbWFudWFsbHkgdG8gbWFrZSByb290cyBhdmFpbGFibGUgYWNyb3NzIG1vZHVsZXMuXG4gKiBAbmFtZSByb290c1xuICogQHR5cGUge09iamVjdC48c3RyaW5nLFJvb3Q+fVxuICogQGV4YW1wbGVcbiAqIC8vIHBianMgLXIgbXlyb290IC1vIGNvbXBpbGVkLmpzIC4uLlxuICpcbiAqIC8vIGluIGFub3RoZXIgbW9kdWxlOlxuICogcmVxdWlyZShcIi4vY29tcGlsZWQuanNcIik7XG4gKlxuICogLy8gaW4gYW55IHN1YnNlcXVlbnQgbW9kdWxlOlxuICogdmFyIHJvb3QgPSBwcm90b2J1Zi5yb290c1tcIm15cm9vdFwiXTtcbiAqL1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/roots.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Streaming RPC helpers.\n * @namespace\n */ var rpc = exports;\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */ /**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */ rpc.Service = __webpack_require__(/*! ./rpc/service */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc/service.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBRWI7OztDQUdDLEdBQ0QsSUFBSUEsTUFBTUM7QUFFVjs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUVEOzs7Ozs7O0NBT0MsR0FFREQsSUFBSUUsT0FBTyxHQUFHQyxtQkFBT0EsQ0FBQyxvR0FBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy9ycGMuanM/Njc4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBTdHJlYW1pbmcgUlBDIGhlbHBlcnMuXG4gKiBAbmFtZXNwYWNlXG4gKi9cbnZhciBycGMgPSBleHBvcnRzO1xuXG4vKipcbiAqIFJQQyBpbXBsZW1lbnRhdGlvbiBwYXNzZWQgdG8ge0BsaW5rIFNlcnZpY2UjY3JlYXRlfSBwZXJmb3JtaW5nIGEgc2VydmljZSByZXF1ZXN0IG9uIG5ldHdvcmsgbGV2ZWwsIGkuZS4gYnkgdXRpbGl6aW5nIGh0dHAgcmVxdWVzdHMgb3Igd2Vic29ja2V0cy5cbiAqIEB0eXBlZGVmIFJQQ0ltcGxcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPE1lc3NhZ2U8e30+LE1lc3NhZ2U8e30+Pn0gbWV0aG9kIFJlZmxlY3RlZCBvciBzdGF0aWMgbWV0aG9kIGJlaW5nIGNhbGxlZFxuICogQHBhcmFtIHtVaW50OEFycmF5fSByZXF1ZXN0RGF0YSBSZXF1ZXN0IGRhdGFcbiAqIEBwYXJhbSB7UlBDSW1wbENhbGxiYWNrfSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEBleGFtcGxlXG4gKiBmdW5jdGlvbiBycGNJbXBsKG1ldGhvZCwgcmVxdWVzdERhdGEsIGNhbGxiYWNrKSB7XG4gKiAgICAgaWYgKHByb3RvYnVmLnV0aWwubGNGaXJzdChtZXRob2QubmFtZSkgIT09IFwibXlNZXRob2RcIikgLy8gY29tcGF0aWJsZSB3aXRoIHN0YXRpYyBjb2RlXG4gKiAgICAgICAgIHRocm93IEVycm9yKFwibm8gc3VjaCBtZXRob2RcIik7XG4gKiAgICAgYXN5bmNocm9ub3VzbHlPYnRhaW5BUmVzcG9uc2UocmVxdWVzdERhdGEsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VEYXRhKSB7XG4gKiAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzcG9uc2VEYXRhKTtcbiAqICAgICB9KTtcbiAqIH1cbiAqL1xuXG4vKipcbiAqIE5vZGUtc3R5bGUgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgUlBDSW1wbH0uXG4gKiBAdHlwZWRlZiBSUENJbXBsQ2FsbGJhY2tcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxuICogQHBhcmFtIHtVaW50OEFycmF5fG51bGx9IFtyZXNwb25zZV0gUmVzcG9uc2UgZGF0YSBvciBgbnVsbGAgdG8gc2lnbmFsIGVuZCBvZiBzdHJlYW0sIGlmIHRoZXJlIGhhc24ndCBiZWVuIGFuIGVycm9yXG4gKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbnJwYy5TZXJ2aWNlID0gcmVxdWlyZShcIi4vcnBjL3NlcnZpY2VcIik7XG4iXSwibmFtZXMiOlsicnBjIiwiZXhwb3J0cyIsIlNlcnZpY2UiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc/service.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc/service.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Service;\nvar util = __webpack_require__(/*! ../util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */ /**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */ /**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */ function Service(rpcImpl, requestDelimited, responseDelimited) {\n    if (typeof rpcImpl !== \"function\") throw TypeError(\"rpcImpl must be a function\");\n    util.EventEmitter.call(this);\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */ this.rpcImpl = rpcImpl;\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */ this.requestDelimited = Boolean(requestDelimited);\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */ this.responseDelimited = Boolean(responseDelimited);\n}\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */ Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n    if (!request) throw TypeError(\"request must be specified\");\n    var self = this;\n    if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n    if (!self.rpcImpl) {\n        setTimeout(function() {\n            callback(Error(\"already ended\"));\n        }, 0);\n        return undefined;\n    }\n    try {\n        return self.rpcImpl(method, requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(), function rpcCallback(err, response) {\n            if (err) {\n                self.emit(\"error\", err, method);\n                return callback(err);\n            }\n            if (response === null) {\n                self.end(/* endedByRPC */ true);\n                return undefined;\n            }\n            if (!(response instanceof responseCtor)) {\n                try {\n                    response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                } catch (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n            }\n            self.emit(\"data\", response, method);\n            return callback(null, response);\n        });\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() {\n            callback(err);\n        }, 0);\n        return undefined;\n    }\n};\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */ Service.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvcnBjL3NlcnZpY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFPQyxtQkFBT0EsQ0FBQyx1R0FBaUI7QUFFcEMsdUJBQXVCO0FBQ3RCRixDQUFBQSxRQUFRRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osS0FBS0ssWUFBWSxDQUFDSCxTQUFTLEdBQUdJLFdBQVcsR0FBR1A7QUFFL0U7Ozs7Ozs7Ozs7Q0FVQyxHQUVEOzs7Ozs7Ozs7Q0FTQyxHQUVEOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNBLFFBQVFRLE9BQU8sRUFBRUMsZ0JBQWdCLEVBQUVDLGlCQUFpQjtJQUV6RCxJQUFJLE9BQU9GLFlBQVksWUFDbkIsTUFBTUcsVUFBVTtJQUVwQlYsS0FBS0ssWUFBWSxDQUFDTSxJQUFJLENBQUMsSUFBSTtJQUUzQjs7O0tBR0MsR0FDRCxJQUFJLENBQUNKLE9BQU8sR0FBR0E7SUFFZjs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLGdCQUFnQixHQUFHSSxRQUFRSjtJQUVoQzs7O0tBR0MsR0FDRCxJQUFJLENBQUNDLGlCQUFpQixHQUFHRyxRQUFRSDtBQUNyQztBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRFYsUUFBUUcsU0FBUyxDQUFDVyxPQUFPLEdBQUcsU0FBU0EsUUFBUUMsTUFBTSxFQUFFQyxXQUFXLEVBQUVDLFlBQVksRUFBRUMsT0FBTyxFQUFFQyxRQUFRO0lBRTdGLElBQUksQ0FBQ0QsU0FDRCxNQUFNUCxVQUFVO0lBRXBCLElBQUlTLE9BQU8sSUFBSTtJQUNmLElBQUksQ0FBQ0QsVUFDRCxPQUFPbEIsS0FBS29CLFNBQVMsQ0FBQ1AsU0FBU00sTUFBTUwsUUFBUUMsYUFBYUMsY0FBY0M7SUFFNUUsSUFBSSxDQUFDRSxLQUFLWixPQUFPLEVBQUU7UUFDZmMsV0FBVztZQUFhSCxTQUFTSSxNQUFNO1FBQW1CLEdBQUc7UUFDN0QsT0FBT0M7SUFDWDtJQUVBLElBQUk7UUFDQSxPQUFPSixLQUFLWixPQUFPLENBQ2ZPLFFBQ0FDLFdBQVcsQ0FBQ0ksS0FBS1gsZ0JBQWdCLEdBQUcsb0JBQW9CLFNBQVMsQ0FBQ1MsU0FBU08sTUFBTSxJQUNqRixTQUFTQyxZQUFZQyxHQUFHLEVBQUVDLFFBQVE7WUFFOUIsSUFBSUQsS0FBSztnQkFDTFAsS0FBS1MsSUFBSSxDQUFDLFNBQVNGLEtBQUtaO2dCQUN4QixPQUFPSSxTQUFTUTtZQUNwQjtZQUVBLElBQUlDLGFBQWEsTUFBTTtnQkFDbkJSLEtBQUtVLEdBQUcsQ0FBQyxjQUFjLEdBQUc7Z0JBQzFCLE9BQU9OO1lBQ1g7WUFFQSxJQUFJLENBQUVJLENBQUFBLG9CQUFvQlgsWUFBVyxHQUFJO2dCQUNyQyxJQUFJO29CQUNBVyxXQUFXWCxZQUFZLENBQUNHLEtBQUtWLGlCQUFpQixHQUFHLG9CQUFvQixTQUFTLENBQUNrQjtnQkFDbkYsRUFBRSxPQUFPRCxLQUFLO29CQUNWUCxLQUFLUyxJQUFJLENBQUMsU0FBU0YsS0FBS1o7b0JBQ3hCLE9BQU9JLFNBQVNRO2dCQUNwQjtZQUNKO1lBRUFQLEtBQUtTLElBQUksQ0FBQyxRQUFRRCxVQUFVYjtZQUM1QixPQUFPSSxTQUFTLE1BQU1TO1FBQzFCO0lBRVIsRUFBRSxPQUFPRCxLQUFLO1FBQ1ZQLEtBQUtTLElBQUksQ0FBQyxTQUFTRixLQUFLWjtRQUN4Qk8sV0FBVztZQUFhSCxTQUFTUTtRQUFNLEdBQUc7UUFDMUMsT0FBT0g7SUFDWDtBQUNKO0FBRUE7Ozs7Q0FJQyxHQUNEeEIsUUFBUUcsU0FBUyxDQUFDMkIsR0FBRyxHQUFHLFNBQVNBLElBQUlDLFVBQVU7SUFDM0MsSUFBSSxJQUFJLENBQUN2QixPQUFPLEVBQUU7UUFDZCxJQUFJLENBQUN1QixZQUNELElBQUksQ0FBQ3ZCLE9BQU8sQ0FBQyxNQUFNLE1BQU07UUFDN0IsSUFBSSxDQUFDQSxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNxQixJQUFJLENBQUMsT0FBT0csR0FBRztJQUN4QjtJQUNBLE9BQU8sSUFBSTtBQUNmIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3JwYy9zZXJ2aWNlLmpzPzdjODMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFNlcnZpY2U7XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWwvbWluaW1hbFwiKTtcblxuLy8gRXh0ZW5kcyBFdmVudEVtaXR0ZXJcbihTZXJ2aWNlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodXRpbC5FdmVudEVtaXR0ZXIucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlO1xuXG4vKipcbiAqIEEgc2VydmljZSBtZXRob2QgY2FsbGJhY2sgYXMgdXNlZCBieSB7QGxpbmsgcnBjLlNlcnZpY2VNZXRob2R8U2VydmljZU1ldGhvZH0uXG4gKlxuICogRGlmZmVycyBmcm9tIHtAbGluayBSUENJbXBsQ2FsbGJhY2t9IGluIHRoYXQgaXQgaXMgYW4gYWN0dWFsIGNhbGxiYWNrIG9mIGEgc2VydmljZSBtZXRob2Qgd2hpY2ggbWF5IG5vdCByZXR1cm4gYHJlc3BvbnNlID0gbnVsbGAuXG4gKiBAdHlwZWRlZiBycGMuU2VydmljZU1ldGhvZENhbGxiYWNrXG4gKiBAdGVtcGxhdGUgVFJlcyBleHRlbmRzIE1lc3NhZ2U8VFJlcz5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7RXJyb3J8bnVsbH0gZXJyb3IgRXJyb3IsIGlmIGFueVxuICogQHBhcmFtIHtUUmVzfSBbcmVzcG9uc2VdIFJlc3BvbnNlIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBBIHNlcnZpY2UgbWV0aG9kIHBhcnQgb2YgYSB7QGxpbmsgcnBjLlNlcnZpY2V9IGFzIGNyZWF0ZWQgYnkge0BsaW5rIFNlcnZpY2UuY3JlYXRlfS5cbiAqIEB0eXBlZGVmIHJwYy5TZXJ2aWNlTWV0aG9kXG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtUUmVxfFByb3BlcnRpZXM8VFJlcT59IHJlcXVlc3QgUmVxdWVzdCBtZXNzYWdlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtycGMuU2VydmljZU1ldGhvZENhbGxiYWNrPFRSZXM+fSBbY2FsbGJhY2tdIE5vZGUtc3R5bGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggdGhlIGVycm9yLCBpZiBhbnksIGFuZCB0aGUgcmVzcG9uc2UgbWVzc2FnZVxuICogQHJldHVybnMge1Byb21pc2U8TWVzc2FnZTxUUmVzPj59IFByb21pc2UgaWYgYGNhbGxiYWNrYCBoYXMgYmVlbiBvbWl0dGVkLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqL1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgUlBDIHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIEFuIFJQQyBzZXJ2aWNlIGFzIHJldHVybmVkIGJ5IHtAbGluayBTZXJ2aWNlI2NyZWF0ZX0uXG4gKiBAZXhwb3J0cyBycGMuU2VydmljZVxuICogQGV4dGVuZHMgdXRpbC5FdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UocnBjSW1wbCwgcmVxdWVzdERlbGltaXRlZCwgcmVzcG9uc2VEZWxpbWl0ZWQpIHtcblxuICAgIGlmICh0eXBlb2YgcnBjSW1wbCAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJycGNJbXBsIG11c3QgYmUgYSBmdW5jdGlvblwiKTtcblxuICAgIHV0aWwuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBSUEMgaW1wbGVtZW50YXRpb24uIEJlY29tZXMgYG51bGxgIG9uY2UgdGhlIHNlcnZpY2UgaXMgZW5kZWQuXG4gICAgICogQHR5cGUge1JQQ0ltcGx8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJwY0ltcGwgPSBycGNJbXBsO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3REZWxpbWl0ZWQgPSBCb29sZWFuKHJlcXVlc3REZWxpbWl0ZWQpO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciByZXNwb25zZXMgYXJlIGxlbmd0aC1kZWxpbWl0ZWQuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5yZXNwb25zZURlbGltaXRlZCA9IEJvb2xlYW4ocmVzcG9uc2VEZWxpbWl0ZWQpO1xufVxuXG4vKipcbiAqIENhbGxzIGEgc2VydmljZSBtZXRob2QgdGhyb3VnaCB7QGxpbmsgcnBjLlNlcnZpY2UjcnBjSW1wbHxycGNJbXBsfS5cbiAqIEBwYXJhbSB7TWV0aG9kfHJwYy5TZXJ2aWNlTWV0aG9kPFRSZXEsVFJlcz59IG1ldGhvZCBSZWZsZWN0ZWQgb3Igc3RhdGljIG1ldGhvZFxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVxPn0gcmVxdWVzdEN0b3IgUmVxdWVzdCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUUmVzPn0gcmVzcG9uc2VDdG9yIFJlc3BvbnNlIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1RSZXF8UHJvcGVydGllczxUUmVxPn0gcmVxdWVzdCBSZXF1ZXN0IG1lc3NhZ2Ugb3IgcGxhaW4gb2JqZWN0XG4gKiBAcGFyYW0ge3JwYy5TZXJ2aWNlTWV0aG9kQ2FsbGJhY2s8VFJlcz59IGNhbGxiYWNrIFNlcnZpY2UgY2FsbGJhY2tcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKiBAdGVtcGxhdGUgVFJlcSBleHRlbmRzIE1lc3NhZ2U8VFJlcT5cbiAqIEB0ZW1wbGF0ZSBUUmVzIGV4dGVuZHMgTWVzc2FnZTxUUmVzPlxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5ycGNDYWxsID0gZnVuY3Rpb24gcnBjQ2FsbChtZXRob2QsIHJlcXVlc3RDdG9yLCByZXNwb25zZUN0b3IsIHJlcXVlc3QsIGNhbGxiYWNrKSB7XG5cbiAgICBpZiAoIXJlcXVlc3QpXG4gICAgICAgIHRocm93IFR5cGVFcnJvcihcInJlcXVlc3QgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCFjYWxsYmFjaylcbiAgICAgICAgcmV0dXJuIHV0aWwuYXNQcm9taXNlKHJwY0NhbGwsIHNlbGYsIG1ldGhvZCwgcmVxdWVzdEN0b3IsIHJlc3BvbnNlQ3RvciwgcmVxdWVzdCk7XG5cbiAgICBpZiAoIXNlbGYucnBjSW1wbCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBjYWxsYmFjayhFcnJvcihcImFscmVhZHkgZW5kZWRcIikpOyB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gc2VsZi5ycGNJbXBsKFxuICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgcmVxdWVzdEN0b3Jbc2VsZi5yZXF1ZXN0RGVsaW1pdGVkID8gXCJlbmNvZGVEZWxpbWl0ZWRcIiA6IFwiZW5jb2RlXCJdKHJlcXVlc3QpLmZpbmlzaCgpLFxuICAgICAgICAgICAgZnVuY3Rpb24gcnBjQ2FsbGJhY2soZXJyLCByZXNwb25zZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnIsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmVuZCgvKiBlbmRlZEJ5UlBDICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlIGluc3RhbmNlb2YgcmVzcG9uc2VDdG9yKSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXNwb25zZUN0b3Jbc2VsZi5yZXNwb25zZURlbGltaXRlZCA/IFwiZGVjb2RlRGVsaW1pdGVkXCIgOiBcImRlY29kZVwiXShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwiZXJyb3JcIiwgZXJyLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJkYXRhXCIsIHJlc3BvbnNlLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdChcImVycm9yXCIsIGVyciwgbWV0aG9kKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgY2FsbGJhY2soZXJyKTsgfSwgMCk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmRzIHRoaXMgc2VydmljZSBhbmQgZW1pdHMgdGhlIGBlbmRgIGV2ZW50LlxuICogQHBhcmFtIHtib29sZWFufSBbZW5kZWRCeVJQQz1mYWxzZV0gV2hldGhlciB0aGUgc2VydmljZSBoYXMgYmVlbiBlbmRlZCBieSB0aGUgUlBDIGltcGxlbWVudGF0aW9uLlxuICogQHJldHVybnMge3JwYy5TZXJ2aWNlfSBgdGhpc2BcbiAqL1xuU2VydmljZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kKGVuZGVkQnlSUEMpIHtcbiAgICBpZiAodGhpcy5ycGNJbXBsKSB7XG4gICAgICAgIGlmICghZW5kZWRCeVJQQykgLy8gc2lnbmFsIGVuZCB0byBycGNJbXBsXG4gICAgICAgICAgICB0aGlzLnJwY0ltcGwobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucnBjSW1wbCA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChcImVuZFwiKS5vZmYoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJTZXJ2aWNlIiwidXRpbCIsInJlcXVpcmUiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJFdmVudEVtaXR0ZXIiLCJjb25zdHJ1Y3RvciIsInJwY0ltcGwiLCJyZXF1ZXN0RGVsaW1pdGVkIiwicmVzcG9uc2VEZWxpbWl0ZWQiLCJUeXBlRXJyb3IiLCJjYWxsIiwiQm9vbGVhbiIsInJwY0NhbGwiLCJtZXRob2QiLCJyZXF1ZXN0Q3RvciIsInJlc3BvbnNlQ3RvciIsInJlcXVlc3QiLCJjYWxsYmFjayIsInNlbGYiLCJhc1Byb21pc2UiLCJzZXRUaW1lb3V0IiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJmaW5pc2giLCJycGNDYWxsYmFjayIsImVyciIsInJlc3BvbnNlIiwiZW1pdCIsImVuZCIsImVuZGVkQnlSUEMiLCJvZmYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc/service.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Service;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\");\n((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = \"Service\";\nvar Method = __webpack_require__(/*! ./method */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/method.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\"), rpc = __webpack_require__(/*! ./rpc */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/rpc.js\");\n/**\n * Constructs a new service instance.\n * @classdesc Reflected service.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Service name\n * @param {Object.<string,*>} [options] Service options\n * @throws {TypeError} If arguments are invalid\n */ function Service(name, options) {\n    Namespace.call(this, name, options);\n    /**\n     * Service methods.\n     * @type {Object.<string,Method>}\n     */ this.methods = {}; // toJSON, marker\n    /**\n     * Cached methods as an array.\n     * @type {Method[]|null}\n     * @private\n     */ this._methodsArray = null;\n}\n/**\n * Service descriptor.\n * @interface IService\n * @extends INamespace\n * @property {Object.<string,IMethod>} methods Method descriptors\n */ /**\n * Constructs a service from a service descriptor.\n * @param {string} name Service name\n * @param {IService} json Service descriptor\n * @returns {Service} Created service\n * @throws {TypeError} If arguments are invalid\n */ Service.fromJSON = function fromJSON(name, json) {\n    var service = new Service(name, json.options);\n    /* istanbul ignore else */ if (json.methods) for(var names = Object.keys(json.methods), i = 0; i < names.length; ++i)service.add(Method.fromJSON(names[i], json.methods[names[i]]));\n    if (json.nested) service.addJSON(json.nested);\n    if (json.edition) service._edition = json.edition;\n    service.comment = json.comment;\n    service._defaultEdition = \"proto3\"; // For backwards-compatibility.\n    return service;\n};\n/**\n * Converts this service to a service descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IService} Service descriptor\n */ Service.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"edition\",\n        this._editionToJSON(),\n        \"options\",\n        inherited && inherited.options || undefined,\n        \"methods\",\n        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */ {},\n        \"nested\",\n        inherited && inherited.nested || undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * Methods of this service as an array for iteration.\n * @name Service#methodsArray\n * @type {Method[]}\n * @readonly\n */ Object.defineProperty(Service.prototype, \"methodsArray\", {\n    get: function() {\n        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));\n    }\n});\nfunction clearCache(service) {\n    service._methodsArray = null;\n    return service;\n}\n/**\n * @override\n */ Service.prototype.get = function get(name) {\n    return this.methods[name] || Namespace.prototype.get.call(this, name);\n};\n/**\n * @override\n */ Service.prototype.resolveAll = function resolveAll() {\n    if (!this._needsRecursiveResolve) return this;\n    Namespace.prototype.resolve.call(this);\n    var methods = this.methodsArray;\n    for(var i = 0; i < methods.length; ++i)methods[i].resolve();\n    return this;\n};\n/**\n * @override\n */ Service.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n    if (!this._needsRecursiveFeatureResolution) return this;\n    edition = this._edition || edition;\n    Namespace.prototype._resolveFeaturesRecursive.call(this, edition);\n    this.methodsArray.forEach((method)=>{\n        method._resolveFeaturesRecursive(edition);\n    });\n    return this;\n};\n/**\n * @override\n */ Service.prototype.add = function add(object) {\n    /* istanbul ignore if */ if (this.get(object.name)) throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    if (object instanceof Method) {\n        this.methods[object.name] = object;\n        object.parent = this;\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n/**\n * @override\n */ Service.prototype.remove = function remove(object) {\n    if (object instanceof Method) {\n        /* istanbul ignore if */ if (this.methods[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.methods[object.name];\n        object.parent = null;\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n/**\n * Creates a runtime service using the specified rpc implementation.\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n * @returns {rpc.Service} RPC service. Useful where requests and/or responses are streamed.\n */ Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {\n    var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);\n    for(var i = 0, method; i < /* initializes */ this.methodsArray.length; ++i){\n        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\\w_]/g, \"\");\n        rpcService[methodName] = util.codegen([\n            \"r\",\n            \"c\"\n        ], util.isReserved(methodName) ? methodName + \"_\" : methodName)(\"return this.rpcCall(m,q,s,r,c)\")({\n            m: method,\n            q: method.resolvedRequestType.ctor,\n            s: method.resolvedResponseType.ctor\n        });\n    }\n    return rpcService;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvc2VydmljZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLG9CQUFvQjtBQUNwQixJQUFJQyxZQUFZQyxtQkFBT0EsQ0FBQyxnR0FBYTtBQUNwQyxFQUFDRixRQUFRRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osVUFBVUUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLE9BQU0sRUFBR08sU0FBUyxHQUFHO0FBRTdGLElBQUlDLFNBQVNOLG1CQUFPQSxDQUFDLDBGQUFVLEdBQzNCTyxPQUFTUCxtQkFBT0EsQ0FBQyxzRkFBUSxHQUN6QlEsTUFBU1IsbUJBQU9BLENBQUMsb0ZBQU87QUFFNUI7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTRixRQUFRVyxJQUFJLEVBQUVDLE9BQU87SUFDMUJYLFVBQVVZLElBQUksQ0FBQyxJQUFJLEVBQUVGLE1BQU1DO0lBRTNCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsT0FBTyxHQUFHLENBQUMsR0FBRyxpQkFBaUI7SUFFcEM7Ozs7S0FJQyxHQUNELElBQUksQ0FBQ0MsYUFBYSxHQUFHO0FBQ3pCO0FBRUE7Ozs7O0NBS0MsR0FFRDs7Ozs7O0NBTUMsR0FDRGYsUUFBUWdCLFFBQVEsR0FBRyxTQUFTQSxTQUFTTCxJQUFJLEVBQUVNLElBQUk7SUFDM0MsSUFBSUMsVUFBVSxJQUFJbEIsUUFBUVcsTUFBTU0sS0FBS0wsT0FBTztJQUM1Qyx3QkFBd0IsR0FDeEIsSUFBSUssS0FBS0gsT0FBTyxFQUNaLElBQUssSUFBSUssUUFBUWYsT0FBT2dCLElBQUksQ0FBQ0gsS0FBS0gsT0FBTyxHQUFHTyxJQUFJLEdBQUdBLElBQUlGLE1BQU1HLE1BQU0sRUFBRSxFQUFFRCxFQUNuRUgsUUFBUUssR0FBRyxDQUFDZixPQUFPUSxRQUFRLENBQUNHLEtBQUssQ0FBQ0UsRUFBRSxFQUFFSixLQUFLSCxP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bEQsS0FBS21ELE9BQU8sQ0FBQyxDQUFDVixTQUFTLElBQUksQ0FBQ25DLGFBQWEsQ0FBQ00sRUFBRSxFQUFFeUIsT0FBTyxHQUFHbkMsSUFBSSxFQUFFa0QsT0FBTyxDQUFDLFlBQVk7UUFDbkdILFVBQVUsQ0FBQ0MsV0FBVyxHQUFHbEQsS0FBS3FELE9BQU8sQ0FBQztZQUFDO1lBQUk7U0FBSSxFQUFFckQsS0FBS3NELFVBQVUsQ0FBQ0osY0FBY0EsYUFBYSxNQUFNQSxZQUFZLGtDQUFrQztZQUM1SUssR0FBR2Q7WUFDSGUsR0FBR2YsT0FBT2dCLG1CQUFtQixDQUFDQyxJQUFJO1lBQ2xDQyxHQUFHbEIsT0FBT21CLG9CQUFvQixDQUFDRixJQUFJO1FBQ3ZDO0lBQ0o7SUFDQSxPQUFPVDtBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3NlcnZpY2UuanM/MTg5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbm1vZHVsZS5leHBvcnRzID0gU2VydmljZTtcblxuLy8gZXh0ZW5kcyBOYW1lc3BhY2VcbnZhciBOYW1lc3BhY2UgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XG4oKFNlcnZpY2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOYW1lc3BhY2UucHJvdG90eXBlKSkuY29uc3RydWN0b3IgPSBTZXJ2aWNlKS5jbGFzc05hbWUgPSBcIlNlcnZpY2VcIjtcblxudmFyIE1ldGhvZCA9IHJlcXVpcmUoXCIuL21ldGhvZFwiKSxcbiAgICB1dGlsICAgPSByZXF1aXJlKFwiLi91dGlsXCIpLFxuICAgIHJwYyAgICA9IHJlcXVpcmUoXCIuL3JwY1wiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBzZXJ2aWNlLlxuICogQGV4dGVuZHMgTmFtZXNwYWNlQmFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBTZXJ2aWNlIG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtvcHRpb25zXSBTZXJ2aWNlIG9wdGlvbnNcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYXJndW1lbnRzIGFyZSBpbnZhbGlkXG4gKi9cbmZ1bmN0aW9uIFNlcnZpY2UobmFtZSwgb3B0aW9ucykge1xuICAgIE5hbWVzcGFjZS5jYWxsKHRoaXMsIG5hbWUsIG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogU2VydmljZSBtZXRob2RzLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxNZXRob2Q+fVxuICAgICAqL1xuICAgIHRoaXMubWV0aG9kcyA9IHt9OyAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIG1ldGhvZHMgYXMgYW4gYXJyYXkuXG4gICAgICogQHR5cGUge01ldGhvZFtdfG51bGx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9tZXRob2RzQXJyYXkgPSBudWxsO1xufVxuXG4vKipcbiAqIFNlcnZpY2UgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSVNlcnZpY2VcbiAqIEBleHRlbmRzIElOYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSU1ldGhvZD59IG1ldGhvZHMgTWV0aG9kIGRlc2NyaXB0b3JzXG4gKi9cblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgc2VydmljZSBmcm9tIGEgc2VydmljZSBkZXNjcmlwdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU2VydmljZSBuYW1lXG4gKiBAcGFyYW0ge0lTZXJ2aWNlfSBqc29uIFNlcnZpY2UgZGVzY3JpcHRvclxuICogQHJldHVybnMge1NlcnZpY2V9IENyZWF0ZWQgc2VydmljZVxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBhcmd1bWVudHMgYXJlIGludmFsaWRcbiAqL1xuU2VydmljZS5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKG5hbWUsIGpzb24pIHtcbiAgICB2YXIgc2VydmljZSA9IG5ldyBTZXJ2aWNlKG5hbWUsIGpzb24ub3B0aW9ucyk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoanNvbi5tZXRob2RzKVxuICAgICAgICBmb3IgKHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24ubWV0aG9kcyksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBzZXJ2aWNlLmFkZChNZXRob2QuZnJvbUpTT04obmFtZXNbaV0sIGpzb24ubWV0aG9kc1tuYW1lc1tpXV0pKTtcbiAgICBpZiAoanNvbi5uZXN0ZWQpXG4gICAgICAgIHNlcnZpY2UuYWRkSlNPTihqc29uLm5lc3RlZCk7XG4gICAgaWYgKGpzb24uZWRpdGlvbilcbiAgICAgICAgc2VydmljZS5fZWRpdGlvbiA9IGpzb24uZWRpdGlvbjtcbiAgICBzZXJ2aWNlLmNvbW1lbnQgPSBqc29uLmNvbW1lbnQ7XG4gICAgc2VydmljZS5fZGVmYXVsdEVkaXRpb24gPSBcInByb3RvM1wiOyAgLy8gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LlxuICAgIHJldHVybiBzZXJ2aWNlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGlzIHNlcnZpY2UgdG8gYSBzZXJ2aWNlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJU2VydmljZX0gU2VydmljZSBkZXNjcmlwdG9yXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTih0b0pTT05PcHRpb25zKSB7XG4gICAgdmFyIGluaGVyaXRlZCA9IE5hbWVzcGFjZS5wcm90b3R5cGUudG9KU09OLmNhbGwodGhpcywgdG9KU09OT3B0aW9ucyk7XG4gICAgdmFyIGtlZXBDb21tZW50cyA9IHRvSlNPTk9wdGlvbnMgPyBCb29sZWFuKHRvSlNPTk9wdGlvbnMua2VlcENvbW1lbnRzKSA6IGZhbHNlO1xuICAgIHJldHVybiB1dGlsLnRvT2JqZWN0KFtcbiAgICAgICAgXCJlZGl0aW9uXCIgLCB0aGlzLl9lZGl0aW9uVG9KU09OKCksXG4gICAgICAgIFwib3B0aW9uc1wiICwgaW5oZXJpdGVkICYmIGluaGVyaXRlZC5vcHRpb25zIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJtZXRob2RzXCIgLCBOYW1lc3BhY2UuYXJyYXlUb0pTT04odGhpcy5tZXRob2RzQXJyYXksIHRvSlNPTk9wdGlvbnMpIHx8IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHt9LFxuICAgICAgICBcIm5lc3RlZFwiICAsIGluaGVyaXRlZCAmJiBpbmhlcml0ZWQubmVzdGVkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgXCJjb21tZW50XCIgLCBrZWVwQ29tbWVudHMgPyB0aGlzLmNvbW1lbnQgOiB1bmRlZmluZWRcbiAgICBdKTtcbn07XG5cbi8qKlxuICogTWV0aG9kcyBvZiB0aGlzIHNlcnZpY2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAqIEBuYW1lIFNlcnZpY2UjbWV0aG9kc0FycmF5XG4gKiBAdHlwZSB7TWV0aG9kW119XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFNlcnZpY2UucHJvdG90eXBlLCBcIm1ldGhvZHNBcnJheVwiLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZHNBcnJheSB8fCAodGhpcy5fbWV0aG9kc0FycmF5ID0gdXRpbC50b0FycmF5KHRoaXMubWV0aG9kcykpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjbGVhckNhY2hlKHNlcnZpY2UpIHtcbiAgICBzZXJ2aWNlLl9tZXRob2RzQXJyYXkgPSBudWxsO1xuICAgIHJldHVybiBzZXJ2aWNlO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZHNbbmFtZV1cbiAgICAgICAgfHwgTmFtZXNwYWNlLnByb3RvdHlwZS5nZXQuY2FsbCh0aGlzLCBuYW1lKTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJlc29sdmVBbGwgPSBmdW5jdGlvbiByZXNvbHZlQWxsKCkge1xuICAgIGlmICghdGhpcy5fbmVlZHNSZWN1cnNpdmVSZXNvbHZlKSByZXR1cm4gdGhpcztcblxuICAgIE5hbWVzcGFjZS5wcm90b3R5cGUucmVzb2x2ZS5jYWxsKHRoaXMpO1xuICAgIHZhciBtZXRob2RzID0gdGhpcy5tZXRob2RzQXJyYXk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgKytpKVxuICAgICAgICBtZXRob2RzW2ldLnJlc29sdmUoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLl9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUgPSBmdW5jdGlvbiBfcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlKGVkaXRpb24pIHtcbiAgICBpZiAoIXRoaXMuX25lZWRzUmVjdXJzaXZlRmVhdHVyZVJlc29sdXRpb24pIHJldHVybiB0aGlzO1xuXG4gICAgZWRpdGlvbiA9IHRoaXMuX2VkaXRpb24gfHwgZWRpdGlvbjtcblxuICAgIE5hbWVzcGFjZS5wcm90b3R5cGUuX3Jlc29sdmVGZWF0dXJlc1JlY3Vyc2l2ZS5jYWxsKHRoaXMsIGVkaXRpb24pO1xuICAgIHRoaXMubWV0aG9kc0FycmF5LmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgICAgbWV0aG9kLl9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUoZWRpdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQob2JqZWN0KSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAodGhpcy5nZXQob2JqZWN0Lm5hbWUpKVxuICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBuYW1lICdcIiArIG9iamVjdC5uYW1lICsgXCInIGluIFwiICsgdGhpcyk7XG5cbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWV0aG9kKSB7XG4gICAgICAgIHRoaXMubWV0aG9kc1tvYmplY3QubmFtZV0gPSBvYmplY3Q7XG4gICAgICAgIG9iamVjdC5wYXJlbnQgPSB0aGlzO1xuICAgICAgICByZXR1cm4gY2xlYXJDYWNoZSh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgb2JqZWN0KTtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgTWV0aG9kKSB7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICh0aGlzLm1ldGhvZHNbb2JqZWN0Lm5hbWVdICE9PSBvYmplY3QpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihvYmplY3QgKyBcIiBpcyBub3QgYSBtZW1iZXIgb2YgXCIgKyB0aGlzKTtcblxuICAgICAgICBkZWxldGUgdGhpcy5tZXRob2RzW29iamVjdC5uYW1lXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzLCBvYmplY3QpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcnVudGltZSBzZXJ2aWNlIHVzaW5nIHRoZSBzcGVjaWZpZWQgcnBjIGltcGxlbWVudGF0aW9uLlxuICogQHBhcmFtIHtSUENJbXBsfSBycGNJbXBsIFJQQyBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbcmVxdWVzdERlbGltaXRlZD1mYWxzZV0gV2hldGhlciByZXF1ZXN0cyBhcmUgbGVuZ3RoLWRlbGltaXRlZFxuICogQHBhcmFtIHtib29sZWFufSBbcmVzcG9uc2VEZWxpbWl0ZWQ9ZmFsc2VdIFdoZXRoZXIgcmVzcG9uc2VzIGFyZSBsZW5ndGgtZGVsaW1pdGVkXG4gKiBAcmV0dXJucyB7cnBjLlNlcnZpY2V9IFJQQyBzZXJ2aWNlLiBVc2VmdWwgd2hlcmUgcmVxdWVzdHMgYW5kL29yIHJlc3BvbnNlcyBhcmUgc3RyZWFtZWQuXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShycGNJbXBsLCByZXF1ZXN0RGVsaW1pdGVkLCByZXNwb25zZURlbGltaXRlZCkge1xuICAgIHZhciBycGNTZXJ2aWNlID0gbmV3IHJwYy5TZXJ2aWNlKHJwY0ltcGwsIHJlcXVlc3REZWxpbWl0ZWQsIHJlc3BvbnNlRGVsaW1pdGVkKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbWV0aG9kOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5tZXRob2RzQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSB1dGlsLmxjRmlyc3QoKG1ldGhvZCA9IHRoaXMuX21ldGhvZHNBcnJheVtpXSkucmVzb2x2ZSgpLm5hbWUpLnJlcGxhY2UoL1teJFxcd19dL2csIFwiXCIpO1xuICAgICAgICBycGNTZXJ2aWNlW21ldGhvZE5hbWVdID0gdXRpbC5jb2RlZ2VuKFtcInJcIixcImNcIl0sIHV0aWwuaXNSZXNlcnZlZChtZXRob2ROYW1lKSA/IG1ldGhvZE5hbWUgKyBcIl9cIiA6IG1ldGhvZE5hbWUpKFwicmV0dXJuIHRoaXMucnBjQ2FsbChtLHEscyxyLGMpXCIpKHtcbiAgICAgICAgICAgIG06IG1ldGhvZCxcbiAgICAgICAgICAgIHE6IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlLmN0b3IsXG4gICAgICAgICAgICBzOiBtZXRob2QucmVzb2x2ZWRSZXNwb25zZVR5cGUuY3RvclxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJwY1NlcnZpY2U7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJTZXJ2aWNlIiwiTmFtZXNwYWNlIiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiY2xhc3NOYW1lIiwiTWV0aG9kIiwidXRpbCIsInJwYyIsIm5hbWUiLCJvcHRpb25zIiwiY2FsbCIsIm1ldGhvZHMiLCJfbWV0aG9kc0FycmF5IiwiZnJvbUpTT04iLCJqc29uIiwic2VydmljZSIsIm5hbWVzIiwia2V5cyIsImkiLCJsZW5ndGgiLCJhZGQiLCJuZXN0ZWQiLCJhZGRKU09OIiwiZWRpdGlvbiIsIl9lZGl0aW9uIiwiY29tbWVudCIsIl9kZWZhdWx0RWRpdGlvbiIsInRvSlNPTiIsInRvSlNPTk9wdGlvbnMiLCJpbmhlcml0ZWQiLCJrZWVwQ29tbWVudHMiLCJCb29sZWFuIiwidG9PYmplY3QiLCJfZWRpdGlvblRvSlNPTiIsInVuZGVmaW5lZCIsImFycmF5VG9KU09OIiwibWV0aG9kc0FycmF5IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJ0b0FycmF5IiwiY2xlYXJDYWNoZSIsInJlc29sdmVBbGwiLCJfbmVlZHNSZWN1cnNpdmVSZXNvbHZlIiwicmVzb2x2ZSIsIl9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUiLCJfbmVlZHNSZWN1cnNpdmVGZWF0dXJlUmVzb2x1dGlvbiIsImZvckVhY2giLCJtZXRob2QiLCJvYmplY3QiLCJFcnJvciIsInBhcmVudCIsInJlbW92ZSIsInJwY0ltcGwiLCJyZXF1ZXN0RGVsaW1pdGVkIiwicmVzcG9uc2VEZWxpbWl0ZWQiLCJycGNTZXJ2aWNlIiwibWV0aG9kTmFtZSIsImxjRmlyc3QiLCJyZXBsYWNlIiwiY29kZWdlbiIsImlzUmVzZXJ2ZWQiLCJtIiwicSIsInJlc29sdmVkUmVxdWVzdFR5cGUiLCJjdG9yIiwicyIsInJlc29sdmVkUmVzcG9uc2VUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/tokenize.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/tokenize.js ***!
  \****************************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = tokenize;\nvar delimRe = /[\\s{}=;:[\\],'\"()<>]/g, stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g, stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\nvar setCommentRe = /^ *[*/]+ */, setCommentAltRe = /^\\s*\\*?\\/*/, setCommentSplitRe = /\\n/g, whitespaceRe = /\\s/, unescapeRe = /\\\\(.?)/g;\nvar unescapeMap = {\n    \"0\": \"\\x00\",\n    \"r\": \"\\r\",\n    \"n\": \"\\n\",\n    \"t\": \"\t\"\n};\n/**\n * Unescapes a string.\n * @param {string} str String to unescape\n * @returns {string} Unescaped string\n * @property {Object.<string,string>} map Special characters map\n * @memberof tokenize\n */ function unescape(str) {\n    return str.replace(unescapeRe, function($0, $1) {\n        switch($1){\n            case \"\\\\\":\n            case \"\":\n                return $1;\n            default:\n                return unescapeMap[$1] || \"\";\n        }\n    });\n}\ntokenize.unescape = unescape;\n/**\n * Gets the next token and advances.\n * @typedef TokenizerHandleNext\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */ /**\n * Peeks for the next token.\n * @typedef TokenizerHandlePeek\n * @type {function}\n * @returns {string|null} Next token or `null` on eof\n */ /**\n * Pushes a token back to the stack.\n * @typedef TokenizerHandlePush\n * @type {function}\n * @param {string} token Token\n * @returns {undefined}\n */ /**\n * Skips the next token.\n * @typedef TokenizerHandleSkip\n * @type {function}\n * @param {string} expected Expected token\n * @param {boolean} [optional=false] If optional\n * @returns {boolean} Whether the token matched\n * @throws {Error} If the token didn't match and is not optional\n */ /**\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\n * @typedef TokenizerHandleCmnt\n * @type {function}\n * @param {number} [line] Line number\n * @returns {string|null} Comment text or `null` if none\n */ /**\n * Handle object returned from {@link tokenize}.\n * @interface ITokenizerHandle\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\n * @property {number} line Current line number\n */ /**\n * Tokenizes the given .proto source and returns an object with useful utility functions.\n * @param {string} source Source contents\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\n * @returns {ITokenizerHandle} Tokenizer handle\n */ function tokenize(source, alternateCommentMode) {\n    /* eslint-disable callback-return */ source = source.toString();\n    var offset = 0, length = source.length, line = 1, lastCommentLine = 0, comments = {};\n    var stack = [];\n    var stringDelim = null;\n    /* istanbul ignore next */ /**\n     * Creates an error for illegal syntax.\n     * @param {string} subject Subject\n     * @returns {Error} Error created\n     * @inner\n     */ function illegal(subject) {\n        return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n    }\n    /**\n     * Reads a string till its end.\n     * @returns {string} String read\n     * @inner\n     */ function readString() {\n        var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n        re.lastIndex = offset - 1;\n        var match = re.exec(source);\n        if (!match) throw illegal(\"string\");\n        offset = re.lastIndex;\n        push(stringDelim);\n        stringDelim = null;\n        return unescape(match[1]);\n    }\n    /**\n     * Gets the character at `pos` within the source.\n     * @param {number} pos Position\n     * @returns {string} Character\n     * @inner\n     */ function charAt(pos) {\n        return source.charAt(pos);\n    }\n    /**\n     * Sets the current comment text.\n     * @param {number} start Start offset\n     * @param {number} end End offset\n     * @param {boolean} isLeading set if a leading comment\n     * @returns {undefined}\n     * @inner\n     */ function setComment(start, end, isLeading) {\n        var comment = {\n            type: source.charAt(start++),\n            lineEmpty: false,\n            leading: isLeading\n        };\n        var lookback;\n        if (alternateCommentMode) {\n            lookback = 2; // alternate comment parsing: \"//\" or \"/*\"\n        } else {\n            lookback = 3; // \"///\" or \"/**\"\n        }\n        var commentOffset = start - lookback, c;\n        do {\n            if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === \"\\n\") {\n                comment.lineEmpty = true;\n                break;\n            }\n        }while (c === \" \" || c === \"\t\");\n        var lines = source.substring(start, end).split(setCommentSplitRe);\n        for(var i = 0; i < lines.length; ++i)lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\").trim();\n        comment.text = lines.join(\"\\n\").trim();\n        comments[line] = comment;\n        lastCommentLine = line;\n    }\n    function isDoubleSlashCommentLine(startOffset) {\n        var endOffset = findEndOfLine(startOffset);\n        // see if remaining line matches comment pattern\n        var lineText = source.substring(startOffset, endOffset);\n        var isComment = /^\\s*\\/\\//.test(lineText);\n        return isComment;\n    }\n    function findEndOfLine(cursor) {\n        // find end of cursor's line\n        var endOffset = cursor;\n        while(endOffset < length && charAt(endOffset) !== \"\\n\"){\n            endOffset++;\n        }\n        return endOffset;\n    }\n    /**\n     * Obtains the next token.\n     * @returns {string|null} Next token or `null` on eof\n     * @inner\n     */ function next() {\n        if (stack.length > 0) return stack.shift();\n        if (stringDelim) return readString();\n        var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;\n        do {\n            if (offset === length) return null;\n            repeat = false;\n            while(whitespaceRe.test(curr = charAt(offset))){\n                if (curr === \"\\n\") {\n                    isLeadingComment = true;\n                    ++line;\n                }\n                if (++offset === length) return null;\n            }\n            if (charAt(offset) === \"/\") {\n                if (++offset === length) {\n                    throw illegal(\"comment\");\n                }\n                if (charAt(offset) === \"/\") {\n                    if (!alternateCommentMode) {\n                        // check for triple-slash comment\n                        isDoc = charAt(start = offset + 1) === \"/\";\n                        while(charAt(++offset) !== \"\\n\"){\n                            if (offset === length) {\n                                return null;\n                            }\n                        }\n                        ++offset;\n                        if (isDoc) {\n                            setComment(start, offset - 1, isLeadingComment);\n                            // Trailing comment cannot not be multi-line,\n                            // so leading comment state should be reset to handle potential next comments\n                            isLeadingComment = true;\n                        }\n                        ++line;\n                        repeat = true;\n                    } else {\n                        // check for double-slash comments, consolidating consecutive lines\n                        start = offset;\n                        isDoc = false;\n                        if (isDoubleSlashCommentLine(offset - 1)) {\n                            isDoc = true;\n                            do {\n                                offset = findEndOfLine(offset);\n                                if (offset === length) {\n                                    break;\n                                }\n                                offset++;\n                                if (!isLeadingComment) {\n                                    break;\n                                }\n                            }while (isDoubleSlashCommentLine(offset));\n                        } else {\n                            offset = Math.min(length, findEndOfLine(offset) + 1);\n                        }\n                        if (isDoc) {\n                            setComment(start, offset, isLeadingComment);\n                            isLeadingComment = true;\n                        }\n                        line++;\n                        repeat = true;\n                    }\n                } else if ((curr = charAt(offset)) === \"*\") {\n                    // check for /** (regular comment mode) or /* (alternate comment mode)\n                    start = offset + 1;\n                    isDoc = alternateCommentMode || charAt(start) === \"*\";\n                    do {\n                        if (curr === \"\\n\") {\n                            ++line;\n                        }\n                        if (++offset === length) {\n                            throw illegal(\"comment\");\n                        }\n                        prev = curr;\n                        curr = charAt(offset);\n                    }while (prev !== \"*\" || curr !== \"/\");\n                    ++offset;\n                    if (isDoc) {\n                        setComment(start, offset - 2, isLeadingComment);\n                        isLeadingComment = true;\n                    }\n                    repeat = true;\n                } else {\n                    return \"/\";\n                }\n            }\n        }while (repeat);\n        // offset !== length if we got here\n        var end = offset;\n        delimRe.lastIndex = 0;\n        var delim = delimRe.test(charAt(end++));\n        if (!delim) while(end < length && !delimRe.test(charAt(end)))++end;\n        var token = source.substring(offset, offset = end);\n        if (token === '\"' || token === \"'\") stringDelim = token;\n        return token;\n    }\n    /**\n     * Pushes a token back to the stack.\n     * @param {string} token Token\n     * @returns {undefined}\n     * @inner\n     */ function push(token) {\n        stack.push(token);\n    }\n    /**\n     * Peeks for the next token.\n     * @returns {string|null} Token or `null` on eof\n     * @inner\n     */ function peek() {\n        if (!stack.length) {\n            var token = next();\n            if (token === null) return null;\n            push(token);\n        }\n        return stack[0];\n    }\n    /**\n     * Skips a token.\n     * @param {string} expected Expected token\n     * @param {boolean} [optional=false] Whether the token is optional\n     * @returns {boolean} `true` when skipped, `false` if not\n     * @throws {Error} When a required token is not present\n     * @inner\n     */ function skip(expected, optional) {\n        var actual = peek(), equals = actual === expected;\n        if (equals) {\n            next();\n            return true;\n        }\n        if (!optional) throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n        return false;\n    }\n    /**\n     * Gets a comment.\n     * @param {number} [trailingLine] Line number if looking for a trailing comment\n     * @returns {string|null} Comment text\n     * @inner\n     */ function cmnt(trailingLine) {\n        var ret = null;\n        var comment;\n        if (trailingLine === undefined) {\n            comment = comments[line - 1];\n            delete comments[line - 1];\n            if (comment && (alternateCommentMode || comment.type === \"*\" || comment.lineEmpty)) {\n                ret = comment.leading ? comment.text : null;\n            }\n        } else {\n            /* istanbul ignore else */ if (lastCommentLine < trailingLine) {\n                peek();\n            }\n            comment = comments[trailingLine];\n            delete comments[trailingLine];\n            if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === \"/\")) {\n                ret = comment.leading ? null : comment.text;\n            }\n        }\n        return ret;\n    }\n    return Object.defineProperty({\n        next: next,\n        peek: peek,\n        push: push,\n        skip: skip,\n        cmnt: cmnt\n    }, \"line\", {\n        get: function() {\n            return line;\n        }\n    });\n/* eslint-enable callback-return */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdG9rZW5pemUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxVQUFpQix3QkFDakJDLGlCQUFpQixtQ0FDakJDLGlCQUFpQjtBQUVyQixJQUFJQyxlQUFlLGNBQ2ZDLGtCQUFrQixjQUNsQkMsb0JBQW9CLE9BQ3BCQyxlQUFlLE1BQ2ZDLGFBQWE7QUFFakIsSUFBSUMsY0FBYztJQUNkLEtBQUs7SUFDTCxLQUFLO0lBQ0wsS0FBSztJQUNMLEtBQUs7QUFDVDtBQUVBOzs7Ozs7Q0FNQyxHQUNELFNBQVNDLFNBQVNDLEdBQUc7SUFDakIsT0FBT0EsSUFBSUMsT0FBTyxDQUFDSixZQUFZLFNBQVNLLEVBQUUsRUFBRUMsRUFBRTtRQUMxQyxPQUFRQTtZQUNKLEtBQUs7WUFDTCxLQUFLO2dCQUNELE9BQU9BO1lBQ1g7Z0JBQ0ksT0FBT0wsV0FBVyxDQUFDSyxHQUFHLElBQUk7UUFDbEM7SUFDSjtBQUNKO0FBRUFkLFNBQVNVLFFBQVEsR0FBR0E7QUFFcEI7Ozs7O0NBS0MsR0FFRDs7Ozs7Q0FLQyxHQUVEOzs7Ozs7Q0FNQyxHQUVEOzs7Ozs7OztDQVFDLEdBRUQ7Ozs7OztDQU1DLEdBRUQ7Ozs7Ozs7OztDQVNDLEdBRUQ7Ozs7O0NBS0MsR0FDRCxTQUFTVixTQUFTZSxNQUFNLEVBQUVDLG9CQUFvQjtJQUMxQyxrQ0FBa0MsR0FDbENELFNBQVNBLE9BQU9FLFFBQVE7SUFFeEIsSUFBSUMsU0FBUyxHQUNUQyxTQUFTSixPQUFPSSxNQUFNLEVBQ3RCQyxPQUFPLEdBQ1BDLGtCQUFrQixHQUNsQkMsV0FBVyxDQUFDO0lBRWhCLElBQUlDLFFBQVEsRUFBRTtJQUVkLElBQUlDLGNBQWM7SUFFbEIsd0JBQXdCLEdBQ3hCOzs7OztLQUtDLEdBQ0QsU0FBU0MsUUFBUUMsT0FBTztRQUNwQixPQUFPQyxNQUFNLGFBQWFE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Q1JoQjtZQUNBLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ2MsVUFDRCxNQUFNbkQsUUFBUSxZQUFZb0QsU0FBUyxTQUFTRixXQUFXO1FBQzNELE9BQU87SUFDWDtJQUVBOzs7OztLQUtDLEdBQ0QsU0FBU0ksS0FBS0MsWUFBWTtRQUN0QixJQUFJQyxNQUFNO1FBQ1YsSUFBSXpDO1FBQ0osSUFBSXdDLGlCQUFpQkUsV0FBVztZQUM1QjFDLFVBQVVsQixRQUFRLENBQUNGLE9BQU8sRUFBRTtZQUM1QixPQUFPRSxRQUFRLENBQUNGLE9BQU8sRUFBRTtZQUN6QixJQUFJb0IsV0FBWXhCLENBQUFBLHdCQUF3QndCLFFBQVFDLElBQUksS0FBSyxPQUFPRCxRQUFRRSxTQUFTLEdBQUc7Z0JBQ2hGdUMsTUFBTXpDLFFBQVFHLE9BQU8sR0FBR0gsUUFBUVksSUFBSSxHQUFHO1lBQzNDO1FBQ0osT0FBTztZQUNILHdCQUF3QixHQUN4QixJQUFJL0Isa0JBQWtCMkQsY0FBYztnQkFDaENQO1lBQ0o7WUFDQWpDLFVBQVVsQixRQUFRLENBQUMwRCxhQUFhO1lBQ2hDLE9BQU8xRCxRQUFRLENBQUMwRCxhQUFhO1lBQzdCLElBQUl4QyxXQUFXLENBQUNBLFFBQVFFLFNBQVMsSUFBSzFCLENBQUFBLHdCQUF3QndCLFFBQVFDLElBQUksS0FBSyxHQUFFLEdBQUk7Z0JBQ2pGd0MsTUFBTXpDLFFBQVFHLE9BQU8sR0FBRyxPQUFPSCxRQUFRWSxJQUFJO1lBQy9DO1FBQ0o7UUFDQSxPQUFPNkI7SUFDWDtJQUVBLE9BQU9FLE9BQU9DLGNBQWMsQ0FBQztRQUN6QnRCLE1BQU1BO1FBQ05XLE1BQU1BO1FBQ054QyxNQUFNQTtRQUNOeUMsTUFBTUE7UUFDTkssTUFBTUE7SUFDVixHQUFHLFFBQVE7UUFDUE0sS0FBSztZQUFhLE9BQU9qRTtRQUFNO0lBQ25DO0FBQ0EsaUNBQWlDLEdBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3Rva2VuaXplLmpzPzIwOGQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHRva2VuaXplO1xuXG52YXIgZGVsaW1SZSAgICAgICAgPSAvW1xcc3t9PTs6W1xcXSwnXCIoKTw+XS9nLFxuICAgIHN0cmluZ0RvdWJsZVJlID0gLyg/OlwiKFteXCJcXFxcXSooPzpcXFxcLlteXCJcXFxcXSopKilcIikvZyxcbiAgICBzdHJpbmdTaW5nbGVSZSA9IC8oPzonKFteJ1xcXFxdKig/OlxcXFwuW14nXFxcXF0qKSopJykvZztcblxudmFyIHNldENvbW1lbnRSZSA9IC9eICpbKi9dKyAqLyxcbiAgICBzZXRDb21tZW50QWx0UmUgPSAvXlxccypcXCo/XFwvKi8sXG4gICAgc2V0Q29tbWVudFNwbGl0UmUgPSAvXFxuL2csXG4gICAgd2hpdGVzcGFjZVJlID0gL1xccy8sXG4gICAgdW5lc2NhcGVSZSA9IC9cXFxcKC4/KS9nO1xuXG52YXIgdW5lc2NhcGVNYXAgPSB7XG4gICAgXCIwXCI6IFwiXFwwXCIsXG4gICAgXCJyXCI6IFwiXFxyXCIsXG4gICAgXCJuXCI6IFwiXFxuXCIsXG4gICAgXCJ0XCI6IFwiXFx0XCJcbn07XG5cbi8qKlxuICogVW5lc2NhcGVzIGEgc3RyaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0ciBTdHJpbmcgdG8gdW5lc2NhcGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVuZXNjYXBlZCBzdHJpbmdcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gbWFwIFNwZWNpYWwgY2hhcmFjdGVycyBtYXBcbiAqIEBtZW1iZXJvZiB0b2tlbml6ZVxuICovXG5mdW5jdGlvbiB1bmVzY2FwZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UodW5lc2NhcGVSZSwgZnVuY3Rpb24oJDAsICQxKSB7XG4gICAgICAgIHN3aXRjaCAoJDEpIHtcbiAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQxO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5lc2NhcGVNYXBbJDFdIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxudG9rZW5pemUudW5lc2NhcGUgPSB1bmVzY2FwZTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuZXh0IHRva2VuIGFuZCBhZHZhbmNlcy5cbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZU5leHRcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gTmV4dCB0b2tlbiBvciBgbnVsbGAgb24gZW9mXG4gKi9cblxuLyoqXG4gKiBQZWVrcyBmb3IgdGhlIG5leHQgdG9rZW4uXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVQZWVrXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IE5leHQgdG9rZW4gb3IgYG51bGxgIG9uIGVvZlxuICovXG5cbi8qKlxuICogUHVzaGVzIGEgdG9rZW4gYmFjayB0byB0aGUgc3RhY2suXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVQdXNoXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gVG9rZW5cbiAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gKi9cblxuLyoqXG4gKiBTa2lwcyB0aGUgbmV4dCB0b2tlbi5cbiAqIEB0eXBlZGVmIFRva2VuaXplckhhbmRsZVNraXBcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZCBFeHBlY3RlZCB0b2tlblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9uYWw9ZmFsc2VdIElmIG9wdGlvbmFsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgdG9rZW4gbWF0Y2hlZFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSB0b2tlbiBkaWRuJ3QgbWF0Y2ggYW5kIGlzIG5vdCBvcHRpb25hbFxuICovXG5cbi8qKlxuICogR2V0cyB0aGUgY29tbWVudCBvbiB0aGUgcHJldmlvdXMgbGluZSBvciwgYWx0ZXJuYXRpdmVseSwgdGhlIGxpbmUgY29tbWVudCBvbiB0aGUgc3BlY2lmaWVkIGxpbmUuXG4gKiBAdHlwZWRlZiBUb2tlbml6ZXJIYW5kbGVDbW50XG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcGFyYW0ge251bWJlcn0gW2xpbmVdIExpbmUgbnVtYmVyXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IENvbW1lbnQgdGV4dCBvciBgbnVsbGAgaWYgbm9uZVxuICovXG5cbi8qKlxuICogSGFuZGxlIG9iamVjdCByZXR1cm5lZCBmcm9tIHtAbGluayB0b2tlbml6ZX0uXG4gKiBAaW50ZXJmYWNlIElUb2tlbml6ZXJIYW5kbGVcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlTmV4dH0gbmV4dCBHZXRzIHRoZSBuZXh0IHRva2VuIGFuZCBhZHZhbmNlcyAoYG51bGxgIG9uIGVvZilcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlUGVla30gcGVlayBQZWVrcyBmb3IgdGhlIG5leHQgdG9rZW4gKGBudWxsYCBvbiBlb2YpXG4gKiBAcHJvcGVydHkge1Rva2VuaXplckhhbmRsZVB1c2h9IHB1c2ggUHVzaGVzIGEgdG9rZW4gYmFjayB0byB0aGUgc3RhY2tcbiAqIEBwcm9wZXJ0eSB7VG9rZW5pemVySGFuZGxlU2tpcH0gc2tpcCBTa2lwcyBhIHRva2VuLCByZXR1cm5zIGl0cyBwcmVzZW5jZSBhbmQgYWR2YW5jZXMgb3IsIGlmIG5vbi1vcHRpb25hbCBhbmQgbm90IHByZXNlbnQsIHRocm93c1xuICogQHByb3BlcnR5IHtUb2tlbml6ZXJIYW5kbGVDbW50fSBjbW50IEdldHMgdGhlIGNvbW1lbnQgb24gdGhlIHByZXZpb3VzIGxpbmUgb3IgdGhlIGxpbmUgY29tbWVudCBvbiB0aGUgc3BlY2lmaWVkIGxpbmUsIGlmIGFueVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbmUgQ3VycmVudCBsaW5lIG51bWJlclxuICovXG5cbi8qKlxuICogVG9rZW5pemVzIHRoZSBnaXZlbiAucHJvdG8gc291cmNlIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHVzZWZ1bCB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgU291cmNlIGNvbnRlbnRzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGFsdGVybmF0ZUNvbW1lbnRNb2RlIFdoZXRoZXIgd2Ugc2hvdWxkIGFjdGl2YXRlIGFsdGVybmF0ZSBjb21tZW50IHBhcnNpbmcgbW9kZS5cbiAqIEByZXR1cm5zIHtJVG9rZW5pemVySGFuZGxlfSBUb2tlbml6ZXIgaGFuZGxlXG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplKHNvdXJjZSwgYWx0ZXJuYXRlQ29tbWVudE1vZGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjYWxsYmFjay1yZXR1cm4gKi9cbiAgICBzb3VyY2UgPSBzb3VyY2UudG9TdHJpbmcoKTtcblxuICAgIHZhciBvZmZzZXQgPSAwLFxuICAgICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLFxuICAgICAgICBsaW5lID0gMSxcbiAgICAgICAgbGFzdENvbW1lbnRMaW5lID0gMCxcbiAgICAgICAgY29tbWVudHMgPSB7fTtcblxuICAgIHZhciBzdGFjayA9IFtdO1xuXG4gICAgdmFyIHN0cmluZ0RlbGltID0gbnVsbDtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBlcnJvciBmb3IgaWxsZWdhbCBzeW50YXguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN1YmplY3QgU3ViamVjdFxuICAgICAqIEByZXR1cm5zIHtFcnJvcn0gRXJyb3IgY3JlYXRlZFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlsbGVnYWwoc3ViamVjdCkge1xuICAgICAgICByZXR1cm4gRXJyb3IoXCJpbGxlZ2FsIFwiICsgc3ViamVjdCArIFwiIChsaW5lIFwiICsgbGluZSArIFwiKVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBhIHN0cmluZyB0aWxsIGl0cyBlbmQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gU3RyaW5nIHJlYWRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkU3RyaW5nKCkge1xuICAgICAgICB2YXIgcmUgPSBzdHJpbmdEZWxpbSA9PT0gXCInXCIgPyBzdHJpbmdTaW5nbGVSZSA6IHN0cmluZ0RvdWJsZVJlO1xuICAgICAgICByZS5sYXN0SW5kZXggPSBvZmZzZXQgLSAxO1xuICAgICAgICB2YXIgbWF0Y2ggPSByZS5leGVjKHNvdXJjZSk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICB0aHJvdyBpbGxlZ2FsKFwic3RyaW5nXCIpO1xuICAgICAgICBvZmZzZXQgPSByZS5sYXN0SW5kZXg7XG4gICAgICAgIHB1c2goc3RyaW5nRGVsaW0pO1xuICAgICAgICBzdHJpbmdEZWxpbSA9IG51bGw7XG4gICAgICAgIHJldHVybiB1bmVzY2FwZShtYXRjaFsxXSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY2hhcmFjdGVyIGF0IGBwb3NgIHdpdGhpbiB0aGUgc291cmNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgUG9zaXRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBDaGFyYWN0ZXJcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFyQXQocG9zKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2UuY2hhckF0KHBvcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBjb21tZW50IHRleHQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFN0YXJ0IG9mZnNldFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgRW5kIG9mZnNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMZWFkaW5nIHNldCBpZiBhIGxlYWRpbmcgY29tbWVudFxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q29tbWVudChzdGFydCwgZW5kLCBpc0xlYWRpbmcpIHtcbiAgICAgICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICAgICAgICB0eXBlOiBzb3VyY2UuY2hhckF0KHN0YXJ0KyspLFxuICAgICAgICAgICAgbGluZUVtcHR5OiBmYWxzZSxcbiAgICAgICAgICAgIGxlYWRpbmc6IGlzTGVhZGluZyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGxvb2tiYWNrO1xuICAgICAgICBpZiAoYWx0ZXJuYXRlQ29tbWVudE1vZGUpIHtcbiAgICAgICAgICAgIGxvb2tiYWNrID0gMjsgIC8vIGFsdGVybmF0ZSBjb21tZW50IHBhcnNpbmc6IFwiLy9cIiBvciBcIi8qXCJcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvb2tiYWNrID0gMzsgIC8vIFwiLy8vXCIgb3IgXCIvKipcIlxuICAgICAgICB9XG4gICAgICAgIHZhciBjb21tZW50T2Zmc2V0ID0gc3RhcnQgLSBsb29rYmFjayxcbiAgICAgICAgICAgIGM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmICgtLWNvbW1lbnRPZmZzZXQgPCAwIHx8XG4gICAgICAgICAgICAgICAgICAgIChjID0gc291cmNlLmNoYXJBdChjb21tZW50T2Zmc2V0KSkgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICBjb21tZW50LmxpbmVFbXB0eSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKGMgPT09IFwiIFwiIHx8IGMgPT09IFwiXFx0XCIpO1xuICAgICAgICB2YXIgbGluZXMgPSBzb3VyY2VcbiAgICAgICAgICAgIC5zdWJzdHJpbmcoc3RhcnQsIGVuZClcbiAgICAgICAgICAgIC5zcGxpdChzZXRDb21tZW50U3BsaXRSZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBsaW5lc1tpXSA9IGxpbmVzW2ldXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoYWx0ZXJuYXRlQ29tbWVudE1vZGUgPyBzZXRDb21tZW50QWx0UmUgOiBzZXRDb21tZW50UmUsIFwiXCIpXG4gICAgICAgICAgICAgICAgLnRyaW0oKTtcbiAgICAgICAgY29tbWVudC50ZXh0ID0gbGluZXNcbiAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpXG4gICAgICAgICAgICAudHJpbSgpO1xuXG4gICAgICAgIGNvbW1lbnRzW2xpbmVdID0gY29tbWVudDtcbiAgICAgICAgbGFzdENvbW1lbnRMaW5lID0gbGluZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RvdWJsZVNsYXNoQ29tbWVudExpbmUoc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgdmFyIGVuZE9mZnNldCA9IGZpbmRFbmRPZkxpbmUoc3RhcnRPZmZzZXQpO1xuXG4gICAgICAgIC8vIHNlZSBpZiByZW1haW5pbmcgbGluZSBtYXRjaGVzIGNvbW1lbnQgcGF0dGVyblxuICAgICAgICB2YXIgbGluZVRleHQgPSBzb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgICB2YXIgaXNDb21tZW50ID0gL15cXHMqXFwvXFwvLy50ZXN0KGxpbmVUZXh0KTtcbiAgICAgICAgcmV0dXJuIGlzQ29tbWVudDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kRW5kT2ZMaW5lKGN1cnNvcikge1xuICAgICAgICAvLyBmaW5kIGVuZCBvZiBjdXJzb3IncyBsaW5lXG4gICAgICAgIHZhciBlbmRPZmZzZXQgPSBjdXJzb3I7XG4gICAgICAgIHdoaWxlIChlbmRPZmZzZXQgPCBsZW5ndGggJiYgY2hhckF0KGVuZE9mZnNldCkgIT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmRPZmZzZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT2J0YWlucyB0aGUgbmV4dCB0b2tlbi5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IE5leHQgdG9rZW4gb3IgYG51bGxgIG9uIGVvZlxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPiAwKVxuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgIGlmIChzdHJpbmdEZWxpbSlcbiAgICAgICAgICAgIHJldHVybiByZWFkU3RyaW5nKCk7XG4gICAgICAgIHZhciByZXBlYXQsXG4gICAgICAgICAgICBwcmV2LFxuICAgICAgICAgICAgY3VycixcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgaXNEb2MsXG4gICAgICAgICAgICBpc0xlYWRpbmdDb21tZW50ID0gb2Zmc2V0ID09PSAwO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICh3aGl0ZXNwYWNlUmUudGVzdChjdXJyID0gY2hhckF0KG9mZnNldCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnIgPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICsrbGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCsrb2Zmc2V0ID09PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2hhckF0KG9mZnNldCkgPT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCsrb2Zmc2V0ID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcImNvbW1lbnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGFyQXQob2Zmc2V0KSA9PT0gXCIvXCIpIHsgLy8gTGluZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsdGVybmF0ZUNvbW1lbnRNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgdHJpcGxlLXNsYXNoIGNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRG9jID0gY2hhckF0KHN0YXJ0ID0gb2Zmc2V0ICsgMSkgPT09IFwiL1wiO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckF0KCsrb2Zmc2V0KSAhPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICArK29mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldENvbW1lbnQoc3RhcnQsIG9mZnNldCAtIDEsIGlzTGVhZGluZ0NvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyYWlsaW5nIGNvbW1lbnQgY2Fubm90IG5vdCBiZSBtdWx0aS1saW5lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGxlYWRpbmcgY29tbWVudCBzdGF0ZSBzaG91bGQgYmUgcmVzZXQgdG8gaGFuZGxlIHBvdGVudGlhbCBuZXh0IGNvbW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNMZWFkaW5nQ29tbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICArK2xpbmU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBlYXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGRvdWJsZS1zbGFzaCBjb21tZW50cywgY29uc29saWRhdGluZyBjb25zZWN1dGl2ZSBsaW5lc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0RvYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG91YmxlU2xhc2hDb21tZW50TGluZShvZmZzZXQgLSAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRG9jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGZpbmRFbmRPZkxpbmUob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0xlYWRpbmdDb21tZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFpbGluZyBjb21tZW50IGNhbm5vdCBub3QgYmUgbXVsdGktbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlIChpc0RvdWJsZVNsYXNoQ29tbWVudExpbmUob2Zmc2V0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWluKGxlbmd0aCwgZmluZEVuZE9mTGluZShvZmZzZXQpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNEb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRDb21tZW50KHN0YXJ0LCBvZmZzZXQsIGlzTGVhZGluZ0NvbW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTGVhZGluZ0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKGN1cnIgPSBjaGFyQXQob2Zmc2V0KSkgPT09IFwiKlwiKSB7IC8qIEJsb2NrICovXG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciAvKiogKHJlZ3VsYXIgY29tbWVudCBtb2RlKSBvciAvKiAoYWx0ZXJuYXRlIGNvbW1lbnQgbW9kZSlcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBvZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpc0RvYyA9IGFsdGVybmF0ZUNvbW1lbnRNb2RlIHx8IGNoYXJBdChzdGFydCkgPT09IFwiKlwiO1xuICAgICAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VyciA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICsrbGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK29mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgaWxsZWdhbChcImNvbW1lbnRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2ID0gY3VycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjaGFyQXQob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAocHJldiAhPT0gXCIqXCIgfHwgY3VyciAhPT0gXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICArK29mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRG9jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRDb21tZW50KHN0YXJ0LCBvZmZzZXQgLSAyLCBpc0xlYWRpbmdDb21tZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTGVhZGluZ0NvbW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlcGVhdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiL1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAocmVwZWF0KTtcblxuICAgICAgICAvLyBvZmZzZXQgIT09IGxlbmd0aCBpZiB3ZSBnb3QgaGVyZVxuXG4gICAgICAgIHZhciBlbmQgPSBvZmZzZXQ7XG4gICAgICAgIGRlbGltUmUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgdmFyIGRlbGltID0gZGVsaW1SZS50ZXN0KGNoYXJBdChlbmQrKykpO1xuICAgICAgICBpZiAoIWRlbGltKVxuICAgICAgICAgICAgd2hpbGUgKGVuZCA8IGxlbmd0aCAmJiAhZGVsaW1SZS50ZXN0KGNoYXJBdChlbmQpKSlcbiAgICAgICAgICAgICAgICArK2VuZDtcbiAgICAgICAgdmFyIHRva2VuID0gc291cmNlLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCA9IGVuZCk7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gXCJcXFwiXCIgfHwgdG9rZW4gPT09IFwiJ1wiKVxuICAgICAgICAgICAgc3RyaW5nRGVsaW0gPSB0b2tlbjtcbiAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhIHRva2VuIGJhY2sgdG8gdGhlIHN0YWNrLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiBUb2tlblxuICAgICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVzaCh0b2tlbikge1xuICAgICAgICBzdGFjay5wdXNoKHRva2VuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZWVrcyBmb3IgdGhlIG5leHQgdG9rZW4uXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBUb2tlbiBvciBgbnVsbGAgb24gZW9mXG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGVlaygpIHtcbiAgICAgICAgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IG5leHQoKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFja1swXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTa2lwcyBhIHRva2VuLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZCBFeHBlY3RlZCB0b2tlblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbmFsPWZhbHNlXSBXaGV0aGVyIHRoZSB0b2tlbiBpcyBvcHRpb25hbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgd2hlbiBza2lwcGVkLCBgZmFsc2VgIGlmIG5vdFxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBXaGVuIGEgcmVxdWlyZWQgdG9rZW4gaXMgbm90IHByZXNlbnRcbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBza2lwKGV4cGVjdGVkLCBvcHRpb25hbCkge1xuICAgICAgICB2YXIgYWN0dWFsID0gcGVlaygpLFxuICAgICAgICAgICAgZXF1YWxzID0gYWN0dWFsID09PSBleHBlY3RlZDtcbiAgICAgICAgaWYgKGVxdWFscykge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25hbClcbiAgICAgICAgICAgIHRocm93IGlsbGVnYWwoXCJ0b2tlbiAnXCIgKyBhY3R1YWwgKyBcIicsICdcIiArIGV4cGVjdGVkICsgXCInIGV4cGVjdGVkXCIpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGNvbW1lbnQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt0cmFpbGluZ0xpbmVdIExpbmUgbnVtYmVyIGlmIGxvb2tpbmcgZm9yIGEgdHJhaWxpbmcgY29tbWVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH0gQ29tbWVudCB0ZXh0XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gY21udCh0cmFpbGluZ0xpbmUpIHtcbiAgICAgICAgdmFyIHJldCA9IG51bGw7XG4gICAgICAgIHZhciBjb21tZW50O1xuICAgICAgICBpZiAodHJhaWxpbmdMaW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbW1lbnQgPSBjb21tZW50c1tsaW5lIC0gMV07XG4gICAgICAgICAgICBkZWxldGUgY29tbWVudHNbbGluZSAtIDFdO1xuICAgICAgICAgICAgaWYgKGNvbW1lbnQgJiYgKGFsdGVybmF0ZUNvbW1lbnRNb2RlIHx8IGNvbW1lbnQudHlwZSA9PT0gXCIqXCIgfHwgY29tbWVudC5saW5lRW1wdHkpKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gY29tbWVudC5sZWFkaW5nID8gY29tbWVudC50ZXh0IDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAobGFzdENvbW1lbnRMaW5lIDwgdHJhaWxpbmdMaW5lKSB7XG4gICAgICAgICAgICAgICAgcGVlaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29tbWVudCA9IGNvbW1lbnRzW3RyYWlsaW5nTGluZV07XG4gICAgICAgICAgICBkZWxldGUgY29tbWVudHNbdHJhaWxpbmdMaW5lXTtcbiAgICAgICAgICAgIGlmIChjb21tZW50ICYmICFjb21tZW50LmxpbmVFbXB0eSAmJiAoYWx0ZXJuYXRlQ29tbWVudE1vZGUgfHwgY29tbWVudC50eXBlID09PSBcIi9cIikpIHtcbiAgICAgICAgICAgICAgICByZXQgPSBjb21tZW50LmxlYWRpbmcgPyBudWxsIDogY29tbWVudC50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gICAgICAgIG5leHQ6IG5leHQsXG4gICAgICAgIHBlZWs6IHBlZWssXG4gICAgICAgIHB1c2g6IHB1c2gsXG4gICAgICAgIHNraXA6IHNraXAsXG4gICAgICAgIGNtbnQ6IGNtbnRcbiAgICB9LCBcImxpbmVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbGluZTsgfVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgY2FsbGJhY2stcmV0dXJuICovXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInRva2VuaXplIiwiZGVsaW1SZSIsInN0cmluZ0RvdWJsZVJlIiwic3RyaW5nU2luZ2xlUmUiLCJzZXRDb21tZW50UmUiLCJzZXRDb21tZW50QWx0UmUiLCJzZXRDb21tZW50U3BsaXRSZSIsIndoaXRlc3BhY2VSZSIsInVuZXNjYXBlUmUiLCJ1bmVzY2FwZU1hcCIsInVuZXNjYXBlIiwic3RyIiwicmVwbGFjZSIsIiQwIiwiJDEiLCJzb3VyY2UiLCJhbHRlcm5hdGVDb21tZW50TW9kZSIsInRvU3RyaW5nIiwib2Zmc2V0IiwibGVuZ3RoIiwibGluZSIsImxhc3RDb21tZW50TGluZSIsImNvbW1lbnRzIiwic3RhY2siLCJzdHJpbmdEZWxpbSIsImlsbGVnYWwiLCJzdWJqZWN0IiwiRXJyb3IiLCJyZWFkU3RyaW5nIiwicmUiLCJsYXN0SW5kZXgiLCJtYXRjaCIsImV4ZWMiLCJwdXNoIiwiY2hhckF0IiwicG9zIiwic2V0Q29tbWVudCIsInN0YXJ0IiwiZW5kIiwiaXNMZWFkaW5nIiwiY29tbWVudCIsInR5cGUiLCJsaW5lRW1wdHkiLCJsZWFkaW5nIiwibG9va2JhY2siLCJjb21tZW50T2Zmc2V0IiwiYyIsImxpbmVzIiwic3Vic3RyaW5nIiwic3BsaXQiLCJpIiwidHJpbSIsInRleHQiLCJqb2luIiwiaXNEb3VibGVTbGFzaENvbW1lbnRMaW5lIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJmaW5kRW5kT2ZMaW5lIiwibGluZVRleHQiLCJpc0NvbW1lbnQiLCJ0ZXN0IiwiY3Vyc29yIiwibmV4dCIsInNoaWZ0IiwicmVwZWF0IiwicHJldiIsImN1cnIiLCJpc0RvYyIsImlzTGVhZGluZ0NvbW1lbnQiLCJNYXRoIiwibWluIiwiZGVsaW0iLCJ0b2tlbiIsInBlZWsiLCJza2lwIiwiZXhwZWN0ZWQiLCJvcHRpb25hbCIsImFjdHVhbCIsImVxdWFscyIsImNtbnQiLCJ0cmFpbGluZ0xpbmUiLCJyZXQiLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImdldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/tokenize.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Type;\n// extends Namespace\nvar Namespace = __webpack_require__(/*! ./namespace */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/namespace.js\");\n((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = \"Type\";\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"), OneOf = __webpack_require__(/*! ./oneof */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/oneof.js\"), Field = __webpack_require__(/*! ./field */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/field.js\"), MapField = __webpack_require__(/*! ./mapfield */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/mapfield.js\"), Service = __webpack_require__(/*! ./service */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/service.js\"), Message = __webpack_require__(/*! ./message */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js\"), Reader = __webpack_require__(/*! ./reader */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/reader.js\"), Writer = __webpack_require__(/*! ./writer */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\"), encoder = __webpack_require__(/*! ./encoder */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/encoder.js\"), decoder = __webpack_require__(/*! ./decoder */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/decoder.js\"), verifier = __webpack_require__(/*! ./verifier */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/verifier.js\"), converter = __webpack_require__(/*! ./converter */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/converter.js\"), wrappers = __webpack_require__(/*! ./wrappers */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/wrappers.js\");\n/**\n * Constructs a new reflected message type instance.\n * @classdesc Reflected message type.\n * @extends NamespaceBase\n * @constructor\n * @param {string} name Message name\n * @param {Object.<string,*>} [options] Declared options\n */ function Type(name, options) {\n    Namespace.call(this, name, options);\n    /**\n     * Message fields.\n     * @type {Object.<string,Field>}\n     */ this.fields = {}; // toJSON, marker\n    /**\n     * Oneofs declared within this namespace, if any.\n     * @type {Object.<string,OneOf>}\n     */ this.oneofs = undefined; // toJSON\n    /**\n     * Extension ranges, if any.\n     * @type {number[][]}\n     */ this.extensions = undefined; // toJSON\n    /**\n     * Reserved ranges, if any.\n     * @type {Array.<number[]|string>}\n     */ this.reserved = undefined; // toJSON\n    /*?\n     * Whether this type is a legacy group.\n     * @type {boolean|undefined}\n     */ this.group = undefined; // toJSON\n    /**\n     * Cached fields by id.\n     * @type {Object.<number,Field>|null}\n     * @private\n     */ this._fieldsById = null;\n    /**\n     * Cached fields as an array.\n     * @type {Field[]|null}\n     * @private\n     */ this._fieldsArray = null;\n    /**\n     * Cached oneofs as an array.\n     * @type {OneOf[]|null}\n     * @private\n     */ this._oneofsArray = null;\n    /**\n     * Cached constructor.\n     * @type {Constructor<{}>}\n     * @private\n     */ this._ctor = null;\n}\nObject.defineProperties(Type.prototype, {\n    /**\n     * Message fields by id.\n     * @name Type#fieldsById\n     * @type {Object.<number,Field>}\n     * @readonly\n     */ fieldsById: {\n        get: function() {\n            /* istanbul ignore if */ if (this._fieldsById) return this._fieldsById;\n            this._fieldsById = {};\n            for(var names = Object.keys(this.fields), i = 0; i < names.length; ++i){\n                var field = this.fields[names[i]], id = field.id;\n                /* istanbul ignore if */ if (this._fieldsById[id]) throw Error(\"duplicate id \" + id + \" in \" + this);\n                this._fieldsById[id] = field;\n            }\n            return this._fieldsById;\n        }\n    },\n    /**\n     * Fields of this message as an array for iteration.\n     * @name Type#fieldsArray\n     * @type {Field[]}\n     * @readonly\n     */ fieldsArray: {\n        get: function() {\n            return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));\n        }\n    },\n    /**\n     * Oneofs of this message as an array for iteration.\n     * @name Type#oneofsArray\n     * @type {OneOf[]}\n     * @readonly\n     */ oneofsArray: {\n        get: function() {\n            return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));\n        }\n    },\n    /**\n     * The registered constructor, if any registered, otherwise a generic constructor.\n     * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.\n     * @name Type#ctor\n     * @type {Constructor<{}>}\n     */ ctor: {\n        get: function() {\n            return this._ctor || (this.ctor = Type.generateConstructor(this)());\n        },\n        set: function(ctor) {\n            // Ensure proper prototype\n            var prototype = ctor.prototype;\n            if (!(prototype instanceof Message)) {\n                (ctor.prototype = new Message()).constructor = ctor;\n                util.merge(ctor.prototype, prototype);\n            }\n            // Classes and messages reference their reflected type\n            ctor.$type = ctor.prototype.$type = this;\n            // Mix in static methods\n            util.merge(ctor, Message, true);\n            this._ctor = ctor;\n            // Messages have non-enumerable default values on their prototype\n            var i = 0;\n            for(; i < /* initializes */ this.fieldsArray.length; ++i)this._fieldsArray[i].resolve(); // ensures a proper value\n            // Messages have non-enumerable getters and setters for each virtual oneof field\n            var ctorProperties = {};\n            for(i = 0; i < /* initializes */ this.oneofsArray.length; ++i)ctorProperties[this._oneofsArray[i].resolve().name] = {\n                get: util.oneOfGetter(this._oneofsArray[i].oneof),\n                set: util.oneOfSetter(this._oneofsArray[i].oneof)\n            };\n            if (i) Object.defineProperties(ctor.prototype, ctorProperties);\n        }\n    }\n});\n/**\n * Generates a constructor function for the specified type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ Type.generateConstructor = function generateConstructor(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"p\"\n    ], mtype.name);\n    // explicitly initialize mutable object/array fields so that these aren't just inherited from the prototype\n    for(var i = 0, field; i < mtype.fieldsArray.length; ++i)if ((field = mtype._fieldsArray[i]).map) gen(\"this%s={}\", util.safeProp(field.name));\n    else if (field.repeated) gen(\"this%s=[]\", util.safeProp(field.name));\n    return gen(\"if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)\") // omit undefined or null\n    (\"this[ks[i]]=p[ks[i]]\");\n/* eslint-enable no-unexpected-multiline */ };\nfunction clearCache(type) {\n    type._fieldsById = type._fieldsArray = type._oneofsArray = null;\n    delete type.encode;\n    delete type.decode;\n    delete type.verify;\n    return type;\n}\n/**\n * Message type descriptor.\n * @interface IType\n * @extends INamespace\n * @property {Object.<string,IOneOf>} [oneofs] Oneof descriptors\n * @property {Object.<string,IField>} fields Field descriptors\n * @property {number[][]} [extensions] Extension ranges\n * @property {Array.<number[]|string>} [reserved] Reserved ranges\n * @property {boolean} [group=false] Whether a legacy group or not\n */ /**\n * Creates a message type from a message type descriptor.\n * @param {string} name Message name\n * @param {IType} json Message type descriptor\n * @returns {Type} Created message type\n */ Type.fromJSON = function fromJSON(name, json) {\n    var type = new Type(name, json.options);\n    type.extensions = json.extensions;\n    type.reserved = json.reserved;\n    var names = Object.keys(json.fields), i = 0;\n    for(; i < names.length; ++i)type.add((typeof json.fields[names[i]].keyType !== \"undefined\" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));\n    if (json.oneofs) for(names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));\n    if (json.nested) for(names = Object.keys(json.nested), i = 0; i < names.length; ++i){\n        var nested = json.nested[names[i]];\n        type.add((nested.id !== undefined ? Field.fromJSON : nested.fields !== undefined ? Type.fromJSON : nested.values !== undefined ? Enum.fromJSON : nested.methods !== undefined ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));\n    }\n    if (json.extensions && json.extensions.length) type.extensions = json.extensions;\n    if (json.reserved && json.reserved.length) type.reserved = json.reserved;\n    if (json.group) type.group = true;\n    if (json.comment) type.comment = json.comment;\n    if (json.edition) type._edition = json.edition;\n    type._defaultEdition = \"proto3\"; // For backwards-compatibility.\n    return type;\n};\n/**\n * Converts this message type to a message type descriptor.\n * @param {IToJSONOptions} [toJSONOptions] JSON conversion options\n * @returns {IType} Message type descriptor\n */ Type.prototype.toJSON = function toJSON(toJSONOptions) {\n    var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);\n    var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;\n    return util.toObject([\n        \"edition\",\n        this._editionToJSON(),\n        \"options\",\n        inherited && inherited.options || undefined,\n        \"oneofs\",\n        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),\n        \"fields\",\n        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {\n            return !obj.declaringField;\n        }), toJSONOptions) || {},\n        \"extensions\",\n        this.extensions && this.extensions.length ? this.extensions : undefined,\n        \"reserved\",\n        this.reserved && this.reserved.length ? this.reserved : undefined,\n        \"group\",\n        this.group || undefined,\n        \"nested\",\n        inherited && inherited.nested || undefined,\n        \"comment\",\n        keepComments ? this.comment : undefined\n    ]);\n};\n/**\n * @override\n */ Type.prototype.resolveAll = function resolveAll() {\n    if (!this._needsRecursiveResolve) return this;\n    Namespace.prototype.resolveAll.call(this);\n    var oneofs = this.oneofsArray;\n    i = 0;\n    while(i < oneofs.length)oneofs[i++].resolve();\n    var fields = this.fieldsArray, i = 0;\n    while(i < fields.length)fields[i++].resolve();\n    return this;\n};\n/**\n * @override\n */ Type.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {\n    if (!this._needsRecursiveFeatureResolution) return this;\n    edition = this._edition || edition;\n    Namespace.prototype._resolveFeaturesRecursive.call(this, edition);\n    this.oneofsArray.forEach((oneof)=>{\n        oneof._resolveFeatures(edition);\n    });\n    this.fieldsArray.forEach((field)=>{\n        field._resolveFeatures(edition);\n    });\n    return this;\n};\n/**\n * @override\n */ Type.prototype.get = function get(name) {\n    return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;\n};\n/**\n * Adds a nested object to this type.\n * @param {ReflectionObject} object Nested object to add\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If there is already a nested object with this name or, if a field, when there is already a field with this id\n */ Type.prototype.add = function add(object) {\n    if (this.get(object.name)) throw Error(\"duplicate name '\" + object.name + \"' in \" + this);\n    if (object instanceof Field && object.extend === undefined) {\n        // NOTE: Extension fields aren't actual fields on the declaring type, but nested objects.\n        // The root object takes care of adding distinct sister-fields to the respective extended\n        // type instead.\n        // avoids calling the getter if not absolutely necessary because it's called quite frequently\n        if (this._fieldsById ? /* istanbul ignore next */ this._fieldsById[object.id] : this.fieldsById[object.id]) throw Error(\"duplicate id \" + object.id + \" in \" + this);\n        if (this.isReservedId(object.id)) throw Error(\"id \" + object.id + \" is reserved in \" + this);\n        if (this.isReservedName(object.name)) throw Error(\"name '\" + object.name + \"' is reserved in \" + this);\n        if (object.parent) object.parent.remove(object);\n        this.fields[object.name] = object;\n        object.message = this;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        if (!this.oneofs) this.oneofs = {};\n        this.oneofs[object.name] = object;\n        object.onAdd(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.add.call(this, object);\n};\n/**\n * Removes a nested object from this type.\n * @param {ReflectionObject} object Nested object to remove\n * @returns {Type} `this`\n * @throws {TypeError} If arguments are invalid\n * @throws {Error} If `object` is not a member of this type\n */ Type.prototype.remove = function remove(object) {\n    if (object instanceof Field && object.extend === undefined) {\n        // See Type#add for the reason why extension fields are excluded here.\n        /* istanbul ignore if */ if (!this.fields || this.fields[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.fields[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    if (object instanceof OneOf) {\n        /* istanbul ignore if */ if (!this.oneofs || this.oneofs[object.name] !== object) throw Error(object + \" is not a member of \" + this);\n        delete this.oneofs[object.name];\n        object.parent = null;\n        object.onRemove(this);\n        return clearCache(this);\n    }\n    return Namespace.prototype.remove.call(this, object);\n};\n/**\n * Tests if the specified id is reserved.\n * @param {number} id Id to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Type.prototype.isReservedId = function isReservedId(id) {\n    return Namespace.isReservedId(this.reserved, id);\n};\n/**\n * Tests if the specified name is reserved.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ Type.prototype.isReservedName = function isReservedName(name) {\n    return Namespace.isReservedName(this.reserved, name);\n};\n/**\n * Creates a new message of this type using the specified properties.\n * @param {Object.<string,*>} [properties] Properties to set\n * @returns {Message<{}>} Message instance\n */ Type.prototype.create = function create(properties) {\n    return new this.ctor(properties);\n};\n/**\n * Sets up {@link Type#encode|encode}, {@link Type#decode|decode} and {@link Type#verify|verify}.\n * @returns {Type} `this`\n */ Type.prototype.setup = function setup() {\n    // Sets up everything at once so that the prototype chain does not have to be re-evaluated\n    // multiple times (V8, soft-deopt prototype-check).\n    var fullName = this.fullName, types = [];\n    for(var i = 0; i < /* initializes */ this.fieldsArray.length; ++i)types.push(this._fieldsArray[i].resolve().resolvedType);\n    // Replace setup methods with type-specific generated functions\n    this.encode = encoder(this)({\n        Writer: Writer,\n        types: types,\n        util: util\n    });\n    this.decode = decoder(this)({\n        Reader: Reader,\n        types: types,\n        util: util\n    });\n    this.verify = verifier(this)({\n        types: types,\n        util: util\n    });\n    this.fromObject = converter.fromObject(this)({\n        types: types,\n        util: util\n    });\n    this.toObject = converter.toObject(this)({\n        types: types,\n        util: util\n    });\n    // Inject custom wrappers for common types\n    var wrapper = wrappers[fullName];\n    if (wrapper) {\n        var originalThis = Object.create(this);\n        // if (wrapper.fromObject) {\n        originalThis.fromObject = this.fromObject;\n        this.fromObject = wrapper.fromObject.bind(originalThis);\n        // }\n        // if (wrapper.toObject) {\n        originalThis.toObject = this.toObject;\n        this.toObject = wrapper.toObject.bind(originalThis);\n    // }\n    }\n    return this;\n};\n/**\n * Encodes a message of this type. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */ Type.prototype.encode = function encode_setup(message, writer) {\n    return this.setup().encode(message, writer); // overrides this method\n};\n/**\n * Encodes a message of this type preceeded by its byte length as a varint. Does not implicitly {@link Type#verify|verify} messages.\n * @param {Message<{}>|Object.<string,*>} message Message instance or plain object\n * @param {Writer} [writer] Writer to encode to\n * @returns {Writer} writer\n */ Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {\n    return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();\n};\n/**\n * Decodes a message of this type.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @param {number} [length] Length of the message, if known beforehand\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError<{}>} If required fields are missing\n */ Type.prototype.decode = function decode_setup(reader, length) {\n    return this.setup().decode(reader, length); // overrides this method\n};\n/**\n * Decodes a message of this type preceeded by its byte length as a varint.\n * @param {Reader|Uint8Array} reader Reader or buffer to decode from\n * @returns {Message<{}>} Decoded message\n * @throws {Error} If the payload is not a reader or valid buffer\n * @throws {util.ProtocolError} If required fields are missing\n */ Type.prototype.decodeDelimited = function decodeDelimited(reader) {\n    if (!(reader instanceof Reader)) reader = Reader.create(reader);\n    return this.decode(reader, reader.uint32());\n};\n/**\n * Verifies that field values are valid and that required fields are present.\n * @param {Object.<string,*>} message Plain object to verify\n * @returns {null|string} `null` if valid, otherwise the reason why it is not\n */ Type.prototype.verify = function verify_setup(message) {\n    return this.setup().verify(message); // overrides this method\n};\n/**\n * Creates a new message of this type from a plain object. Also converts values to their respective internal types.\n * @param {Object.<string,*>} object Plain object to convert\n * @returns {Message<{}>} Message instance\n */ Type.prototype.fromObject = function fromObject(object) {\n    return this.setup().fromObject(object);\n};\n/**\n * Conversion options as used by {@link Type#toObject} and {@link Message.toObject}.\n * @interface IConversionOptions\n * @property {Function} [longs] Long conversion type.\n * Valid values are `String` and `Number` (the global types).\n * Defaults to copy the present value, which is a possibly unsafe number without and a {@link Long} with a long library.\n * @property {Function} [enums] Enum value conversion type.\n * Only valid value is `String` (the global type).\n * Defaults to copy the present value, which is the numeric id.\n * @property {Function} [bytes] Bytes value conversion type.\n * Valid values are `Array` and (a base64 encoded) `String` (the global types).\n * Defaults to copy the present value, which usually is a Buffer under node and an Uint8Array in the browser.\n * @property {boolean} [defaults=false] Also sets default values on the resulting object\n * @property {boolean} [arrays=false] Sets empty arrays for missing repeated fields even if `defaults=false`\n * @property {boolean} [objects=false] Sets empty objects for missing map fields even if `defaults=false`\n * @property {boolean} [oneofs=false] Includes virtual oneof properties set to the present field's name, if any\n * @property {boolean} [json=false] Performs additional JSON compatibility conversions, i.e. NaN and Infinity to strings\n */ /**\n * Creates a plain object from a message of this type. Also converts values to other types if specified.\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n */ Type.prototype.toObject = function toObject(message, options) {\n    return this.setup().toObject(message, options);\n};\n/**\n * Decorator function as returned by {@link Type.d} (TypeScript).\n * @typedef TypeDecorator\n * @type {function}\n * @param {Constructor<T>} target Target constructor\n * @returns {undefined}\n * @template T extends Message<T>\n */ /**\n * Type decorator (TypeScript).\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {TypeDecorator<T>} Decorator function\n * @template T extends Message<T>\n */ Type.d = function decorateType(typeName) {\n    return function typeDecorator(target) {\n        util.decorateType(target, typeName);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdHlwZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLG9CQUFvQjtBQUNwQixJQUFJQyxZQUFZQyxtQkFBT0EsQ0FBQyxnR0FBYTtBQUNwQyxFQUFDRixLQUFLRyxTQUFTLEdBQUdDLE9BQU9DLE1BQU0sQ0FBQ0osVUFBVUUsU0FBUyxHQUFHRyxXQUFXLEdBQUdOLElBQUcsRUFBR08sU0FBUyxHQUFHO0FBRXZGLElBQUlDLE9BQVlOLG1CQUFPQSxDQUFDLHNGQUFRLEdBQzVCTyxRQUFZUCxtQkFBT0EsQ0FBQyx3RkFBUyxHQUM3QlEsUUFBWVIsbUJBQU9BLENBQUMsd0ZBQVMsR0FDN0JTLFdBQVlULG1CQUFPQSxDQUFDLDhGQUFZLEdBQ2hDVSxVQUFZVixtQkFBT0EsQ0FBQyw0RkFBVyxHQUMvQlcsVUFBWVgsbUJBQU9BLENBQUMsNEZBQVcsR0FDL0JZLFNBQVlaLG1CQUFPQSxDQUFDLDBGQUFVLEdBQzlCYSxTQUFZYixtQkFBT0EsQ0FBQywwRkFBVSxHQUM5QmMsT0FBWWQsbUJBQU9BLENBQUMsc0ZBQVEsR0FDNUJlLFVBQVlmLG1CQUFPQSxDQUFDLDRGQUFXLEdBQy9CZ0IsVUFBWWhCLG1CQUFPQSxDQUFDLDRGQUFXLEdBQy9CaUIsV0FBWWpCLG1CQUFPQSxDQUFDLDhGQUFZLEdBQ2hDa0IsWUFBWWxCLG1CQUFPQSxDQUFDLGdHQUFhLEdBQ2pDbUIsV0FBWW5CLG1CQUFPQSxDQUFDLDhGQUFZO0FBRXBDOzs7Ozs7O0NBT0MsR0FDRCxTQUFTRixLQUFLc0IsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZCdEIsVUFBVXVCLElBQUksQ0FBQyxJQUFJLEVBQUVGLE1BQU1DO0lBRTNCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsTUFBTSxHQUFHLENBQUMsR0FBSSxpQkFBaUI7SUFFcEM7OztLQUdDLEdBQ0QsSUFBSSxDQUFD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ZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy90eXBlLmpzPzBmNzIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFR5cGU7XG5cbi8vIGV4dGVuZHMgTmFtZXNwYWNlXG52YXIgTmFtZXNwYWNlID0gcmVxdWlyZShcIi4vbmFtZXNwYWNlXCIpO1xuKChUeXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTmFtZXNwYWNlLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gVHlwZSkuY2xhc3NOYW1lID0gXCJUeXBlXCI7XG5cbnZhciBFbnVtICAgICAgPSByZXF1aXJlKFwiLi9lbnVtXCIpLFxuICAgIE9uZU9mICAgICA9IHJlcXVpcmUoXCIuL29uZW9mXCIpLFxuICAgIEZpZWxkICAgICA9IHJlcXVpcmUoXCIuL2ZpZWxkXCIpLFxuICAgIE1hcEZpZWxkICA9IHJlcXVpcmUoXCIuL21hcGZpZWxkXCIpLFxuICAgIFNlcnZpY2UgICA9IHJlcXVpcmUoXCIuL3NlcnZpY2VcIiksXG4gICAgTWVzc2FnZSAgID0gcmVxdWlyZShcIi4vbWVzc2FnZVwiKSxcbiAgICBSZWFkZXIgICAgPSByZXF1aXJlKFwiLi9yZWFkZXJcIiksXG4gICAgV3JpdGVyICAgID0gcmVxdWlyZShcIi4vd3JpdGVyXCIpLFxuICAgIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWxcIiksXG4gICAgZW5jb2RlciAgID0gcmVxdWlyZShcIi4vZW5jb2RlclwiKSxcbiAgICBkZWNvZGVyICAgPSByZXF1aXJlKFwiLi9kZWNvZGVyXCIpLFxuICAgIHZlcmlmaWVyICA9IHJlcXVpcmUoXCIuL3ZlcmlmaWVyXCIpLFxuICAgIGNvbnZlcnRlciA9IHJlcXVpcmUoXCIuL2NvbnZlcnRlclwiKSxcbiAgICB3cmFwcGVycyAgPSByZXF1aXJlKFwiLi93cmFwcGVyc1wiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHJlZmxlY3RlZCBtZXNzYWdlIHR5cGUgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFJlZmxlY3RlZCBtZXNzYWdlIHR5cGUuXG4gKiBAZXh0ZW5kcyBOYW1lc3BhY2VCYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW29wdGlvbnNdIERlY2xhcmVkIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gVHlwZShuYW1lLCBvcHRpb25zKSB7XG4gICAgTmFtZXNwYWNlLmNhbGwodGhpcywgbmFtZSwgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBNZXNzYWdlIGZpZWxkcy5cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsRmllbGQ+fVxuICAgICAqL1xuICAgIHRoaXMuZmllbGRzID0ge307ICAvLyB0b0pTT04sIG1hcmtlclxuXG4gICAgLyoqXG4gICAgICogT25lb2ZzIGRlY2xhcmVkIHdpdGhpbiB0aGlzIG5hbWVzcGFjZSwgaWYgYW55LlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxPbmVPZj59XG4gICAgICovXG4gICAgdGhpcy5vbmVvZnMgPSB1bmRlZmluZWQ7IC8vIHRvSlNPTlxuXG4gICAgLyoqXG4gICAgICogRXh0ZW5zaW9uIHJhbmdlcywgaWYgYW55LlxuICAgICAqIEB0eXBlIHtudW1iZXJbXVtdfVxuICAgICAqL1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBSZXNlcnZlZCByYW5nZXMsIGlmIGFueS5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcltdfHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5yZXNlcnZlZCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKj9cbiAgICAgKiBXaGV0aGVyIHRoaXMgdHlwZSBpcyBhIGxlZ2FjeSBncm91cC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5ncm91cCA9IHVuZGVmaW5lZDsgLy8gdG9KU09OXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgZmllbGRzIGJ5IGlkLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPG51bWJlcixGaWVsZD58bnVsbH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZpZWxkc0J5SWQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGZpZWxkcyBhcyBhbiBhcnJheS5cbiAgICAgKiBAdHlwZSB7RmllbGRbXXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZmllbGRzQXJyYXkgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIG9uZW9mcyBhcyBhbiBhcnJheS5cbiAgICAgKiBAdHlwZSB7T25lT2ZbXXxudWxsfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fb25lb2ZzQXJyYXkgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIGNvbnN0cnVjdG9yLlxuICAgICAqIEB0eXBlIHtDb25zdHJ1Y3Rvcjx7fT59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jdG9yID0gbnVsbDtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVHlwZS5wcm90b3R5cGUsIHtcblxuICAgIC8qKlxuICAgICAqIE1lc3NhZ2UgZmllbGRzIGJ5IGlkLlxuICAgICAqIEBuYW1lIFR5cGUjZmllbGRzQnlJZFxuICAgICAqIEB0eXBlIHtPYmplY3QuPG51bWJlcixGaWVsZD59XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgZmllbGRzQnlJZDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLl9maWVsZHNCeUlkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9maWVsZHNCeUlkO1xuXG4gICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBuYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBmaWVsZCA9IHRoaXMuZmllbGRzW25hbWVzW2ldXSxcbiAgICAgICAgICAgICAgICAgICAgaWQgPSBmaWVsZC5pZDtcblxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9maWVsZHNCeUlkW2lkXSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgaWQgXCIgKyBpZCArIFwiIGluIFwiICsgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9maWVsZHNCeUlkW2lkXSA9IGZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc0J5SWQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRmllbGRzIG9mIHRoaXMgbWVzc2FnZSBhcyBhbiBhcnJheSBmb3IgaXRlcmF0aW9uLlxuICAgICAqIEBuYW1lIFR5cGUjZmllbGRzQXJyYXlcbiAgICAgKiBAdHlwZSB7RmllbGRbXX1cbiAgICAgKiBAcmVhZG9ubHlcbiAgICAgKi9cbiAgICBmaWVsZHNBcnJheToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpZWxkc0FycmF5IHx8ICh0aGlzLl9maWVsZHNBcnJheSA9IHV0aWwudG9BcnJheSh0aGlzLmZpZWxkcykpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE9uZW9mcyBvZiB0aGlzIG1lc3NhZ2UgYXMgYW4gYXJyYXkgZm9yIGl0ZXJhdGlvbi5cbiAgICAgKiBAbmFtZSBUeXBlI29uZW9mc0FycmF5XG4gICAgICogQHR5cGUge09uZU9mW119XG4gICAgICogQHJlYWRvbmx5XG4gICAgICovXG4gICAgb25lb2ZzQXJyYXk6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmVvZnNBcnJheSB8fCAodGhpcy5fb25lb2ZzQXJyYXkgPSB1dGlsLnRvQXJyYXkodGhpcy5vbmVvZnMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVnaXN0ZXJlZCBjb25zdHJ1Y3RvciwgaWYgYW55IHJlZ2lzdGVyZWQsIG90aGVyd2lzZSBhIGdlbmVyaWMgY29uc3RydWN0b3IuXG4gICAgICogQXNzaWduaW5nIGEgZnVuY3Rpb24gcmVwbGFjZXMgdGhlIGludGVybmFsIGNvbnN0cnVjdG9yLiBJZiB0aGUgZnVuY3Rpb24gZG9lcyBub3QgZXh0ZW5kIHtAbGluayBNZXNzYWdlfSB5ZXQsIGl0cyBwcm90b3R5cGUgd2lsbCBiZSBzZXR1cCBhY2NvcmRpbmdseSBhbmQgc3RhdGljIG1ldGhvZHMgd2lsbCBiZSBwb3B1bGF0ZWQuIElmIGl0IGFscmVhZHkgZXh0ZW5kcyB7QGxpbmsgTWVzc2FnZX0sIGl0IHdpbGwganVzdCByZXBsYWNlIHRoZSBpbnRlcm5hbCBjb25zdHJ1Y3Rvci5cbiAgICAgKiBAbmFtZSBUeXBlI2N0b3JcbiAgICAgKiBAdHlwZSB7Q29uc3RydWN0b3I8e30+fVxuICAgICAqL1xuICAgIGN0b3I6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jdG9yIHx8ICh0aGlzLmN0b3IgPSBUeXBlLmdlbmVyYXRlQ29uc3RydWN0b3IodGhpcykoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24oY3Rvcikge1xuXG4gICAgICAgICAgICAvLyBFbnN1cmUgcHJvcGVyIHByb3RvdHlwZVxuICAgICAgICAgICAgdmFyIHByb3RvdHlwZSA9IGN0b3IucHJvdG90eXBlO1xuICAgICAgICAgICAgaWYgKCEocHJvdG90eXBlIGluc3RhbmNlb2YgTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAoY3Rvci5wcm90b3R5cGUgPSBuZXcgTWVzc2FnZSgpKS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gICAgICAgICAgICAgICAgdXRpbC5tZXJnZShjdG9yLnByb3RvdHlwZSwgcHJvdG90eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ2xhc3NlcyBhbmQgbWVzc2FnZXMgcmVmZXJlbmNlIHRoZWlyIHJlZmxlY3RlZCB0eXBlXG4gICAgICAgICAgICBjdG9yLiR0eXBlID0gY3Rvci5wcm90b3R5cGUuJHR5cGUgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBNaXggaW4gc3RhdGljIG1ldGhvZHNcbiAgICAgICAgICAgIHV0aWwubWVyZ2UoY3RvciwgTWVzc2FnZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2N0b3IgPSBjdG9yO1xuXG4gICAgICAgICAgICAvLyBNZXNzYWdlcyBoYXZlIG5vbi1lbnVtZXJhYmxlIGRlZmF1bHQgdmFsdWVzIG9uIHRoZWlyIHByb3RvdHlwZVxuICAgICAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICAgICAgZm9yICg7IGkgPCAvKiBpbml0aWFsaXplcyAqLyB0aGlzLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpZWxkc0FycmF5W2ldLnJlc29sdmUoKTsgLy8gZW5zdXJlcyBhIHByb3BlciB2YWx1ZVxuXG4gICAgICAgICAgICAvLyBNZXNzYWdlcyBoYXZlIG5vbi1lbnVtZXJhYmxlIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIGVhY2ggdmlydHVhbCBvbmVvZiBmaWVsZFxuICAgICAgICAgICAgdmFyIGN0b3JQcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgLyogaW5pdGlhbGl6ZXMgKi8gdGhpcy5vbmVvZnNBcnJheS5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgICAgICBjdG9yUHJvcGVydGllc1t0aGlzLl9vbmVvZnNBcnJheVtpXS5yZXNvbHZlKCkubmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGdldDogdXRpbC5vbmVPZkdldHRlcih0aGlzLl9vbmVvZnNBcnJheVtpXS5vbmVvZiksXG4gICAgICAgICAgICAgICAgICAgIHNldDogdXRpbC5vbmVPZlNldHRlcih0aGlzLl9vbmVvZnNBcnJheVtpXS5vbmVvZilcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY3Rvci5wcm90b3R5cGUsIGN0b3JQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuVHlwZS5nZW5lcmF0ZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gZ2VuZXJhdGVDb25zdHJ1Y3RvcihtdHlwZSkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJwXCJdLCBtdHlwZS5uYW1lKTtcbiAgICAvLyBleHBsaWNpdGx5IGluaXRpYWxpemUgbXV0YWJsZSBvYmplY3QvYXJyYXkgZmllbGRzIHNvIHRoYXQgdGhlc2UgYXJlbid0IGp1c3QgaW5oZXJpdGVkIGZyb20gdGhlIHByb3RvdHlwZVxuICAgIGZvciAodmFyIGkgPSAwLCBmaWVsZDsgaSA8IG10eXBlLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoKGZpZWxkID0gbXR5cGUuX2ZpZWxkc0FycmF5W2ldKS5tYXApIGdlblxuICAgICAgICAgICAgKFwidGhpcyVzPXt9XCIsIHV0aWwuc2FmZVByb3AoZmllbGQubmFtZSkpO1xuICAgICAgICBlbHNlIGlmIChmaWVsZC5yZXBlYXRlZCkgZ2VuXG4gICAgICAgICAgICAoXCJ0aGlzJXM9W11cIiwgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKSk7XG4gICAgcmV0dXJuIGdlblxuICAgIChcImlmKHApZm9yKHZhciBrcz1PYmplY3Qua2V5cyhwKSxpPTA7aTxrcy5sZW5ndGg7KytpKWlmKHBba3NbaV1dIT1udWxsKVwiKSAvLyBvbWl0IHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgIChcInRoaXNba3NbaV1dPXBba3NbaV1dXCIpO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW5leHBlY3RlZC1tdWx0aWxpbmUgKi9cbn07XG5cbmZ1bmN0aW9uIGNsZWFyQ2FjaGUodHlwZSkge1xuICAgIHR5cGUuX2ZpZWxkc0J5SWQgPSB0eXBlLl9maWVsZHNBcnJheSA9IHR5cGUuX29uZW9mc0FycmF5ID0gbnVsbDtcbiAgICBkZWxldGUgdHlwZS5lbmNvZGU7XG4gICAgZGVsZXRlIHR5cGUuZGVjb2RlO1xuICAgIGRlbGV0ZSB0eXBlLnZlcmlmeTtcbiAgICByZXR1cm4gdHlwZTtcbn1cblxuLyoqXG4gKiBNZXNzYWdlIHR5cGUgZGVzY3JpcHRvci5cbiAqIEBpbnRlcmZhY2UgSVR5cGVcbiAqIEBleHRlbmRzIElOYW1lc3BhY2VcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSU9uZU9mPn0gW29uZW9mc10gT25lb2YgZGVzY3JpcHRvcnNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsSUZpZWxkPn0gZmllbGRzIEZpZWxkIGRlc2NyaXB0b3JzXG4gKiBAcHJvcGVydHkge251bWJlcltdW119IFtleHRlbnNpb25zXSBFeHRlbnNpb24gcmFuZ2VzXG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXJbXXxzdHJpbmc+fSBbcmVzZXJ2ZWRdIFJlc2VydmVkIHJhbmdlc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbZ3JvdXA9ZmFsc2VdIFdoZXRoZXIgYSBsZWdhY3kgZ3JvdXAgb3Igbm90XG4gKi9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWVzc2FnZSB0eXBlIGZyb20gYSBtZXNzYWdlIHR5cGUgZGVzY3JpcHRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE1lc3NhZ2UgbmFtZVxuICogQHBhcmFtIHtJVHlwZX0ganNvbiBNZXNzYWdlIHR5cGUgZGVzY3JpcHRvclxuICogQHJldHVybnMge1R5cGV9IENyZWF0ZWQgbWVzc2FnZSB0eXBlXG4gKi9cblR5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihuYW1lLCBqc29uKSB7XG4gICAgdmFyIHR5cGUgPSBuZXcgVHlwZShuYW1lLCBqc29uLm9wdGlvbnMpO1xuICAgIHR5cGUuZXh0ZW5zaW9ucyA9IGpzb24uZXh0ZW5zaW9ucztcbiAgICB0eXBlLnJlc2VydmVkID0ganNvbi5yZXNlcnZlZDtcbiAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLmZpZWxkcyksXG4gICAgICAgIGkgPSAwO1xuICAgIGZvciAoOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgIHR5cGUuYWRkKFxuICAgICAgICAgICAgKCB0eXBlb2YganNvbi5maWVsZHNbbmFtZXNbaV1dLmtleVR5cGUgIT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgICAgID8gTWFwRmllbGQuZnJvbUpTT05cbiAgICAgICAgICAgIDogRmllbGQuZnJvbUpTT04gKShuYW1lc1tpXSwganNvbi5maWVsZHNbbmFtZXNbaV1dKVxuICAgICAgICApO1xuICAgIGlmIChqc29uLm9uZW9mcylcbiAgICAgICAgZm9yIChuYW1lcyA9IE9iamVjdC5rZXlzKGpzb24ub25lb2ZzKSwgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICAgIHR5cGUuYWRkKE9uZU9mLmZyb21KU09OKG5hbWVzW2ldLCBqc29uLm9uZW9mc1tuYW1lc1tpXV0pKTtcbiAgICBpZiAoanNvbi5uZXN0ZWQpXG4gICAgICAgIGZvciAobmFtZXMgPSBPYmplY3Qua2V5cyhqc29uLm5lc3RlZCksIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuZXN0ZWQgPSBqc29uLm5lc3RlZFtuYW1lc1tpXV07XG4gICAgICAgICAgICB0eXBlLmFkZCggLy8gbW9zdCB0byBsZWFzdCBsaWtlbHlcbiAgICAgICAgICAgICAgICAoIG5lc3RlZC5pZCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBGaWVsZC5mcm9tSlNPTlxuICAgICAgICAgICAgICAgIDogbmVzdGVkLmZpZWxkcyAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBUeXBlLmZyb21KU09OXG4gICAgICAgICAgICAgICAgOiBuZXN0ZWQudmFsdWVzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IEVudW0uZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IG5lc3RlZC5tZXRob2RzICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IFNlcnZpY2UuZnJvbUpTT05cbiAgICAgICAgICAgICAgICA6IE5hbWVzcGFjZS5mcm9tSlNPTiApKG5hbWVzW2ldLCBuZXN0ZWQpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgaWYgKGpzb24uZXh0ZW5zaW9ucyAmJiBqc29uLmV4dGVuc2lvbnMubGVuZ3RoKVxuICAgICAgICB0eXBlLmV4dGVuc2lvbnMgPSBqc29uLmV4dGVuc2lvbnM7XG4gICAgaWYgKGpzb24ucmVzZXJ2ZWQgJiYganNvbi5yZXNlcnZlZC5sZW5ndGgpXG4gICAgICAgIHR5cGUucmVzZXJ2ZWQgPSBqc29uLnJlc2VydmVkO1xuICAgIGlmIChqc29uLmdyb3VwKVxuICAgICAgICB0eXBlLmdyb3VwID0gdHJ1ZTtcbiAgICBpZiAoanNvbi5jb21tZW50KVxuICAgICAgICB0eXBlLmNvbW1lbnQgPSBqc29uLmNvbW1lbnQ7XG4gICAgaWYgKGpzb24uZWRpdGlvbilcbiAgICAgICAgdHlwZS5fZWRpdGlvbiA9IGpzb24uZWRpdGlvbjtcbiAgICB0eXBlLl9kZWZhdWx0RWRpdGlvbiA9IFwicHJvdG8zXCI7ICAvLyBGb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHkuXG4gICAgcmV0dXJuIHR5cGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbWVzc2FnZSB0eXBlIHRvIGEgbWVzc2FnZSB0eXBlIGRlc2NyaXB0b3IuXG4gKiBAcGFyYW0ge0lUb0pTT05PcHRpb25zfSBbdG9KU09OT3B0aW9uc10gSlNPTiBjb252ZXJzaW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtJVHlwZX0gTWVzc2FnZSB0eXBlIGRlc2NyaXB0b3JcbiAqL1xuVHlwZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKHRvSlNPTk9wdGlvbnMpIHtcbiAgICB2YXIgaW5oZXJpdGVkID0gTmFtZXNwYWNlLnByb3RvdHlwZS50b0pTT04uY2FsbCh0aGlzLCB0b0pTT05PcHRpb25zKTtcbiAgICB2YXIga2VlcENvbW1lbnRzID0gdG9KU09OT3B0aW9ucyA/IEJvb2xlYW4odG9KU09OT3B0aW9ucy5rZWVwQ29tbWVudHMpIDogZmFsc2U7XG4gICAgcmV0dXJuIHV0aWwudG9PYmplY3QoW1xuICAgICAgICBcImVkaXRpb25cIiAgICAsIHRoaXMuX2VkaXRpb25Ub0pTT04oKSxcbiAgICAgICAgXCJvcHRpb25zXCIgICAgLCBpbmhlcml0ZWQgJiYgaW5oZXJpdGVkLm9wdGlvbnMgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcIm9uZW9mc1wiICAgICAsIE5hbWVzcGFjZS5hcnJheVRvSlNPTih0aGlzLm9uZW9mc0FycmF5LCB0b0pTT05PcHRpb25zKSxcbiAgICAgICAgXCJmaWVsZHNcIiAgICAgLCBOYW1lc3BhY2UuYXJyYXlUb0pTT04odGhpcy5maWVsZHNBcnJheS5maWx0ZXIoZnVuY3Rpb24ob2JqKSB7IHJldHVybiAhb2JqLmRlY2xhcmluZ0ZpZWxkOyB9KSwgdG9KU09OT3B0aW9ucykgfHwge30sXG4gICAgICAgIFwiZXh0ZW5zaW9uc1wiICwgdGhpcy5leHRlbnNpb25zICYmIHRoaXMuZXh0ZW5zaW9ucy5sZW5ndGggPyB0aGlzLmV4dGVuc2lvbnMgOiB1bmRlZmluZWQsXG4gICAgICAgIFwicmVzZXJ2ZWRcIiAgICwgdGhpcy5yZXNlcnZlZCAmJiB0aGlzLnJlc2VydmVkLmxlbmd0aCA/IHRoaXMucmVzZXJ2ZWQgOiB1bmRlZmluZWQsXG4gICAgICAgIFwiZ3JvdXBcIiAgICAgICwgdGhpcy5ncm91cCB8fCB1bmRlZmluZWQsXG4gICAgICAgIFwibmVzdGVkXCIgICAgICwgaW5oZXJpdGVkICYmIGluaGVyaXRlZC5uZXN0ZWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICBcImNvbW1lbnRcIiAgICAsIGtlZXBDb21tZW50cyA/IHRoaXMuY29tbWVudCA6IHVuZGVmaW5lZFxuICAgIF0pO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHlwZS5wcm90b3R5cGUucmVzb2x2ZUFsbCA9IGZ1bmN0aW9uIHJlc29sdmVBbGwoKSB7XG4gICAgaWYgKCF0aGlzLl9uZWVkc1JlY3Vyc2l2ZVJlc29sdmUpIHJldHVybiB0aGlzO1xuXG4gICAgTmFtZXNwYWNlLnByb3RvdHlwZS5yZXNvbHZlQWxsLmNhbGwodGhpcyk7XG4gICAgdmFyIG9uZW9mcyA9IHRoaXMub25lb2ZzQXJyYXk7IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgb25lb2ZzLmxlbmd0aClcbiAgICAgICAgb25lb2ZzW2krK10ucmVzb2x2ZSgpO1xuICAgIHZhciBmaWVsZHMgPSB0aGlzLmZpZWxkc0FycmF5LCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGZpZWxkcy5sZW5ndGgpXG4gICAgICAgIGZpZWxkc1tpKytdLnJlc29sdmUoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblR5cGUucHJvdG90eXBlLl9yZXNvbHZlRmVhdHVyZXNSZWN1cnNpdmUgPSBmdW5jdGlvbiBfcmVzb2x2ZUZlYXR1cmVzUmVjdXJzaXZlKGVkaXRpb24pIHtcbiAgICBpZiAoIXRoaXMuX25lZWRzUmVjdXJzaXZlRmVhdHVyZVJlc29sdXRpb24pIHJldHVybiB0aGlzO1xuXG4gICAgZWRpdGlvbiA9IHRoaXMuX2VkaXRpb24gfHwgZWRpdGlvbjtcblxuICAgIE5hbWVzcGFjZS5wcm90b3R5cGUuX3Jlc29sdmVGZWF0dXJlc1JlY3Vyc2l2ZS5jYWxsKHRoaXMsIGVkaXRpb24pO1xuICAgIHRoaXMub25lb2ZzQXJyYXkuZm9yRWFjaChvbmVvZiA9PiB7XG4gICAgICAgIG9uZW9mLl9yZXNvbHZlRmVhdHVyZXMoZWRpdGlvbik7XG4gICAgfSk7XG4gICAgdGhpcy5maWVsZHNBcnJheS5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICAgICAgZmllbGQuX3Jlc29sdmVGZWF0dXJlcyhlZGl0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblR5cGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZmllbGRzW25hbWVdXG4gICAgICAgIHx8IHRoaXMub25lb2ZzICYmIHRoaXMub25lb2ZzW25hbWVdXG4gICAgICAgIHx8IHRoaXMubmVzdGVkICYmIHRoaXMubmVzdGVkW25hbWVdXG4gICAgICAgIHx8IG51bGw7XG59O1xuXG4vKipcbiAqIEFkZHMgYSBuZXN0ZWQgb2JqZWN0IHRvIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gYWRkXG4gKiBAcmV0dXJucyB7VHlwZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZXJlIGlzIGFscmVhZHkgYSBuZXN0ZWQgb2JqZWN0IHdpdGggdGhpcyBuYW1lIG9yLCBpZiBhIGZpZWxkLCB3aGVuIHRoZXJlIGlzIGFscmVhZHkgYSBmaWVsZCB3aXRoIHRoaXMgaWRcbiAqL1xuVHlwZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKG9iamVjdCkge1xuXG4gICAgaWYgKHRoaXMuZ2V0KG9iamVjdC5uYW1lKSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJkdXBsaWNhdGUgbmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpbiBcIiArIHRoaXMpO1xuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEZpZWxkICYmIG9iamVjdC5leHRlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBOT1RFOiBFeHRlbnNpb24gZmllbGRzIGFyZW4ndCBhY3R1YWwgZmllbGRzIG9uIHRoZSBkZWNsYXJpbmcgdHlwZSwgYnV0IG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAvLyBUaGUgcm9vdCBvYmplY3QgdGFrZXMgY2FyZSBvZiBhZGRpbmcgZGlzdGluY3Qgc2lzdGVyLWZpZWxkcyB0byB0aGUgcmVzcGVjdGl2ZSBleHRlbmRlZFxuICAgICAgICAvLyB0eXBlIGluc3RlYWQuXG5cbiAgICAgICAgLy8gYXZvaWRzIGNhbGxpbmcgdGhlIGdldHRlciBpZiBub3QgYWJzb2x1dGVseSBuZWNlc3NhcnkgYmVjYXVzZSBpdCdzIGNhbGxlZCBxdWl0ZSBmcmVxdWVudGx5XG4gICAgICAgIGlmICh0aGlzLl9maWVsZHNCeUlkID8gLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdGhpcy5fZmllbGRzQnlJZFtvYmplY3QuaWRdIDogdGhpcy5maWVsZHNCeUlkW29iamVjdC5pZF0pXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcImR1cGxpY2F0ZSBpZCBcIiArIG9iamVjdC5pZCArIFwiIGluIFwiICsgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWRJZChvYmplY3QuaWQpKVxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJpZCBcIiArIG9iamVjdC5pZCArIFwiIGlzIHJlc2VydmVkIGluIFwiICsgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmlzUmVzZXJ2ZWROYW1lKG9iamVjdC5uYW1lKSlcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibmFtZSAnXCIgKyBvYmplY3QubmFtZSArIFwiJyBpcyByZXNlcnZlZCBpbiBcIiArIHRoaXMpO1xuXG4gICAgICAgIGlmIChvYmplY3QucGFyZW50KVxuICAgICAgICAgICAgb2JqZWN0LnBhcmVudC5yZW1vdmUob2JqZWN0KTtcbiAgICAgICAgdGhpcy5maWVsZHNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3QubWVzc2FnZSA9IHRoaXM7XG4gICAgICAgIG9iamVjdC5vbkFkZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikge1xuICAgICAgICBpZiAoIXRoaXMub25lb2ZzKVxuICAgICAgICAgICAgdGhpcy5vbmVvZnMgPSB7fTtcbiAgICAgICAgdGhpcy5vbmVvZnNbb2JqZWN0Lm5hbWVdID0gb2JqZWN0O1xuICAgICAgICBvYmplY3Qub25BZGQodGhpcyk7XG4gICAgICAgIHJldHVybiBjbGVhckNhY2hlKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gTmFtZXNwYWNlLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBvYmplY3QpO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgbmVzdGVkIG9iamVjdCBmcm9tIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVmbGVjdGlvbk9iamVjdH0gb2JqZWN0IE5lc3RlZCBvYmplY3QgdG8gcmVtb3ZlXG4gKiBAcmV0dXJucyB7VHlwZX0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFyZ3VtZW50cyBhcmUgaW52YWxpZFxuICogQHRocm93cyB7RXJyb3J9IElmIGBvYmplY3RgIGlzIG5vdCBhIG1lbWJlciBvZiB0aGlzIHR5cGVcbiAqL1xuVHlwZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBGaWVsZCAmJiBvYmplY3QuZXh0ZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gU2VlIFR5cGUjYWRkIGZvciB0aGUgcmVhc29uIHdoeSBleHRlbnNpb24gZmllbGRzIGFyZSBleGNsdWRlZCBoZXJlLlxuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMuZmllbGRzIHx8IHRoaXMuZmllbGRzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuZmllbGRzW29iamVjdC5uYW1lXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBPbmVPZikge1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIXRoaXMub25lb2ZzIHx8IHRoaXMub25lb2ZzW29iamVjdC5uYW1lXSAhPT0gb2JqZWN0KVxuICAgICAgICAgICAgdGhyb3cgRXJyb3Iob2JqZWN0ICsgXCIgaXMgbm90IGEgbWVtYmVyIG9mIFwiICsgdGhpcyk7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMub25lb2ZzW29iamVjdC5uYW1lXTtcbiAgICAgICAgb2JqZWN0LnBhcmVudCA9IG51bGw7XG4gICAgICAgIG9iamVjdC5vblJlbW92ZSh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNsZWFyQ2FjaGUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBOYW1lc3BhY2UucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsIG9iamVjdCk7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgaWQgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gaWQgSWQgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuVHlwZS5wcm90b3R5cGUuaXNSZXNlcnZlZElkID0gZnVuY3Rpb24gaXNSZXNlcnZlZElkKGlkKSB7XG4gICAgcmV0dXJuIE5hbWVzcGFjZS5pc1Jlc2VydmVkSWQodGhpcy5yZXNlcnZlZCwgaWQpO1xufTtcblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG5hbWUgaXMgcmVzZXJ2ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgcmVzZXJ2ZWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cblR5cGUucHJvdG90eXBlLmlzUmVzZXJ2ZWROYW1lID0gZnVuY3Rpb24gaXNSZXNlcnZlZE5hbWUobmFtZSkge1xuICAgIHJldHVybiBOYW1lc3BhY2UuaXNSZXNlcnZlZE5hbWUodGhpcy5yZXNlcnZlZCwgbmFtZSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgdXNpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gW3Byb3BlcnRpZXNdIFByb3BlcnRpZXMgdG8gc2V0XG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IE1lc3NhZ2UgaW5zdGFuY2VcbiAqL1xuVHlwZS5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY3Rvcihwcm9wZXJ0aWVzKTtcbn07XG5cbi8qKlxuICogU2V0cyB1cCB7QGxpbmsgVHlwZSNlbmNvZGV8ZW5jb2RlfSwge0BsaW5rIFR5cGUjZGVjb2RlfGRlY29kZX0gYW5kIHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9LlxuICogQHJldHVybnMge1R5cGV9IGB0aGlzYFxuICovXG5UeXBlLnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uIHNldHVwKCkge1xuICAgIC8vIFNldHMgdXAgZXZlcnl0aGluZyBhdCBvbmNlIHNvIHRoYXQgdGhlIHByb3RvdHlwZSBjaGFpbiBkb2VzIG5vdCBoYXZlIHRvIGJlIHJlLWV2YWx1YXRlZFxuICAgIC8vIG11bHRpcGxlIHRpbWVzIChWOCwgc29mdC1kZW9wdCBwcm90b3R5cGUtY2hlY2spLlxuXG4gICAgdmFyIGZ1bGxOYW1lID0gdGhpcy5mdWxsTmFtZSxcbiAgICAgICAgdHlwZXMgICAgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIHRoaXMuZmllbGRzQXJyYXkubGVuZ3RoOyArK2kpXG4gICAgICAgIHR5cGVzLnB1c2godGhpcy5fZmllbGRzQXJyYXlbaV0ucmVzb2x2ZSgpLnJlc29sdmVkVHlwZSk7XG5cbiAgICAvLyBSZXBsYWNlIHNldHVwIG1ldGhvZHMgd2l0aCB0eXBlLXNwZWNpZmljIGdlbmVyYXRlZCBmdW5jdGlvbnNcbiAgICB0aGlzLmVuY29kZSA9IGVuY29kZXIodGhpcykoe1xuICAgICAgICBXcml0ZXIgOiBXcml0ZXIsXG4gICAgICAgIHR5cGVzICA6IHR5cGVzLFxuICAgICAgICB1dGlsICAgOiB1dGlsXG4gICAgfSk7XG4gICAgdGhpcy5kZWNvZGUgPSBkZWNvZGVyKHRoaXMpKHtcbiAgICAgICAgUmVhZGVyIDogUmVhZGVyLFxuICAgICAgICB0eXBlcyAgOiB0eXBlcyxcbiAgICAgICAgdXRpbCAgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMudmVyaWZ5ID0gdmVyaWZpZXIodGhpcykoe1xuICAgICAgICB0eXBlcyA6IHR5cGVzLFxuICAgICAgICB1dGlsICA6IHV0aWxcbiAgICB9KTtcbiAgICB0aGlzLmZyb21PYmplY3QgPSBjb252ZXJ0ZXIuZnJvbU9iamVjdCh0aGlzKSh7XG4gICAgICAgIHR5cGVzIDogdHlwZXMsXG4gICAgICAgIHV0aWwgIDogdXRpbFxuICAgIH0pO1xuICAgIHRoaXMudG9PYmplY3QgPSBjb252ZXJ0ZXIudG9PYmplY3QodGhpcykoe1xuICAgICAgICB0eXBlcyA6IHR5cGVzLFxuICAgICAgICB1dGlsICA6IHV0aWxcbiAgICB9KTtcblxuICAgIC8vIEluamVjdCBjdXN0b20gd3JhcHBlcnMgZm9yIGNvbW1vbiB0eXBlc1xuICAgIHZhciB3cmFwcGVyID0gd3JhcHBlcnNbZnVsbE5hbWVdO1xuICAgIGlmICh3cmFwcGVyKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbFRoaXMgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgICAgICAvLyBpZiAod3JhcHBlci5mcm9tT2JqZWN0KSB7XG4gICAgICAgICAgICBvcmlnaW5hbFRoaXMuZnJvbU9iamVjdCA9IHRoaXMuZnJvbU9iamVjdDtcbiAgICAgICAgICAgIHRoaXMuZnJvbU9iamVjdCA9IHdyYXBwZXIuZnJvbU9iamVjdC5iaW5kKG9yaWdpbmFsVGhpcyk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYgKHdyYXBwZXIudG9PYmplY3QpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsVGhpcy50b09iamVjdCA9IHRoaXMudG9PYmplY3Q7XG4gICAgICAgICAgICB0aGlzLnRvT2JqZWN0ID0gd3JhcHBlci50b09iamVjdC5iaW5kKG9yaWdpbmFsVGhpcyk7XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW5jb2RlcyBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICogQHBhcmFtIHtNZXNzYWdlPHt9PnxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IHdyaXRlclxuICovXG5UeXBlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGVfc2V0dXAobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dXAoKS5lbmNvZGUobWVzc2FnZSwgd3JpdGVyKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZSBwcmVjZWVkZWQgYnkgaXRzIGJ5dGUgbGVuZ3RoIGFzIGEgdmFyaW50LiBEb2VzIG5vdCBpbXBsaWNpdGx5IHtAbGluayBUeXBlI3ZlcmlmeXx2ZXJpZnl9IG1lc3NhZ2VzLlxuICogQHBhcmFtIHtNZXNzYWdlPHt9PnxPYmplY3QuPHN0cmluZywqPn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlIG9yIHBsYWluIG9iamVjdFxuICogQHBhcmFtIHtXcml0ZXJ9IFt3cml0ZXJdIFdyaXRlciB0byBlbmNvZGUgdG9cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IHdyaXRlclxuICovXG5UeXBlLnByb3RvdHlwZS5lbmNvZGVEZWxpbWl0ZWQgPSBmdW5jdGlvbiBlbmNvZGVEZWxpbWl0ZWQobWVzc2FnZSwgd3JpdGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5jb2RlKG1lc3NhZ2UsIHdyaXRlciAmJiB3cml0ZXIubGVuID8gd3JpdGVyLmZvcmsoKSA6IHdyaXRlcikubGRlbGltKCk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBtZXNzYWdlIG9mIHRoaXMgdHlwZS5cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF0gTGVuZ3RoIG9mIHRoZSBtZXNzYWdlLCBpZiBrbm93biBiZWZvcmVoYW5kXG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IERlY29kZWQgbWVzc2FnZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAqIEB0aHJvd3Mge3V0aWwuUHJvdG9jb2xFcnJvcjx7fT59IElmIHJlcXVpcmVkIGZpZWxkcyBhcmUgbWlzc2luZ1xuICovXG5UeXBlLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGVfc2V0dXAocmVhZGVyLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLmRlY29kZShyZWFkZXIsIGxlbmd0aCk7IC8vIG92ZXJyaWRlcyB0aGlzIG1ldGhvZFxufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgbWVzc2FnZSBvZiB0aGlzIHR5cGUgcHJlY2VlZGVkIGJ5IGl0cyBieXRlIGxlbmd0aCBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7UmVhZGVyfFVpbnQ4QXJyYXl9IHJlYWRlciBSZWFkZXIgb3IgYnVmZmVyIHRvIGRlY29kZSBmcm9tXG4gKiBAcmV0dXJucyB7TWVzc2FnZTx7fT59IERlY29kZWQgbWVzc2FnZVxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBwYXlsb2FkIGlzIG5vdCBhIHJlYWRlciBvciB2YWxpZCBidWZmZXJcbiAqIEB0aHJvd3Mge3V0aWwuUHJvdG9jb2xFcnJvcn0gSWYgcmVxdWlyZWQgZmllbGRzIGFyZSBtaXNzaW5nXG4gKi9cblR5cGUucHJvdG90eXBlLmRlY29kZURlbGltaXRlZCA9IGZ1bmN0aW9uIGRlY29kZURlbGltaXRlZChyZWFkZXIpIHtcbiAgICBpZiAoIShyZWFkZXIgaW5zdGFuY2VvZiBSZWFkZXIpKVxuICAgICAgICByZWFkZXIgPSBSZWFkZXIuY3JlYXRlKHJlYWRlcik7XG4gICAgcmV0dXJuIHRoaXMuZGVjb2RlKHJlYWRlciwgcmVhZGVyLnVpbnQzMigpKTtcbn07XG5cbi8qKlxuICogVmVyaWZpZXMgdGhhdCBmaWVsZCB2YWx1ZXMgYXJlIHZhbGlkIGFuZCB0aGF0IHJlcXVpcmVkIGZpZWxkcyBhcmUgcHJlc2VudC5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG1lc3NhZ2UgUGxhaW4gb2JqZWN0IHRvIHZlcmlmeVxuICogQHJldHVybnMge251bGx8c3RyaW5nfSBgbnVsbGAgaWYgdmFsaWQsIG90aGVyd2lzZSB0aGUgcmVhc29uIHdoeSBpdCBpcyBub3RcbiAqL1xuVHlwZS5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5X3NldHVwKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLnZlcmlmeShtZXNzYWdlKTsgLy8gb3ZlcnJpZGVzIHRoaXMgbWV0aG9kXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBvZiB0aGlzIHR5cGUgZnJvbSBhIHBsYWluIG9iamVjdC4gQWxzbyBjb252ZXJ0cyB2YWx1ZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBpbnRlcm5hbCB0eXBlcy5cbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IG9iamVjdCBQbGFpbiBvYmplY3QgdG8gY29udmVydFxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBNZXNzYWdlIGluc3RhbmNlXG4gKi9cblR5cGUucHJvdG90eXBlLmZyb21PYmplY3QgPSBmdW5jdGlvbiBmcm9tT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiB0aGlzLnNldHVwKCkuZnJvbU9iamVjdChvYmplY3QpO1xufTtcblxuLyoqXG4gKiBDb252ZXJzaW9uIG9wdGlvbnMgYXMgdXNlZCBieSB7QGxpbmsgVHlwZSN0b09iamVjdH0gYW5kIHtAbGluayBNZXNzYWdlLnRvT2JqZWN0fS5cbiAqIEBpbnRlcmZhY2UgSUNvbnZlcnNpb25PcHRpb25zXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbbG9uZ3NdIExvbmcgY29udmVyc2lvbiB0eXBlLlxuICogVmFsaWQgdmFsdWVzIGFyZSBgU3RyaW5nYCBhbmQgYE51bWJlcmAgKHRoZSBnbG9iYWwgdHlwZXMpLlxuICogRGVmYXVsdHMgdG8gY29weSB0aGUgcHJlc2VudCB2YWx1ZSwgd2hpY2ggaXMgYSBwb3NzaWJseSB1bnNhZmUgbnVtYmVyIHdpdGhvdXQgYW5kIGEge0BsaW5rIExvbmd9IHdpdGggYSBsb25nIGxpYnJhcnkuXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBbZW51bXNdIEVudW0gdmFsdWUgY29udmVyc2lvbiB0eXBlLlxuICogT25seSB2YWxpZCB2YWx1ZSBpcyBgU3RyaW5nYCAodGhlIGdsb2JhbCB0eXBlKS5cbiAqIERlZmF1bHRzIHRvIGNvcHkgdGhlIHByZXNlbnQgdmFsdWUsIHdoaWNoIGlzIHRoZSBudW1lcmljIGlkLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gW2J5dGVzXSBCeXRlcyB2YWx1ZSBjb252ZXJzaW9uIHR5cGUuXG4gKiBWYWxpZCB2YWx1ZXMgYXJlIGBBcnJheWAgYW5kIChhIGJhc2U2NCBlbmNvZGVkKSBgU3RyaW5nYCAodGhlIGdsb2JhbCB0eXBlcykuXG4gKiBEZWZhdWx0cyB0byBjb3B5IHRoZSBwcmVzZW50IHZhbHVlLCB3aGljaCB1c3VhbGx5IGlzIGEgQnVmZmVyIHVuZGVyIG5vZGUgYW5kIGFuIFVpbnQ4QXJyYXkgaW4gdGhlIGJyb3dzZXIuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkZWZhdWx0cz1mYWxzZV0gQWxzbyBzZXRzIGRlZmF1bHQgdmFsdWVzIG9uIHRoZSByZXN1bHRpbmcgb2JqZWN0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthcnJheXM9ZmFsc2VdIFNldHMgZW1wdHkgYXJyYXlzIGZvciBtaXNzaW5nIHJlcGVhdGVkIGZpZWxkcyBldmVuIGlmIGBkZWZhdWx0cz1mYWxzZWBcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29iamVjdHM9ZmFsc2VdIFNldHMgZW1wdHkgb2JqZWN0cyBmb3IgbWlzc2luZyBtYXAgZmllbGRzIGV2ZW4gaWYgYGRlZmF1bHRzPWZhbHNlYFxuICogQHByb3BlcnR5IHtib29sZWFufSBbb25lb2ZzPWZhbHNlXSBJbmNsdWRlcyB2aXJ0dWFsIG9uZW9mIHByb3BlcnRpZXMgc2V0IHRvIHRoZSBwcmVzZW50IGZpZWxkJ3MgbmFtZSwgaWYgYW55XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtqc29uPWZhbHNlXSBQZXJmb3JtcyBhZGRpdGlvbmFsIEpTT04gY29tcGF0aWJpbGl0eSBjb252ZXJzaW9ucywgaS5lLiBOYU4gYW5kIEluZmluaXR5IHRvIHN0cmluZ3NcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBwbGFpbiBvYmplY3QgZnJvbSBhIG1lc3NhZ2Ugb2YgdGhpcyB0eXBlLiBBbHNvIGNvbnZlcnRzIHZhbHVlcyB0byBvdGhlciB0eXBlcyBpZiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge01lc3NhZ2U8e30+fSBtZXNzYWdlIE1lc3NhZ2UgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SUNvbnZlcnNpb25PcHRpb25zfSBbb3B0aW9uc10gQ29udmVyc2lvbiBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IFBsYWluIG9iamVjdFxuICovXG5UeXBlLnByb3RvdHlwZS50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZXR1cCgpLnRvT2JqZWN0KG1lc3NhZ2UsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3IgZnVuY3Rpb24gYXMgcmV0dXJuZWQgYnkge0BsaW5rIFR5cGUuZH0gKFR5cGVTY3JpcHQpLlxuICogQHR5cGVkZWYgVHlwZURlY29yYXRvclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtDb25zdHJ1Y3RvcjxUPn0gdGFyZ2V0IFRhcmdldCBjb25zdHJ1Y3RvclxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqIEB0ZW1wbGF0ZSBUIGV4dGVuZHMgTWVzc2FnZTxUPlxuICovXG5cbi8qKlxuICogVHlwZSBkZWNvcmF0b3IgKFR5cGVTY3JpcHQpLlxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlTmFtZV0gVHlwZSBuYW1lLCBkZWZhdWx0cyB0byB0aGUgY29uc3RydWN0b3IncyBuYW1lXG4gKiBAcmV0dXJucyB7VHlwZURlY29yYXRvcjxUPn0gRGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqL1xuVHlwZS5kID0gZnVuY3Rpb24gZGVjb3JhdGVUeXBlKHR5cGVOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHR5cGVEZWNvcmF0b3IodGFyZ2V0KSB7XG4gICAgICAgIHV0aWwuZGVjb3JhdGVUeXBlKHRhcmdldCwgdHlwZU5hbWUpO1xuICAgIH07XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJUeXBlIiwiTmFtZXNwYWNlIiwicmVxdWlyZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiY2xhc3NOYW1lIiwiRW51bSIsIk9uZU9mIiwiRmllbGQiLCJNYXBGaWVsZCIsIlNlcnZpY2UiLCJNZXNzYWdlIiwiUmVhZGVyIiwiV3JpdGVyIiwidXRpbCIsImVuY29kZXIiLCJkZWNvZGVyIiwidmVyaWZpZXIiLCJjb252ZXJ0ZXIiLCJ3cmFwcGVycyIsIm5hbWUiLCJvcHRpb25zIiwiY2FsbCIsImZpZWxkcyIsIm9uZW9mcyIsInVuZGVmaW5lZCIsImV4dGVuc2lvbnMiLCJyZXNlcnZlZCIsImdyb3VwIiwiX2ZpZWxkc0J5SWQiLCJfZmllbGRzQXJyYXkiLCJfb25lb2ZzQXJyYXkiLCJfY3RvciIsImRlZmluZVByb3BlcnRpZXMiLCJmaWVsZHNCeUlkIiwiZ2V0IiwibmFtZXMiLCJrZXlzIiwiaSIsImxlbmd0aCIsImZpZWxkIiwiaWQiLCJFcnJvciIsImZpZWxkc0FycmF5IiwidG9BcnJheSIsIm9uZW9mc0FycmF5IiwiY3RvciIsImdlbmVyYXRlQ29uc3RydWN0b3IiLCJzZXQiLCJtZXJnZSIsIiR0eXBlIiwicmVzb2x2ZSIsImN0b3JQcm9wZXJ0aWVzIiwib25lT2ZHZXR0ZXIiLCJvbmVvZiIsIm9uZU9mU2V0dGVyIiwibXR5cGUiLCJnZW4iLCJjb2RlZ2VuIiwibWFwIiwic2FmZVByb3AiLCJyZXBlYXRlZCIsImNsZWFyQ2FjaGUiLCJ0eXBlIiwiZW5jb2RlIiwiZGVjb2RlIiwidmVyaWZ5IiwiZnJvbUpTT04iLCJqc29uIiwiYWRkIiwia2V5VHlwZSIsIm5lc3RlZCIsInZhbHVlcyIsIm1ldGhvZHMiLCJjb21tZW50IiwiZWRpdGlvbiIsIl9lZGl0aW9uIiwiX2RlZmF1bHRFZGl0aW9uIiwidG9KU09OIiwidG9KU09OT3B0aW9ucyIsImluaGVyaXRlZCIsImtlZXBDb21tZW50cyIsIkJvb2xlYW4iLCJ0b09iamVjdCIsIl9lZGl0aW9uVG9KU09OIiwiYXJyYXlUb0pTT04iLCJmaWx0ZXIiLCJvYmoiLCJkZWNsYXJpbmdGaWVsZCIsInJlc29sdmVBbGwiLCJfbmVlZHNSZWN1cnNpdmVSZXNvbHZlIiwiX3Jlc29sdmVGZWF0dXJlc1JlY3Vyc2l2ZSIsIl9uZWVkc1JlY3Vyc2l2ZUZlYXR1cmVSZXNvbHV0aW9uIiwiZm9yRWFjaCIsIl9yZXNvbHZlRmVhdHVyZXMiLCJvYmplY3QiLCJleHRlbmQiLCJpc1Jlc2VydmVkSWQiLCJpc1Jlc2VydmVkTmFtZSIsInBhcmVudCIsInJlbW92ZSIsIm1lc3NhZ2UiLCJvbkFkZCIsIm9uUmVtb3ZlIiwicHJvcGVydGllcyIsInNldHVwIiwiZnVsbE5hbWUiLCJ0eXBlcyIsInB1c2giLCJyZXNvbHZlZFR5cGUiLCJmcm9tT2JqZWN0Iiwid3JhcHBlciIsIm9yaWdpbmFsVGhpcyIsImJpbmQiLCJlbmNvZGVfc2V0dXAiLCJ3cml0ZXIiLCJlbmNvZGVEZWxpbWl0ZWQiLCJsZW4iLCJmb3JrIiwibGRlbGltIiwiZGVjb2RlX3NldHVwIiwicmVhZGVyIiwiZGVjb2RlRGVsaW1pdGVkIiwidWludDMyIiwidmVyaWZ5X3NldHVwIiwiZCIsImRlY29yYXRlVHlwZSIsInR5cGVOYW1lIiwidHlwZURlY29yYXRvciIsInRhcmdldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Common type constants.\n * @namespace\n */ var types = exports;\nvar util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\nvar s = [\n    \"double\",\n    \"float\",\n    \"int32\",\n    \"uint32\",\n    \"sint32\",\n    \"fixed32\",\n    \"sfixed32\",\n    \"int64\",\n    \"uint64\",\n    \"sint64\",\n    \"fixed64\",\n    \"sfixed64\",\n    \"bool\",\n    \"string\",\n    \"bytes\" // 14\n];\nfunction bake(values, offset) {\n    var i = 0, o = {};\n    offset |= 0;\n    while(i < values.length)o[s[i + offset]] = values[i++];\n    return o;\n}\n/**\n * Basic type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n * @property {number} bytes=2 Ldelim wire type\n */ types.basic = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2,\n    /* bytes    */ 2\n]);\n/**\n * Basic type defaults.\n * @type {Object.<string,*>}\n * @const\n * @property {number} double=0 Double default\n * @property {number} float=0 Float default\n * @property {number} int32=0 Int32 default\n * @property {number} uint32=0 Uint32 default\n * @property {number} sint32=0 Sint32 default\n * @property {number} fixed32=0 Fixed32 default\n * @property {number} sfixed32=0 Sfixed32 default\n * @property {number} int64=0 Int64 default\n * @property {number} uint64=0 Uint64 default\n * @property {number} sint64=0 Sint32 default\n * @property {number} fixed64=0 Fixed64 default\n * @property {number} sfixed64=0 Sfixed64 default\n * @property {boolean} bool=false Bool default\n * @property {string} string=\"\" String default\n * @property {Array.<number>} bytes=Array(0) Bytes default\n * @property {null} message=null Message default\n */ types.defaults = bake([\n    /* double   */ 0,\n    /* float    */ 0,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 0,\n    /* sfixed32 */ 0,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 0,\n    /* sfixed64 */ 0,\n    /* bool     */ false,\n    /* string   */ \"\",\n    /* bytes    */ util.emptyArray,\n    /* message  */ null\n]);\n/**\n * Basic long type wire types.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n */ types.long = bake([\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1\n], 7);\n/**\n * Allowed types for map keys with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n * @property {number} string=2 Ldelim wire type\n */ types.mapKey = bake([\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0,\n    /* string   */ 2\n], 2);\n/**\n * Allowed types for packed repeated fields with their associated wire type.\n * @type {Object.<string,number>}\n * @const\n * @property {number} double=1 Fixed64 wire type\n * @property {number} float=5 Fixed32 wire type\n * @property {number} int32=0 Varint wire type\n * @property {number} uint32=0 Varint wire type\n * @property {number} sint32=0 Varint wire type\n * @property {number} fixed32=5 Fixed32 wire type\n * @property {number} sfixed32=5 Fixed32 wire type\n * @property {number} int64=0 Varint wire type\n * @property {number} uint64=0 Varint wire type\n * @property {number} sint64=0 Varint wire type\n * @property {number} fixed64=1 Fixed64 wire type\n * @property {number} sfixed64=1 Fixed64 wire type\n * @property {number} bool=0 Varint wire type\n */ types.packed = bake([\n    /* double   */ 1,\n    /* float    */ 5,\n    /* int32    */ 0,\n    /* uint32   */ 0,\n    /* sint32   */ 0,\n    /* fixed32  */ 5,\n    /* sfixed32 */ 5,\n    /* int64    */ 0,\n    /* uint64   */ 0,\n    /* sint64   */ 0,\n    /* fixed64  */ 1,\n    /* sfixed64 */ 1,\n    /* bool     */ 0\n]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYjs7O0NBR0MsR0FDRCxJQUFJQSxRQUFRQztBQUVaLElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDLHNGQUFRO0FBRTNCLElBQUlDLElBQUk7SUFDSjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsUUFBWSxLQUFLO0NBQ3BCO0FBRUQsU0FBU0MsS0FBS0MsTUFBTSxFQUFFQyxNQUFNO0lBQ3hCLElBQUlDLElBQUksR0FBR0MsSUFBSSxDQUFDO0lBQ2hCRixVQUFVO0lBQ1YsTUFBT0MsSUFBSUYsT0FBT0ksTUFBTSxDQUFFRCxDQUFDLENBQUNMLENBQUMsQ0FBQ0ksSUFBSUQsT0FBTyxDQUFDLEdBQUdELE1BQU0sQ0FBQ0UsSUFBSTtJQUN4RCxPQUFPQztBQUNYO0FBRUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FtQkMsR0FDRFQsTUFBTVcsS0FBSyxHQUFHTixLQUFLO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0NBQ2xCO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBb0JDLEdBQ0RMLE1BQU1ZLFFBQVEsR0FBR1AsS0FBSztJQUNsQixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUc7SUFDZixZQUFZLEdBQUdILEtBQUtXLFVBQVU7SUFDOUIsWUFBWSxHQUFHO0NBQ2xCO0FBRUQ7Ozs7Ozs7OztDQVNDLEdBQ0RiLE1BQU1jLElBQUksR0FBR1QsS0FBSztJQUNkLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztDQUNsQixFQUFFO0FBRUg7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDREwsTUFBTWUsTUFBTSxHQUFHVixLQUFLO0lBQ2hCLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztJQUNmLFlBQVksR0FBRztDQUNsQixFQUFFO0FBRUg7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBaUJDLEdBQ0RMLE1BQU1nQixNQUFNLEdBQUdYLEtBQUs7SUFDaEIsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0lBQ2YsWUFBWSxHQUFHO0NBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3R5cGVzLmpzP2JjZWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29tbW9uIHR5cGUgY29uc3RhbnRzLlxuICogQG5hbWVzcGFjZVxuICovXG52YXIgdHlwZXMgPSBleHBvcnRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBzID0gW1xuICAgIFwiZG91YmxlXCIsICAgLy8gMFxuICAgIFwiZmxvYXRcIiwgICAgLy8gMVxuICAgIFwiaW50MzJcIiwgICAgLy8gMlxuICAgIFwidWludDMyXCIsICAgLy8gM1xuICAgIFwic2ludDMyXCIsICAgLy8gNFxuICAgIFwiZml4ZWQzMlwiLCAgLy8gNVxuICAgIFwic2ZpeGVkMzJcIiwgLy8gNlxuICAgIFwiaW50NjRcIiwgICAgLy8gN1xuICAgIFwidWludDY0XCIsICAgLy8gOFxuICAgIFwic2ludDY0XCIsICAgLy8gOVxuICAgIFwiZml4ZWQ2NFwiLCAgLy8gMTBcbiAgICBcInNmaXhlZDY0XCIsIC8vIDExXG4gICAgXCJib29sXCIsICAgICAvLyAxMlxuICAgIFwic3RyaW5nXCIsICAgLy8gMTNcbiAgICBcImJ5dGVzXCIgICAgIC8vIDE0XG5dO1xuXG5mdW5jdGlvbiBiYWtlKHZhbHVlcywgb2Zmc2V0KSB7XG4gICAgdmFyIGkgPSAwLCBvID0ge307XG4gICAgb2Zmc2V0IHw9IDA7XG4gICAgd2hpbGUgKGkgPCB2YWx1ZXMubGVuZ3RoKSBvW3NbaSArIG9mZnNldF1dID0gdmFsdWVzW2krK107XG4gICAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogQmFzaWMgdHlwZSB3aXJlIHR5cGVzLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHN0cmluZz0yIExkZWxpbSB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBieXRlcz0yIExkZWxpbSB3aXJlIHR5cGVcbiAqL1xudHlwZXMuYmFzaWMgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAxLFxuICAgIC8qIGZsb2F0ICAgICovIDUsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcbiAgICAvKiBzZml4ZWQzMiAqLyA1LFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcbiAgICAvKiBib29sICAgICAqLyAwLFxuICAgIC8qIHN0cmluZyAgICovIDIsXG4gICAgLyogYnl0ZXMgICAgKi8gMlxuXSk7XG5cbi8qKlxuICogQmFzaWMgdHlwZSBkZWZhdWx0cy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywqPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRvdWJsZT0wIERvdWJsZSBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZmxvYXQ9MCBGbG9hdCBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50MzI9MCBJbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDMyPTAgVWludDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBTaW50MzIgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9MCBGaXhlZDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQzMj0wIFNmaXhlZDMyIGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIEludDY0IGRlZmF1bHRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBVaW50NjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFNpbnQzMiBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0wIEZpeGVkNjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTAgU2ZpeGVkNjQgZGVmYXVsdFxuICogQHByb3BlcnR5IHtib29sZWFufSBib29sPWZhbHNlIEJvb2wgZGVmYXVsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IHN0cmluZz1cIlwiIFN0cmluZyBkZWZhdWx0XG4gKiBAcHJvcGVydHkge0FycmF5LjxudW1iZXI+fSBieXRlcz1BcnJheSgwKSBCeXRlcyBkZWZhdWx0XG4gKiBAcHJvcGVydHkge251bGx9IG1lc3NhZ2U9bnVsbCBNZXNzYWdlIGRlZmF1bHRcbiAqL1xudHlwZXMuZGVmYXVsdHMgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAwLFxuICAgIC8qIGZsb2F0ICAgICovIDAsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gMCxcbiAgICAvKiBzZml4ZWQzMiAqLyAwLFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDAsXG4gICAgLyogc2ZpeGVkNjQgKi8gMCxcbiAgICAvKiBib29sICAgICAqLyBmYWxzZSxcbiAgICAvKiBzdHJpbmcgICAqLyBcIlwiLFxuICAgIC8qIGJ5dGVzICAgICovIHV0aWwuZW1wdHlBcnJheSxcbiAgICAvKiBtZXNzYWdlICAqLyBudWxsXG5dKTtcblxuLyoqXG4gKiBCYXNpYyBsb25nIHR5cGUgd2lyZSB0eXBlcy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxudW1iZXI+fVxuICogQGNvbnN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdWludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKi9cbnR5cGVzLmxvbmcgPSBiYWtlKFtcbiAgICAvKiBpbnQ2NCAgICAqLyAwLFxuICAgIC8qIHVpbnQ2NCAgICovIDAsXG4gICAgLyogc2ludDY0ICAgKi8gMCxcbiAgICAvKiBmaXhlZDY0ICAqLyAxLFxuICAgIC8qIHNmaXhlZDY0ICovIDFcbl0sIDcpO1xuXG4vKipcbiAqIEFsbG93ZWQgdHlwZXMgZm9yIG1hcCBrZXlzIHdpdGggdGhlaXIgYXNzb2NpYXRlZCB3aXJlIHR5cGUuXG4gKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsbnVtYmVyPn1cbiAqIEBjb25zdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQzMj01IEZpeGVkMzIgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHVpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gZml4ZWQ2ND0xIEZpeGVkNjQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJvb2w9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc3RyaW5nPTIgTGRlbGltIHdpcmUgdHlwZVxuICovXG50eXBlcy5tYXBLZXkgPSBiYWtlKFtcbiAgICAvKiBpbnQzMiAgICAqLyAwLFxuICAgIC8qIHVpbnQzMiAgICovIDAsXG4gICAgLyogc2ludDMyICAgKi8gMCxcbiAgICAvKiBmaXhlZDMyICAqLyA1LFxuICAgIC8qIHNmaXhlZDMyICovIDUsXG4gICAgLyogaW50NjQgICAgKi8gMCxcbiAgICAvKiB1aW50NjQgICAqLyAwLFxuICAgIC8qIHNpbnQ2NCAgICovIDAsXG4gICAgLyogZml4ZWQ2NCAgKi8gMSxcbiAgICAvKiBzZml4ZWQ2NCAqLyAxLFxuICAgIC8qIGJvb2wgICAgICovIDAsXG4gICAgLyogc3RyaW5nICAgKi8gMlxuXSwgMik7XG5cbi8qKlxuICogQWxsb3dlZCB0eXBlcyBmb3IgcGFja2VkIHJlcGVhdGVkIGZpZWxkcyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd2lyZSB0eXBlLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLG51bWJlcj59XG4gKiBAY29uc3RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkb3VibGU9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZsb2F0PTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQzMj0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50MzI9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDMyPTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkMzI9NSBGaXhlZDMyIHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDMyPTUgRml4ZWQzMiB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnQ2ND0wIFZhcmludCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1aW50NjQ9MCBWYXJpbnQgd2lyZSB0eXBlXG4gKiBAcHJvcGVydHkge251bWJlcn0gc2ludDY0PTAgVmFyaW50IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IGZpeGVkNjQ9MSBGaXhlZDY0IHdpcmUgdHlwZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNmaXhlZDY0PTEgRml4ZWQ2NCB3aXJlIHR5cGVcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBib29sPTAgVmFyaW50IHdpcmUgdHlwZVxuICovXG50eXBlcy5wYWNrZWQgPSBiYWtlKFtcbiAgICAvKiBkb3VibGUgICAqLyAxLFxuICAgIC8qIGZsb2F0ICAgICovIDUsXG4gICAgLyogaW50MzIgICAgKi8gMCxcbiAgICAvKiB1aW50MzIgICAqLyAwLFxuICAgIC8qIHNpbnQzMiAgICovIDAsXG4gICAgLyogZml4ZWQzMiAgKi8gNSxcbiAgICAvKiBzZml4ZWQzMiAqLyA1LFxuICAgIC8qIGludDY0ICAgICovIDAsXG4gICAgLyogdWludDY0ICAgKi8gMCxcbiAgICAvKiBzaW50NjQgICAqLyAwLFxuICAgIC8qIGZpeGVkNjQgICovIDEsXG4gICAgLyogc2ZpeGVkNjQgKi8gMSxcbiAgICAvKiBib29sICAgICAqLyAwXG5dKTtcbiJdLCJuYW1lcyI6WyJ0eXBlcyIsImV4cG9ydHMiLCJ1dGlsIiwicmVxdWlyZSIsInMiLCJiYWtlIiwidmFsdWVzIiwib2Zmc2V0IiwiaSIsIm8iLCJsZW5ndGgiLCJiYXNpYyIsImRlZmF1bHRzIiwiZW1wdHlBcnJheSIsImxvbmciLCJtYXBLZXkiLCJwYWNrZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/types.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js":
/*!************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n/**\n * Various utility functions.\n * @namespace\n */ var util = module.exports = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\nvar roots = __webpack_require__(/*! ./roots */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/roots.js\");\nvar Type, Enum;\nutil.codegen = __webpack_require__(/*! @protobufjs/codegen */ \"(ssr)/./node_modules/@protobufjs/codegen/index.js\");\nutil.fetch = __webpack_require__(/*! @protobufjs/fetch */ \"(ssr)/./node_modules/@protobufjs/fetch/index.js\");\nutil.path = __webpack_require__(/*! @protobufjs/path */ \"(ssr)/./node_modules/@protobufjs/path/index.js\");\n/**\n * Node's fs module if available.\n * @type {Object.<string,*>}\n */ util.fs = util.inquire(\"fs\");\n/**\n * Converts an object's values to an array.\n * @param {Object.<string,*>} object Object to convert\n * @returns {Array.<*>} Converted array\n */ util.toArray = function toArray(object) {\n    if (object) {\n        var keys = Object.keys(object), array = new Array(keys.length), index = 0;\n        while(index < keys.length)array[index] = object[keys[index++]];\n        return array;\n    }\n    return [];\n};\n/**\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\n * @param {Array.<*>} array Array to convert\n * @returns {Object.<string,*>} Converted object\n */ util.toObject = function toObject(array) {\n    var object = {}, index = 0;\n    while(index < array.length){\n        var key = array[index++], val = array[index++];\n        if (val !== undefined) object[key] = val;\n    }\n    return object;\n};\nvar safePropBackslashRe = /\\\\/g, safePropQuoteRe = /\"/g;\n/**\n * Tests whether the specified name is a reserved word in JS.\n * @param {string} name Name to test\n * @returns {boolean} `true` if reserved, otherwise `false`\n */ util.isReserved = function isReserved(name) {\n    return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n/**\n * Returns a safe property accessor for the specified property name.\n * @param {string} prop Property name\n * @returns {string} Safe accessor\n */ util.safeProp = function safeProp(prop) {\n    if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop)) return '[\"' + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, '\\\\\"') + '\"]';\n    return \".\" + prop;\n};\n/**\n * Converts the first character of a string to upper case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.ucFirst = function ucFirst(str) {\n    return str.charAt(0).toUpperCase() + str.substring(1);\n};\nvar camelCaseRe = /_([a-z])/g;\n/**\n * Converts a string to camel case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.camelCase = function camelCase(str) {\n    return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {\n        return $1.toUpperCase();\n    });\n};\n/**\n * Compares reflected fields by id.\n * @param {Field} a First field\n * @param {Field} b Second field\n * @returns {number} Comparison value\n */ util.compareFieldsById = function compareFieldsById(a, b) {\n    return a.id - b.id;\n};\n/**\n * Decorator helper for types (TypeScript).\n * @param {Constructor<T>} ctor Constructor function\n * @param {string} [typeName] Type name, defaults to the constructor's name\n * @returns {Type} Reflected type\n * @template T extends Message<T>\n * @property {Root} root Decorators root\n */ util.decorateType = function decorateType(ctor, typeName) {\n    /* istanbul ignore if */ if (ctor.$type) {\n        if (typeName && ctor.$type.name !== typeName) {\n            util.decorateRoot.remove(ctor.$type);\n            ctor.$type.name = typeName;\n            util.decorateRoot.add(ctor.$type);\n        }\n        return ctor.$type;\n    }\n    /* istanbul ignore next */ if (!Type) Type = __webpack_require__(/*! ./type */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/type.js\");\n    var type = new Type(typeName || ctor.name);\n    util.decorateRoot.add(type);\n    type.ctor = ctor; // sets up .encode, .decode etc.\n    Object.defineProperty(ctor, \"$type\", {\n        value: type,\n        enumerable: false\n    });\n    Object.defineProperty(ctor.prototype, \"$type\", {\n        value: type,\n        enumerable: false\n    });\n    return type;\n};\nvar decorateEnumIndex = 0;\n/**\n * Decorator helper for enums (TypeScript).\n * @param {Object} object Enum object\n * @returns {Enum} Reflected enum\n */ util.decorateEnum = function decorateEnum(object) {\n    /* istanbul ignore if */ if (object.$type) return object.$type;\n    /* istanbul ignore next */ if (!Enum) Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\");\n    var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n    util.decorateRoot.add(enm);\n    Object.defineProperty(object, \"$type\", {\n        value: enm,\n        enumerable: false\n    });\n    return enm;\n};\n/**\n * Sets the value of a property by property path. If a value already exists, it is turned to an array\n * @param {Object.<string,*>} dst Destination object\n * @param {string} path dot '.' delimited path of the property to set\n * @param {Object} value the value to set\n * @param {boolean|undefined} [ifNotSet] Sets the option only if it isn't currently set\n * @returns {Object.<string,*>} Destination object\n */ util.setProperty = function setProperty(dst, path, value, ifNotSet) {\n    function setProp(dst, path, value) {\n        var part = path.shift();\n        if (part === \"__proto__\" || part === \"prototype\") {\n            return dst;\n        }\n        if (path.length > 0) {\n            dst[part] = setProp(dst[part] || {}, path, value);\n        } else {\n            var prevValue = dst[part];\n            if (prevValue && ifNotSet) return dst;\n            if (prevValue) value = [].concat(prevValue).concat(value);\n            dst[part] = value;\n        }\n        return dst;\n    }\n    if (typeof dst !== \"object\") throw TypeError(\"dst must be an object\");\n    if (!path) throw TypeError(\"path must be specified\");\n    path = path.split(\".\");\n    return setProp(dst, path, value);\n};\n/**\n * Decorator root (TypeScript).\n * @name util.decorateRoot\n * @type {Root}\n * @readonly\n */ Object.defineProperty(util, \"decorateRoot\", {\n    get: function() {\n        return roots[\"decorated\"] || (roots[\"decorated\"] = new (__webpack_require__(/*! ./root */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/root.js\"))());\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViOzs7Q0FHQyxHQUNELElBQUlBLE9BQU9DLDRJQUEwQztBQUVyRCxJQUFJRyxRQUFRRCxtQkFBT0EsQ0FBQyx3RkFBUztBQUU3QixJQUFJRSxNQUNBQztBQUVKTixLQUFLTyxPQUFPLEdBQUdKLG1CQUFPQSxDQUFDLDhFQUFxQjtBQUM1Q0gsS0FBS1EsS0FBSyxHQUFLTCxtQkFBT0EsQ0FBQywwRUFBbUI7QUFDMUNILEtBQUtTLElBQUksR0FBTU4sbUJBQU9BLENBQUMsd0VBQWtCO0FBRXpDOzs7Q0FHQyxHQUNESCxLQUFLVSxFQUFFLEdBQUdWLEtBQUtXLE9BQU8sQ0FBQztBQUV2Qjs7OztDQUlDLEdBQ0RYLEtBQUtZLE9BQU8sR0FBRyxTQUFTQSxRQUFRQyxNQUFNO0lBQ2xDLElBQUlBLFFBQVE7UUFDUixJQUFJQyxPQUFRQyxPQUFPRCxJQUFJLENBQUNELFNBQ3BCRyxRQUFRLElBQUlDLE1BQU1ILEtBQUtJLE1BQU0sR0FDN0JDLFFBQVE7UUFDWixNQUFPQSxRQUFRTCxLQUFLSSxNQUFNLENBQ3RCRixLQUFLLENBQUNHLE1BQU0sR0FBR04sTUFBTSxDQUFDQyxJQUFJLENBQUNLLFFBQVEsQ0FBQztRQUN4QyxPQUFPSDtJQUNYO0lBQ0EsT0FBTyxFQUFFO0FBQ2I7QUFFQTs7OztDQUlDLEdBQ0RoQixLQUFLb0IsUUFBUSxHQUFHLFNBQVNBLFNBQVNKLEtBQUs7SUFDbkMsSUFBSUgsU0FBUyxDQUFDLEdBQ1ZNLFFBQVM7SUFDYixNQUFPQSxRQUFRSCxNQUFNRSxNQUFNLENBQUU7UUFDekIsSUFBSUcsTUFBTUwsS0FBSyxDQUFDRyxRQUFRLEVBQ3BCRyxNQUFNTixLQUFLLENBQUNHLFFBQVE7UUFDeEIsSUFBSUcsUUFBUUMsV0FDUlYsTUFBTSxDQUFDUSxJQUFJLEdBQUdDO0lBQ3RCO0lBQ0EsT0FB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L25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsLmpzP2Y0MWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIHJvb3RzID0gcmVxdWlyZShcIi4vcm9vdHNcIik7XG5cbnZhciBUeXBlLCAvLyBjeWNsaWNcbiAgICBFbnVtO1xuXG51dGlsLmNvZGVnZW4gPSByZXF1aXJlKFwiQHByb3RvYnVmanMvY29kZWdlblwiKTtcbnV0aWwuZmV0Y2ggICA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mZXRjaFwiKTtcbnV0aWwucGF0aCAgICA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wYXRoXCIpO1xuXG4vKipcbiAqIE5vZGUncyBmcyBtb2R1bGUgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge09iamVjdC48c3RyaW5nLCo+fVxuICovXG51dGlsLmZzID0gdXRpbC5pbnF1aXJlKFwiZnNcIik7XG5cbi8qKlxuICogQ29udmVydHMgYW4gb2JqZWN0J3MgdmFsdWVzIHRvIGFuIGFycmF5LlxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IE9iamVjdCB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7QXJyYXkuPCo+fSBDb252ZXJ0ZWQgYXJyYXlcbiAqL1xudXRpbC50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheShvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIHZhciBrZXlzICA9IE9iamVjdC5rZXlzKG9iamVjdCksXG4gICAgICAgICAgICBhcnJheSA9IG5ldyBBcnJheShrZXlzLmxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGtleXMubGVuZ3RoKVxuICAgICAgICAgICAgYXJyYXlbaW5kZXhdID0gb2JqZWN0W2tleXNbaW5kZXgrK11dO1xuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYW4gYXJyYXkgb2Yga2V5cyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGVpciByZXNwZWN0aXZlIHZhbHVlIHRvIGFuIG9iamVjdCwgb21pdHRpbmcgdW5kZWZpbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXkuPCo+fSBhcnJheSBBcnJheSB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IENvbnZlcnRlZCBvYmplY3RcbiAqL1xudXRpbC50b09iamVjdCA9IGZ1bmN0aW9uIHRvT2JqZWN0KGFycmF5KSB7XG4gICAgdmFyIG9iamVjdCA9IHt9LFxuICAgICAgICBpbmRleCAgPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGFycmF5Lmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0gYXJyYXlbaW5kZXgrK10sXG4gICAgICAgICAgICB2YWwgPSBhcnJheVtpbmRleCsrXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59O1xuXG52YXIgc2FmZVByb3BCYWNrc2xhc2hSZSA9IC9cXFxcL2csXG4gICAgc2FmZVByb3BRdW90ZVJlICAgICA9IC9cIi9nO1xuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBuYW1lIGlzIGEgcmVzZXJ2ZWQgd29yZCBpbiBKUy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiByZXNlcnZlZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc1Jlc2VydmVkID0gZnVuY3Rpb24gaXNSZXNlcnZlZChuYW1lKSB7XG4gICAgcmV0dXJuIC9eKD86ZG98aWZ8aW58Zm9yfGxldHxuZXd8dHJ5fHZhcnxjYXNlfGVsc2V8ZW51bXxldmFsfGZhbHNlfG51bGx8dGhpc3x0cnVlfHZvaWR8d2l0aHxicmVha3xjYXRjaHxjbGFzc3xjb25zdHxzdXBlcnx0aHJvd3x3aGlsZXx5aWVsZHxkZWxldGV8ZXhwb3J0fGltcG9ydHxwdWJsaWN8cmV0dXJufHN0YXRpY3xzd2l0Y2h8dHlwZW9mfGRlZmF1bHR8ZXh0ZW5kc3xmaW5hbGx5fHBhY2thZ2V8cHJpdmF0ZXxjb250aW51ZXxkZWJ1Z2dlcnxmdW5jdGlvbnxhcmd1bWVudHN8aW50ZXJmYWNlfHByb3RlY3RlZHxpbXBsZW1lbnRzfGluc3RhbmNlb2YpJC8udGVzdChuYW1lKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHNhZmUgcHJvcGVydHkgYWNjZXNzb3IgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFNhZmUgYWNjZXNzb3JcbiAqL1xudXRpbC5zYWZlUHJvcCA9IGZ1bmN0aW9uIHNhZmVQcm9wKHByb3ApIHtcbiAgICBpZiAoIS9eWyRcXHdfXSskLy50ZXN0KHByb3ApIHx8IHV0aWwuaXNSZXNlcnZlZChwcm9wKSlcbiAgICAgICAgcmV0dXJuIFwiW1xcXCJcIiArIHByb3AucmVwbGFjZShzYWZlUHJvcEJhY2tzbGFzaFJlLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2Uoc2FmZVByb3BRdW90ZVJlLCBcIlxcXFxcXFwiXCIpICsgXCJcXFwiXVwiO1xuICAgIHJldHVybiBcIi5cIiArIHByb3A7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBzdHJpbmcgdG8gdXBwZXIgY2FzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgU3RyaW5nIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbnZlcnRlZCBzdHJpbmdcbiAqL1xudXRpbC51Y0ZpcnN0ID0gZnVuY3Rpb24gdWNGaXJzdChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbnZhciBjYW1lbENhc2VSZSA9IC9fKFthLXpdKS9nO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGNhbWVsIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwuY2FtZWxDYXNlID0gZnVuY3Rpb24gY2FtZWxDYXNlKHN0cikge1xuICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKDAsIDEpXG4gICAgICAgICArIHN0ci5zdWJzdHJpbmcoMSlcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKGNhbWVsQ2FzZVJlLCBmdW5jdGlvbigkMCwgJDEpIHsgcmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7IH0pO1xufTtcblxuLyoqXG4gKiBDb21wYXJlcyByZWZsZWN0ZWQgZmllbGRzIGJ5IGlkLlxuICogQHBhcmFtIHtGaWVsZH0gYSBGaXJzdCBmaWVsZFxuICogQHBhcmFtIHtGaWVsZH0gYiBTZWNvbmQgZmllbGRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IENvbXBhcmlzb24gdmFsdWVcbiAqL1xudXRpbC5jb21wYXJlRmllbGRzQnlJZCA9IGZ1bmN0aW9uIGNvbXBhcmVGaWVsZHNCeUlkKGEsIGIpIHtcbiAgICByZXR1cm4gYS5pZCAtIGIuaWQ7XG59O1xuXG4vKipcbiAqIERlY29yYXRvciBoZWxwZXIgZm9yIHR5cGVzIChUeXBlU2NyaXB0KS5cbiAqIEBwYXJhbSB7Q29uc3RydWN0b3I8VD59IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHlwZU5hbWVdIFR5cGUgbmFtZSwgZGVmYXVsdHMgdG8gdGhlIGNvbnN0cnVjdG9yJ3MgbmFtZVxuICogQHJldHVybnMge1R5cGV9IFJlZmxlY3RlZCB0eXBlXG4gKiBAdGVtcGxhdGUgVCBleHRlbmRzIE1lc3NhZ2U8VD5cbiAqIEBwcm9wZXJ0eSB7Um9vdH0gcm9vdCBEZWNvcmF0b3JzIHJvb3RcbiAqL1xudXRpbC5kZWNvcmF0ZVR5cGUgPSBmdW5jdGlvbiBkZWNvcmF0ZVR5cGUoY3RvciwgdHlwZU5hbWUpIHtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChjdG9yLiR0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlTmFtZSAmJiBjdG9yLiR0eXBlLm5hbWUgIT09IHR5cGVOYW1lKSB7XG4gICAgICAgICAgICB1dGlsLmRlY29yYXRlUm9vdC5yZW1vdmUoY3Rvci4kdHlwZSk7XG4gICAgICAgICAgICBjdG9yLiR0eXBlLm5hbWUgPSB0eXBlTmFtZTtcbiAgICAgICAgICAgIHV0aWwuZGVjb3JhdGVSb290LmFkZChjdG9yLiR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3Rvci4kdHlwZTtcbiAgICB9XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIGlmICghVHlwZSlcbiAgICAgICAgVHlwZSA9IHJlcXVpcmUoXCIuL3R5cGVcIik7XG5cbiAgICB2YXIgdHlwZSA9IG5ldyBUeXBlKHR5cGVOYW1lIHx8IGN0b3IubmFtZSk7XG4gICAgdXRpbC5kZWNvcmF0ZVJvb3QuYWRkKHR5cGUpO1xuICAgIHR5cGUuY3RvciA9IGN0b3I7IC8vIHNldHMgdXAgLmVuY29kZSwgLmRlY29kZSBldGMuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IsIFwiJHR5cGVcIiwgeyB2YWx1ZTogdHlwZSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0b3IucHJvdG90eXBlLCBcIiR0eXBlXCIsIHsgdmFsdWU6IHR5cGUsIGVudW1lcmFibGU6IGZhbHNlIH0pO1xuICAgIHJldHVybiB0eXBlO1xufTtcblxudmFyIGRlY29yYXRlRW51bUluZGV4ID0gMDtcblxuLyoqXG4gKiBEZWNvcmF0b3IgaGVscGVyIGZvciBlbnVtcyAoVHlwZVNjcmlwdCkuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IEVudW0gb2JqZWN0XG4gKiBAcmV0dXJucyB7RW51bX0gUmVmbGVjdGVkIGVudW1cbiAqL1xudXRpbC5kZWNvcmF0ZUVudW0gPSBmdW5jdGlvbiBkZWNvcmF0ZUVudW0ob2JqZWN0KSB7XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAob2JqZWN0LiR0eXBlKVxuICAgICAgICByZXR1cm4gb2JqZWN0LiR0eXBlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAoIUVudW0pXG4gICAgICAgIEVudW0gPSByZXF1aXJlKFwiLi9lbnVtXCIpO1xuXG4gICAgdmFyIGVubSA9IG5ldyBFbnVtKFwiRW51bVwiICsgZGVjb3JhdGVFbnVtSW5kZXgrKywgb2JqZWN0KTtcbiAgICB1dGlsLmRlY29yYXRlUm9vdC5hZGQoZW5tKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBcIiR0eXBlXCIsIHsgdmFsdWU6IGVubSwgZW51bWVyYWJsZTogZmFsc2UgfSk7XG4gICAgcmV0dXJuIGVubTtcbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGJ5IHByb3BlcnR5IHBhdGguIElmIGEgdmFsdWUgYWxyZWFkeSBleGlzdHMsIGl0IGlzIHR1cm5lZCB0byBhbiBhcnJheVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gZHN0IERlc3RpbmF0aW9uIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggZG90ICcuJyBkZWxpbWl0ZWQgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgdGhlIHZhbHVlIHRvIHNldFxuICogQHBhcmFtIHtib29sZWFufHVuZGVmaW5lZH0gW2lmTm90U2V0XSBTZXRzIHRoZSBvcHRpb24gb25seSBpZiBpdCBpc24ndCBjdXJyZW50bHkgc2V0XG4gKiBAcmV0dXJucyB7T2JqZWN0LjxzdHJpbmcsKj59IERlc3RpbmF0aW9uIG9iamVjdFxuICovXG51dGlsLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gc2V0UHJvcGVydHkoZHN0LCBwYXRoLCB2YWx1ZSwgaWZOb3RTZXQpIHtcbiAgICBmdW5jdGlvbiBzZXRQcm9wKGRzdCwgcGF0aCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHBhcnQgPSBwYXRoLnNoaWZ0KCk7XG4gICAgICAgIGlmIChwYXJ0ID09PSBcIl9fcHJvdG9fX1wiIHx8IHBhcnQgPT09IFwicHJvdG90eXBlXCIpIHtcbiAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGRzdFtwYXJ0XSA9IHNldFByb3AoZHN0W3BhcnRdIHx8IHt9LCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldlZhbHVlID0gZHN0W3BhcnRdO1xuICAgICAgICAgICAgaWYgKHByZXZWYWx1ZSAmJiBpZk5vdFNldClcbiAgICAgICAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICAgICAgaWYgKHByZXZWYWx1ZSlcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdLmNvbmNhdChwcmV2VmFsdWUpLmNvbmNhdCh2YWx1ZSk7XG4gICAgICAgICAgICBkc3RbcGFydF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZHN0ICE9PSBcIm9iamVjdFwiKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJkc3QgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgaWYgKCFwYXRoKVxuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJwYXRoIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuXG4gICAgcGF0aCA9IHBhdGguc3BsaXQoXCIuXCIpO1xuICAgIHJldHVybiBzZXRQcm9wKGRzdCwgcGF0aCwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBEZWNvcmF0b3Igcm9vdCAoVHlwZVNjcmlwdCkuXG4gKiBAbmFtZSB1dGlsLmRlY29yYXRlUm9vdFxuICogQHR5cGUge1Jvb3R9XG4gKiBAcmVhZG9ubHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KHV0aWwsIFwiZGVjb3JhdGVSb290XCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcm9vdHNbXCJkZWNvcmF0ZWRcIl0gfHwgKHJvb3RzW1wiZGVjb3JhdGVkXCJdID0gbmV3IChyZXF1aXJlKFwiLi9yb290XCIpKSgpKTtcbiAgICB9XG59KTtcbiJdLCJuYW1lcyI6WyJ1dGlsIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJyb290cyIsIlR5cGUiLCJFbnVtIiwiY29kZWdlbiIsImZldGNoIiwicGF0aCIsImZzIiwiaW5xdWlyZSIsInRvQXJyYXkiLCJvYmplY3QiLCJrZXlzIiwiT2JqZWN0IiwiYXJyYXkiLCJBcnJheSIsImxlbmd0aCIsImluZGV4IiwidG9PYmplY3QiLCJrZXkiLCJ2YWwiLCJ1bmRlZmluZWQiLCJzYWZlUHJvcEJhY2tzbGFzaFJlIiwic2FmZVByb3BRdW90ZVJlIiwiaXNSZXNlcnZlZCIsIm5hbWUiLCJ0ZXN0Iiwic2FmZVByb3AiLCJwcm9wIiwicmVwbGFjZSIsInVjRmlyc3QiLCJzdHIiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInN1YnN0cmluZyIsImNhbWVsQ2FzZVJlIiwiY2FtZWxDYXNlIiwiJDAiLCIkMSIsImNvbXBhcmVGaWVsZHNCeUlkIiwiYSIsImIiLCJpZCIsImRlY29yYXRlVHlwZSIsImN0b3IiLCJ0eXBlTmFtZSIsIiR0eXBlIiwiZGVjb3JhdGVSb290IiwicmVtb3ZlIiwiYWRkIiwidHlwZSIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJlbnVtZXJhYmxlIiwicHJvdG90eXBlIiwiZGVjb3JhdGVFbnVtSW5kZXgiLCJkZWNvcmF0ZUVudW0iLCJlbm0iLCJzZXRQcm9wZXJ0eSIsImRzdCIsImlmTm90U2V0Iiwic2V0UHJvcCIsInBhcnQiLCJzaGlmdCIsInByZXZWYWx1ZSIsImNvbmNhdCIsIlR5cGVFcnJvciIsInNwbGl0IiwiZ2V0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/longbits.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/longbits.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = LongBits;\nvar util = __webpack_require__(/*! ../util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */ function LongBits(lo, hi) {\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n    /**\n     * Low bits.\n     * @type {number}\n     */ this.lo = lo >>> 0;\n    /**\n     * High bits.\n     * @type {number}\n     */ this.hi = hi >>> 0;\n}\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */ var zero = LongBits.zero = new LongBits(0, 0);\nzero.toNumber = function() {\n    return 0;\n};\nzero.zzEncode = zero.zzDecode = function() {\n    return this;\n};\nzero.length = function() {\n    return 1;\n};\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */ var zeroHash = LongBits.zeroHash = \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */ LongBits.fromNumber = function fromNumber(value) {\n    if (value === 0) return zero;\n    var sign = value < 0;\n    if (sign) value = -value;\n    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295) hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */ LongBits.from = function from(value) {\n    if (typeof value === \"number\") return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */ if (util.Long) value = util.Long.fromString(value);\n        else return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */ LongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;\n        if (!lo) hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */ LongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {\n        low: this.lo | 0,\n        high: this.hi | 0,\n        unsigned: Boolean(unsigned)\n    };\n};\nvar charCodeAt = String.prototype.charCodeAt;\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */ LongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash) return zero;\n    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);\n};\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */ LongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);\n};\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */ LongBits.prototype.zzEncode = function zzEncode() {\n    var mask = this.hi >> 31;\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo = (this.lo << 1 ^ mask) >>> 0;\n    return this;\n};\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */ LongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0;\n    return this;\n};\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */ LongBits.prototype.length = function length() {\n    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;\n    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9sb25nYml0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLElBQUlDLE9BQU9DLG1CQUFPQSxDQUFDLHVHQUFpQjtBQUVwQzs7Ozs7OztDQU9DLEdBQ0QsU0FBU0YsU0FBU0csRUFBRSxFQUFFQyxFQUFFO0lBRXBCLDRGQUE0RjtJQUM1RiwwRkFBMEY7SUFFMUY7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRCxFQUFFLEdBQUdBLE9BQU87SUFFakI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLE9BQU87QUFDckI7QUFFQTs7OztDQUlDLEdBQ0QsSUFBSUMsT0FBT0wsU0FBU0ssSUFBSSxHQUFHLElBQUlMLFNBQVMsR0FBRztBQUUzQ0ssS0FBS0MsUUFBUSxHQUFHO0lBQWEsT0FBTztBQUFHO0FBQ3ZDRCxLQUFLRSxRQUFRLEdBQUdGLEtBQUtHLFFBQVEsR0FBRztJQUFhLE9BQU8sSUFBSTtBQUFFO0FBQzFESCxLQUFLSSxNQUFNLEdBQUc7SUFBYSxPQUFPO0FBQUc7QUFFckM7Ozs7Q0FJQyxHQUNELElBQUlDLFdBQVdWLFNBQVNVLFFBQVEsR0FBRztBQUVuQzs7OztDQUlDLEdBQ0RWLFNBQVNXLFVBQVUsR0FBRyxTQUFTQSxXQUFXQyxLQUFLO0lBQzNDLElBQUlBLFVBQVUsR0FDVixPQUFPUDtJQUNYLElBQUlRLE9BQU9ELFFBQVE7SUFDbkIsSUFBSUMsTUFDQUQsUUFBUSxDQUFDQTtJQUNiLElBQUlULEtBQUtTLFVBQVUsR0FDZlIsS0FBSyxDQUFDUSxRQUFRVCxFQUFDLElBQUssZUFBZTtJQUN2QyxJQUFJVSxNQUFNO1FBQ05ULEtBQUssQ0FBQ0EsT0FBTztRQUNiRCxLQUFLLENBQUNBLE9BQU87UUFDYixJQUFJLEVBQUVBLEtBQUssWUFBWTtZQUNuQkEsS0FBSztZQUNMLElBQUksRUFB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QUksSUFDbEJBLFFBQVEsVUFBVSxJQUFJLElBQzFCQyxRQUFRLE1BQU0sSUFBSTtBQUM3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy91dGlsL2xvbmdiaXRzLmpzPzJmOGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IExvbmdCaXRzO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsL21pbmltYWxcIik7XG5cbi8qKlxuICogQ29uc3RydWN0cyBuZXcgbG9uZyBiaXRzLlxuICogQGNsYXNzZGVzYyBIZWxwZXIgY2xhc3MgZm9yIHdvcmtpbmcgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWUuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbG8gTG93IDMyIGJpdHMsIHVuc2lnbmVkXG4gKiBAcGFyYW0ge251bWJlcn0gaGkgSGlnaCAzMiBiaXRzLCB1bnNpZ25lZFxuICovXG5mdW5jdGlvbiBMb25nQml0cyhsbywgaGkpIHtcblxuICAgIC8vIG5vdGUgdGhhdCB0aGUgY2FzdHMgYmVsb3cgYXJlIHRoZW9yZXRpY2FsbHkgdW5uZWNlc3NhcnkgYXMgb2YgdG9kYXksIGJ1dCBvbGRlciBzdGF0aWNhbGx5XG4gICAgLy8gZ2VuZXJhdGVkIGNvbnZlcnRlciBjb2RlIG1pZ2h0IHN0aWxsIGNhbGwgdGhlIGN0b3Igd2l0aCBzaWduZWQgMzJiaXRzLiBrZXB0IGZvciBjb21wYXQuXG5cbiAgICAvKipcbiAgICAgKiBMb3cgYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubG8gPSBsbyA+Pj4gMDtcblxuICAgIC8qKlxuICAgICAqIEhpZ2ggYml0cy5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaGkgPSBoaSA+Pj4gMDtcbn1cblxuLyoqXG4gKiBaZXJvIGJpdHMuXG4gKiBAbWVtYmVyb2YgdXRpbC5Mb25nQml0c1xuICogQHR5cGUge3V0aWwuTG9uZ0JpdHN9XG4gKi9cbnZhciB6ZXJvID0gTG9uZ0JpdHMuemVybyA9IG5ldyBMb25nQml0cygwLCAwKTtcblxuemVyby50b051bWJlciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbnplcm8uenpFbmNvZGUgPSB6ZXJvLnp6RGVjb2RlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9O1xuemVyby5sZW5ndGggPSBmdW5jdGlvbigpIHsgcmV0dXJuIDE7IH07XG5cbi8qKlxuICogWmVybyBoYXNoLlxuICogQG1lbWJlcm9mIHV0aWwuTG9uZ0JpdHNcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbnZhciB6ZXJvSGFzaCA9IExvbmdCaXRzLnplcm9IYXNoID0gXCJcXDBcXDBcXDBcXDBcXDBcXDBcXDBcXDBcIjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb21OdW1iZXIgPSBmdW5jdGlvbiBmcm9tTnVtYmVyKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSAwKVxuICAgICAgICByZXR1cm4gemVybztcbiAgICB2YXIgc2lnbiA9IHZhbHVlIDwgMDtcbiAgICBpZiAoc2lnbilcbiAgICAgICAgdmFsdWUgPSAtdmFsdWU7XG4gICAgdmFyIGxvID0gdmFsdWUgPj4+IDAsXG4gICAgICAgIGhpID0gKHZhbHVlIC0gbG8pIC8gNDI5NDk2NzI5NiA+Pj4gMDtcbiAgICBpZiAoc2lnbikge1xuICAgICAgICBoaSA9IH5oaSA+Pj4gMDtcbiAgICAgICAgbG8gPSB+bG8gPj4+IDA7XG4gICAgICAgIGlmICgrK2xvID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgbG8gPSAwO1xuICAgICAgICAgICAgaWYgKCsraGkgPiA0Mjk0OTY3Mjk1KVxuICAgICAgICAgICAgICAgIGhpID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IExvbmdCaXRzKGxvLCBoaSk7XG59O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgbmV3IGxvbmcgYml0cyBmcm9tIGEgbnVtYmVyLCBsb25nIG9yIHN0cmluZy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZVxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IEluc3RhbmNlXG4gKi9cbkxvbmdCaXRzLmZyb20gPSBmdW5jdGlvbiBmcm9tKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAodXRpbC5Mb25nKVxuICAgICAgICAgICAgdmFsdWUgPSB1dGlsLkxvbmcuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBMb25nQml0cy5mcm9tTnVtYmVyKHBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUubG93IHx8IHZhbHVlLmhpZ2ggPyBuZXcgTG9uZ0JpdHModmFsdWUubG93ID4+PiAwLCB2YWx1ZS5oaWdoID4+PiAwKSA6IHplcm87XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgcG9zc2libHkgdW5zYWZlIEphdmFTY3JpcHQgbnVtYmVyLlxuICogQHBhcmFtIHtib29sZWFufSBbdW5zaWduZWQ9ZmFsc2VdIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBQb3NzaWJseSB1bnNhZmUgbnVtYmVyXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKHVuc2lnbmVkKSB7XG4gICAgaWYgKCF1bnNpZ25lZCAmJiB0aGlzLmhpID4+PiAzMSkge1xuICAgICAgICB2YXIgbG8gPSB+dGhpcy5sbyArIDEgPj4+IDAsXG4gICAgICAgICAgICBoaSA9IH50aGlzLmhpICAgICA+Pj4gMDtcbiAgICAgICAgaWYgKCFsbylcbiAgICAgICAgICAgIGhpID0gaGkgKyAxID4+PiAwO1xuICAgICAgICByZXR1cm4gLShsbyArIGhpICogNDI5NDk2NzI5Nik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxvICsgdGhpcy5oaSAqIDQyOTQ5NjcyOTY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgbG9uZy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Vuc2lnbmVkPWZhbHNlXSBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICogQHJldHVybnMge0xvbmd9IExvbmdcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvTG9uZyA9IGZ1bmN0aW9uIHRvTG9uZyh1bnNpZ25lZCkge1xuICAgIHJldHVybiB1dGlsLkxvbmdcbiAgICAgICAgPyBuZXcgdXRpbC5Mb25nKHRoaXMubG8gfCAwLCB0aGlzLmhpIHwgMCwgQm9vbGVhbih1bnNpZ25lZCkpXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIDogeyBsb3c6IHRoaXMubG8gfCAwLCBoaWdoOiB0aGlzLmhpIHwgMCwgdW5zaWduZWQ6IEJvb2xlYW4odW5zaWduZWQpIH07XG59O1xuXG52YXIgY2hhckNvZGVBdCA9IFN0cmluZy5wcm90b3R5cGUuY2hhckNvZGVBdDtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIG5ldyBsb25nIGJpdHMgZnJvbSB0aGUgc3BlY2lmaWVkIDggY2hhcmFjdGVycyBsb25nIGhhc2guXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gQml0c1xuICovXG5Mb25nQml0cy5mcm9tSGFzaCA9IGZ1bmN0aW9uIGZyb21IYXNoKGhhc2gpIHtcbiAgICBpZiAoaGFzaCA9PT0gemVyb0hhc2gpXG4gICAgICAgIHJldHVybiB6ZXJvO1xuICAgIHJldHVybiBuZXcgTG9uZ0JpdHMoXG4gICAgICAgICggY2hhckNvZGVBdC5jYWxsKGhhc2gsIDApXG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDEpIDw8IDhcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMikgPDwgMTZcbiAgICAgICAgfCBjaGFyQ29kZUF0LmNhbGwoaGFzaCwgMykgPDwgMjQpID4+PiAwXG4gICAgLFxuICAgICAgICAoIGNoYXJDb2RlQXQuY2FsbChoYXNoLCA0KVxuICAgICAgICB8IGNoYXJDb2RlQXQuY2FsbChoYXNoLCA1KSA8PCA4XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDYpIDw8IDE2XG4gICAgICAgIHwgY2hhckNvZGVBdC5jYWxsKGhhc2gsIDcpIDw8IDI0KSA+Pj4gMFxuICAgICk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgbG9uZyBiaXRzIHRvIGEgOCBjaGFyYWN0ZXJzIGxvbmcgaGFzaC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEhhc2hcbiAqL1xuTG9uZ0JpdHMucHJvdG90eXBlLnRvSGFzaCA9IGZ1bmN0aW9uIHRvSGFzaCgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShcbiAgICAgICAgdGhpcy5sbyAgICAgICAgJiAyNTUsXG4gICAgICAgIHRoaXMubG8gPj4+IDggICYgMjU1LFxuICAgICAgICB0aGlzLmxvID4+PiAxNiAmIDI1NSxcbiAgICAgICAgdGhpcy5sbyA+Pj4gMjQgICAgICAsXG4gICAgICAgIHRoaXMuaGkgICAgICAgICYgMjU1LFxuICAgICAgICB0aGlzLmhpID4+PiA4ICAmIDI1NSxcbiAgICAgICAgdGhpcy5oaSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHRoaXMuaGkgPj4+IDI0XG4gICAgKTtcbn07XG5cbi8qKlxuICogWmlnLXphZyBlbmNvZGVzIHRoaXMgbG9uZyBiaXRzLlxuICogQHJldHVybnMge3V0aWwuTG9uZ0JpdHN9IGB0aGlzYFxuICovXG5Mb25nQml0cy5wcm90b3R5cGUuenpFbmNvZGUgPSBmdW5jdGlvbiB6ekVuY29kZSgpIHtcbiAgICB2YXIgbWFzayA9ICAgdGhpcy5oaSA+PiAzMTtcbiAgICB0aGlzLmhpICA9ICgodGhpcy5oaSA8PCAxIHwgdGhpcy5sbyA+Pj4gMzEpIF4gbWFzaykgPj4+IDA7XG4gICAgdGhpcy5sbyAgPSAoIHRoaXMubG8gPDwgMSAgICAgICAgICAgICAgICAgICBeIG1hc2spID4+PiAwO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBaaWctemFnIGRlY29kZXMgdGhpcyBsb25nIGJpdHMuXG4gKiBAcmV0dXJucyB7dXRpbC5Mb25nQml0c30gYHRoaXNgXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS56ekRlY29kZSA9IGZ1bmN0aW9uIHp6RGVjb2RlKCkge1xuICAgIHZhciBtYXNrID0gLSh0aGlzLmxvICYgMSk7XG4gICAgdGhpcy5sbyAgPSAoKHRoaXMubG8gPj4+IDEgfCB0aGlzLmhpIDw8IDMxKSBeIG1hc2spID4+PiAwO1xuICAgIHRoaXMuaGkgID0gKCB0aGlzLmhpID4+PiAxICAgICAgICAgICAgICAgICAgXiBtYXNrKSA+Pj4gMDtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgbG9uZ2JpdHMgd2hlbiBlbmNvZGVkIGFzIGEgdmFyaW50LlxuICogQHJldHVybnMge251bWJlcn0gTGVuZ3RoXG4gKi9cbkxvbmdCaXRzLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiBsZW5ndGgoKSB7XG4gICAgdmFyIHBhcnQwID0gIHRoaXMubG8sXG4gICAgICAgIHBhcnQxID0gKHRoaXMubG8gPj4+IDI4IHwgdGhpcy5oaSA8PCA0KSA+Pj4gMCxcbiAgICAgICAgcGFydDIgPSAgdGhpcy5oaSA+Pj4gMjQ7XG4gICAgcmV0dXJuIHBhcnQyID09PSAwXG4gICAgICAgICA/IHBhcnQxID09PSAwXG4gICAgICAgICAgID8gcGFydDAgPCAxNjM4NFxuICAgICAgICAgICAgID8gcGFydDAgPCAxMjggPyAxIDogMlxuICAgICAgICAgICAgIDogcGFydDAgPCAyMDk3MTUyID8gMyA6IDRcbiAgICAgICAgICAgOiBwYXJ0MSA8IDE2Mzg0XG4gICAgICAgICAgICAgPyBwYXJ0MSA8IDEyOCA/IDUgOiA2XG4gICAgICAgICAgICAgOiBwYXJ0MSA8IDIwOTcxNTIgPyA3IDogOFxuICAgICAgICAgOiBwYXJ0MiA8IDEyOCA/IDkgOiAxMDtcbn07XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkxvbmdCaXRzIiwidXRpbCIsInJlcXVpcmUiLCJsbyIsImhpIiwiemVybyIsInRvTnVtYmVyIiwienpFbmNvZGUiLCJ6ekRlY29kZSIsImxlbmd0aCIsInplcm9IYXNoIiwiZnJvbU51bWJlciIsInZhbHVlIiwic2lnbiIsImZyb20iLCJpc1N0cmluZyIsIkxvbmciLCJmcm9tU3RyaW5nIiwicGFyc2VJbnQiLCJsb3ciLCJoaWdoIiwicHJvdG90eXBlIiwidW5zaWduZWQiLCJ0b0xvbmciLCJCb29sZWFuIiwiY2hhckNvZGVBdCIsIlN0cmluZyIsImZyb21IYXNoIiwiaGFzaCIsImNhbGwiLCJ0b0hhc2giLCJmcm9tQ2hhckNvZGUiLCJtYXNrIiwicGFydDAiLCJwYXJ0MSIsInBhcnQyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/longbits.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar util = exports;\n// used to return a Promise where callback is omitted\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"(ssr)/./node_modules/@protobufjs/aspromise/index.js\");\n// converts to / from base64 encoded strings\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"(ssr)/./node_modules/@protobufjs/base64/index.js\");\n// base class of rpc.Service\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"(ssr)/./node_modules/@protobufjs/eventemitter/index.js\");\n// float handling accross browsers\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"(ssr)/./node_modules/@protobufjs/float/index.js\");\n// requires modules optionally and hides the call from bundlers\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"(ssr)/./node_modules/@protobufjs/inquire/index.js\");\n// converts to / from utf8 encoded strings\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"(ssr)/./node_modules/@protobufjs/utf8/index.js\");\n// provides a node-like buffer pool in the browser\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"(ssr)/./node_modules/@protobufjs/pool/index.js\");\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/longbits.js\");\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */ util.isNode = Boolean(typeof global !== \"undefined\" && global && global.process && global.process.versions && global.process.versions.node);\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */ util.global = util.isNode && global ||  false && 0 || typeof self !== \"undefined\" && self || this; // eslint-disable-line no-invalid-this\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */ util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */ util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */ util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */ util.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */ util.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */ util.isset = /**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */ util.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */ /**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */ util.Buffer = function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */ return null;\n    }\n}();\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */ util.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */ return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n};\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */ util.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */  : Array;\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */ /**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */ util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long || /* istanbul ignore next */ util.global.Long || util.inquire(\"long\");\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */ util.key2Re = /^true|false|0|1$/;\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */ util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */ util.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */ util.longToHash = function longToHash(value) {\n    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n};\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */ util.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */ function merge(dst, src, ifNotSet) {\n    for(var keys = Object.keys(src), i = 0; i < keys.length; ++i)if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];\n    return dst;\n}\nutil.merge = merge;\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */ util.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */ function newError(name) {\n    function CustomError(message, properties) {\n        if (!(this instanceof CustomError)) return new CustomError(message, properties);\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n        Object.defineProperty(this, \"message\", {\n            get: function() {\n                return message;\n            }\n        });\n        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);\n        else Object.defineProperty(this, \"stack\", {\n            value: new Error().stack || \"\"\n        });\n        if (properties) merge(this, properties);\n    }\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true\n        },\n        name: {\n            get: function get() {\n                return name;\n            },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true\n        },\n        toString: {\n            value: function value() {\n                return this.name + \": \" + this.message;\n            },\n            writable: true,\n            enumerable: false,\n            configurable: true\n        }\n    });\n    return CustomError;\n}\nutil.newError = newError;\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */ util.ProtocolError = newError(\"ProtocolError\");\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */ /**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */ /**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */ util.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for(var i = 0; i < fieldNames.length; ++i)fieldMap[fieldNames[i]] = 1;\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */ return function() {\n        for(var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];\n    };\n};\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */ /**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */ util.oneOfSetter = function setOneOf(fieldNames) {\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */ return function(name) {\n        for(var i = 0; i < fieldNames.length; ++i)if (fieldNames[i] !== name) delete this[fieldNames[i]];\n    };\n};\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */ util.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */ if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */ function Buffer_from(value, encoding) {\n        return new Buffer(value, encoding);\n    };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */ function Buffer_allocUnsafe(size) {\n        return new Buffer(size);\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsSUFBSUEsT0FBT0M7QUFFWCxxREFBcUQ7QUFDckRELEtBQUtFLFNBQVMsR0FBR0MsbUJBQU9BLENBQUMsa0ZBQXVCO0FBRWhELDRDQUE0QztBQUM1Q0gsS0FBS0ksTUFBTSxHQUFHRCxtQkFBT0EsQ0FBQyw0RUFBb0I7QUFFMUMsNEJBQTRCO0FBQzVCSCxLQUFLSyxZQUFZLEdBQUdGLG1CQUFPQSxDQUFDLHdGQUEwQjtBQUV0RCxrQ0FBa0M7QUFDbENILEtBQUtNLEtBQUssR0FBR0gsbUJBQU9BLENBQUMsMEVBQW1CO0FBRXhDLCtEQUErRDtBQUMvREgsS0FBS08sT0FBTyxHQUFHSixtQkFBT0EsQ0FBQyw4RUFBcUI7QUFFNUMsMENBQTBDO0FBQzFDSCxLQUFLUSxJQUFJLEdBQUdMLG1CQUFPQSxDQUFDLHdFQUFrQjtBQUV0QyxrREFBa0Q7QUFDbERILEtBQUtTLElBQUksR0FBR04sbUJBQU9BLENBQUMsd0VBQWtCO0FBRXRDLCtEQUErRDtBQUMvREgsS0FBS1UsUUFBUSxHQUFHUCxtQkFBT0EsQ0FBQyxtR0FBWTtBQUVwQzs7OztDQUlDLEdBQ0RILEtBQUtXLE1BQU0sR0FBR0MsUUFBUSxPQUFPQyxXQUFXLGVBQ2xCQSxVQUNBQSxPQUFPQyxPQUFPLElBQ2RELE9BQU9DLE9BQU8sQ0FBQ0MsUUFBUSxJQUN2QkYsT0FBT0MsT0FBTyxDQUFDQyxRQUFRLENBQUNDLElBQUk7QUFFbEQ7Ozs7Q0FJQyxHQUNEaEIsS0FBS2EsTUFBTSxHQUFHYixLQUFLVyxNQUFNLElBQUlFLFVBQ2YsTUFBNkIsSUFBSUksQ0FBTUEsSUFDdkMsT0FBT0MsU0FBVyxlQUFlQSxRQUNqQyxJQUFJLEVBQUUsc0NBQXNDO0FBRTFEOzs7OztDQUtDLEdBQ0RsQixLQUFLbUIsVUFBVSxHQUFHQyxPQUFPQyxNQUFN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QyxLQUFLeUMsTUFBTTtJQUN4QixzQkFBc0IsR0FDdEIsSUFBSSxDQUFDQSxRQUFRO1FBQ1R6QyxLQUFLNkMsWUFBWSxHQUFHN0MsS0FBSzhDLG1CQUFtQixHQUFHO1FBQy9DO0lBQ0o7SUFDQSx3REFBd0Q7SUFDeEQsdURBQXVEO0lBQ3ZEOUMsS0FBSzZDLFlBQVksR0FBR0osT0FBT2UsSUFBSSxLQUFLUCxXQUFXTyxJQUFJLElBQUlmLE9BQU9lLElBQUksSUFDOUQsd0JBQXdCLEdBQ3hCLFNBQVNxRCxZQUFZcEYsS0FBSyxFQUFFcUYsUUFBUTtRQUNoQyxPQUFPLElBQUlyRSxPQUFPaEIsT0FBT3FGO0lBQzdCO0lBQ0o5RyxLQUFLOEMsbUJBQW1CLEdBQUdMLE9BQU9zRSxXQUFXLElBQ3pDLHdCQUF3QixHQUN4QixTQUFTQyxtQkFBbUJDLElBQUk7UUFDNUIsT0FBTyxJQUFJeEUsT0FBT3dFO0lBQ3RCO0FBQ1IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdXRpbC9taW5pbWFsLmpzP2Y0NWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgdXRpbCA9IGV4cG9ydHM7XG5cbi8vIHVzZWQgdG8gcmV0dXJuIGEgUHJvbWlzZSB3aGVyZSBjYWxsYmFjayBpcyBvbWl0dGVkXG51dGlsLmFzUHJvbWlzZSA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9hc3Byb21pc2VcIik7XG5cbi8vIGNvbnZlcnRzIHRvIC8gZnJvbSBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG51dGlsLmJhc2U2NCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9iYXNlNjRcIik7XG5cbi8vIGJhc2UgY2xhc3Mgb2YgcnBjLlNlcnZpY2VcbnV0aWwuRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIkBwcm90b2J1ZmpzL2V2ZW50ZW1pdHRlclwiKTtcblxuLy8gZmxvYXQgaGFuZGxpbmcgYWNjcm9zcyBicm93c2Vyc1xudXRpbC5mbG9hdCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9mbG9hdFwiKTtcblxuLy8gcmVxdWlyZXMgbW9kdWxlcyBvcHRpb25hbGx5IGFuZCBoaWRlcyB0aGUgY2FsbCBmcm9tIGJ1bmRsZXJzXG51dGlsLmlucXVpcmUgPSByZXF1aXJlKFwiQHByb3RvYnVmanMvaW5xdWlyZVwiKTtcblxuLy8gY29udmVydHMgdG8gLyBmcm9tIHV0ZjggZW5jb2RlZCBzdHJpbmdzXG51dGlsLnV0ZjggPSByZXF1aXJlKFwiQHByb3RvYnVmanMvdXRmOFwiKTtcblxuLy8gcHJvdmlkZXMgYSBub2RlLWxpa2UgYnVmZmVyIHBvb2wgaW4gdGhlIGJyb3dzZXJcbnV0aWwucG9vbCA9IHJlcXVpcmUoXCJAcHJvdG9idWZqcy9wb29sXCIpO1xuXG4vLyB1dGlsaXR5IHRvIHdvcmsgd2l0aCB0aGUgbG93IGFuZCBoaWdoIGJpdHMgb2YgYSA2NCBiaXQgdmFsdWVcbnV0aWwuTG9uZ0JpdHMgPSByZXF1aXJlKFwiLi9sb25nYml0c1wiKTtcblxuLyoqXG4gKiBXaGV0aGVyIHJ1bm5pbmcgd2l0aGluIG5vZGUgb3Igbm90LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEB0eXBlIHtib29sZWFufVxuICovXG51dGlsLmlzTm9kZSA9IEJvb2xlYW4odHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbFxuICAgICAgICAgICAgICAgICAgICYmIGdsb2JhbC5wcm9jZXNzXG4gICAgICAgICAgICAgICAgICAgJiYgZ2xvYmFsLnByb2Nlc3MudmVyc2lvbnNcbiAgICAgICAgICAgICAgICAgICAmJiBnbG9iYWwucHJvY2Vzcy52ZXJzaW9ucy5ub2RlKTtcblxuLyoqXG4gKiBHbG9iYWwgb2JqZWN0IHJlZmVyZW5jZS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG51dGlsLmdsb2JhbCA9IHV0aWwuaXNOb2RlICYmIGdsb2JhbFxuICAgICAgICAgICB8fCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvd1xuICAgICAgICAgICB8fCB0eXBlb2Ygc2VsZiAgICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGZcbiAgICAgICAgICAgfHwgdGhpczsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1pbnZhbGlkLXRoaXNcblxuLyoqXG4gKiBBbiBpbW11YWJsZSBlbXB0eSBhcnJheS5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAdHlwZSB7QXJyYXkuPCo+fVxuICogQGNvbnN0XG4gKi9cbnV0aWwuZW1wdHlBcnJheSA9IE9iamVjdC5mcmVlemUgPyBPYmplY3QuZnJlZXplKFtdKSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIFtdOyAvLyB1c2VkIG9uIHByb3RvdHlwZXNcblxuLyoqXG4gKiBBbiBpbW11dGFibGUgZW1wdHkgb2JqZWN0LlxuICogQHR5cGUge09iamVjdH1cbiAqIEBjb25zdFxuICovXG51dGlsLmVtcHR5T2JqZWN0ID0gT2JqZWN0LmZyZWV6ZSA/IE9iamVjdC5mcmVlemUoe30pIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge307IC8vIHVzZWQgb24gcHJvdG90eXBlc1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2YWx1ZSBpcyBhbiBpbnRlZ2VyXG4gKi9cbnV0aWwuaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHZhbHVlKSAmJiBNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgc3RyaW5nXG4gKi9cbnV0aWwuaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBTdHJpbmc7XG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBub24tbnVsbCBvYmplY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIGEgbm9uLW51bGwgb2JqZWN0XG4gKi9cbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCI7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayB1dGlsLmlzU2V0fS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBQbGFpbiBvYmplY3Qgb3IgbWVzc2FnZSBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZiBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKi9cbnV0aWwuaXNzZXQgPVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHByb3BlcnR5IG9uIGEgbWVzc2FnZSBpcyBjb25zaWRlcmVkIHRvIGJlIHByZXNlbnQuXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFBsYWluIG9iamVjdCBvciBtZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmIGNvbnNpZGVyZWQgdG8gYmUgcHJlc2VudCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xudXRpbC5pc1NldCA9IGZ1bmN0aW9uIGlzU2V0KG9iaiwgcHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBvYmouaGFzT3duUHJvcGVydHkocHJvcCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxLCBuby1wcm90b3R5cGUtYnVpbHRpbnNcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5sZW5ndGggOiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoKSA+IDA7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBCdWZmZXIgaW5zdGFuY2UuXG4gKiBUaGlzIGlzIGEgbWluaW1hbCBzdGFuZC1hbG9uZSBkZWZpbml0aW9uIG9mIGEgQnVmZmVyIGluc3RhbmNlLiBUaGUgYWN0dWFsIHR5cGUgaXMgdGhhdCBleHBvcnRlZCBieSBub2RlJ3MgdHlwaW5ncy5cbiAqIEBpbnRlcmZhY2UgQnVmZmVyXG4gKiBAZXh0ZW5kcyBVaW50OEFycmF5XG4gKi9cblxuLyoqXG4gKiBOb2RlJ3MgQnVmZmVyIGNsYXNzIGlmIGF2YWlsYWJsZS5cbiAqIEB0eXBlIHtDb25zdHJ1Y3RvcjxCdWZmZXI+fVxuICovXG51dGlsLkJ1ZmZlciA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgICB2YXIgQnVmZmVyID0gdXRpbC5pbnF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcjtcbiAgICAgICAgLy8gcmVmdXNlIHRvIHVzZSBub24tbm9kZSBidWZmZXJzIGlmIG5vdCBleHBsaWNpdGx5IGFzc2lnbmVkIChwZXJmIHJlYXNvbnMpOlxuICAgICAgICByZXR1cm4gQnVmZmVyLnByb3RvdHlwZS51dGY4V3JpdGUgPyBCdWZmZXIgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufSkoKTtcblxuLy8gSW50ZXJuYWwgYWxpYXMgb2Ygb3IgcG9seWZ1bGwgZm9yIEJ1ZmZlci5mcm9tLlxudXRpbC5fQnVmZmVyX2Zyb20gPSBudWxsO1xuXG4vLyBJbnRlcm5hbCBhbGlhcyBvZiBvciBwb2x5ZmlsbCBmb3IgQnVmZmVyLmFsbG9jVW5zYWZlLlxudXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGJ1ZmZlciBvZiB3aGF0ZXZlciB0eXBlIHN1cHBvcnRlZCBieSB0aGUgZW52aXJvbm1lbnQuXG4gKiBAcGFyYW0ge251bWJlcnxudW1iZXJbXX0gW3NpemVPckFycmF5PTBdIEJ1ZmZlciBzaXplIG9yIG51bWJlciBhcnJheVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl8QnVmZmVyfSBCdWZmZXJcbiAqL1xudXRpbC5uZXdCdWZmZXIgPSBmdW5jdGlvbiBuZXdCdWZmZXIoc2l6ZU9yQXJyYXkpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHJldHVybiB0eXBlb2Ygc2l6ZU9yQXJyYXkgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB1dGlsLkJ1ZmZlclxuICAgICAgICAgICAgPyB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZU9yQXJyYXkpXG4gICAgICAgICAgICA6IG5ldyB1dGlsLkFycmF5KHNpemVPckFycmF5KVxuICAgICAgICA6IHV0aWwuQnVmZmVyXG4gICAgICAgICAgICA/IHV0aWwuX0J1ZmZlcl9mcm9tKHNpemVPckFycmF5KVxuICAgICAgICAgICAgOiB0eXBlb2YgVWludDhBcnJheSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gc2l6ZU9yQXJyYXlcbiAgICAgICAgICAgICAgICA6IG5ldyBVaW50OEFycmF5KHNpemVPckFycmF5KTtcbn07XG5cbi8qKlxuICogQXJyYXkgaW1wbGVtZW50YXRpb24gdXNlZCBpbiB0aGUgYnJvd3Nlci4gYFVpbnQ4QXJyYXlgIGlmIHN1cHBvcnRlZCwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAdHlwZSB7Q29uc3RydWN0b3I8VWludDhBcnJheT59XG4gKi9cbnV0aWwuQXJyYXkgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiA/IFVpbnQ4QXJyYXkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gOiBBcnJheTtcblxuLyoqXG4gKiBBbnkgY29tcGF0aWJsZSBMb25nIGluc3RhbmNlLlxuICogVGhpcyBpcyBhIG1pbmltYWwgc3RhbmQtYWxvbmUgZGVmaW5pdGlvbiBvZiBhIExvbmcgaW5zdGFuY2UuIFRoZSBhY3R1YWwgdHlwZSBpcyB0aGF0IGV4cG9ydGVkIGJ5IGxvbmcuanMuXG4gKiBAaW50ZXJmYWNlIExvbmdcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsb3cgTG93IGJpdHNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoIEhpZ2ggYml0c1xuICogQHByb3BlcnR5IHtib29sZWFufSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdFxuICovXG5cbi8qKlxuICogTG9uZy5qcydzIExvbmcgY2xhc3MgaWYgYXZhaWxhYmxlLlxuICogQHR5cGUge0NvbnN0cnVjdG9yPExvbmc+fVxuICovXG51dGlsLkxvbmcgPSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB1dGlsLmdsb2JhbC5kY29kZUlPICYmIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHV0aWwuZ2xvYmFsLmRjb2RlSU8uTG9uZ1xuICAgICAgICAgfHwgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gdXRpbC5nbG9iYWwuTG9uZ1xuICAgICAgICAgfHwgdXRpbC5pbnF1aXJlKFwibG9uZ1wiKTtcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byB2ZXJpZnkgMiBiaXQgKGBib29sYCkgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MlJlID0gL150cnVlfGZhbHNlfDB8MSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSAzMiBiaXQgKGBpbnQzMmAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5MzJSZSA9IC9eLT8oPzowfFsxLTldWzAtOV0qKSQvO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHZlcmlmeSA2NCBiaXQgKGBpbnQ2NGAgZXRjLikgbWFwIGtleXMuXG4gKiBAdHlwZSB7UmVnRXhwfVxuICogQGNvbnN0XG4gKi9cbnV0aWwua2V5NjRSZSA9IC9eKD86W1xcXFx4MDAtXFxcXHhmZl17OH18LT8oPzowfFsxLTldWzAtOV0qKSkkLztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIG51bWJlciBvciBsb25nIHRvIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nLlxuICogQHBhcmFtIHtMb25nfG51bWJlcn0gdmFsdWUgVmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge3N0cmluZ30gSGFzaFxuICovXG51dGlsLmxvbmdUb0hhc2ggPSBmdW5jdGlvbiBsb25nVG9IYXNoKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gdXRpbC5Mb25nQml0cy5mcm9tKHZhbHVlKS50b0hhc2goKVxuICAgICAgICA6IHV0aWwuTG9uZ0JpdHMuemVyb0hhc2g7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGFuIDggY2hhcmFjdGVycyBsb25nIGhhc2ggc3RyaW5nIHRvIGEgbG9uZyBvciBudW1iZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFzaCBIYXNoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt1bnNpZ25lZD1mYWxzZV0gV2hldGhlciB1bnNpZ25lZCBvciBub3RcbiAqIEByZXR1cm5zIHtMb25nfG51bWJlcn0gT3JpZ2luYWwgdmFsdWVcbiAqL1xudXRpbC5sb25nRnJvbUhhc2ggPSBmdW5jdGlvbiBsb25nRnJvbUhhc2goaGFzaCwgdW5zaWduZWQpIHtcbiAgICB2YXIgYml0cyA9IHV0aWwuTG9uZ0JpdHMuZnJvbUhhc2goaGFzaCk7XG4gICAgaWYgKHV0aWwuTG9uZylcbiAgICAgICAgcmV0dXJuIHV0aWwuTG9uZy5mcm9tQml0cyhiaXRzLmxvLCBiaXRzLmhpLCB1bnNpZ25lZCk7XG4gICAgcmV0dXJuIGJpdHMudG9OdW1iZXIoQm9vbGVhbih1bnNpZ25lZCkpO1xufTtcblxuLyoqXG4gKiBNZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHNvdXJjZSBvYmplY3QgaW50byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQG1lbWJlcm9mIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IGRzdCBEZXN0aW5hdGlvbiBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IHNyYyBTb3VyY2Ugb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpZk5vdFNldD1mYWxzZV0gTWVyZ2VzIG9ubHkgaWYgdGhlIGtleSBpcyBub3QgYWxyZWFkeSBzZXRcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZywqPn0gRGVzdGluYXRpb24gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIG1lcmdlKGRzdCwgc3JjLCBpZk5vdFNldCkgeyAvLyB1c2VkIGJ5IGNvbnZlcnRlcnNcbiAgICBmb3IgKHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3JjKSwgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICBpZiAoZHN0W2tleXNbaV1dID09PSB1bmRlZmluZWQgfHwgIWlmTm90U2V0KVxuICAgICAgICAgICAgZHN0W2tleXNbaV1dID0gc3JjW2tleXNbaV1dO1xuICAgIHJldHVybiBkc3Q7XG59XG5cbnV0aWwubWVyZ2UgPSBtZXJnZTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGEgc3RyaW5nIHRvIGxvd2VyIGNhc2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFN0cmluZyB0byBjb252ZXJ0XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb252ZXJ0ZWQgc3RyaW5nXG4gKi9cbnV0aWwubGNGaXJzdCA9IGZ1bmN0aW9uIGxjRmlyc3Qoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjdXN0b20gZXJyb3IgY29uc3RydWN0b3IuXG4gKiBAbWVtYmVyb2YgdXRpbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgRXJyb3IgbmFtZVxuICogQHJldHVybnMge0NvbnN0cnVjdG9yPEVycm9yPn0gQ3VzdG9tIGVycm9yIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIG5ld0Vycm9yKG5hbWUpIHtcblxuICAgIGZ1bmN0aW9uIEN1c3RvbUVycm9yKG1lc3NhZ2UsIHByb3BlcnRpZXMpIHtcblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ3VzdG9tRXJyb3IpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDdXN0b21FcnJvcihtZXNzYWdlLCBwcm9wZXJ0aWVzKTtcblxuICAgICAgICAvLyBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgICAgICAvLyBeIGp1c3QgcmV0dXJucyBhIG5ldyBlcnJvciBpbnN0YW5jZSBiZWNhdXNlIHRoZSBjdG9yIGNhbiBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvblxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm1lc3NhZ2VcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVzc2FnZTsgfSB9KTtcblxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIC8vIG5vZGVcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIEN1c3RvbUVycm9yKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwic3RhY2tcIiwgeyB2YWx1ZTogbmV3IEVycm9yKCkuc3RhY2sgfHwgXCJcIiB9KTtcblxuICAgICAgICBpZiAocHJvcGVydGllcylcbiAgICAgICAgICAgIG1lcmdlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIEN1c3RvbUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgICB2YWx1ZTogQ3VzdG9tRXJyb3IsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHsgcmV0dXJuIG5hbWU7IH0sXG4gICAgICAgICAgICBzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlOiBmYWxzZSB3b3VsZCBhY2N1cmF0ZWx5IHByZXNlcnZlIHRoZSBiZWhhdmlvciBvZlxuICAgICAgICAgICAgLy8gdGhlIG9yaWdpbmFsLCBidXQgSSdtIGd1ZXNzaW5nIHRoYXQgd2FzIG5vdCBpbnRlbnRpb25hbC5cbiAgICAgICAgICAgIC8vIEZvciBhbiBhY3R1YWwgZXJyb3Igc3ViY2xhc3MsIHRoaXMgcHJvcGVydHkgd291bGRcbiAgICAgICAgICAgIC8vIGJlIGNvbmZpZ3VyYWJsZS5cbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgdG9TdHJpbmc6IHtcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHsgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZTsgfSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSk7XG5cbiAgICByZXR1cm4gQ3VzdG9tRXJyb3I7XG59XG5cbnV0aWwubmV3RXJyb3IgPSBuZXdFcnJvcjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHByb3RvY29sIGVycm9yLlxuICogQGNsYXNzZGVzYyBFcnJvciBzdWJjbGFzcyBpbmRpY2F0aW5nIGEgcHJvdG9jb2wgc3BlY2lmYyBlcnJvci5cbiAqIEBtZW1iZXJvZiB1dGlsXG4gKiBAZXh0ZW5kcyBFcnJvclxuICogQHRlbXBsYXRlIFQgZXh0ZW5kcyBNZXNzYWdlPFQ+XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIEVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsKj59IFtwcm9wZXJ0aWVzXSBBZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAqIEBleGFtcGxlXG4gKiB0cnkge1xuICogICAgIE15TWVzc2FnZS5kZWNvZGUoc29tZUJ1ZmZlcik7IC8vIHRocm93cyBpZiByZXF1aXJlZCBmaWVsZHMgYXJlIG1pc3NpbmdcbiAqIH0gY2F0Y2ggKGUpIHtcbiAqICAgICBpZiAoZSBpbnN0YW5jZW9mIFByb3RvY29sRXJyb3IgJiYgZS5pbnN0YW5jZSlcbiAqICAgICAgICAgY29uc29sZS5sb2coXCJkZWNvZGVkIHNvIGZhcjogXCIgKyBKU09OLnN0cmluZ2lmeShlLmluc3RhbmNlKSk7XG4gKiB9XG4gKi9cbnV0aWwuUHJvdG9jb2xFcnJvciA9IG5ld0Vycm9yKFwiUHJvdG9jb2xFcnJvclwiKTtcblxuLyoqXG4gKiBTbyBmYXIgZGVjb2RlZCBtZXNzYWdlIGluc3RhbmNlLlxuICogQG5hbWUgdXRpbC5Qcm90b2NvbEVycm9yI2luc3RhbmNlXG4gKiBAdHlwZSB7TWVzc2FnZTxUPn1cbiAqL1xuXG4vKipcbiAqIEEgT25lT2YgZ2V0dGVyIGFzIHJldHVybmVkIGJ5IHtAbGluayB1dGlsLm9uZU9mR2V0dGVyfS5cbiAqIEB0eXBlZGVmIE9uZU9mR2V0dGVyXG4gKiBAdHlwZSB7ZnVuY3Rpb259XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH0gU2V0IGZpZWxkIG5hbWUsIGlmIGFueVxuICovXG5cbi8qKlxuICogQnVpbGRzIGEgZ2V0dGVyIGZvciBhIG9uZW9mJ3MgcHJlc2VudCBmaWVsZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyBGaWVsZCBuYW1lc1xuICogQHJldHVybnMge09uZU9mR2V0dGVyfSBVbmJvdW5kIGdldHRlclxuICovXG51dGlsLm9uZU9mR2V0dGVyID0gZnVuY3Rpb24gZ2V0T25lT2YoZmllbGROYW1lcykge1xuICAgIHZhciBmaWVsZE1hcCA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmllbGROYW1lcy5sZW5ndGg7ICsraSlcbiAgICAgICAgZmllbGRNYXBbZmllbGROYW1lc1tpXV0gPSAxO1xuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9IFNldCBmaWVsZCBuYW1lLCBpZiBhbnlcbiAgICAgKiBAdGhpcyBPYmplY3RcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXG4gICAgICAgIGZvciAodmFyIGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKSwgaSA9IGtleXMubGVuZ3RoIC0gMTsgaSA+IC0xOyAtLWkpXG4gICAgICAgICAgICBpZiAoZmllbGRNYXBba2V5c1tpXV0gPT09IDEgJiYgdGhpc1trZXlzW2ldXSAhPT0gdW5kZWZpbmVkICYmIHRoaXNba2V5c1tpXV0gIT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXNbaV07XG4gICAgfTtcbn07XG5cbi8qKlxuICogQSBPbmVPZiBzZXR0ZXIgYXMgcmV0dXJuZWQgYnkge0BsaW5rIHV0aWwub25lT2ZTZXR0ZXJ9LlxuICogQHR5cGVkZWYgT25lT2ZTZXR0ZXJcbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gdmFsdWUgRmllbGQgbmFtZVxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuXG4vKipcbiAqIEJ1aWxkcyBhIHNldHRlciBmb3IgYSBvbmVvZidzIHByZXNlbnQgZmllbGQgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkTmFtZXMgRmllbGQgbmFtZXNcbiAqIEByZXR1cm5zIHtPbmVPZlNldHRlcn0gVW5ib3VuZCBzZXR0ZXJcbiAqL1xudXRpbC5vbmVPZlNldHRlciA9IGZ1bmN0aW9uIHNldE9uZU9mKGZpZWxkTmFtZXMpIHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZpZWxkIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgICAqIEB0aGlzIE9iamVjdFxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkTmFtZXMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lc1tpXSAhPT0gbmFtZSlcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpc1tmaWVsZE5hbWVzW2ldXTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IGNvbnZlcnNpb24gb3B0aW9ucyB1c2VkIGZvciB7QGxpbmsgTWVzc2FnZSN0b0pTT059IGltcGxlbWVudGF0aW9ucy5cbiAqXG4gKiBUaGVzZSBvcHRpb25zIGFyZSBjbG9zZSB0byBwcm90bzMncyBKU09OIG1hcHBpbmcgd2l0aCB0aGUgZXhjZXB0aW9uIHRoYXQgaW50ZXJuYWwgdHlwZXMgbGlrZSBBbnkgYXJlIGhhbmRsZWQganVzdCBsaWtlIG1lc3NhZ2VzLiBNb3JlIHByZWNpc2VseTpcbiAqXG4gKiAtIExvbmdzIGJlY29tZSBzdHJpbmdzXG4gKiAtIEVudW1zIGJlY29tZSBzdHJpbmcga2V5c1xuICogLSBCeXRlcyBiZWNvbWUgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICogLSAoU3ViLSlNZXNzYWdlcyBiZWNvbWUgcGxhaW4gb2JqZWN0c1xuICogLSBNYXBzIGJlY29tZSBwbGFpbiBvYmplY3RzIHdpdGggYWxsIHN0cmluZyBrZXlzXG4gKiAtIFJlcGVhdGVkIGZpZWxkcyBiZWNvbWUgYXJyYXlzXG4gKiAtIE5hTiBhbmQgSW5maW5pdHkgZm9yIGZsb2F0IGFuZCBkb3VibGUgZmllbGRzIGJlY29tZSBzdHJpbmdzXG4gKlxuICogQHR5cGUge0lDb252ZXJzaW9uT3B0aW9uc31cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vcHJvdG9jb2wtYnVmZmVycy9kb2NzL3Byb3RvMz9obD1lbiNqc29uXG4gKi9cbnV0aWwudG9KU09OT3B0aW9ucyA9IHtcbiAgICBsb25nczogU3RyaW5nLFxuICAgIGVudW1zOiBTdHJpbmcsXG4gICAgYnl0ZXM6IFN0cmluZyxcbiAgICBqc29uOiB0cnVlXG59O1xuXG4vLyBTZXRzIHVwIGJ1ZmZlciB1dGlsaXR5IGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgKGNhbGxlZCBpbiBpbmRleC1taW5pbWFsKVxudXRpbC5fY29uZmlndXJlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIEJ1ZmZlciA9IHV0aWwuQnVmZmVyO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQnVmZmVyKSB7XG4gICAgICAgIHV0aWwuX0J1ZmZlcl9mcm9tID0gdXRpbC5fQnVmZmVyX2FsbG9jVW5zYWZlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBiZWNhdXNlIG5vZGUgNC54IGJ1ZmZlcnMgYXJlIGluY29tcGF0aWJsZSAmIGltbXV0YWJsZVxuICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Rjb2RlSU8vcHJvdG9idWYuanMvcHVsbC82NjVcbiAgICB1dGlsLl9CdWZmZXJfZnJvbSA9IEJ1ZmZlci5mcm9tICE9PSBVaW50OEFycmF5LmZyb20gJiYgQnVmZmVyLmZyb20gfHxcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgZnVuY3Rpb24gQnVmZmVyX2Zyb20odmFsdWUsIGVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmcpO1xuICAgICAgICB9O1xuICAgIHV0aWwuX0J1ZmZlcl9hbGxvY1Vuc2FmZSA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSB8fFxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBmdW5jdGlvbiBCdWZmZXJfYWxsb2NVbnNhZmUoc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXIoc2l6ZSk7XG4gICAgICAgIH07XG59O1xuIl0sIm5hbWVzIjpbInV0aWwiLCJleHBvcnRzIiwiYXNQcm9taXNlIiwicmVxdWlyZSIsImJhc2U2NCIsIkV2ZW50RW1pdHRlciIsImZsb2F0IiwiaW5xdWlyZSIsInV0ZjgiLCJwb29sIiwiTG9uZ0JpdHMiLCJpc05vZGUiLCJCb29sZWFuIiwiZ2xvYmFsIiwicHJvY2VzcyIsInZlcnNpb25zIiwibm9kZSIsIndpbmRvdyIsInNlbGYiLCJlbXB0eUFycmF5IiwiT2JqZWN0IiwiZnJlZXplIiwiZW1wdHlPYmplY3QiLCJpc0ludGVnZXIiLCJOdW1iZXIiLCJ2YWx1ZSIsImlzRmluaXRlIiwiTWF0aCIsImZsb29yIiwiaXNTdHJpbmciLCJTdHJpbmciLCJpc09iamVjdCIsImlzc2V0IiwiaXNTZXQiLCJvYmoiLCJwcm9wIiwiaGFzT3duUHJvcGVydHkiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJrZXlzIiwiQnVmZmVyIiwicHJvdG90eXBlIiwidXRmOFdyaXRlIiwiZSIsIl9CdWZmZXJfZnJvbSIsIl9CdWZmZXJfYWxsb2NVbnNhZmUiLCJuZXdCdWZmZXIiLCJzaXplT3JBcnJheSIsIlVpbnQ4QXJyYXkiLCJMb25nIiwiZGNvZGVJTyIsImtleTJSZSIsImtleTMyUmUiLCJrZXk2NFJlIiwibG9uZ1RvSGFzaCIsImZyb20iLCJ0b0hhc2giLCJ6ZXJvSGFzaCIsImxvbmdGcm9tSGFzaCIsImhhc2giLCJ1bnNpZ25lZCIsImJpdHMiLCJmcm9tSGFzaCIsImZyb21CaXRzIiwibG8iLCJoaSIsInRvTnVtYmVyIiwibWVyZ2UiLCJkc3QiLCJzcmMiLCJpZk5vdFNldCIsImkiLCJ1bmRlZmluZWQiLCJsY0ZpcnN0Iiwic3RyIiwiY2hhckF0IiwidG9Mb3dlckNhc2UiLCJzdWJzdHJpbmciLCJuZXdFcnJvciIsIm5hbWUiLCJDdXN0b21FcnJvciIsIm1lc3NhZ2UiLCJwcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwic3RhY2siLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInNldCIsInRvU3RyaW5nIiwiUHJvdG9jb2xFcnJvciIsIm9uZU9mR2V0dGVyIiwiZ2V0T25lT2YiLCJmaWVsZE5hbWVzIiwiZmllbGRNYXAiLCJvbmVPZlNldHRlciIsInNldE9uZU9mIiwidG9KU09OT3B0aW9ucyIsImxvbmdzIiwiZW51bXMiLCJieXRlcyIsImpzb24iLCJfY29uZmlndXJlIiwiQnVmZmVyX2Zyb20iLCJlbmNvZGluZyIsImFsbG9jVW5zYWZlIiwiQnVmZmVyX2FsbG9jVW5zYWZlIiwic2l6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/verifier.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/verifier.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = verifier;\nvar Enum = __webpack_require__(/*! ./enum */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/enum.js\"), util = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util.js\");\nfunction invalid(field, expected) {\n    return field.name + \": \" + expected + (field.repeated && expected !== \"array\" ? \"[]\" : field.map && expected !== \"object\" ? \"{k:\" + field.keyType + \"}\" : \"\") + \" expected\";\n}\n/**\n * Generates a partial value verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {number} fieldIndex Field index\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genVerifyValue(gen, field, fieldIndex, ref) {\n    /* eslint-disable no-unexpected-multiline */ if (field.resolvedType) {\n        if (field.resolvedType instanceof Enum) {\n            gen(\"switch(%s){\", ref)(\"default:\")(\"return%j\", invalid(field, \"enum value\"));\n            for(var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j)gen(\"case %i:\", field.resolvedType.values[keys[j]]);\n            gen(\"break\")(\"}\");\n        } else {\n            gen(\"{\")(\"var e=types[%i].verify(%s);\", fieldIndex, ref)(\"if(e)\")(\"return%j+e\", field.name + \".\")(\"}\");\n        }\n    } else {\n        switch(field.type){\n            case \"int32\":\n            case \"uint32\":\n            case \"sint32\":\n            case \"fixed32\":\n            case \"sfixed32\":\n                gen(\"if(!util.isInteger(%s))\", ref)(\"return%j\", invalid(field, \"integer\"));\n                break;\n            case \"int64\":\n            case \"uint64\":\n            case \"sint64\":\n            case \"fixed64\":\n            case \"sfixed64\":\n                gen(\"if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))\", ref, ref, ref, ref)(\"return%j\", invalid(field, \"integer|Long\"));\n                break;\n            case \"float\":\n            case \"double\":\n                gen('if(typeof %s!==\"number\")', ref)(\"return%j\", invalid(field, \"number\"));\n                break;\n            case \"bool\":\n                gen('if(typeof %s!==\"boolean\")', ref)(\"return%j\", invalid(field, \"boolean\"));\n                break;\n            case \"string\":\n                gen(\"if(!util.isString(%s))\", ref)(\"return%j\", invalid(field, \"string\"));\n                break;\n            case \"bytes\":\n                gen('if(!(%s&&typeof %s.length===\"number\"||util.isString(%s)))', ref, ref, ref)(\"return%j\", invalid(field, \"buffer\"));\n                break;\n        }\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline */ }\n/**\n * Generates a partial key verifier.\n * @param {Codegen} gen Codegen instance\n * @param {Field} field Reflected field\n * @param {string} ref Variable reference\n * @returns {Codegen} Codegen instance\n * @ignore\n */ function genVerifyKey(gen, field, ref) {\n    /* eslint-disable no-unexpected-multiline */ switch(field.keyType){\n        case \"int32\":\n        case \"uint32\":\n        case \"sint32\":\n        case \"fixed32\":\n        case \"sfixed32\":\n            gen(\"if(!util.key32Re.test(%s))\", ref)(\"return%j\", invalid(field, \"integer key\"));\n            break;\n        case \"int64\":\n        case \"uint64\":\n        case \"sint64\":\n        case \"fixed64\":\n        case \"sfixed64\":\n            gen(\"if(!util.key64Re.test(%s))\", ref) // see comment above: x is ok, d is not\n            (\"return%j\", invalid(field, \"integer|Long key\"));\n            break;\n        case \"bool\":\n            gen(\"if(!util.key2Re.test(%s))\", ref)(\"return%j\", invalid(field, \"boolean key\"));\n            break;\n    }\n    return gen;\n/* eslint-enable no-unexpected-multiline */ }\n/**\n * Generates a verifier specific to the specified message type.\n * @param {Type} mtype Message type\n * @returns {Codegen} Codegen instance\n */ function verifier(mtype) {\n    /* eslint-disable no-unexpected-multiline */ var gen = util.codegen([\n        \"m\"\n    ], mtype.name + \"$verify\")('if(typeof m!==\"object\"||m===null)')(\"return%j\", \"object expected\");\n    var oneofs = mtype.oneofsArray, seenFirstField = {};\n    if (oneofs.length) gen(\"var p={}\");\n    for(var i = 0; i < /* initializes */ mtype.fieldsArray.length; ++i){\n        var field = mtype._fieldsArray[i].resolve(), ref = \"m\" + util.safeProp(field.name);\n        if (field.optional) gen(\"if(%s!=null&&m.hasOwnProperty(%j)){\", ref, field.name); // !== undefined && !== null\n        // map fields\n        if (field.map) {\n            gen(\"if(!util.isObject(%s))\", ref)(\"return%j\", invalid(field, \"object\"))(\"var k=Object.keys(%s)\", ref)(\"for(var i=0;i<k.length;++i){\");\n            genVerifyKey(gen, field, \"k[i]\");\n            genVerifyValue(gen, field, i, ref + \"[k[i]]\")(\"}\");\n        // repeated fields\n        } else if (field.repeated) {\n            gen(\"if(!Array.isArray(%s))\", ref)(\"return%j\", invalid(field, \"array\"))(\"for(var i=0;i<%s.length;++i){\", ref);\n            genVerifyValue(gen, field, i, ref + \"[i]\")(\"}\");\n        // required or present fields\n        } else {\n            if (field.partOf) {\n                var oneofProp = util.safeProp(field.partOf.name);\n                if (seenFirstField[field.partOf.name] === 1) gen(\"if(p%s===1)\", oneofProp)(\"return%j\", field.partOf.name + \": multiple values\");\n                seenFirstField[field.partOf.name] = 1;\n                gen(\"p%s=1\", oneofProp);\n            }\n            genVerifyValue(gen, field, i, ref);\n        }\n        if (field.optional) gen(\"}\");\n    }\n    return gen(\"return null\");\n/* eslint-enable no-unexpected-multiline */ }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvdmVyaWZpZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxPQUFZQyxtQkFBT0EsQ0FBQyxzRkFBUSxHQUM1QkMsT0FBWUQsbUJBQU9BLENBQUMsc0ZBQVE7QUFFaEMsU0FBU0UsUUFBUUMsS0FBSyxFQUFFQyxRQUFRO0lBQzVCLE9BQU9ELE1BQU1FLElBQUksR0FBRyxPQUFPRCxXQUFZRCxDQUFBQSxNQUFNRyxRQUFRLElBQUlGLGFBQWEsVUFBVSxPQUFPRCxNQUFNSSxHQUFHLElBQUlILGFBQWEsV0FBVyxRQUFNRCxNQUFNSyxPQUFPLEdBQUMsTUFBTSxFQUFDLElBQUs7QUFDaEs7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNELFNBQVNDLGVBQWVDLEdBQUcsRUFBRVAsS0FBSyxFQUFFUSxVQUFVLEVBQUVDLEdBQUc7SUFDL0MsMENBQTBDLEdBQzFDLElBQUlULE1BQU1VLFlBQVksRUFBRTtRQUNwQixJQUFJVixNQUFNVSxZQUFZLFlBQVlkLE1BQU07WUFBRVcsSUFDckMsZUFBZUUsS0FDWCxZQUNJLFlBQVlWLFFBQVFDLE9BQU87WUFDcEMsSUFBSyxJQUFJVyxPQUFPQyxPQUFPRCxJQUFJLENBQUNYLE1BQU1VLFlBQVksQ0FBQ0csTUFBTSxHQUFHQyxJQUFJLEdBQUdBLElBQUlILEtBQUtJLE1BQU0sRUFBRSxFQUFFRCxFQUFHUCxJQUNoRixZQUFZUCxNQUFNVSxZQUFZLENBQUNHLE1BQU0sQ0FBQ0YsSUFBSSxDQUFDRyxFQUFFLENBQUM7WUFDbkRQLElBQ1MsU0FDUjtRQUNMLE9BQU87WUFDSEEsSUFDQyxLQUNJLCtCQUErQkMsWUFBWUMsS0FDM0MsU0FDSSxjQUFjVCxNQUFNRSxJQUFJLEdBQUcsS0FDbkM7UUFDTDtJQUNKLE9BQU87UUFDSCxPQUFRRixNQUFNZ0IsSUFBSTtZQUNkLEtBQUs7WUFD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QUk7Z0JBQy9DLElBQUlvQixjQUFjLENBQUN0QixNQUFNNkIsTUFBTSxDQUFDM0IsSUFBSSxDQUFDLEtBQUssR0FBR0ssSUFDaEQsZUFBZXVCLFdBQ1gsWUFBWTlCLE1BQU02QixNQUFNLENBQUMzQixJQUFJLEdBQUc7Z0JBQ2pDb0IsY0FBYyxDQUFDdEIsTUFBTTZCLE1BQU0sQ0FBQzNCLElBQUksQ0FBQyxHQUFHO2dCQUNwQ0ssSUFDSCxTQUFTdUI7WUFDVjtZQUNBeEIsZUFBZUMsS0FBS1AsT0FBT3VCLEdBQUdkO1FBQ2xDO1FBQ0EsSUFBSVQsTUFBTTRCLFFBQVEsRUFBRXJCLElBQ25CO0lBQ0w7SUFDQSxPQUFPQSxJQUNOO0FBQ0QseUNBQXlDLEdBQzdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3ZlcmlmaWVyLmpzPzVhZDYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IHZlcmlmaWVyO1xuXG52YXIgRW51bSAgICAgID0gcmVxdWlyZShcIi4vZW51bVwiKSxcbiAgICB1dGlsICAgICAgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5mdW5jdGlvbiBpbnZhbGlkKGZpZWxkLCBleHBlY3RlZCkge1xuICAgIHJldHVybiBmaWVsZC5uYW1lICsgXCI6IFwiICsgZXhwZWN0ZWQgKyAoZmllbGQucmVwZWF0ZWQgJiYgZXhwZWN0ZWQgIT09IFwiYXJyYXlcIiA/IFwiW11cIiA6IGZpZWxkLm1hcCAmJiBleHBlY3RlZCAhPT0gXCJvYmplY3RcIiA/IFwie2s6XCIrZmllbGQua2V5VHlwZStcIn1cIiA6IFwiXCIpICsgXCIgZXhwZWN0ZWRcIjtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwYXJ0aWFsIHZhbHVlIHZlcmlmaWVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge251bWJlcn0gZmllbGRJbmRleCBGaWVsZCBpbmRleFxuICogQHBhcmFtIHtzdHJpbmd9IHJlZiBWYXJpYWJsZSByZWZlcmVuY2VcbiAqIEByZXR1cm5zIHtDb2RlZ2VufSBDb2RlZ2VuIGluc3RhbmNlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGZpZWxkSW5kZXgsIHJlZikge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG4gICAgaWYgKGZpZWxkLnJlc29sdmVkVHlwZSkge1xuICAgICAgICBpZiAoZmllbGQucmVzb2x2ZWRUeXBlIGluc3RhbmNlb2YgRW51bSkgeyBnZW5cbiAgICAgICAgICAgIChcInN3aXRjaCglcyl7XCIsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJkZWZhdWx0OlwiKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImVudW0gdmFsdWVcIikpO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXMpLCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIGdlblxuICAgICAgICAgICAgICAgIChcImNhc2UgJWk6XCIsIGZpZWxkLnJlc29sdmVkVHlwZS52YWx1ZXNba2V5c1tqXV0pO1xuICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAgICAgICAgIChcImJyZWFrXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAoXCJ7XCIpXG4gICAgICAgICAgICAgICAgKFwidmFyIGU9dHlwZXNbJWldLnZlcmlmeSglcyk7XCIsIGZpZWxkSW5kZXgsIHJlZilcbiAgICAgICAgICAgICAgICAoXCJpZihlKVwiKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4laitlXCIsIGZpZWxkLm5hbWUgKyBcIi5cIilcbiAgICAgICAgICAgIChcIn1cIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGZpZWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInVpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcInNpbnQzMlwiOlxuICAgICAgICAgICAgY2FzZSBcImZpeGVkMzJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzZml4ZWQzMlwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZighdXRpbC5pc0ludGVnZXIoJXMpKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiaW50ZWdlclwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ1aW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzaW50NjRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaXhlZDY0XCI6XG4gICAgICAgICAgICBjYXNlIFwic2ZpeGVkNjRcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoIXV0aWwuaXNJbnRlZ2VyKCVzKSYmISglcyYmdXRpbC5pc0ludGVnZXIoJXMubG93KSYmdXRpbC5pc0ludGVnZXIoJXMuaGlnaCkpKVwiLCByZWYsIHJlZiwgcmVmLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiaW50ZWdlcnxMb25nXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmbG9hdFwiOlxuICAgICAgICAgICAgY2FzZSBcImRvdWJsZVwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZih0eXBlb2YgJXMhPT1cXFwibnVtYmVyXFxcIilcIiwgcmVmKVxuICAgICAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcIm51bWJlclwiKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm9vbFwiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZih0eXBlb2YgJXMhPT1cXFwiYm9vbGVhblxcXCIpXCIsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJib29sZWFuXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjogZ2VuXG4gICAgICAgICAgICAgICAgKFwiaWYoIXV0aWwuaXNTdHJpbmcoJXMpKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwic3RyaW5nXCIpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJieXRlc1wiOiBnZW5cbiAgICAgICAgICAgICAgICAoXCJpZighKCVzJiZ0eXBlb2YgJXMubGVuZ3RoPT09XFxcIm51bWJlclxcXCJ8fHV0aWwuaXNTdHJpbmcoJXMpKSlcIiwgcmVmLCByZWYsIHJlZilcbiAgICAgICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJidWZmZXJcIikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnZW47XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBhcnRpYWwga2V5IHZlcmlmaWVyLlxuICogQHBhcmFtIHtDb2RlZ2VufSBnZW4gQ29kZWdlbiBpbnN0YW5jZVxuICogQHBhcmFtIHtGaWVsZH0gZmllbGQgUmVmbGVjdGVkIGZpZWxkXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVmIFZhcmlhYmxlIHJlZmVyZW5jZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gZ2VuVmVyaWZ5S2V5KGdlbiwgZmllbGQsIHJlZikge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG4gICAgc3dpdGNoIChmaWVsZC5rZXlUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJpbnQzMlwiOlxuICAgICAgICBjYXNlIFwidWludDMyXCI6XG4gICAgICAgIGNhc2UgXCJzaW50MzJcIjpcbiAgICAgICAgY2FzZSBcImZpeGVkMzJcIjpcbiAgICAgICAgY2FzZSBcInNmaXhlZDMyXCI6IGdlblxuICAgICAgICAgICAgKFwiaWYoIXV0aWwua2V5MzJSZS50ZXN0KCVzKSlcIiwgcmVmKVxuICAgICAgICAgICAgICAgIChcInJldHVybiVqXCIsIGludmFsaWQoZmllbGQsIFwiaW50ZWdlciBrZXlcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJpbnQ2NFwiOlxuICAgICAgICBjYXNlIFwidWludDY0XCI6XG4gICAgICAgIGNhc2UgXCJzaW50NjRcIjpcbiAgICAgICAgY2FzZSBcImZpeGVkNjRcIjpcbiAgICAgICAgY2FzZSBcInNmaXhlZDY0XCI6IGdlblxuICAgICAgICAgICAgKFwiaWYoIXV0aWwua2V5NjRSZS50ZXN0KCVzKSlcIiwgcmVmKSAvLyBzZWUgY29tbWVudCBhYm92ZTogeCBpcyBvaywgZCBpcyBub3RcbiAgICAgICAgICAgICAgICAoXCJyZXR1cm4lalwiLCBpbnZhbGlkKGZpZWxkLCBcImludGVnZXJ8TG9uZyBrZXlcIikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJib29sXCI6IGdlblxuICAgICAgICAgICAgKFwiaWYoIXV0aWwua2V5MlJlLnRlc3QoJXMpKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJib29sZWFuIGtleVwiKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGdlbjtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVuZXhwZWN0ZWQtbXVsdGlsaW5lICovXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdmVyaWZpZXIgc3BlY2lmaWMgdG8gdGhlIHNwZWNpZmllZCBtZXNzYWdlIHR5cGUuXG4gKiBAcGFyYW0ge1R5cGV9IG10eXBlIE1lc3NhZ2UgdHlwZVxuICogQHJldHVybnMge0NvZGVnZW59IENvZGVnZW4gaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gdmVyaWZpZXIobXR5cGUpIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xuXG4gICAgdmFyIGdlbiA9IHV0aWwuY29kZWdlbihbXCJtXCJdLCBtdHlwZS5uYW1lICsgXCIkdmVyaWZ5XCIpXG4gICAgKFwiaWYodHlwZW9mIG0hPT1cXFwib2JqZWN0XFxcInx8bT09PW51bGwpXCIpXG4gICAgICAgIChcInJldHVybiVqXCIsIFwib2JqZWN0IGV4cGVjdGVkXCIpO1xuICAgIHZhciBvbmVvZnMgPSBtdHlwZS5vbmVvZnNBcnJheSxcbiAgICAgICAgc2VlbkZpcnN0RmllbGQgPSB7fTtcbiAgICBpZiAob25lb2ZzLmxlbmd0aCkgZ2VuXG4gICAgKFwidmFyIHA9e31cIik7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IC8qIGluaXRpYWxpemVzICovIG10eXBlLmZpZWxkc0FycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmaWVsZCA9IG10eXBlLl9maWVsZHNBcnJheVtpXS5yZXNvbHZlKCksXG4gICAgICAgICAgICByZWYgICA9IFwibVwiICsgdXRpbC5zYWZlUHJvcChmaWVsZC5uYW1lKTtcblxuICAgICAgICBpZiAoZmllbGQub3B0aW9uYWwpIGdlblxuICAgICAgICAoXCJpZiglcyE9bnVsbCYmbS5oYXNPd25Qcm9wZXJ0eSglaikpe1wiLCByZWYsIGZpZWxkLm5hbWUpOyAvLyAhPT0gdW5kZWZpbmVkICYmICE9PSBudWxsXG5cbiAgICAgICAgLy8gbWFwIGZpZWxkc1xuICAgICAgICBpZiAoZmllbGQubWFwKSB7IGdlblxuICAgICAgICAgICAgKFwiaWYoIXV0aWwuaXNPYmplY3QoJXMpKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJvYmplY3RcIikpXG4gICAgICAgICAgICAoXCJ2YXIgaz1PYmplY3Qua2V5cyglcylcIiwgcmVmKVxuICAgICAgICAgICAgKFwiZm9yKHZhciBpPTA7aTxrLmxlbmd0aDsrK2kpe1wiKTtcbiAgICAgICAgICAgICAgICBnZW5WZXJpZnlLZXkoZ2VuLCBmaWVsZCwgXCJrW2ldXCIpO1xuICAgICAgICAgICAgICAgIGdlblZlcmlmeVZhbHVlKGdlbiwgZmllbGQsIGksIHJlZiArIFwiW2tbaV1dXCIpXG4gICAgICAgICAgICAoXCJ9XCIpO1xuXG4gICAgICAgIC8vIHJlcGVhdGVkIGZpZWxkc1xuICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnJlcGVhdGVkKSB7IGdlblxuICAgICAgICAgICAgKFwiaWYoIUFycmF5LmlzQXJyYXkoJXMpKVwiLCByZWYpXG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgaW52YWxpZChmaWVsZCwgXCJhcnJheVwiKSlcbiAgICAgICAgICAgIChcImZvcih2YXIgaT0wO2k8JXMubGVuZ3RoOysraSl7XCIsIHJlZik7XG4gICAgICAgICAgICAgICAgZ2VuVmVyaWZ5VmFsdWUoZ2VuLCBmaWVsZCwgaSwgcmVmICsgXCJbaV1cIilcbiAgICAgICAgICAgIChcIn1cIik7XG5cbiAgICAgICAgLy8gcmVxdWlyZWQgb3IgcHJlc2VudCBmaWVsZHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmaWVsZC5wYXJ0T2YpIHtcbiAgICAgICAgICAgICAgICB2YXIgb25lb2ZQcm9wID0gdXRpbC5zYWZlUHJvcChmaWVsZC5wYXJ0T2YubmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5GaXJzdEZpZWxkW2ZpZWxkLnBhcnRPZi5uYW1lXSA9PT0gMSkgZ2VuXG4gICAgICAgICAgICAoXCJpZihwJXM9PT0xKVwiLCBvbmVvZlByb3ApXG4gICAgICAgICAgICAgICAgKFwicmV0dXJuJWpcIiwgZmllbGQucGFydE9mLm5hbWUgKyBcIjogbXVsdGlwbGUgdmFsdWVzXCIpO1xuICAgICAgICAgICAgICAgIHNlZW5GaXJzdEZpZWxkW2ZpZWxkLnBhcnRPZi5uYW1lXSA9IDE7XG4gICAgICAgICAgICAgICAgZ2VuXG4gICAgICAgICAgICAoXCJwJXM9MVwiLCBvbmVvZlByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuVmVyaWZ5VmFsdWUoZ2VuLCBmaWVsZCwgaSwgcmVmKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQub3B0aW9uYWwpIGdlblxuICAgICAgICAoXCJ9XCIpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuXG4gICAgKFwicmV0dXJuIG51bGxcIik7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bmV4cGVjdGVkLW11bHRpbGluZSAqL1xufSJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwidmVyaWZpZXIiLCJFbnVtIiwicmVxdWlyZSIsInV0aWwiLCJpbnZhbGlkIiwiZmllbGQiLCJleHBlY3RlZCIsIm5hbWUiLCJyZXBlYXRlZCIsIm1hcCIsImtleVR5cGUiLCJnZW5WZXJpZnlWYWx1ZSIsImdlbiIsImZpZWxkSW5kZXgiLCJyZWYiLCJyZXNvbHZlZFR5cGUiLCJrZXlzIiwiT2JqZWN0IiwidmFsdWVzIiwiaiIsImxlbmd0aCIsInR5cGUiLCJnZW5WZXJpZnlLZXkiLCJtdHlwZSIsImNvZGVnZW4iLCJvbmVvZnMiLCJvbmVvZnNBcnJheSIsInNlZW5GaXJzdEZpZWxkIiwiaSIsImZpZWxkc0FycmF5IiwiX2ZpZWxkc0FycmF5IiwicmVzb2x2ZSIsInNhZmVQcm9wIiwib3B0aW9uYWwiLCJwYXJ0T2YiLCJvbmVvZlByb3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/verifier.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/wrappers.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/wrappers.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Wrappers for common types.\n * @type {Object.<string,IWrapper>}\n * @const\n */ var wrappers = exports;\nvar Message = __webpack_require__(/*! ./message */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/message.js\");\n/**\n * From object converter part of an {@link IWrapper}.\n * @typedef WrapperFromObjectConverter\n * @type {function}\n * @param {Object.<string,*>} object Plain object\n * @returns {Message<{}>} Message instance\n * @this Type\n */ /**\n * To object converter part of an {@link IWrapper}.\n * @typedef WrapperToObjectConverter\n * @type {function}\n * @param {Message<{}>} message Message instance\n * @param {IConversionOptions} [options] Conversion options\n * @returns {Object.<string,*>} Plain object\n * @this Type\n */ /**\n * Common type wrapper part of {@link wrappers}.\n * @interface IWrapper\n * @property {WrapperFromObjectConverter} [fromObject] From object converter\n * @property {WrapperToObjectConverter} [toObject] To object converter\n */ // Custom wrapper for Any\nwrappers[\".google.protobuf.Any\"] = {\n    fromObject: function(object) {\n        // unwrap value type if mapped\n        if (object && object[\"@type\"]) {\n            // Only use fully qualified type name after the last '/'\n            var name = object[\"@type\"].substring(object[\"@type\"].lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */ if (type) {\n                // type_url does not accept leading \".\"\n                var type_url = object[\"@type\"].charAt(0) === \".\" ? object[\"@type\"].slice(1) : object[\"@type\"];\n                // type_url prefix is optional, but path seperator is required\n                if (type_url.indexOf(\"/\") === -1) {\n                    type_url = \"/\" + type_url;\n                }\n                return this.create({\n                    type_url: type_url,\n                    value: type.encode(type.fromObject(object)).finish()\n                });\n            }\n        }\n        return this.fromObject(object);\n    },\n    toObject: function(message, options) {\n        // Default prefix\n        var googleApi = \"type.googleapis.com/\";\n        var prefix = \"\";\n        var name = \"\";\n        // decode value if requested and unmapped\n        if (options && options.json && message.type_url && message.value) {\n            // Only use fully qualified type name after the last '/'\n            name = message.type_url.substring(message.type_url.lastIndexOf(\"/\") + 1);\n            // Separate the prefix used\n            prefix = message.type_url.substring(0, message.type_url.lastIndexOf(\"/\") + 1);\n            var type = this.lookup(name);\n            /* istanbul ignore else */ if (type) message = type.decode(message.value);\n        }\n        // wrap value if unmapped\n        if (!(message instanceof this.ctor) && message instanceof Message) {\n            var object = message.$type.toObject(message, options);\n            var messageName = message.$type.fullName[0] === \".\" ? message.$type.fullName.slice(1) : message.$type.fullName;\n            // Default to type.googleapis.com prefix if no prefix is used\n            if (prefix === \"\") {\n                prefix = googleApi;\n            }\n            name = prefix + messageName;\n            object[\"@type\"] = name;\n            return object;\n        }\n        return this.toObject(message, options);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JhcHBlcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFFYjs7OztDQUlDLEdBQ0QsSUFBSUEsV0FBV0M7QUFFZixJQUFJQyxVQUFVQyxtQkFBT0EsQ0FBQyw0RkFBVztBQUVqQzs7Ozs7OztDQU9DLEdBRUQ7Ozs7Ozs7O0NBUUMsR0FFRDs7Ozs7Q0FLQyxHQUVELHlCQUF5QjtBQUN6QkgsUUFBUSxDQUFDLHVCQUF1QixHQUFHO0lBRS9CSSxZQUFZLFNBQVNDLE1BQU07UUFFdkIsOEJBQThCO1FBQzlCLElBQUlBLFVBQVVBLE1BQU0sQ0FBQyxRQUFRLEVBQUU7WUFDMUIsd0RBQXdEO1lBQ3pELElBQUlDLE9BQU9ELE1BQU0sQ0FBQyxRQUFRLENBQUNFLFNBQVMsQ0FBQ0YsTUFBTSxDQUFDLFFBQVEsQ0FBQ0csV0FBVyxDQUFDLE9BQU87WUFDeEUsSUFBSUMsT0FBTyxJQUFJLENBQUNDLE1BQU0sQ0FBQ0o7WUFDdkIsd0JBQXdCLEdBQ3hCLElBQUlHLE1BQU07Z0JBQ04sdUNBQXVDO2dCQUN2QyxJQUFJRSxXQUFXTixNQUFNLENBQUMsUUFBUSxDQUFDTyxNQUFNLENBQUMsT0FBTyxNQUN6Q1AsTUFBTSxDQUFDLFFBQVEsQ0FBQ1EsS0FBSyxDQUFDLEtBQUtSLE1BQU0sQ0FBQyxRQUFRO2dCQUM5Qyw4REFBOEQ7Z0JBQzlELElBQUlNLFNBQVNHLE9BQU8sQ0FBQyxTQUFTLENBQUMsR0FBRztvQkFDOUJILFdBQVcsTUFBTUE7Z0JBQ3JCO2dCQUNBLE9BQU8sSUFBSSxDQUFDSSxNQUFNLENBQUM7b0JBQ2ZKLFVBQVVBO29CQUNWSyxPQUFPUCxLQUFLUSxNQUFNLENBQUNSLEtBQUtMLFVBQVUsQ0FBQ0MsU0FBU2EsTUFBTTtnQkFDdEQ7WUFDSjtRQUNKO1FBRUEsT0FBTyxJQUFJLENBQUNkLFVBQVUsQ0FBQ0M7SUFDM0I7SUFFQWMsVUFBVSxTQUFTQyxPQUFPLEVBQUVDLE9BQU87UUFFL0IsaUJBQWlCO1FBQ2pCLElBQUlDLFlBQVk7UUFDaEIsSUFBSUMsU0FBUztRQUNiLElBQUlqQixPQUFPO1FBRVgseUNBQXlDO1FBQ3pDLElBQUllLFdBQVdBLFFBQVFHLElBQUksSUFBSUosUUFBUVQsUUFBUSxJQUFJUyxRQUFRSixLQUFLLEVBQUU7WUFDOUQsd0RBQXdEO1lBQ3hEVixPQUFPYyxRQUFRVCxRQUFRLENBQUNKLFNBQVMsQ0FBQ2EsUUFBUVQsUUFBUSxDQUFDSCxXQUFXLENBQUMsT0FBTztZQUN0RSwyQkFBMkI7WUFDM0JlLFNBQVNILFFBQVFULFFBQVEsQ0FBQ0osU0FBUyxDQUFDLEdBQUdhLFFBQVFULFFBQVEsQ0FBQ0gsV0FBVyxDQUFDLE9BQU87WUFDM0UsSUFBSUMsT0FBTyxJQUFJLENBQUNDLE1BQU0sQ0FBQ0o7WUFDdkIsd0JBQXdCLEdBQ3hCLElBQUlHLE1BQ0FXLFVBQVVYLEtBQUtnQixNQUFNLENBQUNMLFFBQVFKLEtBQUs7UUFDM0M7UUFFQSx5QkFBeUI7UUFDekIsSUFBSSxDQUFFSSxDQUFBQSxtQkFBbUIsSUFBSSxDQUFDTSxJQUFJLEtBQUtOLG1CQUFtQmxCLFNBQVM7WUFDL0QsSUFBSUcsU0FBU2UsUUFBUU8sS0FBSyxDQUFDUixRQUFRLENBQUNDLFNBQVNDO1lBQzdDLElBQUlPLGNBQWNSLFFBQVFPLEtBQUssQ0FBQ0UsUUFBUSxDQUFDLEVBQUUsS0FBSyxNQUM1Q1QsUUFBUU8sS0FBSyxDQUFDRSxRQUFRLENBQUNoQixLQUFLLENBQUMsS0FBS08sUUFBUU8sS0FBSyxDQUFDRSxRQUFRO1lBQzVELDZEQUE2RDtZQUM3RCxJQUFJTixXQUFXLElBQUk7Z0JBQ2ZBLFNBQVNEO1lBQ2I7WUFDQWhCLE9BQU9pQixTQUFTSztZQUNoQnZCLE1BQU0sQ0FBQyxRQUFRLEdBQUdDO1lBQ2xCLE9BQU9EO1FBQ1g7UUFFQSxPQUFPLElBQUksQ0FBQ2MsUUFBUSxDQUFDQyxTQUFTQztJQUNsQztBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL3Byb3RvYnVmanMvc3JjL3dyYXBwZXJzLmpzPzVkNTUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogV3JhcHBlcnMgZm9yIGNvbW1vbiB0eXBlcy5cbiAqIEB0eXBlIHtPYmplY3QuPHN0cmluZyxJV3JhcHBlcj59XG4gKiBAY29uc3RcbiAqL1xudmFyIHdyYXBwZXJzID0gZXhwb3J0cztcblxudmFyIE1lc3NhZ2UgPSByZXF1aXJlKFwiLi9tZXNzYWdlXCIpO1xuXG4vKipcbiAqIEZyb20gb2JqZWN0IGNvbnZlcnRlciBwYXJ0IG9mIGFuIHtAbGluayBJV3JhcHBlcn0uXG4gKiBAdHlwZWRlZiBXcmFwcGVyRnJvbU9iamVjdENvbnZlcnRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtPYmplY3QuPHN0cmluZywqPn0gb2JqZWN0IFBsYWluIG9iamVjdFxuICogQHJldHVybnMge01lc3NhZ2U8e30+fSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAdGhpcyBUeXBlXG4gKi9cblxuLyoqXG4gKiBUbyBvYmplY3QgY29udmVydGVyIHBhcnQgb2YgYW4ge0BsaW5rIElXcmFwcGVyfS5cbiAqIEB0eXBlZGVmIFdyYXBwZXJUb09iamVjdENvbnZlcnRlclxuICogQHR5cGUge2Z1bmN0aW9ufVxuICogQHBhcmFtIHtNZXNzYWdlPHt9Pn0gbWVzc2FnZSBNZXNzYWdlIGluc3RhbmNlXG4gKiBAcGFyYW0ge0lDb252ZXJzaW9uT3B0aW9uc30gW29wdGlvbnNdIENvbnZlcnNpb24gb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdC48c3RyaW5nLCo+fSBQbGFpbiBvYmplY3RcbiAqIEB0aGlzIFR5cGVcbiAqL1xuXG4vKipcbiAqIENvbW1vbiB0eXBlIHdyYXBwZXIgcGFydCBvZiB7QGxpbmsgd3JhcHBlcnN9LlxuICogQGludGVyZmFjZSBJV3JhcHBlclxuICogQHByb3BlcnR5IHtXcmFwcGVyRnJvbU9iamVjdENvbnZlcnRlcn0gW2Zyb21PYmplY3RdIEZyb20gb2JqZWN0IGNvbnZlcnRlclxuICogQHByb3BlcnR5IHtXcmFwcGVyVG9PYmplY3RDb252ZXJ0ZXJ9IFt0b09iamVjdF0gVG8gb2JqZWN0IGNvbnZlcnRlclxuICovXG5cbi8vIEN1c3RvbSB3cmFwcGVyIGZvciBBbnlcbndyYXBwZXJzW1wiLmdvb2dsZS5wcm90b2J1Zi5BbnlcIl0gPSB7XG5cbiAgICBmcm9tT2JqZWN0OiBmdW5jdGlvbihvYmplY3QpIHtcblxuICAgICAgICAvLyB1bndyYXAgdmFsdWUgdHlwZSBpZiBtYXBwZWRcbiAgICAgICAgaWYgKG9iamVjdCAmJiBvYmplY3RbXCJAdHlwZVwiXSkge1xuICAgICAgICAgICAgIC8vIE9ubHkgdXNlIGZ1bGx5IHF1YWxpZmllZCB0eXBlIG5hbWUgYWZ0ZXIgdGhlIGxhc3QgJy8nXG4gICAgICAgICAgICB2YXIgbmFtZSA9IG9iamVjdFtcIkB0eXBlXCJdLnN1YnN0cmluZyhvYmplY3RbXCJAdHlwZVwiXS5sYXN0SW5kZXhPZihcIi9cIikgKyAxKTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy5sb29rdXAobmFtZSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAvLyB0eXBlX3VybCBkb2VzIG5vdCBhY2NlcHQgbGVhZGluZyBcIi5cIlxuICAgICAgICAgICAgICAgIHZhciB0eXBlX3VybCA9IG9iamVjdFtcIkB0eXBlXCJdLmNoYXJBdCgwKSA9PT0gXCIuXCIgP1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RbXCJAdHlwZVwiXS5zbGljZSgxKSA6IG9iamVjdFtcIkB0eXBlXCJdO1xuICAgICAgICAgICAgICAgIC8vIHR5cGVfdXJsIHByZWZpeCBpcyBvcHRpb25hbCwgYnV0IHBhdGggc2VwZXJhdG9yIGlzIHJlcXVpcmVkXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVfdXJsLmluZGV4T2YoXCIvXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlX3VybCA9IFwiL1wiICsgdHlwZV91cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGVfdXJsOiB0eXBlX3VybCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHR5cGUuZW5jb2RlKHR5cGUuZnJvbU9iamVjdChvYmplY3QpKS5maW5pc2goKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbU9iamVjdChvYmplY3QpO1xuICAgIH0sXG5cbiAgICB0b09iamVjdDogZnVuY3Rpb24obWVzc2FnZSwgb3B0aW9ucykge1xuXG4gICAgICAgIC8vIERlZmF1bHQgcHJlZml4XG4gICAgICAgIHZhciBnb29nbGVBcGkgPSBcInR5cGUuZ29vZ2xlYXBpcy5jb20vXCI7XG4gICAgICAgIHZhciBwcmVmaXggPSBcIlwiO1xuICAgICAgICB2YXIgbmFtZSA9IFwiXCI7XG5cbiAgICAgICAgLy8gZGVjb2RlIHZhbHVlIGlmIHJlcXVlc3RlZCBhbmQgdW5tYXBwZWRcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5qc29uICYmIG1lc3NhZ2UudHlwZV91cmwgJiYgbWVzc2FnZS52YWx1ZSkge1xuICAgICAgICAgICAgLy8gT25seSB1c2UgZnVsbHkgcXVhbGlmaWVkIHR5cGUgbmFtZSBhZnRlciB0aGUgbGFzdCAnLydcbiAgICAgICAgICAgIG5hbWUgPSBtZXNzYWdlLnR5cGVfdXJsLnN1YnN0cmluZyhtZXNzYWdlLnR5cGVfdXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuICAgICAgICAgICAgLy8gU2VwYXJhdGUgdGhlIHByZWZpeCB1c2VkXG4gICAgICAgICAgICBwcmVmaXggPSBtZXNzYWdlLnR5cGVfdXJsLnN1YnN0cmluZygwLCBtZXNzYWdlLnR5cGVfdXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmxvb2t1cChuYW1lKTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAodHlwZSlcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gdHlwZS5kZWNvZGUobWVzc2FnZS52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3cmFwIHZhbHVlIGlmIHVubWFwcGVkXG4gICAgICAgIGlmICghKG1lc3NhZ2UgaW5zdGFuY2VvZiB0aGlzLmN0b3IpICYmIG1lc3NhZ2UgaW5zdGFuY2VvZiBNZXNzYWdlKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0ID0gbWVzc2FnZS4kdHlwZS50b09iamVjdChtZXNzYWdlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlTmFtZSA9IG1lc3NhZ2UuJHR5cGUuZnVsbE5hbWVbMF0gPT09IFwiLlwiID9cbiAgICAgICAgICAgICAgICBtZXNzYWdlLiR0eXBlLmZ1bGxOYW1lLnNsaWNlKDEpIDogbWVzc2FnZS4kdHlwZS5mdWxsTmFtZTtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gdHlwZS5nb29nbGVhcGlzLmNvbSBwcmVmaXggaWYgbm8gcHJlZml4IGlzIHVzZWRcbiAgICAgICAgICAgIGlmIChwcmVmaXggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICBwcmVmaXggPSBnb29nbGVBcGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lID0gcHJlZml4ICsgbWVzc2FnZU5hbWU7XG4gICAgICAgICAgICBvYmplY3RbXCJAdHlwZVwiXSA9IG5hbWU7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudG9PYmplY3QobWVzc2FnZSwgb3B0aW9ucyk7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6WyJ3cmFwcGVycyIsImV4cG9ydHMiLCJNZXNzYWdlIiwicmVxdWlyZSIsImZyb21PYmplY3QiLCJvYmplY3QiLCJuYW1lIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJ0eXBlIiwibG9va3VwIiwidHlwZV91cmwiLCJjaGFyQXQiLCJzbGljZSIsImluZGV4T2YiLCJjcmVhdGUiLCJ2YWx1ZSIsImVuY29kZSIsImZpbmlzaCIsInRvT2JqZWN0IiwibWVzc2FnZSIsIm9wdGlvbnMiLCJnb29nbGVBcGkiLCJwcmVmaXgiLCJqc29uIiwiZGVjb2RlIiwiY3RvciIsIiR0eXBlIiwibWVzc2FnZU5hbWUiLCJmdWxsTmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/wrappers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = Writer;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\nvar BufferWriter; // cyclic\nvar LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */ function Op(fn, len, val) {\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */ this.fn = fn;\n    /**\n     * Value byte length.\n     * @type {number}\n     */ this.len = len;\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */ this.next = undefined;\n    /**\n     * Value to write.\n     * @type {*}\n     */ this.val = val; // type varies\n}\n/* istanbul ignore next */ function noop() {} // eslint-disable-line no-empty-function\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */ function State(writer) {\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */ this.head = writer.head;\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */ this.tail = writer.tail;\n    /**\n     * Current buffer length.\n     * @type {number}\n     */ this.len = writer.len;\n    /**\n     * Next state.\n     * @type {State|null}\n     */ this.next = writer.states;\n}\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */ function Writer() {\n    /**\n     * Current length.\n     * @type {number}\n     */ this.len = 0;\n    /**\n     * Operations head.\n     * @type {Object}\n     */ this.head = new Op(noop, 0, 0);\n    /**\n     * Operations tail\n     * @type {Object}\n     */ this.tail = this.head;\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */ this.states = null;\n// When a value is written, the writer calculates its byte length and puts it into a linked\n// list of operations to perform when finish() is called. This both allows us to allocate\n// buffers of the exact required size and reduces the amount of work we have to do compared\n// to first calculating over objects and then encoding over objects. In our case, the encoding\n// part is just a linked list walk calling operations with already prepared values.\n}\nvar create = function create() {\n    return util.Buffer ? function create_buffer_setup() {\n        return (Writer.create = function create_buffer() {\n            return new BufferWriter();\n        })();\n    } : function create_array() {\n        return new Writer();\n    };\n};\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */ Writer.create = create();\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */ Writer.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */ if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */ Writer.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\nfunction writeVarint32(val, buf, pos) {\n    while(val > 127){\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */ function VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;\n    return this;\n};\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.int32 = function write_int32(value) {\n    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n     : this.uint32(value);\n};\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\nfunction writeVarint64(val, buf, pos) {\n    while(val.hi){\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while(val.lo > 127){\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.int64 = Writer.prototype.uint64;\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\nfunction writeFixed32(val, buf, pos) {\n    buf[pos] = val & 255;\n    buf[pos + 1] = val >>> 8 & 255;\n    buf[pos + 2] = val >>> 16 & 255;\n    buf[pos + 3] = val >>> 24;\n}\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.sfixed32 = Writer.prototype.fixed32;\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */ Writer.prototype.sfixed64 = Writer.prototype.fixed64;\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\nvar writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {\n    buf.set(val, pos); // also works for plain array values\n} : function writeBytes_for(val, buf, pos) {\n    for(var i = 0; i < val.length; ++i)buf[pos + i] = val[i];\n};\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */ Writer.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len) return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */ Writer.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);\n};\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */ Writer.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */ Writer.prototype.reset = function reset() {\n    if (this.states) {\n        this.head = this.states.head;\n        this.tail = this.states.tail;\n        this.len = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len = 0;\n    }\n    return this;\n};\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */ Writer.prototype.ldelim = function ldelim() {\n    var head = this.head, tail = this.tail, len = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */ Writer.prototype.finish = function finish() {\n    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;\n    while(head){\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLE9BQU9DLE9BQU8sR0FBR0M7QUFFakIsSUFBSUMsT0FBWUMsbUJBQU9BLENBQUMsc0dBQWdCO0FBRXhDLElBQUlDLGNBQWMsU0FBUztBQUUzQixJQUFJQyxXQUFZSCxLQUFLRyxRQUFRLEVBQ3pCQyxTQUFZSixLQUFLSSxNQUFNLEVBQ3ZCQyxPQUFZTCxLQUFLSyxJQUFJO0FBRXpCOzs7Ozs7OztDQVFDLEdBQ0QsU0FBU0MsR0FBR0MsRUFBRSxFQUFFQyxHQUFHLEVBQUVDLEdBQUc7SUFFcEI7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRixFQUFFLEdBQUdBO0lBRVY7OztLQUdDLEdBQ0QsSUFBSSxDQUFDQyxHQUFHLEdBQUdBO0lBRVg7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRSxJQUFJLEdBQUdDO0lBRVo7OztLQUdDLEdBQ0QsSUFBSSxDQUFDRixHQUFHLEdBQUdBLEtBQUssY0FBYztBQUNsQztBQUVBLHdCQUF3QixHQUN4QixTQUFTRyxRQUFRLEVBQUUsd0NBQXdDO0FBRTNEOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxNQUFNQyxNQUFNO0lBRWpCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsSUFBSSxHQUFHRCxPQUFPQyxJQUFJO0lBRXZCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0MsSUFBSSxHQUFHRixPQUFPRSxJQUFJO0lBRXZCOzs7S0FHQyxHQUNELElBQUksQ0FBQ1IsR0FBRyxHQUFHTSxPQUFPTixHQUFHO0lBRXJCOzs7S0FHQyxHQUNELElBQUksQ0FBQ0UsSUFBSSxHQUFHSSxPQUFPRyxNQUFNO0FBQzdCO0FBRUE7Ozs7Q0FJQyxHQUNELFNBQVNsQjtJQUVMOzs7S0FHQyxHQUNELElBQUksQ0FBQ1MsR0FBRyxHQUFHO0lBRVg7OztLQUdDLEdBQ0QsSUFBSSxDQUFDTyxJQUFJLEdBQUcsSUFB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QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lY29tbWVyY2UtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyLmpzPzM2YTciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRlcjtcblxudmFyIHV0aWwgICAgICA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxudmFyIEJ1ZmZlcldyaXRlcjsgLy8gY3ljbGljXG5cbnZhciBMb25nQml0cyAgPSB1dGlsLkxvbmdCaXRzLFxuICAgIGJhc2U2NCAgICA9IHV0aWwuYmFzZTY0LFxuICAgIHV0ZjggICAgICA9IHV0aWwudXRmODtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB3cml0ZXIgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIFVpbnQ4QXJyYXksIG51bWJlcil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7Kn0gdmFsIFZhbHVlIHRvIHdyaXRlXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIE9wKGZuLCBsZW4sIHZhbCkge1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gY2FsbC5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24oVWludDhBcnJheSwgbnVtYmVyLCAqKX1cbiAgICAgKi9cbiAgICB0aGlzLmZuID0gZm47XG5cbiAgICAvKipcbiAgICAgKiBWYWx1ZSBieXRlIGxlbmd0aC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gbGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1dyaXRlci5PcHx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5uZXh0ID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogVmFsdWUgdG8gd3JpdGUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdGhpcy52YWwgPSB2YWw7IC8vIHR5cGUgdmFyaWVzXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBub29wKCkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1lbXB0eS1mdW5jdGlvblxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIHN0YXRlIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBDb3BpZWQgd3JpdGVyIHN0YXRlLlxuICogQG1lbWJlcm9mIFdyaXRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dyaXRlcn0gd3JpdGVyIFdyaXRlciB0byBjb3B5IHN0YXRlIGZyb21cbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gU3RhdGUod3JpdGVyKSB7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhlYWQuXG4gICAgICogQHR5cGUge1dyaXRlci5PcH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSB3cml0ZXIuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdGFpbC5cbiAgICAgKiBAdHlwZSB7V3JpdGVyLk9wfVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHdyaXRlci50YWlsO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBidWZmZXIgbGVuZ3RoLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5sZW4gPSB3cml0ZXIubGVuO1xuXG4gICAgLyoqXG4gICAgICogTmV4dCBzdGF0ZS5cbiAgICAgKiBAdHlwZSB7U3RhdGV8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLm5leHQgPSB3cml0ZXIuc3RhdGVzO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgd3JpdGVyIGluc3RhbmNlLlxuICogQGNsYXNzZGVzYyBXaXJlIGZvcm1hdCB3cml0ZXIgdXNpbmcgYFVpbnQ4QXJyYXlgIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGBBcnJheWAuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gV3JpdGVyKCkge1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBsZW5ndGguXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmxlbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIGhlYWQuXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmhlYWQgPSBuZXcgT3Aobm9vcCwgMCwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBPcGVyYXRpb25zIHRhaWxcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRoaXMudGFpbCA9IHRoaXMuaGVhZDtcblxuICAgIC8qKlxuICAgICAqIExpbmtlZCBmb3JrZWQgc3RhdGVzLlxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnN0YXRlcyA9IG51bGw7XG5cbiAgICAvLyBXaGVuIGEgdmFsdWUgaXMgd3JpdHRlbiwgdGhlIHdyaXRlciBjYWxjdWxhdGVzIGl0cyBieXRlIGxlbmd0aCBhbmQgcHV0cyBpdCBpbnRvIGEgbGlua2VkXG4gICAgLy8gbGlzdCBvZiBvcGVyYXRpb25zIHRvIHBlcmZvcm0gd2hlbiBmaW5pc2goKSBpcyBjYWxsZWQuIFRoaXMgYm90aCBhbGxvd3MgdXMgdG8gYWxsb2NhdGVcbiAgICAvLyBidWZmZXJzIG9mIHRoZSBleGFjdCByZXF1aXJlZCBzaXplIGFuZCByZWR1Y2VzIHRoZSBhbW91bnQgb2Ygd29yayB3ZSBoYXZlIHRvIGRvIGNvbXBhcmVkXG4gICAgLy8gdG8gZmlyc3QgY2FsY3VsYXRpbmcgb3ZlciBvYmplY3RzIGFuZCB0aGVuIGVuY29kaW5nIG92ZXIgb2JqZWN0cy4gSW4gb3VyIGNhc2UsIHRoZSBlbmNvZGluZ1xuICAgIC8vIHBhcnQgaXMganVzdCBhIGxpbmtlZCBsaXN0IHdhbGsgY2FsbGluZyBvcGVyYXRpb25zIHdpdGggYWxyZWFkeSBwcmVwYXJlZCB2YWx1ZXMuXG59XG5cbnZhciBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIHV0aWwuQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gY3JlYXRlX2J1ZmZlcl9zZXR1cCgpIHtcbiAgICAgICAgICAgIHJldHVybiAoV3JpdGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZV9idWZmZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJXcml0ZXIoKTtcbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgOiBmdW5jdGlvbiBjcmVhdGVfYXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdyaXRlcigpO1xuICAgICAgICB9O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHdyaXRlci5cbiAqIEBmdW5jdGlvblxuICogQHJldHVybnMge0J1ZmZlcldyaXRlcnxXcml0ZXJ9IEEge0BsaW5rIEJ1ZmZlcldyaXRlcn0gd2hlbiBCdWZmZXJzIGFyZSBzdXBwb3J0ZWQsIG90aGVyd2lzZSBhIHtAbGluayBXcml0ZXJ9XG4gKi9cbldyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcblxuLyoqXG4gKiBBbGxvY2F0ZXMgYSBidWZmZXIgb2YgdGhlIHNwZWNpZmllZCBzaXplLlxuICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBCdWZmZXJcbiAqL1xuV3JpdGVyLmFsbG9jID0gZnVuY3Rpb24gYWxsb2Moc2l6ZSkge1xuICAgIHJldHVybiBuZXcgdXRpbC5BcnJheShzaXplKTtcbn07XG5cbi8vIFVzZSBVaW50OEFycmF5IGJ1ZmZlciBwb29sIGluIHRoZSBicm93c2VyLCBqdXN0IGxpa2Ugbm9kZSBkb2VzIHdpdGggYnVmZmVyc1xuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbmlmICh1dGlsLkFycmF5ICE9PSBBcnJheSlcbiAgICBXcml0ZXIuYWxsb2MgPSB1dGlsLnBvb2woV3JpdGVyLmFsbG9jLCB1dGlsLkFycmF5LnByb3RvdHlwZS5zdWJhcnJheSk7XG5cbi8qKlxuICogUHVzaGVzIGEgbmV3IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIG51bWJlciwgKil9IGZuIEZ1bmN0aW9uIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHByaXZhdGVcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5fcHVzaCA9IGZ1bmN0aW9uIHB1c2goZm4sIGxlbiwgdmFsKSB7XG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgT3AoZm4sIGxlbiwgdmFsKTtcbiAgICB0aGlzLmxlbiArPSBsZW47XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUJ5dGUodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3NdID0gdmFsICYgMjU1O1xufVxuXG5mdW5jdGlvbiB3cml0ZVZhcmludDMyKHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwgJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbCA+Pj49IDc7XG4gICAgfVxuICAgIGJ1Zltwb3NdID0gdmFsO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgdmFyaW50IHdyaXRlciBvcGVyYXRpb24gaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFNjaGVkdWxlZCB2YXJpbnQgd3JpdGVyIG9wZXJhdGlvbi5cbiAqIEBleHRlbmRzIE9wXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gVmFsdWUgYnl0ZSBsZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWwgVmFsdWUgdG8gd3JpdGVcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gVmFyaW50T3AobGVuLCB2YWwpIHtcbiAgICB0aGlzLmxlbiA9IGxlbjtcbiAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy52YWwgPSB2YWw7XG59XG5cblZhcmludE9wLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoT3AucHJvdG90eXBlKTtcblZhcmludE9wLnByb3RvdHlwZS5mbiA9IHdyaXRlVmFyaW50MzI7XG5cbi8qKlxuICogV3JpdGVzIGFuIHVuc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDMyID0gZnVuY3Rpb24gd3JpdGVfdWludDMyKHZhbHVlKSB7XG4gICAgLy8gaGVyZSwgdGhlIGNhbGwgdG8gdGhpcy5wdXNoIGhhcyBiZWVuIGlubGluZWQgYW5kIGEgdmFyaW50IHNwZWNpZmljIE9wIHN1YmNsYXNzIGlzIHVzZWQuXG4gICAgLy8gdWludDMyIGlzIGJ5IGZhciB0aGUgbW9zdCBmcmVxdWVudGx5IHVzZWQgb3BlcmF0aW9uIGFuZCBiZW5lZml0cyBzaWduaWZpY2FudGx5IGZyb20gdGhpcy5cbiAgICB0aGlzLmxlbiArPSAodGhpcy50YWlsID0gdGhpcy50YWlsLm5leHQgPSBuZXcgVmFyaW50T3AoXG4gICAgICAgICh2YWx1ZSA9IHZhbHVlID4+PiAwKVxuICAgICAgICAgICAgICAgIDwgMTI4ICAgICAgID8gMVxuICAgICAgICA6IHZhbHVlIDwgMTYzODQgICAgID8gMlxuICAgICAgICA6IHZhbHVlIDwgMjA5NzE1MiAgID8gM1xuICAgICAgICA6IHZhbHVlIDwgMjY4NDM1NDU2ID8gNFxuICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgNSxcbiAgICB2YWx1ZSkpLmxlbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5pbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ludDMyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIDwgMFxuICAgICAgICA/IHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgMTAsIExvbmdCaXRzLmZyb21OdW1iZXIodmFsdWUpKSAvLyAxMCBieXRlcyBwZXIgc3BlY1xuICAgICAgICA6IHRoaXMudWludDMyKHZhbHVlKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgMzIgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNpbnQzMiA9IGZ1bmN0aW9uIHdyaXRlX3NpbnQzMih2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigodmFsdWUgPDwgMSBeIHZhbHVlID4+IDMxKSA+Pj4gMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZVZhcmludDY0KHZhbCwgYnVmLCBwb3MpIHtcbiAgICB3aGlsZSAodmFsLmhpKSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9ICh2YWwubG8gPj4+IDcgfCB2YWwuaGkgPDwgMjUpID4+PiAwO1xuICAgICAgICB2YWwuaGkgPj4+PSA3O1xuICAgIH1cbiAgICB3aGlsZSAodmFsLmxvID4gMTI3KSB7XG4gICAgICAgIGJ1Zltwb3MrK10gPSB2YWwubG8gJiAxMjcgfCAxMjg7XG4gICAgICAgIHZhbC5sbyA9IHZhbC5sbyA+Pj4gNztcbiAgICB9XG4gICAgYnVmW3BvcysrXSA9IHZhbC5sbztcbn1cblxuLyoqXG4gKiBXcml0ZXMgYW4gdW5zaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LlxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUudWludDY0ID0gZnVuY3Rpb24gd3JpdGVfdWludDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZVZhcmludDY0LCBiaXRzLmxlbmd0aCgpLCBiaXRzKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDY0IGJpdCB2YWx1ZSBhcyBhIHZhcmludC5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuaW50NjQgPSBXcml0ZXIucHJvdG90eXBlLnVpbnQ2NDtcblxuLyoqXG4gKiBXcml0ZXMgYSBzaWduZWQgNjQgYml0IHZhbHVlIGFzIGEgdmFyaW50LCB6aWctemFnIGVuY29kZWQuXG4gKiBAcGFyYW0ge0xvbmd8bnVtYmVyfHN0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICogQHRocm93cyB7VHlwZUVycm9yfSBJZiBgdmFsdWVgIGlzIGEgc3RyaW5nIGFuZCBubyBsb25nIGxpYnJhcnkgaXMgcHJlc2VudC5cbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5zaW50NjQgPSBmdW5jdGlvbiB3cml0ZV9zaW50NjQodmFsdWUpIHtcbiAgICB2YXIgYml0cyA9IExvbmdCaXRzLmZyb20odmFsdWUpLnp6RW5jb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3B1c2god3JpdGVWYXJpbnQ2NCwgYml0cy5sZW5ndGgoKSwgYml0cyk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGJvb2xpc2ggdmFsdWUgYXMgYSB2YXJpbnQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5ib29sID0gZnVuY3Rpb24gd3JpdGVfYm9vbCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgdmFsdWUgPyAxIDogMCk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUZpeGVkMzIodmFsLCBidWYsIHBvcykge1xuICAgIGJ1Zltwb3MgICAgXSA9ICB2YWwgICAgICAgICAmIDI1NTtcbiAgICBidWZbcG9zICsgMV0gPSAgdmFsID4+PiA4ICAgJiAyNTU7XG4gICAgYnVmW3BvcyArIDJdID0gIHZhbCA+Pj4gMTYgICYgMjU1O1xuICAgIGJ1Zltwb3MgKyAzXSA9ICB2YWwgPj4+IDI0O1xufVxuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCAzMiBiaXQgdmFsdWUgYXMgZml4ZWQgMzIgYml0cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZml4ZWQzMiA9IGZ1bmN0aW9uIHdyaXRlX2ZpeGVkMzIodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIHZhbHVlID4+PiAwKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgc2lnbmVkIDMyIGJpdCB2YWx1ZSBhcyBmaXhlZCAzMiBiaXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnNmaXhlZDMyID0gV3JpdGVyLnByb3RvdHlwZS5maXhlZDMyO1xuXG4vKipcbiAqIFdyaXRlcyBhbiB1bnNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBwYXJhbSB7TG9uZ3xudW1iZXJ8c3RyaW5nfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB2YWx1ZWAgaXMgYSBzdHJpbmcgYW5kIG5vIGxvbmcgbGlicmFyeSBpcyBwcmVzZW50LlxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZpeGVkNjQgPSBmdW5jdGlvbiB3cml0ZV9maXhlZDY0KHZhbHVlKSB7XG4gICAgdmFyIGJpdHMgPSBMb25nQml0cy5mcm9tKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUZpeGVkMzIsIDQsIGJpdHMubG8pLl9wdXNoKHdyaXRlRml4ZWQzMiwgNCwgYml0cy5oaSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHNpZ25lZCA2NCBiaXQgdmFsdWUgYXMgZml4ZWQgNjQgYml0cy5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtMb25nfG51bWJlcnxzdHJpbmd9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgYHZhbHVlYCBpcyBhIHN0cmluZyBhbmQgbm8gbG9uZyBsaWJyYXJ5IGlzIHByZXNlbnQuXG4gKi9cbldyaXRlci5wcm90b3R5cGUuc2ZpeGVkNjQgPSBXcml0ZXIucHJvdG90eXBlLmZpeGVkNjQ7XG5cbi8qKlxuICogV3JpdGVzIGEgZmxvYXQgKDMyIGJpdCkuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZVxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmxvYXQgPSBmdW5jdGlvbiB3cml0ZV9mbG9hdCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9wdXNoKHV0aWwuZmxvYXQud3JpdGVGbG9hdExFLCA0LCB2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIGRvdWJsZSAoNjQgYml0IGZsb2F0KS5cbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5kb3VibGUgPSBmdW5jdGlvbiB3cml0ZV9kb3VibGUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHVzaCh1dGlsLmZsb2F0LndyaXRlRG91YmxlTEUsIDgsIHZhbHVlKTtcbn07XG5cbnZhciB3cml0ZUJ5dGVzID0gdXRpbC5BcnJheS5wcm90b3R5cGUuc2V0XG4gICAgPyBmdW5jdGlvbiB3cml0ZUJ5dGVzX3NldCh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICB9XG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNfZm9yKHZhbCwgYnVmLCBwb3MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWwubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICBidWZbcG9zICsgaV0gPSB2YWxbaV07XG4gICAgfTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzZXF1ZW5jZSBvZiBieXRlcy5cbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IHZhbHVlIEJ1ZmZlciBvciBiYXNlNjQgZW5jb2RlZCBzdHJpbmcgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmJ5dGVzID0gZnVuY3Rpb24gd3JpdGVfYnl0ZXModmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoID4+PiAwO1xuICAgIGlmICghbGVuKVxuICAgICAgICByZXR1cm4gdGhpcy5fcHVzaCh3cml0ZUJ5dGUsIDEsIDApO1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICB2YXIgYnVmID0gV3JpdGVyLmFsbG9jKGxlbiA9IGJhc2U2NC5sZW5ndGgodmFsdWUpKTtcbiAgICAgICAgYmFzZTY0LmRlY29kZSh2YWx1ZSwgYnVmLCAwKTtcbiAgICAgICAgdmFsdWUgPSBidWY7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnVpbnQzMihsZW4pLl9wdXNoKHdyaXRlQnl0ZXMsIGxlbiwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBzdHJpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVmFsdWUgdG8gd3JpdGVcbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZyh2YWx1ZSkge1xuICAgIHZhciBsZW4gPSB1dGY4Lmxlbmd0aCh2YWx1ZSk7XG4gICAgcmV0dXJuIGxlblxuICAgICAgICA/IHRoaXMudWludDMyKGxlbikuX3B1c2godXRmOC53cml0ZSwgbGVuLCB2YWx1ZSlcbiAgICAgICAgOiB0aGlzLl9wdXNoKHdyaXRlQnl0ZSwgMSwgMCk7XG59O1xuXG4vKipcbiAqIEZvcmtzIHRoaXMgd3JpdGVyJ3Mgc3RhdGUgYnkgcHVzaGluZyBpdCB0byBhIHN0YWNrLlxuICogQ2FsbGluZyB7QGxpbmsgV3JpdGVyI3Jlc2V0fHJlc2V0fSBvciB7QGxpbmsgV3JpdGVyI2xkZWxpbXxsZGVsaW19IHJlc2V0cyB0aGUgd3JpdGVyIHRvIHRoZSBwcmV2aW91cyBzdGF0ZS5cbiAqIEByZXR1cm5zIHtXcml0ZXJ9IGB0aGlzYFxuICovXG5Xcml0ZXIucHJvdG90eXBlLmZvcmsgPSBmdW5jdGlvbiBmb3JrKCkge1xuICAgIHRoaXMuc3RhdGVzID0gbmV3IFN0YXRlKHRoaXMpO1xuICAgIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG5ldyBPcChub29wLCAwLCAwKTtcbiAgICB0aGlzLmxlbiA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlc2V0cyB0aGlzIGluc3RhbmNlIHRvIHRoZSBsYXN0IHN0YXRlLlxuICogQHJldHVybnMge1dyaXRlcn0gYHRoaXNgXG4gKi9cbldyaXRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZXMpIHtcbiAgICAgICAgdGhpcy5oZWFkICAgPSB0aGlzLnN0YXRlcy5oZWFkO1xuICAgICAgICB0aGlzLnRhaWwgICA9IHRoaXMuc3RhdGVzLnRhaWw7XG4gICAgICAgIHRoaXMubGVuICAgID0gdGhpcy5zdGF0ZXMubGVuO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHRoaXMuc3RhdGVzLm5leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbmV3IE9wKG5vb3AsIDAsIDApO1xuICAgICAgICB0aGlzLmxlbiAgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRvIHRoZSBsYXN0IHN0YXRlIGFuZCBhcHBlbmRzIHRoZSBmb3JrIHN0YXRlJ3MgY3VycmVudCB3cml0ZSBsZW5ndGggYXMgYSB2YXJpbnQgZm9sbG93ZWQgYnkgaXRzIG9wZXJhdGlvbnMuXG4gKiBAcmV0dXJucyB7V3JpdGVyfSBgdGhpc2BcbiAqL1xuV3JpdGVyLnByb3RvdHlwZS5sZGVsaW0gPSBmdW5jdGlvbiBsZGVsaW0oKSB7XG4gICAgdmFyIGhlYWQgPSB0aGlzLmhlYWQsXG4gICAgICAgIHRhaWwgPSB0aGlzLnRhaWwsXG4gICAgICAgIGxlbiAgPSB0aGlzLmxlbjtcbiAgICB0aGlzLnJlc2V0KCkudWludDMyKGxlbik7XG4gICAgaWYgKGxlbikge1xuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGhlYWQubmV4dDsgLy8gc2tpcCBub29wXG4gICAgICAgIHRoaXMudGFpbCA9IHRhaWw7XG4gICAgICAgIHRoaXMubGVuICs9IGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEZpbmlzaGVzIHRoZSB3cml0ZSBvcGVyYXRpb24uXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX0gRmluaXNoZWQgYnVmZmVyXG4gKi9cbldyaXRlci5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gZmluaXNoKCkge1xuICAgIHZhciBoZWFkID0gdGhpcy5oZWFkLm5leHQsIC8vIHNraXAgbm9vcFxuICAgICAgICBidWYgID0gdGhpcy5jb25zdHJ1Y3Rvci5hbGxvYyh0aGlzLmxlbiksXG4gICAgICAgIHBvcyAgPSAwO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICAgIGhlYWQuZm4oaGVhZC52YWwsIGJ1ZiwgcG9zKTtcbiAgICAgICAgcG9zICs9IGhlYWQubGVuO1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgIH1cbiAgICAvLyB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHJldHVybiBidWY7XG59O1xuXG5Xcml0ZXIuX2NvbmZpZ3VyZSA9IGZ1bmN0aW9uKEJ1ZmZlcldyaXRlcl8pIHtcbiAgICBCdWZmZXJXcml0ZXIgPSBCdWZmZXJXcml0ZXJfO1xuICAgIFdyaXRlci5jcmVhdGUgPSBjcmVhdGUoKTtcbiAgICBCdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwiV3JpdGVyIiwidXRpbCIsInJlcXVpcmUiLCJCdWZmZXJXcml0ZXIiLCJMb25nQml0cyIsImJhc2U2NCIsInV0ZjgiLCJPcCIsImZuIiwibGVuIiwidmFsIiwibmV4dCIsInVuZGVmaW5lZCIsIm5vb3AiLCJTdGF0ZSIsIndyaXRlciIsImhlYWQiLCJ0YWlsIiwic3RhdGVzIiwiY3JlYXRlIiwiQnVmZmVyIiwiY3JlYXRlX2J1ZmZlcl9zZXR1cCIsImNyZWF0ZV9idWZmZXIiLCJjcmVhdGVfYXJyYXkiLCJhbGxvYyIsInNpemUiLCJBcnJheSIsInBvb2wiLCJwcm90b3R5cGUiLCJzdWJhcnJheSIsIl9wdXNoIiwicHVzaCIsIndyaXRlQnl0ZSIsImJ1ZiIsInBvcyIsIndyaXRlVmFyaW50MzIiLCJWYXJpbnRPcCIsIk9iamVjdCIsInVpbnQzMiIsIndyaXRlX3VpbnQzMiIsInZhbHVlIiwiaW50MzIiLCJ3cml0ZV9pbnQzMiIsIndyaXRlVmFyaW50NjQiLCJmcm9tTnVtYmVyIiwic2ludDMyIiwid3JpdGVfc2ludDMyIiwiaGkiLCJsbyIsInVpbnQ2NCIsIndyaXRlX3VpbnQ2NCIsImJpdHMiLCJmcm9tIiwibGVuZ3RoIiwiaW50NjQiLCJzaW50NjQiLCJ3cml0ZV9zaW50NjQiLCJ6ekVuY29kZSIsImJvb2wiLCJ3cml0ZV9ib29sIiwid3JpdGVGaXhlZDMyIiwiZml4ZWQzMiIsIndyaXRlX2ZpeGVkMzIiLCJzZml4ZWQzMiIsImZpeGVkNjQiLCJ3cml0ZV9maXhlZDY0Iiwic2ZpeGVkNjQiLCJmbG9hdCIsIndyaXRlX2Zsb2F0Iiwid3JpdGVGbG9hdExFIiwiZG91YmxlIiwid3JpdGVfZG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlQnl0ZXMiLCJzZXQiLCJ3cml0ZUJ5dGVzX3NldCIsIndyaXRlQnl0ZXNfZm9yIiwiaSIsImJ5dGVzIiwid3JpdGVfYnl0ZXMiLCJpc1N0cmluZyIsImRlY29kZSIsInN0cmluZyIsIndyaXRlX3N0cmluZyIsIndyaXRlIiwiZm9yayIsInJlc2V0IiwibGRlbGltIiwiZmluaXNoIiwiY29uc3RydWN0b3IiLCJfY29uZmlndXJlIiwiQnVmZmVyV3JpdGVyXyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer_buffer.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer_buffer.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = BufferWriter;\n// extends Writer\nvar Writer = __webpack_require__(/*! ./writer */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer.js\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\nvar util = __webpack_require__(/*! ./util/minimal */ \"(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/util/minimal.js\");\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */ function BufferWriter() {\n    Writer.call(this);\n}\nBufferWriter._configure = function() {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */ BufferWriter.alloc = util._Buffer_allocUnsafe;\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\" ? function writeBytesBuffer_set(val, buf, pos) {\n        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n    // also works for plain array values\n    } : function writeBytesBuffer_copy(val, buf, pos) {\n        if (val.copy) val.copy(buf, pos, 0, val.length);\n        else for(var i = 0; i < val.length;)buf[pos++] = val[i++];\n    };\n};\n/**\n * @override\n */ BufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value)) value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len) this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write) buf.utf8Write(val, pos);\n    else buf.write(val, pos);\n}\n/**\n * @override\n */ BufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len) this._push(writeStringBuffer, len, value);\n    return this;\n};\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */ BufferWriter._configure();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvcHJvdG9idWZqcy9zcmMvd3JpdGVyX2J1ZmZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSxPQUFPQyxPQUFPLEdBQUdDO0FBRWpCLGlCQUFpQjtBQUNqQixJQUFJQyxTQUFTQyxtQkFBT0EsQ0FBQywwRkFBVTtBQUM5QkYsQ0FBQUEsYUFBYUcsU0FBUyxHQUFHQyxPQUFPQyxNQUFNLENBQUNKLE9BQU9FLFNBQVMsR0FBR0csV0FBVyxHQUFHTjtBQUV6RSxJQUFJTyxPQUFPTCxtQkFBT0EsQ0FBQyxzR0FBZ0I7QUFFbkM7Ozs7O0NBS0MsR0FDRCxTQUFTRjtJQUNMQyxPQUFPTyxJQUFJLENBQUMsSUFBSTtBQUNwQjtBQUVBUixhQUFhUyxVQUFVLEdBQUc7SUFDdEI7Ozs7O0tBS0MsR0FDRFQsYUFBYVUsS0FBSyxHQUFHSCxLQUFLSSxtQkFBbUI7SUFFN0NYLGFBQWFZLGdCQUFnQixHQUFHTCxLQUFLTSxNQUFNLElBQUlOLEtBQUtNLE1BQU0sQ0FBQ1YsU0FBUyxZQUFZVyxjQUFjUCxLQUFLTSxNQUFNLENBQUNWLFNBQVMsQ0FBQ1ksR0FBRyxDQUFDQyxJQUFJLEtBQUssUUFDM0gsU0FBU0MscUJBQXFCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRztRQUMzQ0QsSUFBSUosR0FBRyxDQUFDRyxLQUFLRSxNQUFNLHNHQUFzRztJQUN6SCxvQ0FBb0M7SUFDdEMsSUFFRSxTQUFTQyxzQkFBc0JILEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO1FBQzVDLElBQUlGLElBQUlJLElBQUksRUFDVkosSUFBSUksSUFBSSxDQUFDSCxLQUFLQyxLQUFLLEdBQUdGLElBQUlLLE1BQU07YUFDN0IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLElBQUlLLE1BQU0sRUFDakNKLEdBQUcsQ0FBQ0MsTUFBTSxHQUFHRixHQUFHLENBQUNNLElBQUk7SUFDekI7QUFDUjtBQUdBOztDQUVDLEdBQ0R4QixhQUFhRyxTQUFTLENBQUNzQixLQUFLLEdBQUcsU0FBU0MsbUJBQW1CQyxLQUFLO0lBQzVELElBQUlwQixLQUFLcUIsUUFBUSxDQUFDRCxRQUNkQSxRQUFRcEIsS0FBS3NCLFlBQVksQ0FBQ0YsT0FBTztJQUNyQyxJQUFJRyxNQUFNSCxNQUFNSixNQUFNLEtBQUs7SUFDM0IsSUFBSSxDQUFDUSxNQUFNLENBQUNEO0lBQ1osSUFBSUEsS0FDQSxJQUFJLENBQUNFLEtBQUssQ0FBQ2hDLGFBQWFZLGdCQUFnQixFQUFFa0IsS0FBS0g7SUFDbkQsT0FBTyxJQUFJO0FBQ2Y7QUFFQSxTQUFTTSxrQkFBa0JmLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHO0lBQ3BDLElBQUlGLElBQUlLLE1BQU0sR0FBRyxJQUNiaEIsS0FBSzJCLElBQUksQ0FBQ0MsS0FBSyxDQUFDakIsS0FBS0MsS0FBS0M7U0FDekIsSUFBSUQsSUFBSWlCLFNBQVMsRUFDbEJqQixJQUFJaUIsU0FBUyxDQUFDbEIsS0FBS0U7U0FFbkJELElBQUlnQixLQUFLLENBQUNqQixLQUFLRTtBQUN2QjtBQUVBOztDQUVDLEdBQ0RwQixhQUFhRyxTQUFTLENBQUNrQyxNQUFNLEdBQUcsU0FBU0Msb0JBQW9CWCxLQUFLO0lBQzlELElBQUlHLE1BQU12QixLQUFLTSxNQUFNLENBQUMwQixVQUFVLENBQUNaO0lBQ2pDLElBQUksQ0FBQ0ksTUFBTSxDQUFDRDtJQUNaLElBQUlBLEtBQ0EsSUFBSSxDQUFDRSxLQUFLLENBQUNDLG1CQUFtQkgsS0FBS0g7SUFDdkMsT0FBTyxJQUFJO0FBQ2Y7QUFHQTs7Ozs7Q0FLQyxHQUVEM0IsYUFBYVMsVUFBVSIsInNvdXJjZXMiOlsid2VicGFjazovL2Vjb21tZXJjZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AZ3JwYy9ncnBjLWpzL25vZGVfbW9kdWxlcy9wcm90b2J1ZmpzL3NyYy93cml0ZXJfYnVmZmVyLmpzPzkwYTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcldyaXRlcjtcblxuLy8gZXh0ZW5kcyBXcml0ZXJcbnZhciBXcml0ZXIgPSByZXF1aXJlKFwiLi93cml0ZXJcIik7XG4oQnVmZmVyV3JpdGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGVyLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yID0gQnVmZmVyV3JpdGVyO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWwvbWluaW1hbFwiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RzIGEgbmV3IGJ1ZmZlciB3cml0ZXIgaW5zdGFuY2UuXG4gKiBAY2xhc3NkZXNjIFdpcmUgZm9ybWF0IHdyaXRlciB1c2luZyBub2RlIGJ1ZmZlcnMuXG4gKiBAZXh0ZW5kcyBXcml0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBCdWZmZXJXcml0ZXIoKSB7XG4gICAgV3JpdGVyLmNhbGwodGhpcyk7XG59XG5cbkJ1ZmZlcldyaXRlci5fY29uZmlndXJlID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEFsbG9jYXRlcyBhIGJ1ZmZlciBvZiB0aGUgc3BlY2lmaWVkIHNpemUuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgQnVmZmVyIHNpemVcbiAgICAgKiBAcmV0dXJucyB7QnVmZmVyfSBCdWZmZXJcbiAgICAgKi9cbiAgICBCdWZmZXJXcml0ZXIuYWxsb2MgPSB1dGlsLl9CdWZmZXJfYWxsb2NVbnNhZmU7XG5cbiAgICBCdWZmZXJXcml0ZXIud3JpdGVCeXRlc0J1ZmZlciA9IHV0aWwuQnVmZmVyICYmIHV0aWwuQnVmZmVyLnByb3RvdHlwZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgdXRpbC5CdWZmZXIucHJvdG90eXBlLnNldC5uYW1lID09PSBcInNldFwiXG4gICAgICAgID8gZnVuY3Rpb24gd3JpdGVCeXRlc0J1ZmZlcl9zZXQodmFsLCBidWYsIHBvcykge1xuICAgICAgICAgIGJ1Zi5zZXQodmFsLCBwb3MpOyAvLyBmYXN0ZXIgdGhhbiBjb3B5IChyZXF1aXJlcyBub2RlID49IDQgd2hlcmUgQnVmZmVycyBleHRlbmQgVWludDhBcnJheSBhbmQgc2V0IGlzIHByb3Blcmx5IGluaGVyaXRlZClcbiAgICAgICAgICAvLyBhbHNvIHdvcmtzIGZvciBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICA6IGZ1bmN0aW9uIHdyaXRlQnl0ZXNCdWZmZXJfY29weSh2YWwsIGJ1ZiwgcG9zKSB7XG4gICAgICAgICAgaWYgKHZhbC5jb3B5KSAvLyBCdWZmZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWwuY29weShidWYsIHBvcywgMCwgdmFsLmxlbmd0aCk7XG4gICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7KSAvLyBwbGFpbiBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgIGJ1Zltwb3MrK10gPSB2YWxbaSsrXTtcbiAgICAgICAgfTtcbn07XG5cblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuQnVmZmVyV3JpdGVyLnByb3RvdHlwZS5ieXRlcyA9IGZ1bmN0aW9uIHdyaXRlX2J5dGVzX2J1ZmZlcih2YWx1ZSkge1xuICAgIGlmICh1dGlsLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB1dGlsLl9CdWZmZXJfZnJvbSh2YWx1ZSwgXCJiYXNlNjRcIik7XG4gICAgdmFyIGxlbiA9IHZhbHVlLmxlbmd0aCA+Pj4gMDtcbiAgICB0aGlzLnVpbnQzMihsZW4pO1xuICAgIGlmIChsZW4pXG4gICAgICAgIHRoaXMuX3B1c2goQnVmZmVyV3JpdGVyLndyaXRlQnl0ZXNCdWZmZXIsIGxlbiwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gd3JpdGVTdHJpbmdCdWZmZXIodmFsLCBidWYsIHBvcykge1xuICAgIGlmICh2YWwubGVuZ3RoIDwgNDApIC8vIHBsYWluIGpzIGlzIGZhc3RlciBmb3Igc2hvcnQgc3RyaW5ncyAocHJvYmFibHkgZHVlIHRvIHJlZHVuZGFudCBhc3NlcnRpb25zKVxuICAgICAgICB1dGlsLnV0Zjgud3JpdGUodmFsLCBidWYsIHBvcyk7XG4gICAgZWxzZSBpZiAoYnVmLnV0ZjhXcml0ZSlcbiAgICAgICAgYnVmLnV0ZjhXcml0ZSh2YWwsIHBvcyk7XG4gICAgZWxzZVxuICAgICAgICBidWYud3JpdGUodmFsLCBwb3MpO1xufVxuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5CdWZmZXJXcml0ZXIucHJvdG90eXBlLnN0cmluZyA9IGZ1bmN0aW9uIHdyaXRlX3N0cmluZ19idWZmZXIodmFsdWUpIHtcbiAgICB2YXIgbGVuID0gdXRpbC5CdWZmZXIuYnl0ZUxlbmd0aCh2YWx1ZSk7XG4gICAgdGhpcy51aW50MzIobGVuKTtcbiAgICBpZiAobGVuKVxuICAgICAgICB0aGlzLl9wdXNoKHdyaXRlU3RyaW5nQnVmZmVyLCBsZW4sIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblxuLyoqXG4gKiBGaW5pc2hlcyB0aGUgd3JpdGUgb3BlcmF0aW9uLlxuICogQG5hbWUgQnVmZmVyV3JpdGVyI2ZpbmlzaFxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBGaW5pc2hlZCBidWZmZXJcbiAqL1xuXG5CdWZmZXJXcml0ZXIuX2NvbmZpZ3VyZSgpO1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJCdWZmZXJXcml0ZXIiLCJXcml0ZXIiLCJyZXF1aXJlIiwicHJvdG90eXBlIiwiT2JqZWN0IiwiY3JlYXRlIiwiY29uc3RydWN0b3IiLCJ1dGlsIiwiY2FsbCIsIl9jb25maWd1cmUiLCJhbGxvYyIsIl9CdWZmZXJfYWxsb2NVbnNhZmUiLCJ3cml0ZUJ5dGVzQnVmZmVyIiwiQnVmZmVyIiwiVWludDhBcnJheSIsInNldCIsIm5hbWUiLCJ3cml0ZUJ5dGVzQnVmZmVyX3NldCIsInZhbCIsImJ1ZiIsInBvcyIsIndyaXRlQnl0ZXNCdWZmZXJfY29weSIsImNvcHkiLCJsZW5ndGgiLCJpIiwiYnl0ZXMiLCJ3cml0ZV9ieXRlc19idWZmZXIiLCJ2YWx1ZSIsImlzU3RyaW5nIiwiX0J1ZmZlcl9mcm9tIiwibGVuIiwidWludDMyIiwiX3B1c2giLCJ3cml0ZVN0cmluZ0J1ZmZlciIsInV0ZjgiLCJ3cml0ZSIsInV0ZjhXcml0ZSIsInN0cmluZyIsIndyaXRlX3N0cmluZ19idWZmZXIiLCJieXRlTGVuZ3RoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/src/writer_buffer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst camelCase = __webpack_require__(/*! lodash.camelcase */ \"(ssr)/./node_modules/lodash.camelcase/index.js\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nconst descriptor = __webpack_require__(/*! protobufjs/ext/descriptor */ \"(ssr)/./node_modules/protobufjs/ext/descriptor/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\");\nconst Long = __webpack_require__(/*! long */ \"(ssr)/./node_modules/long/src/long.js\");\nexports.Long = Long;\nfunction isAnyExtension(obj) {\n    return \"@type\" in obj && typeof obj[\"@type\"] === \"string\";\n}\nexports.isAnyExtension = isAnyExtension;\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true\n};\nfunction joinName(baseName, name) {\n    if (baseName === \"\") {\n        return name;\n    } else {\n        return baseName + \".\" + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [\n            [\n                objName,\n                obj\n            ]\n        ];\n    } else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== \"undefined\") {\n            return Object.keys(obj.nested).map((name)=>{\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            }).reduce((accumulator, currentValue)=>accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        if (Array.isArray(arg)) {\n            throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);\n        }\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */ const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: \"/\" + serviceName + \"/\" + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors)\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray){\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 DescriptorProto\",\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor(\"proto3\");\n    return {\n        format: \"Protocol Buffer 3 EnumDescriptorProto\",\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */ function createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    } else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    } else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    } else {\n        throw new Error(\"Type mismatch in reflection object handling\");\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor(\"proto3\").file;\n    const bufferList = descriptorList.map((value)=>Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, \"\")){\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.json Represent Infinity and NaN as strings in float fields,\n *     and automatically decode google.protobuf.Any values.\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */ function load(filename, options) {\n    return util_1.loadProtosWithOptions(filename, options).then((loadedRoot)=>{\n        return createPackageDefinition(loadedRoot, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const loadedRoot = util_1.loadProtosWithOptionsSync(filename, options);\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.loadSync = loadSync;\nfunction fromJSON(json, options) {\n    options = options || {};\n    const loadedRoot = Protobuf.Root.fromJSON(json);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(loadedRoot, options);\n}\nexports.fromJSON = fromJSON;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\nutil_1.addCommonProtos(); //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiOzs7Ozs7Ozs7Ozs7Ozs7O0NBZ0JDLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdELE1BQU1DLFlBQVlDLG1CQUFPQSxDQUFDLHdFQUFrQjtBQUM1QyxNQUFNQyxXQUFXRCxtQkFBT0EsQ0FBQyw0REFBWTtBQUNyQyxNQUFNRSxhQUFhRixtQkFBT0EsQ0FBQywwRkFBMkI7QUFDdEQsTUFBTUcsU0FBU0gsbUJBQU9BLENBQUMseUVBQVE7QUFDL0IsTUFBTUksT0FBT0osbUJBQU9BLENBQUMsbURBQU07QUFDM0JILFlBQVksR0FBR087QUFDZixTQUFTQyxlQUFlQyxHQUFHO0lBQ3ZCLE9BQU8sV0FBWUEsT0FBUyxPQUFPQSxHQUFHLENBQUMsUUFBUSxLQUFLO0FBQ3hEO0FBQ0FULHNCQUFzQixHQUFHUTtBQUN6QixNQUFNRSxvQkFBb0I7SUFDdEJDLE9BQU9DO0lBQ1BDLE9BQU9EO0lBQ1BFLE9BQU9GO0lBQ1BHLFVBQVU7SUFDVkMsUUFBUTtJQUNSQyxNQUFNO0FBQ1Y7QUFDQSxTQUFTQyxTQUFTQyxRQUFRLEVBQUVDLElBQUk7SUFDNUIsSUFBSUQsYUFBYSxJQUFJO1FBQ2pCLE9BQU9DO0lBQ1gsT0FDSztRQUNELE9BQU9ELFdBQVcsTUFBTUM7SUFDNUI7QUFDSjtBQUNBLFNBQVNDLDBCQUEwQlosR0FBRztJQUNsQyxPQUFRQSxlQUFlTCxTQUFTa0IsT0FBTyxJQUNuQ2IsZUFBZUwsU0FBU21CLElBQUksSUFDNUJkLGVBQWVMLFNBQVNvQixJQUFJO0FBQ3BDO0FBQ0EsU0FBU0MsZ0JBQWdCaEIsR0FBRztJQUN4QixPQUFPQSxlQUFlTCxTQUFTc0IsU0FBUyxJQUFJakIsZUFBZUwsU0FBU3VCLElBQUk7QUFDNUU7QUFDQSxTQUFTQywrQkFBK0JuQixHQUFHLEVBQUVvQixVQUFVO0lBQ25E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dG8tbG9hZGVyL2J1aWxkL3NyYy9pbmRleC5qcz81ZmE1Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoXCJsb2Rhc2guY2FtZWxjYXNlXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmNvbnN0IGRlc2NyaXB0b3IgPSByZXF1aXJlKFwicHJvdG9idWZqcy9leHQvZGVzY3JpcHRvclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBMb25nID0gcmVxdWlyZShcImxvbmdcIik7XG5leHBvcnRzLkxvbmcgPSBMb25nO1xuZnVuY3Rpb24gaXNBbnlFeHRlbnNpb24ob2JqKSB7XG4gICAgcmV0dXJuICgnQHR5cGUnIGluIG9iaikgJiYgKHR5cGVvZiBvYmpbJ0B0eXBlJ10gPT09ICdzdHJpbmcnKTtcbn1cbmV4cG9ydHMuaXNBbnlFeHRlbnNpb24gPSBpc0FueUV4dGVuc2lvbjtcbmNvbnN0IGRlc2NyaXB0b3JPcHRpb25zID0ge1xuICAgIGxvbmdzOiBTdHJpbmcsXG4gICAgZW51bXM6IFN0cmluZyxcbiAgICBieXRlczogU3RyaW5nLFxuICAgIGRlZmF1bHRzOiB0cnVlLFxuICAgIG9uZW9mczogdHJ1ZSxcbiAgICBqc29uOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGpvaW5OYW1lKGJhc2VOYW1lLCBuYW1lKSB7XG4gICAgaWYgKGJhc2VOYW1lID09PSAnJykge1xuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBiYXNlTmFtZSArICcuJyArIG5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopIHtcbiAgICByZXR1cm4gKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UgfHxcbiAgICAgICAgb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSB8fFxuICAgICAgICBvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKTtcbn1cbmZ1bmN0aW9uIGlzTmFtZXNwYWNlQmFzZShvYmopIHtcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgUHJvdG9idWYuTmFtZXNwYWNlIHx8IG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlJvb3Q7XG59XG5mdW5jdGlvbiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMob2JqLCBwYXJlbnROYW1lKSB7XG4gICAgY29uc3Qgb2JqTmFtZSA9IGpvaW5OYW1lKHBhcmVudE5hbWUsIG9iai5uYW1lKTtcbiAgICBpZiAoaXNIYW5kbGVkUmVmbGVjdGlvbk9iamVjdChvYmopKSB7XG4gICAgICAgIHJldHVybiBbW29iak5hbWUsIG9ial1dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGlzTmFtZXNwYWNlQmFzZShvYmopICYmIHR5cGVvZiBvYmoubmVzdGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iai5uZXN0ZWQpXG4gICAgICAgICAgICAgICAgLm1hcChuYW1lID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzKG9iai5uZXN0ZWRbbmFtZV0sIG9iak5hbWUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2N1bXVsYXRvciwgY3VycmVudFZhbHVlKSA9PiBhY2N1bXVsYXRvci5jb25jYXQoY3VycmVudFZhbHVlKSwgW10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURlc2VyaWFsaXplcihjbHMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gZGVzZXJpYWxpemUoYXJnQnVmKSB7XG4gICAgICAgIHJldHVybiBjbHMudG9PYmplY3QoY2xzLmRlY29kZShhcmdCdWYpLCBvcHRpb25zKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VyaWFsaXplcihjbHMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gc2VyaWFsaXplKGFyZykge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBzZXJpYWxpemUgbWVzc2FnZTogZXhwZWN0ZWQgb2JqZWN0IHdpdGggJHtjbHMubmFtZX0gc3RydWN0dXJlLCBnb3QgYXJyYXkgaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBjbHMuZnJvbU9iamVjdChhcmcpO1xuICAgICAgICByZXR1cm4gY2xzLmVuY29kZShtZXNzYWdlKS5maW5pc2goKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRGVmaW5pdGlvbihtZXRob2QsIHNlcnZpY2VOYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpIHtcbiAgICAvKiBUaGlzIGlzIG9ubHkgZXZlciBjYWxsZWQgYWZ0ZXIgdGhlIGNvcnJlc3BvbmRpbmcgcm9vdC5yZXNvbHZlQWxsKCksIHNvIHdlXG4gICAgICogY2FuIGFzc3VtZSB0aGF0IHRoZSByZXNvbHZlZCByZXF1ZXN0IGFuZCByZXNwb25zZSB0eXBlcyBhcmUgbm9uLW51bGwgKi9cbiAgICBjb25zdCByZXF1ZXN0VHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlcXVlc3RUeXBlO1xuICAgIGNvbnN0IHJlc3BvbnNlVHlwZSA9IG1ldGhvZC5yZXNvbHZlZFJlc3BvbnNlVHlwZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiAnLycgKyBzZXJ2aWNlTmFtZSArICcvJyArIG1ldGhvZC5uYW1lLFxuICAgICAgICByZXF1ZXN0U3RyZWFtOiAhIW1ldGhvZC5yZXF1ZXN0U3RyZWFtLFxuICAgICAgICByZXNwb25zZVN0cmVhbTogISFtZXRob2QucmVzcG9uc2VTdHJlYW0sXG4gICAgICAgIHJlcXVlc3RTZXJpYWxpemU6IGNyZWF0ZVNlcmlhbGl6ZXIocmVxdWVzdFR5cGUpLFxuICAgICAgICByZXF1ZXN0RGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXF1ZXN0VHlwZSwgb3B0aW9ucyksXG4gICAgICAgIHJlc3BvbnNlU2VyaWFsaXplOiBjcmVhdGVTZXJpYWxpemVyKHJlc3BvbnNlVHlwZSksXG4gICAgICAgIHJlc3BvbnNlRGVzZXJpYWxpemU6IGNyZWF0ZURlc2VyaWFsaXplcihyZXNwb25zZVR5cGUsIG9wdGlvbnMpLFxuICAgICAgICAvLyBUT0RPKG11cmdhdHJvaWQ5OSk6IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzXG4gICAgICAgIG9yaWdpbmFsTmFtZTogY2FtZWxDYXNlKG1ldGhvZC5uYW1lKSxcbiAgICAgICAgcmVxdWVzdFR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlcXVlc3RUeXBlLCBmaWxlRGVzY3JpcHRvcnMpLFxuICAgICAgICByZXNwb25zZVR5cGU6IGNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uKHJlc3BvbnNlVHlwZSwgZmlsZURlc2NyaXB0b3JzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU2VydmljZURlZmluaXRpb24oc2VydmljZSwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgZGVmID0ge307XG4gICAgZm9yIChjb25zdCBtZXRob2Qgb2Ygc2VydmljZS5tZXRob2RzQXJyYXkpIHtcbiAgICAgICAgZGVmW21ldGhvZC5uYW1lXSA9IGNyZWF0ZU1ldGhvZERlZmluaXRpb24obWV0aG9kLCBuYW1lLCBvcHRpb25zLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZURlZmluaXRpb24obWVzc2FnZSwgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgbWVzc2FnZURlc2NyaXB0b3IgPSBtZXNzYWdlLnRvRGVzY3JpcHRvcigncHJvdG8zJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZm9ybWF0OiAnUHJvdG9jb2wgQnVmZmVyIDMgRGVzY3JpcHRvclByb3RvJyxcbiAgICAgICAgdHlwZTogbWVzc2FnZURlc2NyaXB0b3IuJHR5cGUudG9PYmplY3QobWVzc2FnZURlc2NyaXB0b3IsIGRlc2NyaXB0b3JPcHRpb25zKSxcbiAgICAgICAgZmlsZURlc2NyaXB0b3JQcm90b3M6IGZpbGVEZXNjcmlwdG9ycyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlRW51bURlZmluaXRpb24oZW51bVR5cGUsIGZpbGVEZXNjcmlwdG9ycykge1xuICAgIGNvbnN0IGVudW1EZXNjcmlwdG9yID0gZW51bVR5cGUudG9EZXNjcmlwdG9yKCdwcm90bzMnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmb3JtYXQ6ICdQcm90b2NvbCBCdWZmZXIgMyBFbnVtRGVzY3JpcHRvclByb3RvJyxcbiAgICAgICAgdHlwZTogZW51bURlc2NyaXB0b3IuJHR5cGUudG9PYmplY3QoZW51bURlc2NyaXB0b3IsIGRlc2NyaXB0b3JPcHRpb25zKSxcbiAgICAgICAgZmlsZURlc2NyaXB0b3JQcm90b3M6IGZpbGVEZXNjcmlwdG9ycyxcbiAgICB9O1xufVxuLyoqXG4gKiBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuU2VydmljZSwgbmFtZTogc3RyaW5nLCBvcHRpb25zOlxuICogT3B0aW9ucyk6IFNlcnZpY2VEZWZpbml0aW9uOyBmdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iajogUHJvdG9idWYuVHlwZSxcbiAqIG5hbWU6IHN0cmluZywgb3B0aW9uczogT3B0aW9ucyk6IE1lc3NhZ2VUeXBlRGVmaW5pdGlvbjsgZnVuY3Rpb25cbiAqIGNyZWF0ZURlZmluaXRpb24ob2JqOiBQcm90b2J1Zi5FbnVtLCBuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IE9wdGlvbnMpOlxuICogRW51bVR5cGVEZWZpbml0aW9uO1xuICovXG5mdW5jdGlvbiBjcmVhdGVEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFByb3RvYnVmLlNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNlcnZpY2VEZWZpbml0aW9uKG9iaiwgbmFtZSwgb3B0aW9ucywgZmlsZURlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgUHJvdG9idWYuVHlwZSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlTWVzc2FnZURlZmluaXRpb24ob2JqLCBmaWxlRGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBQcm90b2J1Zi5FbnVtKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbnVtRGVmaW5pdGlvbihvYmosIGZpbGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1R5cGUgbWlzbWF0Y2ggaW4gcmVmbGVjdGlvbiBvYmplY3QgaGFuZGxpbmcnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihyb290LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGVmID0ge307XG4gICAgcm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgY29uc3QgZGVzY3JpcHRvckxpc3QgPSByb290LnRvRGVzY3JpcHRvcigncHJvdG8zJykuZmlsZTtcbiAgICBjb25zdCBidWZmZXJMaXN0ID0gZGVzY3JpcHRvckxpc3QubWFwKHZhbHVlID0+IEJ1ZmZlci5mcm9tKGRlc2NyaXB0b3IuRmlsZURlc2NyaXB0b3JQcm90by5lbmNvZGUodmFsdWUpLmZpbmlzaCgpKSk7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgb2JqXSBvZiBnZXRBbGxIYW5kbGVkUmVmbGVjdGlvbk9iamVjdHMocm9vdCwgJycpKSB7XG4gICAgICAgIGRlZltuYW1lXSA9IGNyZWF0ZURlZmluaXRpb24ob2JqLCBuYW1lLCBvcHRpb25zLCBidWZmZXJMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByb290ID0gUHJvdG9idWYuUm9vdC5mcm9tRGVzY3JpcHRvcihkZWNvZGVkRGVzY3JpcHRvclNldCk7XG4gICAgcm9vdC5yZXNvbHZlQWxsKCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKHJvb3QsIG9wdGlvbnMpO1xufVxuLyoqXG4gKiBMb2FkIGEgLnByb3RvIGZpbGUgd2l0aCB0aGUgc3BlY2lmaWVkIG9wdGlvbnMuXG4gKiBAcGFyYW0gZmlsZW5hbWUgT25lIG9yIG11bHRpcGxlIGZpbGUgcGF0aHMgdG8gbG9hZC4gQ2FuIGJlIGFuIGFic29sdXRlIHBhdGhcbiAqICAgICBvciByZWxhdGl2ZSB0byBhbiBpbmNsdWRlIHBhdGguXG4gKiBAcGFyYW0gb3B0aW9ucy5rZWVwQ2FzZSBQcmVzZXJ2ZSBmaWVsZCBuYW1lcy4gVGhlIGRlZmF1bHQgaXMgdG8gY2hhbmdlIHRoZW1cbiAqICAgICB0byBjYW1lbCBjYXNlLlxuICogQHBhcmFtIG9wdGlvbnMubG9uZ3MgVGhlIHR5cGUgdGhhdCBzaG91bGQgYmUgdXNlZCB0byByZXByZXNlbnQgYGxvbmdgIHZhbHVlcy5cbiAqICAgICBWYWxpZCBvcHRpb25zIGFyZSBgTnVtYmVyYCBhbmQgYFN0cmluZ2AuIERlZmF1bHRzIHRvIGEgYExvbmdgIG9iamVjdCB0eXBlXG4gKiAgICAgZnJvbSBhIGxpYnJhcnkuXG4gKiBAcGFyYW0gb3B0aW9ucy5lbnVtcyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgZW51bWAgdmFsdWVzLlxuICogICAgIFRoZSBvbmx5IHZhbGlkIG9wdGlvbiBpcyBgU3RyaW5nYC4gRGVmYXVsdHMgdG8gdGhlIG51bWVyaWMgdmFsdWUuXG4gKiBAcGFyYW0gb3B0aW9ucy5ieXRlcyBUaGUgdHlwZSB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHJlcHJlc2VudCBgYnl0ZXNgXG4gKiAgICAgdmFsdWVzLiBWYWxpZCBvcHRpb25zIGFyZSBgQXJyYXlgIGFuZCBgU3RyaW5nYC4gVGhlIGRlZmF1bHQgaXMgdG8gdXNlXG4gKiAgICAgYEJ1ZmZlcmAuXG4gKiBAcGFyYW0gb3B0aW9ucy5kZWZhdWx0cyBTZXQgZGVmYXVsdCB2YWx1ZXMgb24gb3V0cHV0IG9iamVjdHMuIERlZmF1bHRzIHRvXG4gKiAgICAgYGZhbHNlYC5cbiAqIEBwYXJhbSBvcHRpb25zLmFycmF5cyBTZXQgZW1wdHkgYXJyYXlzIGZvciBtaXNzaW5nIGFycmF5IHZhbHVlcyBldmVuIGlmXG4gKiAgICAgYGRlZmF1bHRzYCBpcyBgZmFsc2VgLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHBhcmFtIG9wdGlvbnMub2JqZWN0cyBTZXQgZW1wdHkgb2JqZWN0cyBmb3IgbWlzc2luZyBvYmplY3QgdmFsdWVzIGV2ZW4gaWZcbiAqICAgICBgZGVmYXVsdHNgIGlzIGBmYWxzZWAuIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gKiBAcGFyYW0gb3B0aW9ucy5vbmVvZnMgU2V0IHZpcnR1YWwgb25lb2YgcHJvcGVydGllcyB0byB0aGUgcHJlc2VudCBmaWVsZCdzXG4gKiAgICAgbmFtZVxuICogQHBhcmFtIG9wdGlvbnMuanNvbiBSZXByZXNlbnQgSW5maW5pdHkgYW5kIE5hTiBhcyBzdHJpbmdzIGluIGZsb2F0IGZpZWxkcyxcbiAqICAgICBhbmQgYXV0b21hdGljYWxseSBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLkFueSB2YWx1ZXMuXG4gKiBAcGFyYW0gb3B0aW9ucy5pbmNsdWRlRGlycyBQYXRocyB0byBzZWFyY2ggZm9yIGltcG9ydGVkIGAucHJvdG9gIGZpbGVzLlxuICovXG5mdW5jdGlvbiBsb2FkKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHV0aWxfMS5sb2FkUHJvdG9zV2l0aE9wdGlvbnMoZmlsZW5hbWUsIG9wdGlvbnMpLnRoZW4obG9hZGVkUm9vdCA9PiB7XG4gICAgICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5mdW5jdGlvbiBsb2FkU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSB1dGlsXzEubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyhmaWxlbmFtZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uKGxvYWRlZFJvb3QsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkU3luYyA9IGxvYWRTeW5jO1xuZnVuY3Rpb24gZnJvbUpTT04oanNvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSBQcm90b2J1Zi5Sb290LmZyb21KU09OKGpzb24pO1xuICAgIGxvYWRlZFJvb3QucmVzb2x2ZUFsbCgpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbihsb2FkZWRSb290LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZnJvbUpTT04gPSBmcm9tSlNPTjtcbmZ1bmN0aW9uIGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21CdWZmZXIoZGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlY29kZWREZXNjcmlwdG9yU2V0ID0gZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclNldC5kZWNvZGUoZGVzY3JpcHRvclNldCk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhY2thZ2VEZWZpbml0aW9uRnJvbURlc2NyaXB0b3JTZXQoZGVjb2RlZERlc2NyaXB0b3JTZXQsIG9wdGlvbnMpO1xufVxuZXhwb3J0cy5sb2FkRmlsZURlc2NyaXB0b3JTZXRGcm9tQnVmZmVyID0gbG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlcjtcbmZ1bmN0aW9uIGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QoZGVzY3JpcHRvclNldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGRlY29kZWREZXNjcmlwdG9yU2V0ID0gZGVzY3JpcHRvci5GaWxlRGVzY3JpcHRvclNldC5mcm9tT2JqZWN0KGRlc2NyaXB0b3JTZXQpO1xuICAgIHJldHVybiBjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbkZyb21EZXNjcmlwdG9yU2V0KGRlY29kZWREZXNjcmlwdG9yU2V0LCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbU9iamVjdCA9IGxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3Q7XG51dGlsXzEuYWRkQ29tbW9uUHJvdG9zKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjYW1lbENhc2UiLCJyZXF1aXJlIiwiUHJvdG9idWYiLCJkZXNjcmlwdG9yIiwidXRpbF8xIiwiTG9uZyIsImlzQW55RXh0ZW5zaW9uIiwib2JqIiwiZGVzY3JpcHRvck9wdGlvbnMiLCJsb25ncyIsIlN0cmluZyIsImVudW1zIiwiYnl0ZXMiLCJkZWZhdWx0cyIsIm9uZW9mcyIsImpzb24iLCJqb2luTmFtZSIsImJhc2VOYW1lIiwibmFtZSIsImlzSGFuZGxlZFJlZmxlY3Rpb25PYmplY3QiLCJTZXJ2aWNlIiwiVHlwZSIsIkVudW0iLCJpc05hbWVzcGFjZUJhc2UiLCJOYW1lc3BhY2UiLCJSb290IiwiZ2V0QWxsSGFuZGxlZFJlZmxlY3Rpb25PYmplY3RzIiwicGFyZW50TmFtZSIsIm9iak5hbWUiLCJuZXN0ZWQiLCJrZXlzIiwibWFwIiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJjdXJyZW50VmFsdWUiLCJjb25jYXQiLCJjcmVhdGVEZXNlcmlhbGl6ZXIiLCJjbHMiLCJvcHRpb25zIiwiZGVzZXJpYWxpemUiLCJhcmdCdWYiLCJ0b09iamVjdCIsImRlY29kZSIsImNyZWF0ZVNlcmlhbGl6ZXIiLCJzZXJpYWxpemUiLCJhcmciLCJBcnJheSIsImlzQXJyYXkiLCJFcnJvciIsIm1lc3NhZ2UiLCJmcm9tT2JqZWN0IiwiZW5jb2RlIiwiZmluaXNoIiwiY3JlYXRlTWV0aG9kRGVmaW5pdGlvbiIsIm1ldGhvZCIsInNlcnZpY2VOYW1lIiwiZmlsZURlc2NyaXB0b3JzIiwicmVxdWVzdFR5cGUiLCJyZXNvbHZlZFJlcXVlc3RUeXBlIiwicmVzcG9uc2VUeXBlIiwicmVzb2x2ZWRSZXNwb25zZVR5cGUiLCJwYXRoIiwicmVxdWVzdFN0cmVhbSIsInJlc3BvbnNlU3RyZWFtIiwicmVxdWVzdFNlcmlhbGl6ZSIsInJlcXVlc3REZXNlcmlhbGl6ZSIsInJlc3BvbnNlU2VyaWFsaXplIiwicmVzcG9uc2VEZXNlcmlhbGl6ZSIsIm9yaWdpbmFsTmFtZSIsImNyZWF0ZU1lc3NhZ2VEZWZpbml0aW9uIiwiY3JlYXRlU2VydmljZURlZmluaXRpb24iLCJzZXJ2aWNlIiwiZGVmIiwibWV0aG9kc0FycmF5IiwibWVzc2FnZURlc2NyaXB0b3IiLCJ0b0Rlc2NyaXB0b3IiLCJmb3JtYXQiLCJ0eXBlIiwiJHR5cGUiLCJmaWxlRGVzY3JpcHRvclByb3RvcyIsImNyZWF0ZUVudW1EZWZpbml0aW9uIiwiZW51bVR5cGUiLCJlbnVtRGVzY3JpcHRvciIsImNyZWF0ZURlZmluaXRpb24iLCJjcmVhdGVQYWNrYWdlRGVmaW5pdGlvbiIsInJvb3QiLCJyZXNvbHZlQWxsIiwiZGVzY3JpcHRvckxpc3QiLCJmaWxlIiwiYnVmZmVyTGlzdCIsIkJ1ZmZlciIsImZyb20iLCJGaWxlRGVzY3JpcHRvclByb3RvIiwiY3JlYXRlUGFja2FnZURlZmluaXRpb25Gcm9tRGVzY3JpcHRvclNldCIsImRlY29kZWREZXNjcmlwdG9yU2V0IiwiZnJvbURlc2NyaXB0b3IiLCJsb2FkIiwiZmlsZW5hbWUiLCJsb2FkUHJvdG9zV2l0aE9wdGlvbnMiLCJ0aGVuIiwibG9hZGVkUm9vdCIsImxvYWRTeW5jIiwibG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyIsImZyb21KU09OIiwibG9hZEZpbGVEZXNjcmlwdG9yU2V0RnJvbUJ1ZmZlciIsImRlc2NyaXB0b3JTZXQiLCJGaWxlRGVzY3JpcHRvclNldCIsImxvYWRGaWxlRGVzY3JpcHRvclNldEZyb21PYmplY3QiLCJhZGRDb21tb25Qcm90b3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js":
/*!***********************************************************!*\
  !*** ./node_modules/@grpc/proto-loader/build/src/util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Protobuf = __webpack_require__(/*! protobufjs */ \"(ssr)/./node_modules/protobufjs/index.js\");\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target)=>{\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths){\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            } catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nasync function loadProtosWithOptions(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error(\"The includeDirs option must be an array\"));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = await root.load(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptions = loadProtosWithOptions;\nfunction loadProtosWithOptionsSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error(\"The includeDirs option must be an array\");\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return loadedRoot;\n}\nexports.loadProtosWithOptionsSync = loadProtosWithOptionsSync;\n/**\n * Load Google's well-known proto files that aren't exposed by Protobuf.js.\n */ function addCommonProtos() {\n    // Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n    // and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n    // Using constant strings for compatibility with tools like Webpack\n    const apiDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/api.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/api.json\");\n    const descriptorDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/descriptor.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/descriptor.json\");\n    const sourceContextDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/source_context.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/source_context.json\");\n    const typeDescriptor = __webpack_require__(/*! protobufjs/google/protobuf/type.json */ \"(ssr)/./node_modules/protobufjs/google/protobuf/type.json\");\n    Protobuf.common(\"api\", apiDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"descriptor\", descriptorDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"source_context\", sourceContextDescriptor.nested.google.nested.protobuf.nested);\n    Protobuf.common(\"type\", typeDescriptor.nested.google.nested.protobuf.nested);\n}\nexports.addCommonProtos = addCommonProtos; //# sourceMappingURL=util.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvcHJvdG8tbG9hZGVyL2J1aWxkL3NyYy91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FnQkMsR0FDREEsOENBQTZDO0lBQUVHLE9BQU87QUFBSyxDQUFDLEVBQUM7QUFDN0QsTUFBTUMsS0FBS0MsbUJBQU9BLENBQUMsY0FBSTtBQUN2QixNQUFNQyxPQUFPRCxtQkFBT0EsQ0FBQyxrQkFBTTtBQUMzQixNQUFNRSxXQUFXRixtQkFBT0EsQ0FBQyw0REFBWTtBQUNyQyxTQUFTRyx1QkFBdUJDLElBQUksRUFBRUMsWUFBWTtJQUM5QyxNQUFNQyxzQkFBc0JGLEtBQUtHLFdBQVc7SUFDNUNILEtBQUtHLFdBQVcsR0FBRyxDQUFDQyxRQUFRQztRQUN4QixJQUFJUixLQUFLUyxVQUFVLENBQUNELFNBQVM7WUFDekIsT0FBT0E7UUFDWDtRQUNBLEtBQUssTUFBTUUsYUFBYU4sYUFBYztZQUNsQyxNQUFNTyxXQUFXWCxLQUFLWSxJQUFJLENBQUNGLFdBQVdGO1lBQ3RDLElBQUk7Z0JBQ0FWLEdBQUdlLFVBQVUsQ0FBQ0YsVUFBVWIsR0FBR2dCLFNBQVMsQ0FBQ0MsSUFBSTtnQkFDekMsT0FBT0o7WUFDWCxFQUNBLE9BQU9LLEtBQUs7Z0JBQ1I7WUFDSjtRQUNKO1FBQ0FDLFFBQVFDLFdBQVcsQ0FBQyxDQUFDLEVBQUVWLE9BQU8sdUNBQXVDLEVBQUVKLGFBQWEsQ0FBQztRQUNyRixPQUFPQyxvQkFBb0JFLFFBQVFDO0lBQ3ZDO0FBQ0o7QUFDQSxlQUFlVyxzQkFBc0JDLFFBQVEsRUFBRUMsT0FBTztJQUNsRCxNQUFNbEIsT0FBTyxJQUFJRixTQUFTcUIsSUFBSTtJQUM5QkQsVUFBVUEsV0FBVyxDQUFDO0lBQ3RCLElBQUksQ0FBQyxDQUFDQSxRQUFRRSxXQUFXLEVBQUU7UUFDdkIsSUFBSSxDQUFDQyxNQUFNQyxPQUFPLENBQUNKLFFBQVFFLFdBQVcsR0FBRztZQUNyQyxPQUFPRyxRQUFRQyxNQUFNLENBQUMsSUFBSUMsTUFBTTtRQUNwQztRQUNBMUIsdUJBQXVCQyxNQUFNa0IsUUFBUUUsV0FBVztJQUNwRDtJQUNBLE1BQU1NLGFBQWEsTUFBTTFCLEtBQUsyQixJQUFJLENBQUNWLFVBQVVDO0lBQzdDUSxXQUFXRSxVQUFVO0lBQ3JCLE9BQU9GO0FBQ1g7QUFDQWpDLDZCQUE2QixHQUFHdUI7QUFDaEMsU0FBU2EsMEJBQTBCWixRQUFRLEVBQUVDLE9BQU87SUFDaEQsTUFBTWxCLE9BQU8sSUFBSUYsU0FBU3FCLElBQUk7SUFDOUJELFVBQVVBLFdBQVcsQ0FBQztJQUN0QixJQUFJLENBQUMsQ0FBQ0EsUUFBUUUsV0FBVyxFQUFFO1FBQ3ZCLElBQUksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDSixRQUFRRSxXQUFXLEdBQUc7WUFDckMsTUFBTSxJQUFJSyxNQUFNO1FBQ3BCO1FBQ0ExQix1QkFBdUJDLE1BQU1rQixRQUFRRSxXQUFXO0lBQ3BEO0lBQ0EsTUFBTU0sYUFBYTFCLEtBQUs4QixRQUFRLENBQUNiLFVBQVVDO0lBQzNDUSxXQUFXRSxVQUFVO0lBQ3JCLE9BQU9GO0FBQ1g7QUFDQWpDLGlDQUFpQyxHQUFHb0M7QUFDcEM7O0NBRUMsR0FDRCxTQUFTRTtJQUNMLDRFQUE0RTtJQUM1RSxxRUFBcUU7SUFDckUsbUVBQW1FO0lBQ25FLE1BQU1DLGdCQUFnQnBDLG1CQUFPQSxDQUFDO0lBQzlCLE1BQU1xQyx1QkFBdUJyQyxtQkFBT0EsQ0FBQztJQUNyQyxNQUFNc0MsMEJBQTBCdEMsbUJBQU9BLENBQUM7SUFDeEMsTUFBTXVDLGlCQUFpQnZDLG1CQUFPQSxDQUFDO0lBQy9CRSxTQUFTc0MsTUFBTSxDQUFDLE9BQU9KLGNBQWNLLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRCxNQUFNLENBQUNFLFFBQVEsQ0FBQ0YsTUFBTTtJQUN6RXZDLFNBQVNzQyxNQUFNLENBQUMsY0FBY0gscUJBQXFCSSxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07SUFDdkZ2QyxTQUFTc0MsTUFBTSxDQUFDLGtCQUFrQkYsd0JBQXdCRyxNQUFNLENBQUNDLE1BQU0sQ0FBQ0QsTUFBTSxDQUFDRSxRQUFRLENBQUNGLE1BQU07SUFDOUZ2QyxTQUFTc0MsTUFBTSxDQUFDLFFBQVFELGVBQWVFLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDRCxNQUFNLENBQUNFLFFBQVEsQ0FBQ0YsTUFBTTtBQUMvRTtBQUNBNUMsdUJBQXVCLEdBQUdzQyxpQkFDMUIsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL3Byb3RvLWxvYWRlci9idWlsZC9zcmMvdXRpbC5qcz82NDFkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggZ1JQQyBhdXRob3JzLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgUHJvdG9idWYgPSByZXF1aXJlKFwicHJvdG9idWZqc1wiKTtcbmZ1bmN0aW9uIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgaW5jbHVkZVBhdGhzKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxSZXNvbHZlUGF0aCA9IHJvb3QucmVzb2x2ZVBhdGg7XG4gICAgcm9vdC5yZXNvbHZlUGF0aCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgICAgICBpZiAocGF0aC5pc0Fic29sdXRlKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBkaXJlY3Rvcnkgb2YgaW5jbHVkZVBhdGhzKSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihkaXJlY3RvcnksIHRhcmdldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLmFjY2Vzc1N5bmMoZnVsbFBhdGgsIGZzLmNvbnN0YW50cy5SX09LKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVsbFBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzcy5lbWl0V2FybmluZyhgJHt0YXJnZXR9IG5vdCBmb3VuZCBpbiBhbnkgb2YgdGhlIGluY2x1ZGUgcGF0aHMgJHtpbmNsdWRlUGF0aHN9YCk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlc29sdmVQYXRoKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICB9O1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zKGZpbGVuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgcm9vdCA9IG5ldyBQcm90b2J1Zi5Sb290KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCEhb3B0aW9ucy5pbmNsdWRlRGlycykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0aW9ucy5pbmNsdWRlRGlycykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRJbmNsdWRlUGF0aFJlc29sdmVyKHJvb3QsIG9wdGlvbnMuaW5jbHVkZURpcnMpO1xuICAgIH1cbiAgICBjb25zdCBsb2FkZWRSb290ID0gYXdhaXQgcm9vdC5sb2FkKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zID0gbG9hZFByb3Rvc1dpdGhPcHRpb25zO1xuZnVuY3Rpb24gbG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyhmaWxlbmFtZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJvb3QgPSBuZXcgUHJvdG9idWYuUm9vdCgpO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghIW9wdGlvbnMuaW5jbHVkZURpcnMpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5jbHVkZURpcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBpbmNsdWRlRGlycyBvcHRpb24gbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIocm9vdCwgb3B0aW9ucy5pbmNsdWRlRGlycyk7XG4gICAgfVxuICAgIGNvbnN0IGxvYWRlZFJvb3QgPSByb290LmxvYWRTeW5jKGZpbGVuYW1lLCBvcHRpb25zKTtcbiAgICBsb2FkZWRSb290LnJlc29sdmVBbGwoKTtcbiAgICByZXR1cm4gbG9hZGVkUm9vdDtcbn1cbmV4cG9ydHMubG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyA9IGxvYWRQcm90b3NXaXRoT3B0aW9uc1N5bmM7XG4vKipcbiAqIExvYWQgR29vZ2xlJ3Mgd2VsbC1rbm93biBwcm90byBmaWxlcyB0aGF0IGFyZW4ndCBleHBvc2VkIGJ5IFByb3RvYnVmLmpzLlxuICovXG5mdW5jdGlvbiBhZGRDb21tb25Qcm90b3MoKSB7XG4gICAgLy8gUHJvdG9idWYuanMgZXhwb3NlczogYW55LCBkdXJhdGlvbiwgZW1wdHksIGZpZWxkX21hc2ssIHN0cnVjdCwgdGltZXN0YW1wLFxuICAgIC8vIGFuZCB3cmFwcGVycy4gY29tcGlsZXIvcGx1Z2luIGlzIGV4Y2x1ZGVkIGluIFByb3RvYnVmLmpzIGFuZCBoZXJlLlxuICAgIC8vIFVzaW5nIGNvbnN0YW50IHN0cmluZ3MgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0b29scyBsaWtlIFdlYnBhY2tcbiAgICBjb25zdCBhcGlEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvYXBpLmpzb24nKTtcbiAgICBjb25zdCBkZXNjcmlwdG9yRGVzY3JpcHRvciA9IHJlcXVpcmUoJ3Byb3RvYnVmanMvZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0b3IuanNvbicpO1xuICAgIGNvbnN0IHNvdXJjZUNvbnRleHREZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvc291cmNlX2NvbnRleHQuanNvbicpO1xuICAgIGNvbnN0IHR5cGVEZXNjcmlwdG9yID0gcmVxdWlyZSgncHJvdG9idWZqcy9nb29nbGUvcHJvdG9idWYvdHlwZS5qc29uJyk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdhcGknLCBhcGlEZXNjcmlwdG9yLm5lc3RlZC5nb29nbGUubmVzdGVkLnByb3RvYnVmLm5lc3RlZCk7XG4gICAgUHJvdG9idWYuY29tbW9uKCdkZXNjcmlwdG9yJywgZGVzY3JpcHRvckRlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3NvdXJjZV9jb250ZXh0Jywgc291cmNlQ29udGV4dERlc2NyaXB0b3IubmVzdGVkLmdvb2dsZS5uZXN0ZWQucHJvdG9idWYubmVzdGVkKTtcbiAgICBQcm90b2J1Zi5jb21tb24oJ3R5cGUnLCB0eXBlRGVzY3JpcHRvci5uZXN0ZWQuZ29vZ2xlLm5lc3RlZC5wcm90b2J1Zi5uZXN0ZWQpO1xufVxuZXhwb3J0cy5hZGRDb21tb25Qcm90b3MgPSBhZGRDb21tb25Qcm90b3M7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImZzIiwicmVxdWlyZSIsInBhdGgiLCJQcm90b2J1ZiIsImFkZEluY2x1ZGVQYXRoUmVzb2x2ZXIiLCJyb290IiwiaW5jbHVkZVBhdGhzIiwib3JpZ2luYWxSZXNvbHZlUGF0aCIsInJlc29sdmVQYXRoIiwib3JpZ2luIiwidGFyZ2V0IiwiaXNBYnNvbHV0ZSIsImRpcmVjdG9yeSIsImZ1bGxQYXRoIiwiam9pbiIsImFjY2Vzc1N5bmMiLCJjb25zdGFudHMiLCJSX09LIiwiZXJyIiwicHJvY2VzcyIsImVtaXRXYXJuaW5nIiwibG9hZFByb3Rvc1dpdGhPcHRpb25zIiwiZmlsZW5hbWUiLCJvcHRpb25zIiwiUm9vdCIsImluY2x1ZGVEaXJzIiwiQXJyYXkiLCJpc0FycmF5IiwiUHJvbWlzZSIsInJlamVjdCIsIkVycm9yIiwibG9hZGVkUm9vdCIsImxvYWQiLCJyZXNvbHZlQWxsIiwibG9hZFByb3Rvc1dpdGhPcHRpb25zU3luYyIsImxvYWRTeW5jIiwiYWRkQ29tbW9uUHJvdG9zIiwiYXBpRGVzY3JpcHRvciIsImRlc2NyaXB0b3JEZXNjcmlwdG9yIiwic291cmNlQ29udGV4dERlc2NyaXB0b3IiLCJ0eXBlRGVzY3JpcHRvciIsImNvbW1vbiIsIm5lc3RlZCIsImdvb2dsZSIsInByb3RvYnVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/proto-loader/build/src/util.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/long/umd/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/long/umd/index.js ***!
  \*******************************************************************/
/***/ ((module, exports) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n// GENERATED FILE. DO NOT EDIT.\n(function(global, factory) {\n    function preferDefault(exports1) {\n        return exports1.default || exports1;\n    }\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            var exports1 = {};\n            factory(exports1);\n            return preferDefault(exports1);\n        }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(typeof globalThis !== \"undefined\" ? globalThis : typeof self !== \"undefined\" ? self : void 0, function(_exports) {\n    \"use strict\";\n    Object.defineProperty(_exports, \"__esModule\", {\n        value: true\n    });\n    _exports.default = void 0;\n    /**\n     * @license\n     * Copyright 2009 The Closure Library Authors\n     * Copyright 2020 Daniel Wirtz / The long.js Authors.\n     *\n     * Licensed under the Apache License, Version 2.0 (the \"License\");\n     * you may not use this file except in compliance with the License.\n     * You may obtain a copy of the License at\n     *\n     *     http://www.apache.org/licenses/LICENSE-2.0\n     *\n     * Unless required by applicable law or agreed to in writing, software\n     * distributed under the License is distributed on an \"AS IS\" BASIS,\n     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     * See the License for the specific language governing permissions and\n     * limitations under the License.\n     *\n     * SPDX-License-Identifier: Apache-2.0\n     */ // WebAssembly optimizations to do native i64 multiplication and divide\n    var wasm = null;\n    try {\n        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n            // \\0asm\n            0,\n            97,\n            115,\n            109,\n            // version 1\n            1,\n            0,\n            0,\n            0,\n            // section \"type\"\n            1,\n            13,\n            2,\n            // 0, () => i32\n            96,\n            0,\n            1,\n            127,\n            // 1, (i32, i32, i32, i32) => i32\n            96,\n            4,\n            127,\n            127,\n            127,\n            127,\n            1,\n            127,\n            // section \"function\"\n            3,\n            7,\n            6,\n            // 0, type 0\n            0,\n            // 1, type 1\n            1,\n            // 2, type 1\n            1,\n            // 3, type 1\n            1,\n            // 4, type 1\n            1,\n            // 5, type 1\n            1,\n            // section \"global\"\n            6,\n            6,\n            1,\n            // 0, \"high\", mutable i32\n            127,\n            1,\n            65,\n            0,\n            11,\n            // section \"export\"\n            7,\n            50,\n            6,\n            // 0, \"mul\"\n            3,\n            109,\n            117,\n            108,\n            0,\n            1,\n            // 1, \"div_s\"\n            5,\n            100,\n            105,\n            118,\n            95,\n            115,\n            0,\n            2,\n            // 2, \"div_u\"\n            5,\n            100,\n            105,\n            118,\n            95,\n            117,\n            0,\n            3,\n            // 3, \"rem_s\"\n            5,\n            114,\n            101,\n            109,\n            95,\n            115,\n            0,\n            4,\n            // 4, \"rem_u\"\n            5,\n            114,\n            101,\n            109,\n            95,\n            117,\n            0,\n            5,\n            // 5, \"get_high\"\n            8,\n            103,\n            101,\n            116,\n            95,\n            104,\n            105,\n            103,\n            104,\n            0,\n            0,\n            // section \"code\"\n            10,\n            191,\n            1,\n            6,\n            // 0, \"get_high\"\n            4,\n            0,\n            35,\n            0,\n            11,\n            // 1, \"mul\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            126,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 2, \"div_s\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            127,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 3, \"div_u\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            128,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 4, \"rem_s\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            129,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11,\n            // 5, \"rem_u\"\n            36,\n            1,\n            1,\n            126,\n            32,\n            0,\n            173,\n            32,\n            1,\n            173,\n            66,\n            32,\n            134,\n            132,\n            32,\n            2,\n            173,\n            32,\n            3,\n            173,\n            66,\n            32,\n            134,\n            132,\n            130,\n            34,\n            4,\n            66,\n            32,\n            135,\n            167,\n            36,\n            0,\n            32,\n            4,\n            167,\n            11\n        ])), {}).exports;\n    } catch  {\n    // no wasm support :(\n    }\n    /**\n     * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\n     *  See the from* functions below for more convenient ways of constructing Longs.\n     * @exports Long\n     * @class A Long class for representing a 64 bit two's-complement integer value.\n     * @param {number} low The low (signed) 32 bits of the long\n     * @param {number} high The high (signed) 32 bits of the long\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n     * @constructor\n     */ function Long(low, high, unsigned) {\n        /**\n       * The low 32 bits as a signed value.\n       * @type {number}\n       */ this.low = low | 0;\n        /**\n       * The high 32 bits as a signed value.\n       * @type {number}\n       */ this.high = high | 0;\n        /**\n       * Whether unsigned or not.\n       * @type {boolean}\n       */ this.unsigned = !!unsigned;\n    }\n    // The internal representation of a long is the two given signed, 32-bit values.\n    // We use 32-bit pieces because these are the size of integers on which\n    // Javascript performs bit-operations.  For operations like addition and\n    // multiplication, we split each number into 16 bit pieces, which can easily be\n    // multiplied within Javascript's floating-point representation without overflow\n    // or change in sign.\n    //\n    // In the algorithms below, we frequently reduce the negative case to the\n    // positive case by negating the input(s) and then post-processing the result.\n    // Note that we must ALWAYS check specially whether those values are MIN_VALUE\n    // (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n    // a positive number, it overflows back into a negative).  Not handling this\n    // case would often result in infinite recursion.\n    //\n    // Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\n    // methods on which they depend.\n    /**\n     * An indicator used to reliably determine if an object is a Long or not.\n     * @type {boolean}\n     * @const\n     * @private\n     */ Long.prototype.__isLong__;\n    Object.defineProperty(Long.prototype, \"__isLong__\", {\n        value: true\n    });\n    /**\n     * @function\n     * @param {*} obj Object\n     * @returns {boolean}\n     * @inner\n     */ function isLong(obj) {\n        return (obj && obj[\"__isLong__\"]) === true;\n    }\n    /**\n     * @function\n     * @param {*} value number\n     * @returns {number}\n     * @inner\n     */ function ctz32(value) {\n        var c = Math.clz32(value & -value);\n        return value ? 31 - c : c;\n    }\n    /**\n     * Tests if the specified object is a Long.\n     * @function\n     * @param {*} obj Object\n     * @returns {boolean}\n     */ Long.isLong = isLong;\n    /**\n     * A cache of the Long representations of small integer values.\n     * @type {!Object}\n     * @inner\n     */ var INT_CACHE = {};\n    /**\n     * A cache of the Long representations of small unsigned integer values.\n     * @type {!Object}\n     * @inner\n     */ var UINT_CACHE = {};\n    /**\n     * @param {number} value\n     * @param {boolean=} unsigned\n     * @returns {!Long}\n     * @inner\n     */ function fromInt(value, unsigned) {\n        var obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if (cache = 0 <= value && value < 256) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = fromBits(value, 0, true);\n            if (cache) UINT_CACHE[value] = obj;\n            return obj;\n        } else {\n            value |= 0;\n            if (cache = -128 <= value && value < 128) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache) INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    /**\n     * Returns a Long representing the given 32 bit integer value.\n     * @function\n     * @param {number} value The 32 bit integer in question\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n     * @returns {!Long} The corresponding Long value\n     */ Long.fromInt = fromInt;\n    /**\n     * @param {number} value\n     * @param {boolean=} unsigned\n     * @returns {!Long}\n     * @inner\n     */ function fromNumber(value, unsigned) {\n        if (isNaN(value)) return unsigned ? UZERO : ZERO;\n        if (unsigned) {\n            if (value < 0) return UZERO;\n            if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;\n        } else {\n            if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;\n        }\n        if (value < 0) return fromNumber(-value, unsigned).neg();\n        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    /**\n     * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\n     * @function\n     * @param {number} value The number in question\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n     * @returns {!Long} The corresponding Long value\n     */ Long.fromNumber = fromNumber;\n    /**\n     * @param {number} lowBits\n     * @param {number} highBits\n     * @param {boolean=} unsigned\n     * @returns {!Long}\n     * @inner\n     */ function fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    /**\n     * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\n     *  assumed to use 32 bits.\n     * @function\n     * @param {number} lowBits The low 32 bits\n     * @param {number} highBits The high 32 bits\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n     * @returns {!Long} The corresponding Long value\n     */ Long.fromBits = fromBits;\n    /**\n     * @function\n     * @param {number} base\n     * @param {number} exponent\n     * @returns {number}\n     * @inner\n     */ var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\n    /**\n     * @param {string} str\n     * @param {(boolean|number)=} unsigned\n     * @param {number=} radix\n     * @returns {!Long}\n     * @inner\n     */ function fromString(str, unsigned, radix) {\n        if (str.length === 0) throw Error(\"empty string\");\n        if (typeof unsigned === \"number\") {\n            // For goog.math.long compatibility\n            radix = unsigned;\n            unsigned = false;\n        } else {\n            unsigned = !!unsigned;\n        }\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return unsigned ? UZERO : ZERO;\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n        var p;\n        if ((p = str.indexOf(\"-\")) > 0) throw Error(\"interior hyphen\");\n        else if (p === 0) {\n            return fromString(str.substring(1), unsigned, radix).neg();\n        }\n        // Do several (8) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = fromNumber(pow_dbl(radix, 8));\n        var result = ZERO;\n        for(var i = 0; i < str.length; i += 8){\n            var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                var power = fromNumber(pow_dbl(radix, size));\n                result = result.mul(power).add(fromNumber(value));\n            } else {\n                result = result.mul(radixToPower);\n                result = result.add(fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    /**\n     * Returns a Long representation of the given string, written using the specified radix.\n     * @function\n     * @param {string} str The textual representation of the Long\n     * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\n     * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\n     * @returns {!Long} The corresponding Long value\n     */ Long.fromString = fromString;\n    /**\n     * @function\n     * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\n     * @param {boolean=} unsigned\n     * @returns {!Long}\n     * @inner\n     */ function fromValue(val, unsigned) {\n        if (typeof val === \"number\") return fromNumber(val, unsigned);\n        if (typeof val === \"string\") return fromString(val, unsigned);\n        // Throws for non-objects, converts non-instanceof Long:\n        return fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    /**\n     * Converts the specified value to a Long using the appropriate from* function for its type.\n     * @function\n     * @param {!Long|number|bigint|string|!{low: number, high: number, unsigned: boolean}} val Value\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n     * @returns {!Long}\n     */ Long.fromValue = fromValue;\n    // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\n    // no runtime penalty for these.\n    /**\n     * @type {number}\n     * @const\n     * @inner\n     */ var TWO_PWR_16_DBL = 1 << 16;\n    /**\n     * @type {number}\n     * @const\n     * @inner\n     */ var TWO_PWR_24_DBL = 1 << 24;\n    /**\n     * @type {number}\n     * @const\n     * @inner\n     */ var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\n    /**\n     * @type {number}\n     * @const\n     * @inner\n     */ var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\n    /**\n     * @type {number}\n     * @const\n     * @inner\n     */ var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\n    /**\n     * @type {!Long}\n     * @const\n     * @inner\n     */ var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\n    /**\n     * @type {!Long}\n     * @inner\n     */ var ZERO = fromInt(0);\n    /**\n     * Signed zero.\n     * @type {!Long}\n     */ Long.ZERO = ZERO;\n    /**\n     * @type {!Long}\n     * @inner\n     */ var UZERO = fromInt(0, true);\n    /**\n     * Unsigned zero.\n     * @type {!Long}\n     */ Long.UZERO = UZERO;\n    /**\n     * @type {!Long}\n     * @inner\n     */ var ONE = fromInt(1);\n    /**\n     * Signed one.\n     * @type {!Long}\n     */ Long.ONE = ONE;\n    /**\n     * @type {!Long}\n     * @inner\n     */ var UONE = fromInt(1, true);\n    /**\n     * Unsigned one.\n     * @type {!Long}\n     */ Long.UONE = UONE;\n    /**\n     * @type {!Long}\n     * @inner\n     */ var NEG_ONE = fromInt(-1);\n    /**\n     * Signed negative one.\n     * @type {!Long}\n     */ Long.NEG_ONE = NEG_ONE;\n    /**\n     * @type {!Long}\n     * @inner\n     */ var MAX_VALUE = fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\n    /**\n     * Maximum signed value.\n     * @type {!Long}\n     */ Long.MAX_VALUE = MAX_VALUE;\n    /**\n     * @type {!Long}\n     * @inner\n     */ var MAX_UNSIGNED_VALUE = fromBits(0xffffffff | 0, 0xffffffff | 0, true);\n    /**\n     * Maximum unsigned value.\n     * @type {!Long}\n     */ Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\n    /**\n     * @type {!Long}\n     * @inner\n     */ var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);\n    /**\n     * Minimum signed value.\n     * @type {!Long}\n     */ Long.MIN_VALUE = MIN_VALUE;\n    /**\n     * @alias Long.prototype\n     * @inner\n     */ var LongPrototype = Long.prototype;\n    /**\n     * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\n     * @this {!Long}\n     * @returns {number}\n     */ LongPrototype.toInt = function toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    };\n    /**\n     * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\n     * @this {!Long}\n     * @returns {number}\n     */ LongPrototype.toNumber = function toNumber() {\n        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    };\n    /**\n     * Converts the Long to a string written in the specified radix.\n     * @this {!Long}\n     * @param {number=} radix Radix (2-36), defaults to 10\n     * @returns {string}\n     * @override\n     * @throws {RangeError} If `radix` is out of range\n     */ LongPrototype.toString = function toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw RangeError(\"radix\");\n        if (this.isZero()) return \"0\";\n        if (this.isNegative()) {\n            // Unsigned Longs are never negative\n            if (this.eq(MIN_VALUE)) {\n                // We need to change the Long value before it can be negated, so we remove\n                // the bottom-most digit in this base and then recurse to do the rest.\n                var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            } else return \"-\" + this.neg().toString(radix);\n        }\n        // Do several (6) digits each time through the loop, so as to\n        // minimize the calls to the very expensive emulated div.\n        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;\n        var result = \"\";\n        while(true){\n            var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) return digits + result;\n            else {\n                while(digits.length < 6)digits = \"0\" + digits;\n                result = \"\" + digits + result;\n            }\n        }\n    };\n    /**\n     * Gets the high 32 bits as a signed integer.\n     * @this {!Long}\n     * @returns {number} Signed high bits\n     */ LongPrototype.getHighBits = function getHighBits() {\n        return this.high;\n    };\n    /**\n     * Gets the high 32 bits as an unsigned integer.\n     * @this {!Long}\n     * @returns {number} Unsigned high bits\n     */ LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\n        return this.high >>> 0;\n    };\n    /**\n     * Gets the low 32 bits as a signed integer.\n     * @this {!Long}\n     * @returns {number} Signed low bits\n     */ LongPrototype.getLowBits = function getLowBits() {\n        return this.low;\n    };\n    /**\n     * Gets the low 32 bits as an unsigned integer.\n     * @this {!Long}\n     * @returns {number} Unsigned low bits\n     */ LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\n        return this.low >>> 0;\n    };\n    /**\n     * Gets the number of bits needed to represent the absolute value of this Long.\n     * @this {!Long}\n     * @returns {number}\n     */ LongPrototype.getNumBitsAbs = function getNumBitsAbs() {\n        if (this.isNegative()) // Unsigned Longs are never negative\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        var val = this.high != 0 ? this.high : this.low;\n        for(var bit = 31; bit > 0; bit--)if ((val & 1 << bit) != 0) break;\n        return this.high != 0 ? bit + 33 : bit + 1;\n    };\n    /**\n     * Tests if this Long can be safely represented as a JavaScript number.\n     * @this {!Long}\n     * @returns {boolean}\n     */ LongPrototype.isSafeInteger = function isSafeInteger() {\n        // 2^53-1 is the maximum safe value\n        var top11Bits = this.high >> 21;\n        // [0, 2^53-1]\n        if (!top11Bits) return true;\n        // > 2^53-1\n        if (this.unsigned) return false;\n        // [-2^53, -1] except -2^53\n        return top11Bits === -1 && !(this.low === 0 && this.high === -0x200000);\n    };\n    /**\n     * Tests if this Long's value equals zero.\n     * @this {!Long}\n     * @returns {boolean}\n     */ LongPrototype.isZero = function isZero() {\n        return this.high === 0 && this.low === 0;\n    };\n    /**\n     * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\n     * @returns {boolean}\n     */ LongPrototype.eqz = LongPrototype.isZero;\n    /**\n     * Tests if this Long's value is negative.\n     * @this {!Long}\n     * @returns {boolean}\n     */ LongPrototype.isNegative = function isNegative() {\n        return !this.unsigned && this.high < 0;\n    };\n    /**\n     * Tests if this Long's value is positive or zero.\n     * @this {!Long}\n     * @returns {boolean}\n     */ LongPrototype.isPositive = function isPositive() {\n        return this.unsigned || this.high >= 0;\n    };\n    /**\n     * Tests if this Long's value is odd.\n     * @this {!Long}\n     * @returns {boolean}\n     */ LongPrototype.isOdd = function isOdd() {\n        return (this.low & 1) === 1;\n    };\n    /**\n     * Tests if this Long's value is even.\n     * @this {!Long}\n     * @returns {boolean}\n     */ LongPrototype.isEven = function isEven() {\n        return (this.low & 1) === 0;\n    };\n    /**\n     * Tests if this Long's value equals the specified's.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.equals = function equals(other) {\n        if (!isLong(other)) other = fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n        return this.high === other.high && this.low === other.low;\n    };\n    /**\n     * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\n     * @function\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.eq = LongPrototype.equals;\n    /**\n     * Tests if this Long's value differs from the specified's.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.notEquals = function notEquals(other) {\n        return !this.eq(/* validates */ other);\n    };\n    /**\n     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n     * @function\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.neq = LongPrototype.notEquals;\n    /**\n     * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\n     * @function\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.ne = LongPrototype.notEquals;\n    /**\n     * Tests if this Long's value is less than the specified's.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.lessThan = function lessThan(other) {\n        return this.comp(/* validates */ other) < 0;\n    };\n    /**\n     * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\n     * @function\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.lt = LongPrototype.lessThan;\n    /**\n     * Tests if this Long's value is less than or equal the specified's.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\n        return this.comp(/* validates */ other) <= 0;\n    };\n    /**\n     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n     * @function\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.lte = LongPrototype.lessThanOrEqual;\n    /**\n     * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\n     * @function\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.le = LongPrototype.lessThanOrEqual;\n    /**\n     * Tests if this Long's value is greater than the specified's.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.greaterThan = function greaterThan(other) {\n        return this.comp(/* validates */ other) > 0;\n    };\n    /**\n     * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\n     * @function\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.gt = LongPrototype.greaterThan;\n    /**\n     * Tests if this Long's value is greater than or equal the specified's.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\n        return this.comp(/* validates */ other) >= 0;\n    };\n    /**\n     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n     * @function\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.gte = LongPrototype.greaterThanOrEqual;\n    /**\n     * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\n     * @function\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {boolean}\n     */ LongPrototype.ge = LongPrototype.greaterThanOrEqual;\n    /**\n     * Compares this Long's value with the specified's.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n     *  if the given one is greater\n     */ LongPrototype.compare = function compare(other) {\n        if (!isLong(other)) other = fromValue(other);\n        if (this.eq(other)) return 0;\n        var thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg) return -1;\n        if (!thisNeg && otherNeg) return 1;\n        // At this point the sign bits are the same\n        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n        // Both are positive if at least one is unsigned\n        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    };\n    /**\n     * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\n     * @function\n     * @param {!Long|number|bigint|string} other Other value\n     * @returns {number} 0 if they are the same, 1 if the this is greater and -1\n     *  if the given one is greater\n     */ LongPrototype.comp = LongPrototype.compare;\n    /**\n     * Negates this Long's value.\n     * @this {!Long}\n     * @returns {!Long} Negated Long\n     */ LongPrototype.negate = function negate() {\n        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;\n        return this.not().add(ONE);\n    };\n    /**\n     * Negates this Long's value. This is an alias of {@link Long#negate}.\n     * @function\n     * @returns {!Long} Negated Long\n     */ LongPrototype.neg = LongPrototype.negate;\n    /**\n     * Returns the sum of this and the specified Long.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} addend Addend\n     * @returns {!Long} Sum\n     */ LongPrototype.add = function add(addend) {\n        if (!isLong(addend)) addend = fromValue(addend);\n        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xffff;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xffff;\n        var b48 = addend.high >>> 16;\n        var b32 = addend.high & 0xffff;\n        var b16 = addend.low >>> 16;\n        var b00 = addend.low & 0xffff;\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 + b48;\n        c48 &= 0xffff;\n        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    /**\n     * Returns the difference of this and the specified Long.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} subtrahend Subtrahend\n     * @returns {!Long} Difference\n     */ LongPrototype.subtract = function subtract(subtrahend) {\n        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    };\n    /**\n     * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\n     * @function\n     * @param {!Long|number|bigint|string} subtrahend Subtrahend\n     * @returns {!Long} Difference\n     */ LongPrototype.sub = LongPrototype.subtract;\n    /**\n     * Returns the product of this and the specified Long.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} multiplier Multiplier\n     * @returns {!Long} Product\n     */ LongPrototype.multiply = function multiply(multiplier) {\n        if (this.isZero()) return this;\n        if (!isLong(multiplier)) multiplier = fromValue(multiplier);\n        // use wasm support if present\n        if (wasm) {\n            var low = wasm[\"mul\"](this.low, this.high, multiplier.low, multiplier.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;\n        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;\n        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n            else return this.neg().mul(multiplier).neg();\n        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n        // If both longs are small, use float multiplication\n        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n        // We can skip products that would overflow.\n        var a48 = this.high >>> 16;\n        var a32 = this.high & 0xffff;\n        var a16 = this.low >>> 16;\n        var a00 = this.low & 0xffff;\n        var b48 = multiplier.high >>> 16;\n        var b32 = multiplier.high & 0xffff;\n        var b16 = multiplier.low >>> 16;\n        var b00 = multiplier.low & 0xffff;\n        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xffff;\n        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    };\n    /**\n     * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\n     * @function\n     * @param {!Long|number|bigint|string} multiplier Multiplier\n     * @returns {!Long} Product\n     */ LongPrototype.mul = LongPrototype.multiply;\n    /**\n     * Returns this Long divided by the specified. The result is signed if this Long is signed or\n     *  unsigned if this Long is unsigned.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} divisor Divisor\n     * @returns {!Long} Quotient\n     */ LongPrototype.divide = function divide(divisor) {\n        if (!isLong(divisor)) divisor = fromValue(divisor);\n        if (divisor.isZero()) throw Error(\"division by zero\");\n        // use wasm support if present\n        if (wasm) {\n            // guard against signed division overflow: the largest\n            // negative number / -1 would be 1 larger than the largest\n            // positive number, due to two's complement.\n            if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n                // be consistent with non-wasm code path\n                return this;\n            }\n            var low = (this.unsigned ? wasm[\"div_u\"] : wasm[\"div_s\"])(this.low, this.high, divisor.low, divisor.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        if (this.isZero()) return this.unsigned ? UZERO : ZERO;\n        var approx, rem, res;\n        if (!this.unsigned) {\n            // This section is only relevant for signed longs and is derived from the\n            // closure library as a whole.\n            if (this.eq(MIN_VALUE)) {\n                if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE\n                else if (divisor.eq(MIN_VALUE)) return ONE;\n                else {\n                    // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n                    var halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(ZERO)) {\n                        return divisor.isNegative() ? ONE : NEG_ONE;\n                    } else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative()) return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n            res = ZERO;\n        } else {\n            // The algorithm below has not been made for unsigned longs. It's therefore\n            // required to take special care of the MSB prior to running it.\n            if (!divisor.unsigned) divisor = divisor.toUnsigned();\n            if (divisor.gt(this)) return UZERO;\n            if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\n            return UONE;\n            res = UZERO;\n        }\n        // Repeat the following until the remainder is less than other:  find a\n        // floating-point that approximates remainder / other *from below*, add this\n        // into the result, and subtract it from the remainder.  It is critical that\n        // the approximate value is less than or equal to the real value so that the\n        // remainder never becomes negative.\n        rem = this;\n        while(rem.gte(divisor)){\n            // Approximate the result of division. This may be a little greater or\n            // smaller than the actual value.\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n            // We will tweak the approximate result by changing it in the 48-th digit or\n            // the smallest non-fractional digit, whichever is larger.\n            var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), // Decrease the approximation until it is smaller than the remainder.  Note\n            // that if it is too large, the product overflows and is negative.\n            approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);\n            while(approxRem.isNegative() || approxRem.gt(rem)){\n                approx -= delta;\n                approxRes = fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            }\n            // We know the answer can't be zero... and actually, zero would cause\n            // infinite recursion since we would make no progress.\n            if (approxRes.isZero()) approxRes = ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    };\n    /**\n     * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\n     * @function\n     * @param {!Long|number|bigint|string} divisor Divisor\n     * @returns {!Long} Quotient\n     */ LongPrototype.div = LongPrototype.divide;\n    /**\n     * Returns this Long modulo the specified.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} divisor Divisor\n     * @returns {!Long} Remainder\n     */ LongPrototype.modulo = function modulo(divisor) {\n        if (!isLong(divisor)) divisor = fromValue(divisor);\n        // use wasm support if present\n        if (wasm) {\n            var low = (this.unsigned ? wasm[\"rem_u\"] : wasm[\"rem_s\"])(this.low, this.high, divisor.low, divisor.high);\n            return fromBits(low, wasm[\"get_high\"](), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    };\n    /**\n     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n     * @function\n     * @param {!Long|number|bigint|string} divisor Divisor\n     * @returns {!Long} Remainder\n     */ LongPrototype.mod = LongPrototype.modulo;\n    /**\n     * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\n     * @function\n     * @param {!Long|number|bigint|string} divisor Divisor\n     * @returns {!Long} Remainder\n     */ LongPrototype.rem = LongPrototype.modulo;\n    /**\n     * Returns the bitwise NOT of this Long.\n     * @this {!Long}\n     * @returns {!Long}\n     */ LongPrototype.not = function not() {\n        return fromBits(~this.low, ~this.high, this.unsigned);\n    };\n    /**\n     * Returns count leading zeros of this Long.\n     * @this {!Long}\n     * @returns {!number}\n     */ LongPrototype.countLeadingZeros = function countLeadingZeros() {\n        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;\n    };\n    /**\n     * Returns count leading zeros. This is an alias of {@link Long#countLeadingZeros}.\n     * @function\n     * @param {!Long}\n     * @returns {!number}\n     */ LongPrototype.clz = LongPrototype.countLeadingZeros;\n    /**\n     * Returns count trailing zeros of this Long.\n     * @this {!Long}\n     * @returns {!number}\n     */ LongPrototype.countTrailingZeros = function countTrailingZeros() {\n        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;\n    };\n    /**\n     * Returns count trailing zeros. This is an alias of {@link Long#countTrailingZeros}.\n     * @function\n     * @param {!Long}\n     * @returns {!number}\n     */ LongPrototype.ctz = LongPrototype.countTrailingZeros;\n    /**\n     * Returns the bitwise AND of this Long and the specified.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} other Other Long\n     * @returns {!Long}\n     */ LongPrototype.and = function and(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    };\n    /**\n     * Returns the bitwise OR of this Long and the specified.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} other Other Long\n     * @returns {!Long}\n     */ LongPrototype.or = function or(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    };\n    /**\n     * Returns the bitwise XOR of this Long and the given one.\n     * @this {!Long}\n     * @param {!Long|number|bigint|string} other Other Long\n     * @returns {!Long}\n     */ LongPrototype.xor = function xor(other) {\n        if (!isLong(other)) other = fromValue(other);\n        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    };\n    /**\n     * Returns this Long with bits shifted to the left by the given amount.\n     * @this {!Long}\n     * @param {number|!Long} numBits Number of bits\n     * @returns {!Long} Shifted Long\n     */ LongPrototype.shiftLeft = function shiftLeft(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n        else return fromBits(0, this.low << numBits - 32, this.unsigned);\n    };\n    /**\n     * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\n     * @function\n     * @param {number|!Long} numBits Number of bits\n     * @returns {!Long} Shifted Long\n     */ LongPrototype.shl = LongPrototype.shiftLeft;\n    /**\n     * Returns this Long with bits arithmetically shifted to the right by the given amount.\n     * @this {!Long}\n     * @param {number|!Long} numBits Number of bits\n     * @returns {!Long} Shifted Long\n     */ LongPrototype.shiftRight = function shiftRight(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n        else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    };\n    /**\n     * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\n     * @function\n     * @param {number|!Long} numBits Number of bits\n     * @returns {!Long} Shifted Long\n     */ LongPrototype.shr = LongPrototype.shiftRight;\n    /**\n     * Returns this Long with bits logically shifted to the right by the given amount.\n     * @this {!Long}\n     * @param {number|!Long} numBits Number of bits\n     * @returns {!Long} Shifted Long\n     */ LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);\n        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);\n        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);\n    };\n    /**\n     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n     * @function\n     * @param {number|!Long} numBits Number of bits\n     * @returns {!Long} Shifted Long\n     */ LongPrototype.shru = LongPrototype.shiftRightUnsigned;\n    /**\n     * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\n     * @function\n     * @param {number|!Long} numBits Number of bits\n     * @returns {!Long} Shifted Long\n     */ LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\n    /**\n     * Returns this Long with bits rotated to the left by the given amount.\n     * @this {!Long}\n     * @param {number|!Long} numBits Number of bits\n     * @returns {!Long} Rotated Long\n     */ LongPrototype.rotateLeft = function rotateLeft(numBits) {\n        var b;\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n        if (numBits < 32) {\n            b = 32 - numBits;\n            return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);\n        }\n        numBits -= 32;\n        b = 32 - numBits;\n        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);\n    };\n    /**\n     * Returns this Long with bits rotated to the left by the given amount. This is an alias of {@link Long#rotateLeft}.\n     * @function\n     * @param {number|!Long} numBits Number of bits\n     * @returns {!Long} Rotated Long\n     */ LongPrototype.rotl = LongPrototype.rotateLeft;\n    /**\n     * Returns this Long with bits rotated to the right by the given amount.\n     * @this {!Long}\n     * @param {number|!Long} numBits Number of bits\n     * @returns {!Long} Rotated Long\n     */ LongPrototype.rotateRight = function rotateRight(numBits) {\n        var b;\n        if (isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);\n        if (numBits < 32) {\n            b = 32 - numBits;\n            return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);\n        }\n        numBits -= 32;\n        b = 32 - numBits;\n        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);\n    };\n    /**\n     * Returns this Long with bits rotated to the right by the given amount. This is an alias of {@link Long#rotateRight}.\n     * @function\n     * @param {number|!Long} numBits Number of bits\n     * @returns {!Long} Rotated Long\n     */ LongPrototype.rotr = LongPrototype.rotateRight;\n    /**\n     * Converts this Long to signed.\n     * @this {!Long}\n     * @returns {!Long} Signed long\n     */ LongPrototype.toSigned = function toSigned() {\n        if (!this.unsigned) return this;\n        return fromBits(this.low, this.high, false);\n    };\n    /**\n     * Converts this Long to unsigned.\n     * @this {!Long}\n     * @returns {!Long} Unsigned long\n     */ LongPrototype.toUnsigned = function toUnsigned() {\n        if (this.unsigned) return this;\n        return fromBits(this.low, this.high, true);\n    };\n    /**\n     * Converts this Long to its byte representation.\n     * @param {boolean=} le Whether little or big endian, defaults to big endian\n     * @this {!Long}\n     * @returns {!Array.<number>} Byte representation\n     */ LongPrototype.toBytes = function toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    };\n    /**\n     * Converts this Long to its little endian byte representation.\n     * @this {!Long}\n     * @returns {!Array.<number>} Little endian byte representation\n     */ LongPrototype.toBytesLE = function toBytesLE() {\n        var hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            lo >>> 8 & 0xff,\n            lo >>> 16 & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            hi >>> 8 & 0xff,\n            hi >>> 16 & 0xff,\n            hi >>> 24\n        ];\n    };\n    /**\n     * Converts this Long to its big endian byte representation.\n     * @this {!Long}\n     * @returns {!Array.<number>} Big endian byte representation\n     */ LongPrototype.toBytesBE = function toBytesBE() {\n        var hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            hi >>> 16 & 0xff,\n            hi >>> 8 & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            lo >>> 16 & 0xff,\n            lo >>> 8 & 0xff,\n            lo & 0xff\n        ];\n    };\n    /**\n     * Creates a Long from its byte representation.\n     * @param {!Array.<number>} bytes Byte representation\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n     * @param {boolean=} le Whether little or big endian, defaults to big endian\n     * @returns {Long} The corresponding Long value\n     */ Long.fromBytes = function fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    };\n    /**\n     * Creates a Long from its little endian byte representation.\n     * @param {!Array.<number>} bytes Little endian byte representation\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n     * @returns {Long} The corresponding Long value\n     */ Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n    };\n    /**\n     * Creates a Long from its big endian byte representation.\n     * @param {!Array.<number>} bytes Big endian byte representation\n     * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n     * @returns {Long} The corresponding Long value\n     */ Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {\n        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n    };\n    // Support conversion to/from BigInt where available\n    if (typeof BigInt === \"function\") {\n        /**\n       * Returns a Long representing the given big integer.\n       * @function\n       * @param {number} value The big integer value\n       * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\n       * @returns {!Long} The corresponding Long value\n       */ Long.fromBigInt = function fromBigInt(value, unsigned) {\n            var lowBits = Number(BigInt.asIntN(32, value));\n            var highBits = Number(BigInt.asIntN(32, value >> BigInt(32)));\n            return fromBits(lowBits, highBits, unsigned);\n        };\n        // Override\n        Long.fromValue = function fromValueWithBigInt(value, unsigned) {\n            if (typeof value === \"bigint\") return Long.fromBigInt(value, unsigned);\n            return fromValue(value, unsigned);\n        };\n        /**\n       * Converts the Long to its big integer representation.\n       * @this {!Long}\n       * @returns {bigint}\n       */ LongPrototype.toBigInt = function toBigInt() {\n            var lowBigInt = BigInt(this.low >>> 0);\n            var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);\n            return highBigInt << BigInt(32) | lowBigInt;\n        };\n    }\n    var _default = _exports.default = Long;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGdycGMvZ3JwYy1qcy9ub2RlX21vZHVsZXMvbG9uZy91bWQvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLCtCQUErQjtBQUM5QixVQUFVQSxNQUFNLEVBQUVDLE9BQU87SUFDeEIsU0FBU0MsY0FBY0MsUUFBTztRQUM1QixPQUFPQSxTQUFRQyxPQUFPLElBQUlEO0lBQzVCO0lBQ0EsSUFBSSxJQUEwQyxFQUFFO1FBQzlDRSxpQ0FBTyxFQUFFLG1DQUFFO1lBQ1QsSUFBSUYsV0FBVSxDQUFDO1lBQ2ZGLFFBQVFFO1lBQ1IsT0FBT0QsY0FBY0M7UUFDdkIsQ0FBQztBQUFBLGtHQUFDO0lBQ0osT0FBTyxFQVNOO0FBQ0gsR0FDRSxPQUFPTSxlQUFlLGNBQ2xCQSxhQUNBLE9BQU9DLFNBQVMsY0FDZEEsT0FDQSxRQUNOLFNBQVVDLFFBQVE7SUFDaEI7SUFFQUMsT0FBT0MsY0FBYyxDQUFDRixVQUFVLGNBQWM7UUFDNUNHLE9BQU87SUFDVDtJQUNBSCxTQUFTUCxPQUFPLEdBQUcsS0FBSztJQUN4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0tBa0JDLEdBRUQsdUVBQXVFO0lBQ3ZFLElBQUlXLE9BQU87SUFDWCxJQUFJO1FBQ0ZBLE9BQU8sSUFBSUMsWUFBWUMsUUFBUSxDQUM3QixJQUFJRCxZQUFZRSxNQUFNLENBQ3BCLElBQUlDLFdBQVc7WUFDYixRQUFRO1lBQ1I7WUFBRztZQUFJO1lBQUs7WUFDWixZQUFZO1lBQ1o7WUFBRztZQUFHO1lBQUc7WUFDVCxpQkFBaUI7WUFDakI7WUFBRztZQUFJO1lBQ1AsZUFBZTtZQUNmO1lBQUk7WUFBRztZQUFHO1lBQ1YsaUNBQWlDO1lBQ2pDO1lBQUk7WUFBRztZQUFLO1lBQUs7WUFBSztZQUFLO1lBQUc7WUFDOUIscUJBQXFCO1lBQ3JCO1lBQUc7WUFBRztZQUNOLFlBQVk7WUFDWjtZQUNBLFlBQVk7WUFDWjtZQUNBLFlBQVk7WUFDWjtZQUNBLFlBQVk7WUFDWjtZQUNBLFlBQVk7WUFDWjtZQUNB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Q3BELElBQUksT0FBT3dLLFdBQVcsWUFBWTtRQUNoQzs7Ozs7O09BTUMsR0FDRHRMLEtBQUt1TCxVQUFVLEdBQUcsU0FBU0EsV0FBV2pMLEtBQUssRUFBRVEsUUFBUTtZQUNuRCxJQUFJMEIsVUFBVWdKLE9BQU9GLE9BQU9HLE1BQU0sQ0FBQyxJQUFJbkw7WUFDdkMsSUFBSW1DLFdBQVcrSSxPQUFPRixPQUFPRyxNQUFNLENBQUMsSUFBSW5MLFNBQVNnTCxPQUFPO1lBQ3hELE9BQU8xSixTQUFTWSxTQUFTQyxVQUFVM0I7UUFDckM7UUFFQSxXQUFXO1FBQ1hkLEtBQUs4RCxTQUFTLEdBQUcsU0FBUzRILG9CQUFvQnBMLEtBQUssRUFBRVEsUUFBUTtZQUMzRCxJQUFJLE9BQU9SLFVBQVUsVUFBVSxPQUFPTixLQUFLdUwsVUFBVSxDQUFDakwsT0FBT1E7WUFDN0QsT0FBT2dELFVBQVV4RCxPQUFPUTtRQUMxQjtRQUVBOzs7O09BSUMsR0FDRHdELGNBQWNxSCxRQUFRLEdBQUcsU0FBU0E7WUFDaEMsSUFBSUMsWUFBWU4sT0FBTyxJQUFJLENBQUMxSyxHQUFHLEtBQUs7WUFDcEMsSUFBSWlMLGFBQWFQLE9BQU8sSUFBSSxDQUFDeEssUUFBUSxHQUFHLElBQUksQ0FBQ0QsSUFBSSxLQUFLLElBQUksSUFBSSxDQUFDQSxJQUFJO1lBQ25FLE9BQU8sY0FBZXlLLE9BQU8sTUFBT007UUFDdEM7SUFDRjtJQUNBLElBQUlFLFdBQVkzTCxTQUFTUCxPQUFPLEdBQUdJO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWNvbW1lcmNlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0BncnBjL2dycGMtanMvbm9kZV9tb2R1bGVzL2xvbmcvdW1kL2luZGV4LmpzP2NhYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR0VORVJBVEVEIEZJTEUuIERPIE5PVCBFRElULlxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgZnVuY3Rpb24gcHJlZmVyRGVmYXVsdChleHBvcnRzKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzO1xuICB9XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbXSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gICAgICByZXR1cm4gcHJlZmVyRGVmYXVsdChleHBvcnRzKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIpIG1vZHVsZS5leHBvcnRzID0gcHJlZmVyRGVmYXVsdChleHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgICAgIGZhY3RvcnkoZXhwb3J0cyk7XG4gICAgICBnbG9iYWwuTG9uZyA9IHByZWZlckRlZmF1bHQoZXhwb3J0cyk7XG4gICAgfSkoKTtcbiAgfVxufSkoXG4gIHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBnbG9iYWxUaGlzXG4gICAgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIlxuICAgICAgPyBzZWxmXG4gICAgICA6IHRoaXMsXG4gIGZ1bmN0aW9uIChfZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9leHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgICAgdmFsdWU6IHRydWUsXG4gICAgfSk7XG4gICAgX2V4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAbGljZW5zZVxuICAgICAqIENvcHlyaWdodCAyMDA5IFRoZSBDbG9zdXJlIExpYnJhcnkgQXV0aG9yc1xuICAgICAqIENvcHlyaWdodCAyMDIwIERhbmllbCBXaXJ0eiAvIFRoZSBsb25nLmpzIEF1dGhvcnMuXG4gICAgICpcbiAgICAgKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICAgICAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgICAgKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgKlxuICAgICAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKlxuICAgICAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgICAgKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gICAgICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gICAgICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICAgICAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICAgICAqXG4gICAgICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAgICAgKi9cblxuICAgIC8vIFdlYkFzc2VtYmx5IG9wdGltaXphdGlvbnMgdG8gZG8gbmF0aXZlIGk2NCBtdWx0aXBsaWNhdGlvbiBhbmQgZGl2aWRlXG4gICAgdmFyIHdhc20gPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICB3YXNtID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKFxuICAgICAgICBuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKFxuICAgICAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIC8vIFxcMGFzbVxuICAgICAgICAgICAgMCwgOTcsIDExNSwgMTA5LFxuICAgICAgICAgICAgLy8gdmVyc2lvbiAxXG4gICAgICAgICAgICAxLCAwLCAwLCAwLFxuICAgICAgICAgICAgLy8gc2VjdGlvbiBcInR5cGVcIlxuICAgICAgICAgICAgMSwgMTMsIDIsXG4gICAgICAgICAgICAvLyAwLCAoKSA9PiBpMzJcbiAgICAgICAgICAgIDk2LCAwLCAxLCAxMjcsXG4gICAgICAgICAgICAvLyAxLCAoaTMyLCBpMzIsIGkzMiwgaTMyKSA9PiBpMzJcbiAgICAgICAgICAgIDk2LCA0LCAxMjcsIDEyNywgMTI3LCAxMjcsIDEsIDEyNyxcbiAgICAgICAgICAgIC8vIHNlY3Rpb24gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAzLCA3LCA2LFxuICAgICAgICAgICAgLy8gMCwgdHlwZSAwXG4gICAgICAgICAgICAwLFxuICAgICAgICAgICAgLy8gMSwgdHlwZSAxXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgLy8gMiwgdHlwZSAxXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgLy8gMywgdHlwZSAxXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgLy8gNCwgdHlwZSAxXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgLy8gNSwgdHlwZSAxXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgLy8gc2VjdGlvbiBcImdsb2JhbFwiXG4gICAgICAgICAgICA2LCA2LCAxLFxuICAgICAgICAgICAgLy8gMCwgXCJoaWdoXCIsIG11dGFibGUgaTMyXG4gICAgICAgICAgICAxMjcsIDEsIDY1LCAwLCAxMSxcbiAgICAgICAgICAgIC8vIHNlY3Rpb24gXCJleHBvcnRcIlxuICAgICAgICAgICAgNywgNTAsIDYsXG4gICAgICAgICAgICAvLyAwLCBcIm11bFwiXG4gICAgICAgICAgICAzLCAxMDksIDExNywgMTA4LCAwLCAxLFxuICAgICAgICAgICAgLy8gMSwgXCJkaXZfc1wiXG4gICAgICAgICAgICA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE1LCAwLCAyLFxuICAgICAgICAgICAgLy8gMiwgXCJkaXZfdVwiXG4gICAgICAgICAgICA1LCAxMDAsIDEwNSwgMTE4LCA5NSwgMTE3LCAwLCAzLFxuICAgICAgICAgICAgLy8gMywgXCJyZW1fc1wiXG4gICAgICAgICAgICA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE1LCAwLCA0LFxuICAgICAgICAgICAgLy8gNCwgXCJyZW1fdVwiXG4gICAgICAgICAgICA1LCAxMTQsIDEwMSwgMTA5LCA5NSwgMTE3LCAwLCA1LFxuICAgICAgICAgICAgLy8gNSwgXCJnZXRfaGlnaFwiXG4gICAgICAgICAgICA4LCAxMDMsIDEwMSwgMTE2LCA5NSwgMTA0LCAxMDUsIDEwMywgMTA0LCAwLCAwLFxuICAgICAgICAgICAgLy8gc2VjdGlvbiBcImNvZGVcIlxuICAgICAgICAgICAgMTAsIDE5MSwgMSwgNixcbiAgICAgICAgICAgIC8vIDAsIFwiZ2V0X2hpZ2hcIlxuICAgICAgICAgICAgNCwgMCwgMzUsIDAsIDExLFxuICAgICAgICAgICAgLy8gMSwgXCJtdWxcIlxuICAgICAgICAgICAgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MyxcbiAgICAgICAgICAgIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyNiwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLFxuICAgICAgICAgICAgMzIsIDQsIDE2NywgMTEsXG4gICAgICAgICAgICAvLyAyLCBcImRpdl9zXCJcbiAgICAgICAgICAgIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsXG4gICAgICAgICAgICAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCxcbiAgICAgICAgICAgIDMyLCA0LCAxNjcsIDExLFxuICAgICAgICAgICAgLy8gMywgXCJkaXZfdVwiXG4gICAgICAgICAgICAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLFxuICAgICAgICAgICAgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI4LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsXG4gICAgICAgICAgICAzMiwgNCwgMTY3LCAxMSxcbiAgICAgICAgICAgIC8vIDQsIFwicmVtX3NcIlxuICAgICAgICAgICAgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MyxcbiAgICAgICAgICAgIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOSwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLFxuICAgICAgICAgICAgMzIsIDQsIDE2NywgMTEsXG4gICAgICAgICAgICAvLyA1LCBcInJlbV91XCJcbiAgICAgICAgICAgIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsXG4gICAgICAgICAgICAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCxcbiAgICAgICAgICAgIDMyLCA0LCAxNjcsIDExLFxuICAgICAgICAgIF0pLFxuICAgICAgICApLFxuICAgICAgICB7fSxcbiAgICAgICkuZXhwb3J0cztcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIG5vIHdhc20gc3VwcG9ydCA6KFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSA2NCBiaXQgdHdvJ3MtY29tcGxlbWVudCBpbnRlZ2VyLCBnaXZlbiBpdHMgbG93IGFuZCBoaWdoIDMyIGJpdCB2YWx1ZXMgYXMgKnNpZ25lZCogaW50ZWdlcnMuXG4gICAgICogIFNlZSB0aGUgZnJvbSogZnVuY3Rpb25zIGJlbG93IGZvciBtb3JlIGNvbnZlbmllbnQgd2F5cyBvZiBjb25zdHJ1Y3RpbmcgTG9uZ3MuXG4gICAgICogQGV4cG9ydHMgTG9uZ1xuICAgICAqIEBjbGFzcyBBIExvbmcgY2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIDY0IGJpdCB0d28ncy1jb21wbGVtZW50IGludGVnZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IChzaWduZWQpIDMyIGJpdHMgb2YgdGhlIGxvbmdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaCBUaGUgaGlnaCAoc2lnbmVkKSAzMiBiaXRzIG9mIHRoZSBsb25nXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExvbmcobG93LCBoaWdoLCB1bnNpZ25lZCkge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbG93IDMyIGJpdHMgYXMgYSBzaWduZWQgdmFsdWUuXG4gICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICB0aGlzLmxvdyA9IGxvdyB8IDA7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIGhpZ2ggMzIgYml0cyBhcyBhIHNpZ25lZCB2YWx1ZS5cbiAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xuXG4gICAgICAvKipcbiAgICAgICAqIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LlxuICAgICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIHRoaXMudW5zaWduZWQgPSAhIXVuc2lnbmVkO1xuICAgIH1cblxuICAgIC8vIFRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIGxvbmcgaXMgdGhlIHR3byBnaXZlbiBzaWduZWQsIDMyLWJpdCB2YWx1ZXMuXG4gICAgLy8gV2UgdXNlIDMyLWJpdCBwaWVjZXMgYmVjYXVzZSB0aGVzZSBhcmUgdGhlIHNpemUgb2YgaW50ZWdlcnMgb24gd2hpY2hcbiAgICAvLyBKYXZhc2NyaXB0IHBlcmZvcm1zIGJpdC1vcGVyYXRpb25zLiAgRm9yIG9wZXJhdGlvbnMgbGlrZSBhZGRpdGlvbiBhbmRcbiAgICAvLyBtdWx0aXBsaWNhdGlvbiwgd2Ugc3BsaXQgZWFjaCBudW1iZXIgaW50byAxNiBiaXQgcGllY2VzLCB3aGljaCBjYW4gZWFzaWx5IGJlXG4gICAgLy8gbXVsdGlwbGllZCB3aXRoaW4gSmF2YXNjcmlwdCdzIGZsb2F0aW5nLXBvaW50IHJlcHJlc2VudGF0aW9uIHdpdGhvdXQgb3ZlcmZsb3dcbiAgICAvLyBvciBjaGFuZ2UgaW4gc2lnbi5cbiAgICAvL1xuICAgIC8vIEluIHRoZSBhbGdvcml0aG1zIGJlbG93LCB3ZSBmcmVxdWVudGx5IHJlZHVjZSB0aGUgbmVnYXRpdmUgY2FzZSB0byB0aGVcbiAgICAvLyBwb3NpdGl2ZSBjYXNlIGJ5IG5lZ2F0aW5nIHRoZSBpbnB1dChzKSBhbmQgdGhlbiBwb3N0LXByb2Nlc3NpbmcgdGhlIHJlc3VsdC5cbiAgICAvLyBOb3RlIHRoYXQgd2UgbXVzdCBBTFdBWVMgY2hlY2sgc3BlY2lhbGx5IHdoZXRoZXIgdGhvc2UgdmFsdWVzIGFyZSBNSU5fVkFMVUVcbiAgICAvLyAoLTJeNjMpIGJlY2F1c2UgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUUgKHNpbmNlIDJeNjMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGFzXG4gICAgLy8gYSBwb3NpdGl2ZSBudW1iZXIsIGl0IG92ZXJmbG93cyBiYWNrIGludG8gYSBuZWdhdGl2ZSkuICBOb3QgaGFuZGxpbmcgdGhpc1xuICAgIC8vIGNhc2Ugd291bGQgb2Z0ZW4gcmVzdWx0IGluIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAvL1xuICAgIC8vIENvbW1vbiBjb25zdGFudCB2YWx1ZXMgWkVSTywgT05FLCBORUdfT05FLCBldGMuIGFyZSBkZWZpbmVkIGJlbG93IHRoZSBmcm9tKlxuICAgIC8vIG1ldGhvZHMgb24gd2hpY2ggdGhleSBkZXBlbmQuXG5cbiAgICAvKipcbiAgICAgKiBBbiBpbmRpY2F0b3IgdXNlZCB0byByZWxpYWJseSBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgTG9uZyBvciBub3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQGNvbnN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBMb25nLnByb3RvdHlwZS5fX2lzTG9uZ19fO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShMb25nLnByb3RvdHlwZSwgXCJfX2lzTG9uZ19fXCIsIHtcbiAgICAgIHZhbHVlOiB0cnVlLFxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMb25nKG9iaikge1xuICAgICAgcmV0dXJuIChvYmogJiYgb2JqW1wiX19pc0xvbmdfX1wiXSkgPT09IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBudW1iZXJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN0ejMyKHZhbHVlKSB7XG4gICAgICB2YXIgYyA9IE1hdGguY2x6MzIodmFsdWUgJiAtdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlID8gMzEgLSBjIDogYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGUgc3BlY2lmaWVkIG9iamVjdCBpcyBhIExvbmcuXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHsqfSBvYmogT2JqZWN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZy5pc0xvbmcgPSBpc0xvbmc7XG5cbiAgICAvKipcbiAgICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCBpbnRlZ2VyIHZhbHVlcy5cbiAgICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgSU5UX0NBQ0hFID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBIGNhY2hlIG9mIHRoZSBMb25nIHJlcHJlc2VudGF0aW9ucyBvZiBzbWFsbCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy5cbiAgICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgVUlOVF9DQUNIRSA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWRcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbUludCh2YWx1ZSwgdW5zaWduZWQpIHtcbiAgICAgIHZhciBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XG4gICAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgICBpZiAoKGNhY2hlID0gMCA8PSB2YWx1ZSAmJiB2YWx1ZSA8IDI1NikpIHtcbiAgICAgICAgICBjYWNoZWRPYmogPSBVSU5UX0NBQ0hFW3ZhbHVlXTtcbiAgICAgICAgICBpZiAoY2FjaGVkT2JqKSByZXR1cm4gY2FjaGVkT2JqO1xuICAgICAgICB9XG4gICAgICAgIG9iaiA9IGZyb21CaXRzKHZhbHVlLCAwLCB0cnVlKTtcbiAgICAgICAgaWYgKGNhY2hlKSBVSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlIHw9IDA7XG4gICAgICAgIGlmICgoY2FjaGUgPSAtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xuICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgICAgaWYgKGNhY2hlZE9iaikgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgICAgfVxuICAgICAgICBvYmogPSBmcm9tQml0cyh2YWx1ZSwgdmFsdWUgPCAwID8gLTEgOiAwLCBmYWxzZSk7XG4gICAgICAgIGlmIChjYWNoZSkgSU5UX0NBQ0hFW3ZhbHVlXSA9IG9iajtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgTG9uZyByZXByZXNlbnRpbmcgdGhlIGdpdmVuIDMyIGJpdCBpbnRlZ2VyIHZhbHVlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgMzIgYml0IGludGVnZXIgaW4gcXVlc3Rpb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZCBXaGV0aGVyIHVuc2lnbmVkIG9yIG5vdCwgZGVmYXVsdHMgdG8gc2lnbmVkXG4gICAgICogQHJldHVybnMgeyFMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAgICovXG4gICAgTG9uZy5mcm9tSW50ID0gZnJvbUludDtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21OdW1iZXIodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgICBpZiAoaXNOYU4odmFsdWUpKSByZXR1cm4gdW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gICAgICBpZiAodW5zaWduZWQpIHtcbiAgICAgICAgaWYgKHZhbHVlIDwgMCkgcmV0dXJuIFVaRVJPO1xuICAgICAgICBpZiAodmFsdWUgPj0gVFdPX1BXUl82NF9EQkwpIHJldHVybiBNQVhfVU5TSUdORURfVkFMVUU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodmFsdWUgPD0gLVRXT19QV1JfNjNfREJMKSByZXR1cm4gTUlOX1ZBTFVFO1xuICAgICAgICBpZiAodmFsdWUgKyAxID49IFRXT19QV1JfNjNfREJMKSByZXR1cm4gTUFYX1ZBTFVFO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlIDwgMCkgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XG4gICAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICAgIHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLFxuICAgICAgICAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLFxuICAgICAgICB1bnNpZ25lZCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIExvbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiB2YWx1ZSwgcHJvdmlkZWQgdGhhdCBpdCBpcyBhIGZpbml0ZSBudW1iZXIuIE90aGVyd2lzZSwgemVybyBpcyByZXR1cm5lZC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgVGhlIG51bWJlciBpbiBxdWVzdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICAgKi9cbiAgICBMb25nLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd0JpdHNcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGlnaEJpdHNcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSB1bnNpZ25lZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpIHtcbiAgICAgIHJldHVybiBuZXcgTG9uZyhsb3dCaXRzLCBoaWdoQml0cywgdW5zaWduZWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgNjQgYml0IGludGVnZXIgdGhhdCBjb21lcyBieSBjb25jYXRlbmF0aW5nIHRoZSBnaXZlbiBsb3cgYW5kIGhpZ2ggYml0cy4gRWFjaCBpc1xuICAgICAqICBhc3N1bWVkIHRvIHVzZSAzMiBiaXRzLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsb3dCaXRzIFRoZSBsb3cgMzIgYml0c1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoaWdoQml0cyBUaGUgaGlnaCAzMiBiaXRzXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgICAqL1xuICAgIExvbmcuZnJvbUJpdHMgPSBmcm9tQml0cztcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiYXNlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4cG9uZW50XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgcG93X2RibCA9IE1hdGgucG93OyAvLyBVc2VkIDQgdGltZXMgKDQqOCB0byAxNSs0KVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEBwYXJhbSB7KGJvb2xlYW58bnVtYmVyKT19IHVuc2lnbmVkXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeFxuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tU3RyaW5nKHN0ciwgdW5zaWduZWQsIHJhZGl4KSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkgdGhyb3cgRXJyb3IoXCJlbXB0eSBzdHJpbmdcIik7XG4gICAgICBpZiAodHlwZW9mIHVuc2lnbmVkID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIC8vIEZvciBnb29nLm1hdGgubG9uZyBjb21wYXRpYmlsaXR5XG4gICAgICAgIHJhZGl4ID0gdW5zaWduZWQ7XG4gICAgICAgIHVuc2lnbmVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHN0ciA9PT0gXCJOYU5cIiB8fFxuICAgICAgICBzdHIgPT09IFwiSW5maW5pdHlcIiB8fFxuICAgICAgICBzdHIgPT09IFwiK0luZmluaXR5XCIgfHxcbiAgICAgICAgc3RyID09PSBcIi1JbmZpbml0eVwiXG4gICAgICApXG4gICAgICAgIHJldHVybiB1bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICAgIHJhZGl4ID0gcmFkaXggfHwgMTA7XG4gICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpIHRocm93IFJhbmdlRXJyb3IoXCJyYWRpeFwiKTtcbiAgICAgIHZhciBwO1xuICAgICAgaWYgKChwID0gc3RyLmluZGV4T2YoXCItXCIpKSA+IDApIHRocm93IEVycm9yKFwiaW50ZXJpb3IgaHlwaGVuXCIpO1xuICAgICAgZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZnJvbVN0cmluZyhzdHIuc3Vic3RyaW5nKDEpLCB1bnNpZ25lZCwgcmFkaXgpLm5lZygpO1xuICAgICAgfVxuXG4gICAgICAvLyBEbyBzZXZlcmFsICg4KSBkaWdpdHMgZWFjaCB0aW1lIHRocm91Z2ggdGhlIGxvb3AsIHNvIGFzIHRvXG4gICAgICAvLyBtaW5pbWl6ZSB0aGUgY2FsbHMgdG8gdGhlIHZlcnkgZXhwZW5zaXZlIGVtdWxhdGVkIGRpdi5cbiAgICAgIHZhciByYWRpeFRvUG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIDgpKTtcbiAgICAgIHZhciByZXN1bHQgPSBaRVJPO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgdmFyIHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksXG4gICAgICAgICAgdmFsdWUgPSBwYXJzZUludChzdHIuc3Vic3RyaW5nKGksIGkgKyBzaXplKSwgcmFkaXgpO1xuICAgICAgICBpZiAoc2l6ZSA8IDgpIHtcbiAgICAgICAgICB2YXIgcG93ZXIgPSBmcm9tTnVtYmVyKHBvd19kYmwocmFkaXgsIHNpemUpKTtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQubXVsKHBvd2VyKS5hZGQoZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tdWwocmFkaXhUb1Bvd2VyKTtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuYWRkKGZyb21OdW1iZXIodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBzdHJpbmcsIHdyaXR0ZW4gdXNpbmcgdGhlIHNwZWNpZmllZCByYWRpeC5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBMb25nXG4gICAgICogQHBhcmFtIHsoYm9vbGVhbnxudW1iZXIpPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gcmFkaXggVGhlIHJhZGl4IGluIHdoaWNoIHRoZSB0ZXh0IGlzIHdyaXR0ZW4gKDItMzYpLCBkZWZhdWx0cyB0byAxMFxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgICAqL1xuICAgIExvbmcuZnJvbVN0cmluZyA9IGZyb21TdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkXG4gICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIGZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XG4gICAgICAvLyBUaHJvd3MgZm9yIG5vbi1vYmplY3RzLCBjb252ZXJ0cyBub24taW5zdGFuY2VvZiBMb25nOlxuICAgICAgcmV0dXJuIGZyb21CaXRzKFxuICAgICAgICB2YWwubG93LFxuICAgICAgICB2YWwuaGlnaCxcbiAgICAgICAgdHlwZW9mIHVuc2lnbmVkID09PSBcImJvb2xlYW5cIiA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgc3BlY2lmaWVkIHZhbHVlIHRvIGEgTG9uZyB1c2luZyB0aGUgYXBwcm9wcmlhdGUgZnJvbSogZnVuY3Rpb24gZm9yIGl0cyB0eXBlLlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd8IXtsb3c6IG51bWJlciwgaGlnaDogbnVtYmVyLCB1bnNpZ25lZDogYm9vbGVhbn19IHZhbCBWYWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9XG4gICAgICovXG4gICAgTG9uZy5mcm9tVmFsdWUgPSBmcm9tVmFsdWU7XG5cbiAgICAvLyBOT1RFOiB0aGUgY29tcGlsZXIgc2hvdWxkIGlubGluZSB0aGVzZSBjb25zdGFudCB2YWx1ZXMgYmVsb3cgYW5kIHRoZW4gcmVtb3ZlIHRoZXNlIHZhcmlhYmxlcywgc28gdGhlcmUgc2hvdWxkIGJlXG4gICAgLy8gbm8gcnVudGltZSBwZW5hbHR5IGZvciB0aGVzZS5cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGNvbnN0XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIFRXT19QV1JfMTZfREJMID0gMSA8PCAxNjtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGNvbnN0XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIFRXT19QV1JfMjRfREJMID0gMSA8PCAyNDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGNvbnN0XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIFRXT19QV1JfMzJfREJMID0gVFdPX1BXUl8xNl9EQkwgKiBUV09fUFdSXzE2X0RCTDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGNvbnN0XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIFRXT19QV1JfNjRfREJMID0gVFdPX1BXUl8zMl9EQkwgKiBUV09fUFdSXzMyX0RCTDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGNvbnN0XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIFRXT19QV1JfNjNfREJMID0gVFdPX1BXUl82NF9EQkwgLyAyO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqIEBjb25zdFxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBUV09fUFdSXzI0ID0gZnJvbUludChUV09fUFdSXzI0X0RCTCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIFpFUk8gPSBmcm9tSW50KDApO1xuXG4gICAgLyoqXG4gICAgICogU2lnbmVkIHplcm8uXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqL1xuICAgIExvbmcuWkVSTyA9IFpFUk87XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIFVaRVJPID0gZnJvbUludCgwLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFVuc2lnbmVkIHplcm8uXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqL1xuICAgIExvbmcuVVpFUk8gPSBVWkVSTztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgT05FID0gZnJvbUludCgxKTtcblxuICAgIC8qKlxuICAgICAqIFNpZ25lZCBvbmUuXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqL1xuICAgIExvbmcuT05FID0gT05FO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFMb25nfVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBVT05FID0gZnJvbUludCgxLCB0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFVuc2lnbmVkIG9uZS5cbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICovXG4gICAgTG9uZy5VT05FID0gVU9ORTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgTkVHX09ORSA9IGZyb21JbnQoLTEpO1xuXG4gICAgLyoqXG4gICAgICogU2lnbmVkIG5lZ2F0aXZlIG9uZS5cbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICovXG4gICAgTG9uZy5ORUdfT05FID0gTkVHX09ORTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgTUFYX1ZBTFVFID0gZnJvbUJpdHMoMHhmZmZmZmZmZiB8IDAsIDB4N2ZmZmZmZmYgfCAwLCBmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIHNpZ25lZCB2YWx1ZS5cbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICovXG4gICAgTG9uZy5NQVhfVkFMVUUgPSBNQVhfVkFMVUU7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7IUxvbmd9XG4gICAgICogQGlubmVyXG4gICAgICovXG4gICAgdmFyIE1BWF9VTlNJR05FRF9WQUxVRSA9IGZyb21CaXRzKDB4ZmZmZmZmZmYgfCAwLCAweGZmZmZmZmZmIHwgMCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIHVuc2lnbmVkIHZhbHVlLlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKi9cbiAgICBMb25nLk1BWF9VTlNJR05FRF9WQUxVRSA9IE1BWF9VTlNJR05FRF9WQUxVRTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKiBAaW5uZXJcbiAgICAgKi9cbiAgICB2YXIgTUlOX1ZBTFVFID0gZnJvbUJpdHMoMCwgMHg4MDAwMDAwMCB8IDAsIGZhbHNlKTtcblxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gc2lnbmVkIHZhbHVlLlxuICAgICAqIEB0eXBlIHshTG9uZ31cbiAgICAgKi9cbiAgICBMb25nLk1JTl9WQUxVRSA9IE1JTl9WQUxVRTtcblxuICAgIC8qKlxuICAgICAqIEBhbGlhcyBMb25nLnByb3RvdHlwZVxuICAgICAqIEBpbm5lclxuICAgICAqL1xuICAgIHZhciBMb25nUHJvdG90eXBlID0gTG9uZy5wcm90b3R5cGU7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBhIDMyIGJpdCBpbnRlZ2VyLCBhc3N1bWluZyBpdCBpcyBhIDMyIGJpdCBpbnRlZ2VyLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUudG9JbnQgPSBmdW5jdGlvbiB0b0ludCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gdGhpcy5sb3cgPj4+IDAgOiB0aGlzLmxvdztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIExvbmcgdG8gYSB0aGUgbmVhcmVzdCBmbG9hdGluZy1wb2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHZhbHVlIChkb3VibGUsIDUzIGJpdCBtYW50aXNzYSkuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyKCkge1xuICAgICAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgICAgIHJldHVybiAodGhpcy5oaWdoID4+PiAwKSAqIFRXT19QV1JfMzJfREJMICsgKHRoaXMubG93ID4+PiAwKTtcbiAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBMb25nIHRvIGEgc3RyaW5nIHdyaXR0ZW4gaW4gdGhlIHNwZWNpZmllZCByYWRpeC5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHtudW1iZXI9fSByYWRpeCBSYWRpeCAoMi0zNiksIGRlZmF1bHRzIHRvIDEwXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcmFkaXhgIGlzIG91dCBvZiByYW5nZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhyYWRpeCkge1xuICAgICAgcmFkaXggPSByYWRpeCB8fCAxMDtcbiAgICAgIGlmIChyYWRpeCA8IDIgfHwgMzYgPCByYWRpeCkgdGhyb3cgUmFuZ2VFcnJvcihcInJhZGl4XCIpO1xuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBcIjBcIjtcbiAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcbiAgICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkge1xuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY2hhbmdlIHRoZSBMb25nIHZhbHVlIGJlZm9yZSBpdCBjYW4gYmUgbmVnYXRlZCwgc28gd2UgcmVtb3ZlXG4gICAgICAgICAgLy8gdGhlIGJvdHRvbS1tb3N0IGRpZ2l0IGluIHRoaXMgYmFzZSBhbmQgdGhlbiByZWN1cnNlIHRvIGRvIHRoZSByZXN0LlxuICAgICAgICAgIHZhciByYWRpeExvbmcgPSBmcm9tTnVtYmVyKHJhZGl4KSxcbiAgICAgICAgICAgIGRpdiA9IHRoaXMuZGl2KHJhZGl4TG9uZyksXG4gICAgICAgICAgICByZW0xID0gZGl2Lm11bChyYWRpeExvbmcpLnN1Yih0aGlzKTtcbiAgICAgICAgICByZXR1cm4gZGl2LnRvU3RyaW5nKHJhZGl4KSArIHJlbTEudG9JbnQoKS50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gXCItXCIgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgIH1cblxuICAgICAgLy8gRG8gc2V2ZXJhbCAoNikgZGlnaXRzIGVhY2ggdGltZSB0aHJvdWdoIHRoZSBsb29wLCBzbyBhcyB0b1xuICAgICAgLy8gbWluaW1pemUgdGhlIGNhbGxzIHRvIHRoZSB2ZXJ5IGV4cGVuc2l2ZSBlbXVsYXRlZCBkaXYuXG4gICAgICB2YXIgcmFkaXhUb1Bvd2VyID0gZnJvbU51bWJlcihwb3dfZGJsKHJhZGl4LCA2KSwgdGhpcy51bnNpZ25lZCksXG4gICAgICAgIHJlbSA9IHRoaXM7XG4gICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZW1EaXYgPSByZW0uZGl2KHJhZGl4VG9Qb3dlciksXG4gICAgICAgICAgaW50dmFsID0gcmVtLnN1YihyZW1EaXYubXVsKHJhZGl4VG9Qb3dlcikpLnRvSW50KCkgPj4+IDAsXG4gICAgICAgICAgZGlnaXRzID0gaW50dmFsLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgcmVtID0gcmVtRGl2O1xuICAgICAgICBpZiAocmVtLmlzWmVybygpKSByZXR1cm4gZGlnaXRzICsgcmVzdWx0O1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAoZGlnaXRzLmxlbmd0aCA8IDYpIGRpZ2l0cyA9IFwiMFwiICsgZGlnaXRzO1xuICAgICAgICAgIHJlc3VsdCA9IFwiXCIgKyBkaWdpdHMgKyByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGlnaCAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBoaWdoIGJpdHNcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmdldEhpZ2hCaXRzID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oaWdoO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBoaWdoIDMyIGJpdHMgYXMgYW4gdW5zaWduZWQgaW50ZWdlci5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHJldHVybnMge251bWJlcn0gVW5zaWduZWQgaGlnaCBiaXRzXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRIaWdoQml0c1Vuc2lnbmVkID0gZnVuY3Rpb24gZ2V0SGlnaEJpdHNVbnNpZ25lZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhpZ2ggPj4+IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGEgc2lnbmVkIGludGVnZXIuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFNpZ25lZCBsb3cgYml0c1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZ2V0TG93Qml0cyA9IGZ1bmN0aW9uIGdldExvd0JpdHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb3c7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxvdyAzMiBiaXRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFVuc2lnbmVkIGxvdyBiaXRzXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5nZXRMb3dCaXRzVW5zaWduZWQgPSBmdW5jdGlvbiBnZXRMb3dCaXRzVW5zaWduZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sb3cgPj4+IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG51bWJlciBvZiBiaXRzIG5lZWRlZCB0byByZXByZXNlbnQgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgTG9uZy5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmdldE51bUJpdHNBYnMgPSBmdW5jdGlvbiBnZXROdW1CaXRzQWJzKCkge1xuICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKVxuICAgICAgICAvLyBVbnNpZ25lZCBMb25ncyBhcmUgbmV2ZXIgbmVnYXRpdmVcbiAgICAgICAgcmV0dXJuIHRoaXMuZXEoTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XG4gICAgICB2YXIgdmFsID0gdGhpcy5oaWdoICE9IDAgPyB0aGlzLmhpZ2ggOiB0aGlzLmxvdztcbiAgICAgIGZvciAodmFyIGJpdCA9IDMxOyBiaXQgPiAwOyBiaXQtLSkgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPSAwKSBicmVhaztcbiAgICAgIHJldHVybiB0aGlzLmhpZ2ggIT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nIGNhbiBiZSBzYWZlbHkgcmVwcmVzZW50ZWQgYXMgYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5pc1NhZmVJbnRlZ2VyID0gZnVuY3Rpb24gaXNTYWZlSW50ZWdlcigpIHtcbiAgICAgIC8vIDJeNTMtMSBpcyB0aGUgbWF4aW11bSBzYWZlIHZhbHVlXG4gICAgICB2YXIgdG9wMTFCaXRzID0gdGhpcy5oaWdoID4+IDIxO1xuICAgICAgLy8gWzAsIDJeNTMtMV1cbiAgICAgIGlmICghdG9wMTFCaXRzKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vID4gMl41My0xXG4gICAgICBpZiAodGhpcy51bnNpZ25lZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gWy0yXjUzLCAtMV0gZXhjZXB0IC0yXjUzXG4gICAgICByZXR1cm4gdG9wMTFCaXRzID09PSAtMSAmJiAhKHRoaXMubG93ID09PSAwICYmIHRoaXMuaGlnaCA9PT0gLTB4MjAwMDAwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGlnaCA9PT0gMCAmJiB0aGlzLmxvdyA9PT0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHplcm8uIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjaXNaZXJvfS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmVxeiA9IExvbmdQcm90b3R5cGUuaXNaZXJvO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbmVnYXRpdmUuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uIGlzTmVnYXRpdmUoKSB7XG4gICAgICByZXR1cm4gIXRoaXMudW5zaWduZWQgJiYgdGhpcy5oaWdoIDwgMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgcG9zaXRpdmUgb3IgemVyby5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkIHx8IHRoaXMuaGlnaCA+PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBvZGQuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCgpIHtcbiAgICAgIHJldHVybiAodGhpcy5sb3cgJiAxKSA9PT0gMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZXZlbi5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5pc0V2ZW4gPSBmdW5jdGlvbiBpc0V2ZW4oKSB7XG4gICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGVxdWFscyB0aGUgc3BlY2lmaWVkJ3MuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMob3RoZXIpIHtcbiAgICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJlxuICAgICAgICB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmXG4gICAgICAgIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxXG4gICAgICApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzLmhpZ2ggPT09IG90aGVyLmhpZ2ggJiYgdGhpcy5sb3cgPT09IG90aGVyLmxvdztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZXF1YWxzIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNlcXVhbHN9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5lcSA9IExvbmdQcm90b3R5cGUuZXF1YWxzO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm5vdEVxdWFscyA9IGZ1bmN0aW9uIG5vdEVxdWFscyhvdGhlcikge1xuICAgICAgcmV0dXJuICF0aGlzLmVxKC8qIHZhbGlkYXRlcyAqLyBvdGhlcik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbm90RXF1YWxzfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubmVxID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI25vdEVxdWFsc30uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm5lID0gTG9uZ1Byb3RvdHlwZS5ub3RFcXVhbHM7XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubGVzc1RoYW4gPSBmdW5jdGlvbiBsZXNzVGhhbihvdGhlcikge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcCgvKiB2YWxpZGF0ZXMgKi8gb3RoZXIpIDwgMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbn0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmx0ID0gTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbjtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5sZXNzVGhhbk9yRXF1YWwgPSBmdW5jdGlvbiBsZXNzVGhhbk9yRXF1YWwob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA8PSAwO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2xlc3NUaGFuT3JFcXVhbH0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmx0ZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNsZXNzVGhhbk9yRXF1YWx9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5sZSA9IExvbmdQcm90b3R5cGUubGVzc1RoYW5PckVxdWFsO1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIHRoZSBzcGVjaWZpZWQncy5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gZnVuY3Rpb24gZ3JlYXRlclRoYW4ob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXAoLyogdmFsaWRhdGVzICovIG90aGVyKSA+IDA7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW59LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5ndCA9IExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW47XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBpZiB0aGlzIExvbmcncyB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsID0gZnVuY3Rpb24gZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wKC8qIHZhbGlkYXRlcyAqLyBvdGhlcikgPj0gMDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGVzdHMgaWYgdGhpcyBMb25nJ3MgdmFsdWUgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRoZSBzcGVjaWZpZWQncy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNncmVhdGVyVGhhbk9yRXF1YWx9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IG90aGVyIE90aGVyIHZhbHVlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5ndGUgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcblxuICAgIC8qKlxuICAgICAqIFRlc3RzIGlmIHRoaXMgTG9uZydzIHZhbHVlIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjZ3JlYXRlclRoYW5PckVxdWFsfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZ2UgPSBMb25nUHJvdG90eXBlLmdyZWF0ZXJUaGFuT3JFcXVhbDtcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHRoaXMgTG9uZydzIHZhbHVlIHdpdGggdGhlIHNwZWNpZmllZCdzLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIDEgaWYgdGhlIHRoaXMgaXMgZ3JlYXRlciBhbmQgLTFcbiAgICAgKiAgaWYgdGhlIGdpdmVuIG9uZSBpcyBncmVhdGVyXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZShvdGhlcikge1xuICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgICBpZiAodGhpcy5lcShvdGhlcikpIHJldHVybiAwO1xuICAgICAgdmFyIHRoaXNOZWcgPSB0aGlzLmlzTmVnYXRpdmUoKSxcbiAgICAgICAgb3RoZXJOZWcgPSBvdGhlci5pc05lZ2F0aXZlKCk7XG4gICAgICBpZiAodGhpc05lZyAmJiAhb3RoZXJOZWcpIHJldHVybiAtMTtcbiAgICAgIGlmICghdGhpc05lZyAmJiBvdGhlck5lZykgcmV0dXJuIDE7XG4gICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZSBzaWduIGJpdHMgYXJlIHRoZSBzYW1lXG4gICAgICBpZiAoIXRoaXMudW5zaWduZWQpIHJldHVybiB0aGlzLnN1YihvdGhlcikuaXNOZWdhdGl2ZSgpID8gLTEgOiAxO1xuICAgICAgLy8gQm90aCBhcmUgcG9zaXRpdmUgaWYgYXQgbGVhc3Qgb25lIGlzIHVuc2lnbmVkXG4gICAgICByZXR1cm4gb3RoZXIuaGlnaCA+Pj4gMCA+IHRoaXMuaGlnaCA+Pj4gMCB8fFxuICAgICAgICAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwKVxuICAgICAgICA/IC0xXG4gICAgICAgIDogMTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdGhpcyBMb25nJ3MgdmFsdWUgd2l0aCB0aGUgc3BlY2lmaWVkJ3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY29tcGFyZX0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAwIGlmIHRoZXkgYXJlIHRoZSBzYW1lLCAxIGlmIHRoZSB0aGlzIGlzIGdyZWF0ZXIgYW5kIC0xXG4gICAgICogIGlmIHRoZSBnaXZlbiBvbmUgaXMgZ3JlYXRlclxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuY29tcCA9IExvbmdQcm90b3R5cGUuY29tcGFyZTtcblxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gTmVnYXRlZCBMb25nXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbiBuZWdhdGUoKSB7XG4gICAgICBpZiAoIXRoaXMudW5zaWduZWQgJiYgdGhpcy5lcShNSU5fVkFMVUUpKSByZXR1cm4gTUlOX1ZBTFVFO1xuICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKE9ORSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE5lZ2F0ZXMgdGhpcyBMb25nJ3MgdmFsdWUuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbmVnYXRlfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IE5lZ2F0ZWQgTG9uZ1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubmVnID0gTG9uZ1Byb3RvdHlwZS5uZWdhdGU7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBhZGRlbmQgQWRkZW5kXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTdW1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChhZGRlbmQpIHtcbiAgICAgIGlmICghaXNMb25nKGFkZGVuZCkpIGFkZGVuZCA9IGZyb21WYWx1ZShhZGRlbmQpO1xuXG4gICAgICAvLyBEaXZpZGUgZWFjaCBudW1iZXIgaW50byA0IGNodW5rcyBvZiAxNiBiaXRzLCBhbmQgdGhlbiBzdW0gdGhlIGNodW5rcy5cblxuICAgICAgdmFyIGE0OCA9IHRoaXMuaGlnaCA+Pj4gMTY7XG4gICAgICB2YXIgYTMyID0gdGhpcy5oaWdoICYgMHhmZmZmO1xuICAgICAgdmFyIGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICAgIHZhciBhMDAgPSB0aGlzLmxvdyAmIDB4ZmZmZjtcbiAgICAgIHZhciBiNDggPSBhZGRlbmQuaGlnaCA+Pj4gMTY7XG4gICAgICB2YXIgYjMyID0gYWRkZW5kLmhpZ2ggJiAweGZmZmY7XG4gICAgICB2YXIgYjE2ID0gYWRkZW5kLmxvdyA+Pj4gMTY7XG4gICAgICB2YXIgYjAwID0gYWRkZW5kLmxvdyAmIDB4ZmZmZjtcbiAgICAgIHZhciBjNDggPSAwLFxuICAgICAgICBjMzIgPSAwLFxuICAgICAgICBjMTYgPSAwLFxuICAgICAgICBjMDAgPSAwO1xuICAgICAgYzAwICs9IGEwMCArIGIwMDtcbiAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgICAgYzAwICY9IDB4ZmZmZjtcbiAgICAgIGMxNiArPSBhMTYgKyBiMTY7XG4gICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICBjMzIgKz0gYTMyICsgYjMyO1xuICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgYzQ4ICs9IGE0OCArIGI0ODtcbiAgICAgIGM0OCAmPSAweGZmZmY7XG4gICAgICByZXR1cm4gZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiBzdWJ0cmFjdChzdWJ0cmFoZW5kKSB7XG4gICAgICBpZiAoIWlzTG9uZyhzdWJ0cmFoZW5kKSkgc3VidHJhaGVuZCA9IGZyb21WYWx1ZShzdWJ0cmFoZW5kKTtcbiAgICAgIHJldHVybiB0aGlzLmFkZChzdWJ0cmFoZW5kLm5lZygpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlmZmVyZW5jZSBvZiB0aGlzIGFuZCB0aGUgc3BlY2lmaWVkIExvbmcuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc3VidHJhY3R9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IHN1YnRyYWhlbmQgU3VidHJhaGVuZFxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gRGlmZmVyZW5jZVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuc3ViID0gTG9uZ1Byb3RvdHlwZS5zdWJ0cmFjdDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb2R1Y3Qgb2YgdGhpcyBhbmQgdGhlIHNwZWNpZmllZCBMb25nLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBtdWx0aXBsaWVyIE11bHRpcGxpZXJcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFByb2R1Y3RcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24gbXVsdGlwbHkobXVsdGlwbGllcikge1xuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFpc0xvbmcobXVsdGlwbGllcikpIG11bHRpcGxpZXIgPSBmcm9tVmFsdWUobXVsdGlwbGllcik7XG5cbiAgICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICAgICAgaWYgKHdhc20pIHtcbiAgICAgICAgdmFyIGxvdyA9IHdhc21bXCJtdWxcIl0oXG4gICAgICAgICAgdGhpcy5sb3csXG4gICAgICAgICAgdGhpcy5oaWdoLFxuICAgICAgICAgIG11bHRpcGxpZXIubG93LFxuICAgICAgICAgIG11bHRpcGxpZXIuaGlnaCxcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKGxvdywgd2FzbVtcImdldF9oaWdoXCJdKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgfVxuICAgICAgaWYgKG11bHRpcGxpZXIuaXNaZXJvKCkpIHJldHVybiB0aGlzLnVuc2lnbmVkID8gVVpFUk8gOiBaRVJPO1xuICAgICAgaWYgKHRoaXMuZXEoTUlOX1ZBTFVFKSkgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IE1JTl9WQUxVRSA6IFpFUk87XG4gICAgICBpZiAobXVsdGlwbGllci5lcShNSU5fVkFMVUUpKSByZXR1cm4gdGhpcy5pc09kZCgpID8gTUlOX1ZBTFVFIDogWkVSTztcbiAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcbiAgICAgICAgZWxzZSByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XG4gICAgICB9IGVsc2UgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxuICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XG5cbiAgICAgIC8vIElmIGJvdGggbG9uZ3MgYXJlIHNtYWxsLCB1c2UgZmxvYXQgbXVsdGlwbGljYXRpb25cbiAgICAgIGlmICh0aGlzLmx0KFRXT19QV1JfMjQpICYmIG11bHRpcGxpZXIubHQoVFdPX1BXUl8yNCkpXG4gICAgICAgIHJldHVybiBmcm9tTnVtYmVyKFxuICAgICAgICAgIHRoaXMudG9OdW1iZXIoKSAqIG11bHRpcGxpZXIudG9OdW1iZXIoKSxcbiAgICAgICAgICB0aGlzLnVuc2lnbmVkLFxuICAgICAgICApO1xuXG4gICAgICAvLyBEaXZpZGUgZWFjaCBsb25nIGludG8gNCBjaHVua3Mgb2YgMTYgYml0cywgYW5kIHRoZW4gYWRkIHVwIDR4NCBwcm9kdWN0cy5cbiAgICAgIC8vIFdlIGNhbiBza2lwIHByb2R1Y3RzIHRoYXQgd291bGQgb3ZlcmZsb3cuXG5cbiAgICAgIHZhciBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgICAgdmFyIGEzMiA9IHRoaXMuaGlnaCAmIDB4ZmZmZjtcbiAgICAgIHZhciBhMTYgPSB0aGlzLmxvdyA+Pj4gMTY7XG4gICAgICB2YXIgYTAwID0gdGhpcy5sb3cgJiAweGZmZmY7XG4gICAgICB2YXIgYjQ4ID0gbXVsdGlwbGllci5oaWdoID4+PiAxNjtcbiAgICAgIHZhciBiMzIgPSBtdWx0aXBsaWVyLmhpZ2ggJiAweGZmZmY7XG4gICAgICB2YXIgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xuICAgICAgdmFyIGIwMCA9IG11bHRpcGxpZXIubG93ICYgMHhmZmZmO1xuICAgICAgdmFyIGM0OCA9IDAsXG4gICAgICAgIGMzMiA9IDAsXG4gICAgICAgIGMxNiA9IDAsXG4gICAgICAgIGMwMCA9IDA7XG4gICAgICBjMDAgKz0gYTAwICogYjAwO1xuICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgICBjMDAgJj0gMHhmZmZmO1xuICAgICAgYzE2ICs9IGExNiAqIGIwMDtcbiAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgYzE2ICY9IDB4ZmZmZjtcbiAgICAgIGMxNiArPSBhMDAgKiBiMTY7XG4gICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICBjMzIgKz0gYTMyICogYjAwO1xuICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgYzMyICs9IGExNiAqIGIxNjtcbiAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgIGMzMiArPSBhMDAgKiBiMzI7XG4gICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICBjNDggKz0gYTQ4ICogYjAwICsgYTMyICogYjE2ICsgYTE2ICogYjMyICsgYTAwICogYjQ4O1xuICAgICAgYzQ4ICY9IDB4ZmZmZjtcbiAgICAgIHJldHVybiBmcm9tQml0cygoYzE2IDw8IDE2KSB8IGMwMCwgKGM0OCA8PCAxNikgfCBjMzIsIHRoaXMudW5zaWduZWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9kdWN0IG9mIHRoaXMgYW5kIHRoZSBzcGVjaWZpZWQgTG9uZy4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtdWx0aXBseX0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gbXVsdGlwbGllciBNdWx0aXBsaWVyXG4gICAgICogQHJldHVybnMgeyFMb25nfSBQcm9kdWN0XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5tdWwgPSBMb25nUHJvdG90eXBlLm11bHRpcGx5O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgZGl2aWRlZCBieSB0aGUgc3BlY2lmaWVkLiBUaGUgcmVzdWx0IGlzIHNpZ25lZCBpZiB0aGlzIExvbmcgaXMgc2lnbmVkIG9yXG4gICAgICogIHVuc2lnbmVkIGlmIHRoaXMgTG9uZyBpcyB1bnNpZ25lZC5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gZGl2aXNvciBEaXZpc29yXG4gICAgICogQHJldHVybnMgeyFMb25nfSBRdW90aWVudFxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24gZGl2aWRlKGRpdmlzb3IpIHtcbiAgICAgIGlmICghaXNMb25nKGRpdmlzb3IpKSBkaXZpc29yID0gZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgICAgaWYgKGRpdmlzb3IuaXNaZXJvKCkpIHRocm93IEVycm9yKFwiZGl2aXNpb24gYnkgemVyb1wiKTtcblxuICAgICAgLy8gdXNlIHdhc20gc3VwcG9ydCBpZiBwcmVzZW50XG4gICAgICBpZiAod2FzbSkge1xuICAgICAgICAvLyBndWFyZCBhZ2FpbnN0IHNpZ25lZCBkaXZpc2lvbiBvdmVyZmxvdzogdGhlIGxhcmdlc3RcbiAgICAgICAgLy8gbmVnYXRpdmUgbnVtYmVyIC8gLTEgd291bGQgYmUgMSBsYXJnZXIgdGhhbiB0aGUgbGFyZ2VzdFxuICAgICAgICAvLyBwb3NpdGl2ZSBudW1iZXIsIGR1ZSB0byB0d28ncyBjb21wbGVtZW50LlxuICAgICAgICBpZiAoXG4gICAgICAgICAgIXRoaXMudW5zaWduZWQgJiZcbiAgICAgICAgICB0aGlzLmhpZ2ggPT09IC0weDgwMDAwMDAwICYmXG4gICAgICAgICAgZGl2aXNvci5sb3cgPT09IC0xICYmXG4gICAgICAgICAgZGl2aXNvci5oaWdoID09PSAtMVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBiZSBjb25zaXN0ZW50IHdpdGggbm9uLXdhc20gY29kZSBwYXRoXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcImRpdl91XCJdIDogd2FzbVtcImRpdl9zXCJdKShcbiAgICAgICAgICB0aGlzLmxvdyxcbiAgICAgICAgICB0aGlzLmhpZ2gsXG4gICAgICAgICAgZGl2aXNvci5sb3csXG4gICAgICAgICAgZGl2aXNvci5oaWdoLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBVWkVSTyA6IFpFUk87XG4gICAgICB2YXIgYXBwcm94LCByZW0sIHJlcztcbiAgICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xuICAgICAgICAvLyBUaGlzIHNlY3Rpb24gaXMgb25seSByZWxldmFudCBmb3Igc2lnbmVkIGxvbmdzIGFuZCBpcyBkZXJpdmVkIGZyb20gdGhlXG4gICAgICAgIC8vIGNsb3N1cmUgbGlicmFyeSBhcyBhIHdob2xlLlxuICAgICAgICBpZiAodGhpcy5lcShNSU5fVkFMVUUpKSB7XG4gICAgICAgICAgaWYgKGRpdmlzb3IuZXEoT05FKSB8fCBkaXZpc29yLmVxKE5FR19PTkUpKVxuICAgICAgICAgICAgcmV0dXJuIE1JTl9WQUxVRTsgLy8gcmVjYWxsIHRoYXQgLU1JTl9WQUxVRSA9PSBNSU5fVkFMVUVcbiAgICAgICAgICBlbHNlIGlmIChkaXZpc29yLmVxKE1JTl9WQUxVRSkpIHJldHVybiBPTkU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBoYXZlIHxvdGhlcnwgPj0gMiwgc28gfHRoaXMvb3RoZXJ8IDwgfE1JTl9WQUxVRXwuXG4gICAgICAgICAgICB2YXIgaGFsZlRoaXMgPSB0aGlzLnNocigxKTtcbiAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XG4gICAgICAgICAgICBpZiAoYXBwcm94LmVxKFpFUk8pKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkaXZpc29yLmlzTmVnYXRpdmUoKSA/IE9ORSA6IE5FR19PTkU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcbiAgICAgICAgICAgICAgcmVzID0gYXBwcm94LmFkZChyZW0uZGl2KGRpdmlzb3IpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGl2aXNvci5lcShNSU5fVkFMVUUpKSByZXR1cm4gdGhpcy51bnNpZ25lZCA/IFVaRVJPIDogWkVSTztcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xuICAgICAgICB9IGVsc2UgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKSByZXR1cm4gdGhpcy5kaXYoZGl2aXNvci5uZWcoKSkubmVnKCk7XG4gICAgICAgIHJlcyA9IFpFUk87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgYWxnb3JpdGhtIGJlbG93IGhhcyBub3QgYmVlbiBtYWRlIGZvciB1bnNpZ25lZCBsb25ncy4gSXQncyB0aGVyZWZvcmVcbiAgICAgICAgLy8gcmVxdWlyZWQgdG8gdGFrZSBzcGVjaWFsIGNhcmUgb2YgdGhlIE1TQiBwcmlvciB0byBydW5uaW5nIGl0LlxuICAgICAgICBpZiAoIWRpdmlzb3IudW5zaWduZWQpIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcbiAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcykpIHJldHVybiBVWkVSTztcbiAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSlcbiAgICAgICAgICAvLyAxNSA+Pj4gMSA9IDcgOyB3aXRoIGRpdmlzb3IgPSA4IDsgdHJ1ZVxuICAgICAgICAgIHJldHVybiBVT05FO1xuICAgICAgICByZXMgPSBVWkVSTztcbiAgICAgIH1cblxuICAgICAgLy8gUmVwZWF0IHRoZSBmb2xsb3dpbmcgdW50aWwgdGhlIHJlbWFpbmRlciBpcyBsZXNzIHRoYW4gb3RoZXI6ICBmaW5kIGFcbiAgICAgIC8vIGZsb2F0aW5nLXBvaW50IHRoYXQgYXBwcm94aW1hdGVzIHJlbWFpbmRlciAvIG90aGVyICpmcm9tIGJlbG93KiwgYWRkIHRoaXNcbiAgICAgIC8vIGludG8gdGhlIHJlc3VsdCwgYW5kIHN1YnRyYWN0IGl0IGZyb20gdGhlIHJlbWFpbmRlci4gIEl0IGlzIGNyaXRpY2FsIHRoYXRcbiAgICAgIC8vIHRoZSBhcHByb3hpbWF0ZSB2YWx1ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHJlYWwgdmFsdWUgc28gdGhhdCB0aGVcbiAgICAgIC8vIHJlbWFpbmRlciBuZXZlciBiZWNvbWVzIG5lZ2F0aXZlLlxuICAgICAgcmVtID0gdGhpcztcbiAgICAgIHdoaWxlIChyZW0uZ3RlKGRpdmlzb3IpKSB7XG4gICAgICAgIC8vIEFwcHJveGltYXRlIHRoZSByZXN1bHQgb2YgZGl2aXNpb24uIFRoaXMgbWF5IGJlIGEgbGl0dGxlIGdyZWF0ZXIgb3JcbiAgICAgICAgLy8gc21hbGxlciB0aGFuIHRoZSBhY3R1YWwgdmFsdWUuXG4gICAgICAgIGFwcHJveCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IocmVtLnRvTnVtYmVyKCkgLyBkaXZpc29yLnRvTnVtYmVyKCkpKTtcblxuICAgICAgICAvLyBXZSB3aWxsIHR3ZWFrIHRoZSBhcHByb3hpbWF0ZSByZXN1bHQgYnkgY2hhbmdpbmcgaXQgaW4gdGhlIDQ4LXRoIGRpZ2l0IG9yXG4gICAgICAgIC8vIHRoZSBzbWFsbGVzdCBub24tZnJhY3Rpb25hbCBkaWdpdCwgd2hpY2hldmVyIGlzIGxhcmdlci5cbiAgICAgICAgdmFyIGxvZzIgPSBNYXRoLmNlaWwoTWF0aC5sb2coYXBwcm94KSAvIE1hdGguTE4yKSxcbiAgICAgICAgICBkZWx0YSA9IGxvZzIgPD0gNDggPyAxIDogcG93X2RibCgyLCBsb2cyIC0gNDgpLFxuICAgICAgICAgIC8vIERlY3JlYXNlIHRoZSBhcHByb3hpbWF0aW9uIHVudGlsIGl0IGlzIHNtYWxsZXIgdGhhbiB0aGUgcmVtYWluZGVyLiAgTm90ZVxuICAgICAgICAgIC8vIHRoYXQgaWYgaXQgaXMgdG9vIGxhcmdlLCB0aGUgcHJvZHVjdCBvdmVyZmxvd3MgYW5kIGlzIG5lZ2F0aXZlLlxuICAgICAgICAgIGFwcHJveFJlcyA9IGZyb21OdW1iZXIoYXBwcm94KSxcbiAgICAgICAgICBhcHByb3hSZW0gPSBhcHByb3hSZXMubXVsKGRpdmlzb3IpO1xuICAgICAgICB3aGlsZSAoYXBwcm94UmVtLmlzTmVnYXRpdmUoKSB8fCBhcHByb3hSZW0uZ3QocmVtKSkge1xuICAgICAgICAgIGFwcHJveCAtPSBkZWx0YTtcbiAgICAgICAgICBhcHByb3hSZXMgPSBmcm9tTnVtYmVyKGFwcHJveCwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgICAgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGtub3cgdGhlIGFuc3dlciBjYW4ndCBiZSB6ZXJvLi4uIGFuZCBhY3R1YWxseSwgemVybyB3b3VsZCBjYXVzZVxuICAgICAgICAvLyBpbmZpbml0ZSByZWN1cnNpb24gc2luY2Ugd2Ugd291bGQgbWFrZSBubyBwcm9ncmVzcy5cbiAgICAgICAgaWYgKGFwcHJveFJlcy5pc1plcm8oKSkgYXBwcm94UmVzID0gT05FO1xuICAgICAgICByZXMgPSByZXMuYWRkKGFwcHJveFJlcyk7XG4gICAgICAgIHJlbSA9IHJlbS5zdWIoYXBwcm94UmVtKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIGRpdmlkZWQgYnkgdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNkaXZpZGV9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUXVvdGllbnRcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmRpdiA9IExvbmdQcm90b3R5cGUuZGl2aWRlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5tb2R1bG8gPSBmdW5jdGlvbiBtb2R1bG8oZGl2aXNvcikge1xuICAgICAgaWYgKCFpc0xvbmcoZGl2aXNvcikpIGRpdmlzb3IgPSBmcm9tVmFsdWUoZGl2aXNvcik7XG5cbiAgICAgIC8vIHVzZSB3YXNtIHN1cHBvcnQgaWYgcHJlc2VudFxuICAgICAgaWYgKHdhc20pIHtcbiAgICAgICAgdmFyIGxvdyA9ICh0aGlzLnVuc2lnbmVkID8gd2FzbVtcInJlbV91XCJdIDogd2FzbVtcInJlbV9zXCJdKShcbiAgICAgICAgICB0aGlzLmxvdyxcbiAgICAgICAgICB0aGlzLmhpZ2gsXG4gICAgICAgICAgZGl2aXNvci5sb3csXG4gICAgICAgICAgZGl2aXNvci5oaWdoLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93LCB3YXNtW1wiZ2V0X2hpZ2hcIl0oKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zdWIodGhpcy5kaXYoZGl2aXNvcikubXVsKGRpdmlzb3IpKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgbW9kdWxvIHRoZSBzcGVjaWZpZWQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjbW9kdWxvfS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBkaXZpc29yIERpdmlzb3JcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJlbWFpbmRlclxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubW9kID0gTG9uZ1Byb3RvdHlwZS5tb2R1bG87XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyBtb2R1bG8gdGhlIHNwZWNpZmllZC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNtb2R1bG99LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd8bnVtYmVyfGJpZ2ludHxzdHJpbmd9IGRpdmlzb3IgRGl2aXNvclxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gUmVtYWluZGVyXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5yZW0gPSBMb25nUHJvdG90eXBlLm1vZHVsbztcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgTk9UIG9mIHRoaXMgTG9uZy5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUubm90ID0gZnVuY3Rpb24gbm90KCkge1xuICAgICAgcmV0dXJuIGZyb21CaXRzKH50aGlzLmxvdywgfnRoaXMuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY291bnQgbGVhZGluZyB6ZXJvcyBvZiB0aGlzIExvbmcuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuY291bnRMZWFkaW5nWmVyb3MgPSBmdW5jdGlvbiBjb3VudExlYWRpbmdaZXJvcygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhpZ2ggPyBNYXRoLmNsejMyKHRoaXMuaGlnaCkgOiBNYXRoLmNsejMyKHRoaXMubG93KSArIDMyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvdW50IGxlYWRpbmcgemVyb3MuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjY291bnRMZWFkaW5nWmVyb3N9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7IUxvbmd9XG4gICAgICogQHJldHVybnMgeyFudW1iZXJ9XG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5jbHogPSBMb25nUHJvdG90eXBlLmNvdW50TGVhZGluZ1plcm9zO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBjb3VudCB0cmFpbGluZyB6ZXJvcyBvZiB0aGlzIExvbmcuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHshbnVtYmVyfVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zID0gZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKCkge1xuICAgICAgcmV0dXJuIHRoaXMubG93ID8gY3R6MzIodGhpcy5sb3cpIDogY3R6MzIodGhpcy5oaWdoKSArIDMyO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvdW50IHRyYWlsaW5nIHplcm9zLiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI2NvdW50VHJhaWxpbmdaZXJvc30uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHshTG9uZ31cbiAgICAgKiBAcmV0dXJucyB7IW51bWJlcn1cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLmN0eiA9IExvbmdQcm90b3R5cGUuY291bnRUcmFpbGluZ1plcm9zO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYml0d2lzZSBBTkQgb2YgdGhpcyBMb25nIGFuZCB0aGUgc3BlY2lmaWVkLlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0geyFMb25nfG51bWJlcnxiaWdpbnR8c3RyaW5nfSBvdGhlciBPdGhlciBMb25nXG4gICAgICogQHJldHVybnMgeyFMb25nfVxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kKG90aGVyKSB7XG4gICAgICBpZiAoIWlzTG9uZyhvdGhlcikpIG90aGVyID0gZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyhcbiAgICAgICAgdGhpcy5sb3cgJiBvdGhlci5sb3csXG4gICAgICAgIHRoaXMuaGlnaCAmIG90aGVyLmhpZ2gsXG4gICAgICAgIHRoaXMudW5zaWduZWQsXG4gICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiaXR3aXNlIE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIHNwZWNpZmllZC5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3Iob3RoZXIpIHtcbiAgICAgIGlmICghaXNMb25nKG90aGVyKSkgb3RoZXIgPSBmcm9tVmFsdWUob3RoZXIpO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKFxuICAgICAgICB0aGlzLmxvdyB8IG90aGVyLmxvdyxcbiAgICAgICAgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCxcbiAgICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpdHdpc2UgWE9SIG9mIHRoaXMgTG9uZyBhbmQgdGhlIGdpdmVuIG9uZS5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHshTG9uZ3xudW1iZXJ8YmlnaW50fHN0cmluZ30gb3RoZXIgT3RoZXIgTG9uZ1xuICAgICAqIEByZXR1cm5zIHshTG9uZ31cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvcihvdGhlcikge1xuICAgICAgaWYgKCFpc0xvbmcob3RoZXIpKSBvdGhlciA9IGZyb21WYWx1ZShvdGhlcik7XG4gICAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICAgIHRoaXMubG93IF4gb3RoZXIubG93LFxuICAgICAgICB0aGlzLmhpZ2ggXiBvdGhlci5oaWdoLFxuICAgICAgICB0aGlzLnVuc2lnbmVkLFxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHNoaWZ0ZWQgdG8gdGhlIGxlZnQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuc2hpZnRMZWZ0ID0gZnVuY3Rpb24gc2hpZnRMZWZ0KG51bUJpdHMpIHtcbiAgICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKFxuICAgICAgICAgIHRoaXMubG93IDw8IG51bUJpdHMsXG4gICAgICAgICAgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLFxuICAgICAgICAgIHRoaXMudW5zaWduZWQsXG4gICAgICAgICk7XG4gICAgICBlbHNlIHJldHVybiBmcm9tQml0cygwLCB0aGlzLmxvdyA8PCAobnVtQml0cyAtIDMyKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBzaGlmdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjc2hpZnRMZWZ0fS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGwgPSBMb25nUHJvdG90eXBlLnNoaWZ0TGVmdDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyBhcml0aG1ldGljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LlxuICAgICAqIEB0aGlzIHshTG9uZ31cbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5zaGlmdFJpZ2h0ID0gZnVuY3Rpb24gc2hpZnRSaWdodChudW1CaXRzKSB7XG4gICAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgICBlbHNlIGlmIChudW1CaXRzIDwgMzIpXG4gICAgICAgIHJldHVybiBmcm9tQml0cyhcbiAgICAgICAgICAodGhpcy5sb3cgPj4+IG51bUJpdHMpIHwgKHRoaXMuaGlnaCA8PCAoMzIgLSBudW1CaXRzKSksXG4gICAgICAgICAgdGhpcy5oaWdoID4+IG51bUJpdHMsXG4gICAgICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIGZyb21CaXRzKFxuICAgICAgICAgIHRoaXMuaGlnaCA+PiAobnVtQml0cyAtIDMyKSxcbiAgICAgICAgICB0aGlzLmhpZ2ggPj0gMCA/IDAgOiAtMSxcbiAgICAgICAgICB0aGlzLnVuc2lnbmVkLFxuICAgICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgYXJpdGhtZXRpY2FsbHkgc2hpZnRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC4gVGhpcyBpcyBhbiBhbGlhcyBvZiB7QGxpbmsgTG9uZyNzaGlmdFJpZ2h0fS5cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcnwhTG9uZ30gbnVtQml0cyBOdW1iZXIgb2YgYml0c1xuICAgICAqIEByZXR1cm5zIHshTG9uZ30gU2hpZnRlZCBMb25nXG4gICAgICovXG4gICAgTG9uZ1Byb3RvdHlwZS5zaHIgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgbG9naWNhbGx5IHNoaWZ0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaGlmdGVkIExvbmdcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZCA9IGZ1bmN0aW9uIHNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKSB7XG4gICAgICBpZiAoaXNMb25nKG51bUJpdHMpKSBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgaWYgKChudW1CaXRzICY9IDYzKSA9PT0gMCkgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAobnVtQml0cyA8IDMyKVxuICAgICAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICAgICAgKHRoaXMubG93ID4+PiBudW1CaXRzKSB8ICh0aGlzLmhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLFxuICAgICAgICAgIHRoaXMuaGlnaCA+Pj4gbnVtQml0cyxcbiAgICAgICAgICB0aGlzLnVuc2lnbmVkLFxuICAgICAgICApO1xuICAgICAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgIHJldHVybiBmcm9tQml0cyh0aGlzLmhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuc2hydSA9IExvbmdQcm90b3R5cGUuc2hpZnRSaWdodFVuc2lnbmVkO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIGxvZ2ljYWxseSBzaGlmdGVkIHRvIHRoZSByaWdodCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3NoaWZ0UmlnaHRVbnNpZ25lZH0uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFNoaWZ0ZWQgTG9uZ1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUuc2hyX3UgPSBMb25nUHJvdG90eXBlLnNoaWZ0UmlnaHRVbnNpZ25lZDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhpcyBMb25nIHdpdGggYml0cyByb3RhdGVkIHRvIHRoZSBsZWZ0IGJ5IHRoZSBnaXZlbiBhbW91bnQuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiByb3RhdGVMZWZ0KG51bUJpdHMpIHtcbiAgICAgIHZhciBiO1xuICAgICAgaWYgKGlzTG9uZyhudW1CaXRzKSkgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApIHJldHVybiB0aGlzO1xuICAgICAgaWYgKG51bUJpdHMgPT09IDMyKSByZXR1cm4gZnJvbUJpdHModGhpcy5oaWdoLCB0aGlzLmxvdywgdGhpcy51bnNpZ25lZCk7XG4gICAgICBpZiAobnVtQml0cyA8IDMyKSB7XG4gICAgICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgICAgIHJldHVybiBmcm9tQml0cyhcbiAgICAgICAgICAodGhpcy5sb3cgPDwgbnVtQml0cykgfCAodGhpcy5oaWdoID4+PiBiKSxcbiAgICAgICAgICAodGhpcy5oaWdoIDw8IG51bUJpdHMpIHwgKHRoaXMubG93ID4+PiBiKSxcbiAgICAgICAgICB0aGlzLnVuc2lnbmVkLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbnVtQml0cyAtPSAzMjtcbiAgICAgIGIgPSAzMiAtIG51bUJpdHM7XG4gICAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICAgICh0aGlzLmhpZ2ggPDwgbnVtQml0cykgfCAodGhpcy5sb3cgPj4+IGIpLFxuICAgICAgICAodGhpcy5sb3cgPDwgbnVtQml0cykgfCAodGhpcy5oaWdoID4+PiBiKSxcbiAgICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICAgICk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgbGVmdCBieSB0aGUgZ2l2ZW4gYW1vdW50LiBUaGlzIGlzIGFuIGFsaWFzIG9mIHtAbGluayBMb25nI3JvdGF0ZUxlZnR9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnJvdGwgPSBMb25nUHJvdG90eXBlLnJvdGF0ZUxlZnQ7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoaXMgTG9uZyB3aXRoIGJpdHMgcm90YXRlZCB0byB0aGUgcmlnaHQgYnkgdGhlIGdpdmVuIGFtb3VudC5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHBhcmFtIHtudW1iZXJ8IUxvbmd9IG51bUJpdHMgTnVtYmVyIG9mIGJpdHNcbiAgICAgKiBAcmV0dXJucyB7IUxvbmd9IFJvdGF0ZWQgTG9uZ1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUucm90YXRlUmlnaHQgPSBmdW5jdGlvbiByb3RhdGVSaWdodChudW1CaXRzKSB7XG4gICAgICB2YXIgYjtcbiAgICAgIGlmIChpc0xvbmcobnVtQml0cykpIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKSByZXR1cm4gdGhpcztcbiAgICAgIGlmIChudW1CaXRzID09PSAzMikgcmV0dXJuIGZyb21CaXRzKHRoaXMuaGlnaCwgdGhpcy5sb3csIHRoaXMudW5zaWduZWQpO1xuICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgICBiID0gMzIgLSBudW1CaXRzO1xuICAgICAgICByZXR1cm4gZnJvbUJpdHMoXG4gICAgICAgICAgKHRoaXMuaGlnaCA8PCBiKSB8ICh0aGlzLmxvdyA+Pj4gbnVtQml0cyksXG4gICAgICAgICAgKHRoaXMubG93IDw8IGIpIHwgKHRoaXMuaGlnaCA+Pj4gbnVtQml0cyksXG4gICAgICAgICAgdGhpcy51bnNpZ25lZCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG51bUJpdHMgLT0gMzI7XG4gICAgICBiID0gMzIgLSBudW1CaXRzO1xuICAgICAgcmV0dXJuIGZyb21CaXRzKFxuICAgICAgICAodGhpcy5sb3cgPDwgYikgfCAodGhpcy5oaWdoID4+PiBudW1CaXRzKSxcbiAgICAgICAgKHRoaXMuaGlnaCA8PCBiKSB8ICh0aGlzLmxvdyA+Pj4gbnVtQml0cyksXG4gICAgICAgIHRoaXMudW5zaWduZWQsXG4gICAgICApO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGlzIExvbmcgd2l0aCBiaXRzIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IHRoZSBnaXZlbiBhbW91bnQuIFRoaXMgaXMgYW4gYWxpYXMgb2Yge0BsaW5rIExvbmcjcm90YXRlUmlnaHR9LlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfCFMb25nfSBudW1CaXRzIE51bWJlciBvZiBiaXRzXG4gICAgICogQHJldHVybnMgeyFMb25nfSBSb3RhdGVkIExvbmdcbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnJvdHIgPSBMb25nUHJvdG90eXBlLnJvdGF0ZVJpZ2h0O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIHNpZ25lZC5cbiAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICogQHJldHVybnMgeyFMb25nfSBTaWduZWQgbG9uZ1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUudG9TaWduZWQgPSBmdW5jdGlvbiB0b1NpZ25lZCgpIHtcbiAgICAgIGlmICghdGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIExvbmcgdG8gdW5zaWduZWQuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHshTG9uZ30gVW5zaWduZWQgbG9uZ1xuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIHRvVW5zaWduZWQoKSB7XG4gICAgICBpZiAodGhpcy51bnNpZ25lZCkgcmV0dXJuIHRoaXM7XG4gICAgICByZXR1cm4gZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgdHJ1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoaXMgTG9uZyB0byBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJ5dGUgcmVwcmVzZW50YXRpb25cbiAgICAgKi9cbiAgICBMb25nUHJvdG90eXBlLnRvQnl0ZXMgPSBmdW5jdGlvbiB0b0J5dGVzKGxlKSB7XG4gICAgICByZXR1cm4gbGUgPyB0aGlzLnRvQnl0ZXNMRSgpIDogdGhpcy50b0J5dGVzQkUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBsaXR0bGUgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IExpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0xFID0gZnVuY3Rpb24gdG9CeXRlc0xFKCkge1xuICAgICAgdmFyIGhpID0gdGhpcy5oaWdoLFxuICAgICAgICBsbyA9IHRoaXMubG93O1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgbG8gJiAweGZmLFxuICAgICAgICAobG8gPj4+IDgpICYgMHhmZixcbiAgICAgICAgKGxvID4+PiAxNikgJiAweGZmLFxuICAgICAgICBsbyA+Pj4gMjQsXG4gICAgICAgIGhpICYgMHhmZixcbiAgICAgICAgKGhpID4+PiA4KSAmIDB4ZmYsXG4gICAgICAgIChoaSA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgaGkgPj4+IDI0LFxuICAgICAgXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhpcyBMb25nIHRvIGl0cyBiaWcgZW5kaWFuIGJ5dGUgcmVwcmVzZW50YXRpb24uXG4gICAgICogQHRoaXMgeyFMb25nfVxuICAgICAqIEByZXR1cm5zIHshQXJyYXkuPG51bWJlcj59IEJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvblxuICAgICAqL1xuICAgIExvbmdQcm90b3R5cGUudG9CeXRlc0JFID0gZnVuY3Rpb24gdG9CeXRlc0JFKCkge1xuICAgICAgdmFyIGhpID0gdGhpcy5oaWdoLFxuICAgICAgICBsbyA9IHRoaXMubG93O1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgaGkgPj4+IDI0LFxuICAgICAgICAoaGkgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgIChoaSA+Pj4gOCkgJiAweGZmLFxuICAgICAgICBoaSAmIDB4ZmYsXG4gICAgICAgIGxvID4+PiAyNCxcbiAgICAgICAgKGxvID4+PiAxNikgJiAweGZmLFxuICAgICAgICAobG8gPj4+IDgpICYgMHhmZixcbiAgICAgICAgbG8gJiAweGZmLFxuICAgICAgXTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIExvbmcgZnJvbSBpdHMgYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQnl0ZSByZXByZXNlbnRhdGlvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBsZSBXaGV0aGVyIGxpdHRsZSBvciBiaWcgZW5kaWFuLCBkZWZhdWx0cyB0byBiaWcgZW5kaWFuXG4gICAgICogQHJldHVybnMge0xvbmd9IFRoZSBjb3JyZXNwb25kaW5nIExvbmcgdmFsdWVcbiAgICAgKi9cbiAgICBMb25nLmZyb21CeXRlcyA9IGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcywgdW5zaWduZWQsIGxlKSB7XG4gICAgICByZXR1cm4gbGVcbiAgICAgICAgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZClcbiAgICAgICAgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGxpdHRsZSBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgTGl0dGxlIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAgICovXG4gICAgTG9uZy5mcm9tQnl0ZXNMRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICAgICAgcmV0dXJuIG5ldyBMb25nKFxuICAgICAgICBieXRlc1swXSB8IChieXRlc1sxXSA8PCA4KSB8IChieXRlc1syXSA8PCAxNikgfCAoYnl0ZXNbM10gPDwgMjQpLFxuICAgICAgICBieXRlc1s0XSB8IChieXRlc1s1XSA8PCA4KSB8IChieXRlc1s2XSA8PCAxNikgfCAoYnl0ZXNbN10gPDwgMjQpLFxuICAgICAgICB1bnNpZ25lZCxcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb25nIGZyb20gaXRzIGJpZyBlbmRpYW4gYnl0ZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKiBAcGFyYW0geyFBcnJheS48bnVtYmVyPn0gYnl0ZXMgQmlnIGVuZGlhbiBieXRlIHJlcHJlc2VudGF0aW9uXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdW5zaWduZWQgV2hldGhlciB1bnNpZ25lZCBvciBub3QsIGRlZmF1bHRzIHRvIHNpZ25lZFxuICAgICAqIEByZXR1cm5zIHtMb25nfSBUaGUgY29ycmVzcG9uZGluZyBMb25nIHZhbHVlXG4gICAgICovXG4gICAgTG9uZy5mcm9tQnl0ZXNCRSA9IGZ1bmN0aW9uIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICAgICAgcmV0dXJuIG5ldyBMb25nKFxuICAgICAgICAoYnl0ZXNbNF0gPDwgMjQpIHwgKGJ5dGVzWzVdIDw8IDE2KSB8IChieXRlc1s2XSA8PCA4KSB8IGJ5dGVzWzddLFxuICAgICAgICAoYnl0ZXNbMF0gPDwgMjQpIHwgKGJ5dGVzWzFdIDw8IDE2KSB8IChieXRlc1syXSA8PCA4KSB8IGJ5dGVzWzNdLFxuICAgICAgICB1bnNpZ25lZCxcbiAgICAgICk7XG4gICAgfTtcblxuICAgIC8vIFN1cHBvcnQgY29udmVyc2lvbiB0by9mcm9tIEJpZ0ludCB3aGVyZSBhdmFpbGFibGVcbiAgICBpZiAodHlwZW9mIEJpZ0ludCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAvKipcbiAgICAgICAqIFJldHVybnMgYSBMb25nIHJlcHJlc2VudGluZyB0aGUgZ2l2ZW4gYmlnIGludGVnZXIuXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgYmlnIGludGVnZXIgdmFsdWVcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHVuc2lnbmVkIFdoZXRoZXIgdW5zaWduZWQgb3Igbm90LCBkZWZhdWx0cyB0byBzaWduZWRcbiAgICAgICAqIEByZXR1cm5zIHshTG9uZ30gVGhlIGNvcnJlc3BvbmRpbmcgTG9uZyB2YWx1ZVxuICAgICAgICovXG4gICAgICBMb25nLmZyb21CaWdJbnQgPSBmdW5jdGlvbiBmcm9tQmlnSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICB2YXIgbG93Qml0cyA9IE51bWJlcihCaWdJbnQuYXNJbnROKDMyLCB2YWx1ZSkpO1xuICAgICAgICB2YXIgaGlnaEJpdHMgPSBOdW1iZXIoQmlnSW50LmFzSW50TigzMiwgdmFsdWUgPj4gQmlnSW50KDMyKSkpO1xuICAgICAgICByZXR1cm4gZnJvbUJpdHMobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE92ZXJyaWRlXG4gICAgICBMb25nLmZyb21WYWx1ZSA9IGZ1bmN0aW9uIGZyb21WYWx1ZVdpdGhCaWdJbnQodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHJldHVybiBMb25nLmZyb21CaWdJbnQodmFsdWUsIHVuc2lnbmVkKTtcbiAgICAgICAgcmV0dXJuIGZyb21WYWx1ZSh2YWx1ZSwgdW5zaWduZWQpO1xuICAgICAgfTtcblxuICAgICAgLyoqXG4gICAgICAgKiBDb252ZXJ0cyB0aGUgTG9uZyB0byBpdHMgYmlnIGludGVnZXIgcmVwcmVzZW50YXRpb24uXG4gICAgICAgKiBAdGhpcyB7IUxvbmd9XG4gICAgICAgKiBAcmV0dXJucyB7YmlnaW50fVxuICAgICAgICovXG4gICAgICBMb25nUHJvdG90eXBlLnRvQmlnSW50ID0gZnVuY3Rpb24gdG9CaWdJbnQoKSB7XG4gICAgICAgIHZhciBsb3dCaWdJbnQgPSBCaWdJbnQodGhpcy5sb3cgPj4+IDApO1xuICAgICAgICB2YXIgaGlnaEJpZ0ludCA9IEJpZ0ludCh0aGlzLnVuc2lnbmVkID8gdGhpcy5oaWdoID4+PiAwIDogdGhpcy5oaWdoKTtcbiAgICAgICAgcmV0dXJuIChoaWdoQmlnSW50IDw8IEJpZ0ludCgzMikpIHwgbG93QmlnSW50O1xuICAgICAgfTtcbiAgICB9XG4gICAgdmFyIF9kZWZhdWx0ID0gKF9leHBvcnRzLmRlZmF1bHQgPSBMb25nKTtcbiAgfSxcbik7XG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsInByZWZlckRlZmF1bHQiLCJleHBvcnRzIiwiZGVmYXVsdCIsImRlZmluZSIsImFtZCIsIm1vZHVsZSIsIkxvbmciLCJnbG9iYWxUaGlzIiwic2VsZiIsIl9leHBvcnRzIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsIndhc20iLCJXZWJBc3NlbWJseSIsIkluc3RhbmNlIiwiTW9kdWxlIiwiVWludDhBcnJheSIsImxvdyIsImhpZ2giLCJ1bnNpZ25lZCIsInByb3RvdHlwZSIsIl9faXNMb25nX18iLCJpc0xvbmciLCJvYmoiLCJjdHozMiIsImMiLCJNYXRoIiwiY2x6MzIiLCJJTlRfQ0FDSEUiLCJVSU5UX0NBQ0hFIiwiZnJvbUludCIsImNhY2hlZE9iaiIsImNhY2hlIiwiZnJvbUJpdHMiLCJmcm9tTnVtYmVyIiwiaXNOYU4iLCJVWkVSTyIsIlpFUk8iLCJUV09fUFdSXzY0X0RCTCIsIk1BWF9VTlNJR05FRF9WQUxVRSIsIlRXT19QV1JfNjNfREJMIiwiTUlOX1ZBTFVFIiwiTUFYX1ZBTFVFIiwibmVnIiwiVFdPX1BXUl8zMl9EQkwiLCJsb3dCaXRzIiwiaGlnaEJpdHMiLCJwb3dfZGJsIiwicG93IiwiZnJvbVN0cmluZyIsInN0ciIsInJhZGl4IiwibGVuZ3RoIiwiRXJyb3IiLCJSYW5nZUVycm9yIiwicCIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJyYWRpeFRvUG93ZXIiLCJyZXN1bHQiLCJpIiwic2l6ZSIsIm1pbiIsInBhcnNlSW50IiwicG93ZXIiLCJtdWwiLCJhZGQiLCJmcm9tVmFsdWUiLCJ2YWwiLCJUV09fUFdSXzE2X0RCTCIsIlRXT19QV1JfMjRfREJMIiwiVFdPX1BXUl8yNCIsIk9ORSIsIlVPTkUiLCJORUdfT05FIiwiTG9uZ1Byb3RvdHlwZSIsInRvSW50IiwidG9OdW1iZXIiLCJ0b1N0cmluZyIsImlzWmVybyIsImlzTmVnYXRpdmUiLCJlcSIsInJhZGl4TG9uZyIsImRpdiIsInJlbTEiLCJzdWIiLCJyZW0iLCJyZW1EaXYiLCJpbnR2YWwiLCJkaWdpdHMiLCJnZXRIaWdoQml0cyIsImdldEhpZ2hCaXRzVW5zaWduZWQiLCJnZXRMb3dCaXRzIiwiZ2V0TG93Qml0c1Vuc2lnbmVkIiwiZ2V0TnVtQml0c0FicyIsImJpdCIsImlzU2FmZUludGVnZXIiLCJ0b3AxMUJpdHMiLCJlcXoiLCJpc1Bvc2l0aXZlIiwiaXNPZGQiLCJpc0V2ZW4iLCJlcXVhbHMiLCJvdGhlciIsIm5vdEVxdWFscyIsIm5lcSIsIm5lIiwibGVzc1RoYW4iLCJjb21wIiwibHQiLCJsZXNzVGhhbk9yRXF1YWwiLCJsdGUiLCJsZSIsImdyZWF0ZXJUaGFuIiwiZ3QiLCJncmVhdGVyVGhhbk9yRXF1YWwiLCJndGUiLCJnZSIsImNvbXBhcmUiLCJ0aGlzTmVnIiwib3RoZXJOZWciLCJuZWdhdGUiLCJub3QiLCJhZGRlbmQiLCJhNDgiLCJhMzIiLCJhMTYiLCJhMDAiLCJiNDgiLCJiMzIiLCJiMTYiLCJiMDAiLCJjNDgiLCJjMzIiLCJjMTYiLCJjMDAiLCJzdWJ0cmFjdCIsInN1YnRyYWhlbmQiLCJtdWx0aXBseSIsIm11bHRpcGxpZXIiLCJkaXZpZGUiLCJkaXZpc29yIiwiYXBwcm94IiwicmVzIiwiaGFsZlRoaXMiLCJzaHIiLCJzaGwiLCJ0b1Vuc2lnbmVkIiwic2hydSIsIm1heCIsImZsb29yIiwibG9nMiIsImNlaWwiLCJsb2ciLCJMTjIiLCJkZWx0YSIsImFwcHJveFJlcyIsImFwcHJveFJlbSIsIm1vZHVsbyIsIm1vZCIsImNvdW50TGVhZGluZ1plcm9zIiwiY2x6IiwiY291bnRUcmFpbGluZ1plcm9zIiwiY3R6IiwiYW5kIiwib3IiLCJ4b3IiLCJzaGlmdExlZnQiLCJudW1CaXRzIiwic2hpZnRSaWdodCIsInNoaWZ0UmlnaHRVbnNpZ25lZCIsInNocl91Iiwicm90YXRlTGVmdCIsImIiLCJyb3RsIiwicm90YXRlUmlnaHQiLCJyb3RyIiwidG9TaWduZWQiLCJ0b0J5dGVzIiwidG9CeXRlc0xFIiwidG9CeXRlc0JFIiwiaGkiLCJsbyIsImZyb21CeXRlcyIsImJ5dGVzIiwiZnJvbUJ5dGVzTEUiLCJmcm9tQnl0ZXNCRSIsIkJpZ0ludCIsImZyb21CaWdJbnQiLCJOdW1iZXIiLCJhc0ludE4iLCJmcm9tVmFsdWVXaXRoQmlnSW50IiwidG9CaWdJbnQiLCJsb3dCaWdJbnQiLCJoaWdoQmlnSW50IiwiX2RlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@grpc/grpc-js/node_modules/long/umd/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/api.json":
/*!*************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/api.json ***!
  \*************************************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"Api":{"fields":{"name":{"type":"string","id":1},"methods":{"rule":"repeated","type":"Method","id":2},"options":{"rule":"repeated","type":"Option","id":3},"version":{"type":"string","id":4},"sourceContext":{"type":"SourceContext","id":5},"mixins":{"rule":"repeated","type":"Mixin","id":6},"syntax":{"type":"Syntax","id":7}}},"Method":{"fields":{"name":{"type":"string","id":1},"requestTypeUrl":{"type":"string","id":2},"requestStreaming":{"type":"bool","id":3},"responseTypeUrl":{"type":"string","id":4},"responseStreaming":{"type":"bool","id":5},"options":{"rule":"repeated","type":"Option","id":6},"syntax":{"type":"Syntax","id":7}}},"Mixin":{"fields":{"name":{"type":"string","id":1},"root":{"type":"string","id":2}}},"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}},"Option":{"fields":{"name":{"type":"string","id":1},"value":{"type":"Any","id":2}}},"Syntax":{"values":{"SYNTAX_PROTO2":0,"SYNTAX_PROTO3":1}}}}}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/descriptor.json":
/*!********************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/descriptor.json ***!
  \********************************************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"options":{"go_package":"google.golang.org/protobuf/types/descriptorpb","java_package":"com.google.protobuf","java_outer_classname":"DescriptorProtos","csharp_namespace":"Google.Protobuf.Reflection","objc_class_prefix":"GPB","cc_enable_arenas":true,"optimize_for":"SPEED"},"nested":{"FileDescriptorSet":{"edition":"proto2","fields":{"file":{"rule":"repeated","type":"FileDescriptorProto","id":1}},"extensions":[[536000000,536000000]]},"Edition":{"edition":"proto2","values":{"EDITION_UNKNOWN":0,"EDITION_LEGACY":900,"EDITION_PROTO2":998,"EDITION_PROTO3":999,"EDITION_2023":1000,"EDITION_2024":1001,"EDITION_1_TEST_ONLY":1,"EDITION_2_TEST_ONLY":2,"EDITION_99997_TEST_ONLY":99997,"EDITION_99998_TEST_ONLY":99998,"EDITION_99999_TEST_ONLY":99999,"EDITION_MAX":2147483647}},"FileDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"package":{"type":"string","id":2},"dependency":{"rule":"repeated","type":"string","id":3},"publicDependency":{"rule":"repeated","type":"int32","id":10},"weakDependency":{"rule":"repeated","type":"int32","id":11},"optionDependency":{"rule":"repeated","type":"string","id":15},"messageType":{"rule":"repeated","type":"DescriptorProto","id":4},"enumType":{"rule":"repeated","type":"EnumDescriptorProto","id":5},"service":{"rule":"repeated","type":"ServiceDescriptorProto","id":6},"extension":{"rule":"repeated","type":"FieldDescriptorProto","id":7},"options":{"type":"FileOptions","id":8},"sourceCodeInfo":{"type":"SourceCodeInfo","id":9},"syntax":{"type":"string","id":12},"edition":{"type":"Edition","id":14}}},"DescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"field":{"rule":"repeated","type":"FieldDescriptorProto","id":2},"extension":{"rule":"repeated","type":"FieldDescriptorProto","id":6},"nestedType":{"rule":"repeated","type":"DescriptorProto","id":3},"enumType":{"rule":"repeated","type":"EnumDescriptorProto","id":4},"extensionRange":{"rule":"repeated","type":"ExtensionRange","id":5},"oneofDecl":{"rule":"repeated","type":"OneofDescriptorProto","id":8},"options":{"type":"MessageOptions","id":7},"reservedRange":{"rule":"repeated","type":"ReservedRange","id":9},"reservedName":{"rule":"repeated","type":"string","id":10},"visibility":{"type":"SymbolVisibility","id":11}},"nested":{"ExtensionRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2},"options":{"type":"ExtensionRangeOptions","id":3}}},"ReservedRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2}}}}},"ExtensionRangeOptions":{"edition":"proto2","fields":{"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999},"declaration":{"rule":"repeated","type":"Declaration","id":2,"options":{"retention":"RETENTION_SOURCE"}},"features":{"type":"FeatureSet","id":50},"verification":{"type":"VerificationState","id":3,"options":{"default":"UNVERIFIED","retention":"RETENTION_SOURCE"}}},"extensions":[[1000,536870911]],"nested":{"Declaration":{"fields":{"number":{"type":"int32","id":1},"fullName":{"type":"string","id":2},"type":{"type":"string","id":3},"reserved":{"type":"bool","id":5},"repeated":{"type":"bool","id":6}},"reserved":[[4,4]]},"VerificationState":{"values":{"DECLARATION":0,"UNVERIFIED":1}}}},"FieldDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":3},"label":{"type":"Label","id":4},"type":{"type":"Type","id":5},"typeName":{"type":"string","id":6},"extendee":{"type":"string","id":2},"defaultValue":{"type":"string","id":7},"oneofIndex":{"type":"int32","id":9},"jsonName":{"type":"string","id":10},"options":{"type":"FieldOptions","id":8},"proto3Optional":{"type":"bool","id":17}},"nested":{"Type":{"values":{"TYPE_DOUBLE":1,"TYPE_FLOAT":2,"TYPE_INT64":3,"TYPE_UINT64":4,"TYPE_INT32":5,"TYPE_FIXED64":6,"TYPE_FIXED32":7,"TYPE_BOOL":8,"TYPE_STRING":9,"TYPE_GROUP":10,"TYPE_MESSAGE":11,"TYPE_BYTES":12,"TYPE_UINT32":13,"TYPE_ENUM":14,"TYPE_SFIXED32":15,"TYPE_SFIXED64":16,"TYPE_SINT32":17,"TYPE_SINT64":18}},"Label":{"values":{"LABEL_OPTIONAL":1,"LABEL_REPEATED":3,"LABEL_REQUIRED":2}}}},"OneofDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"options":{"type":"OneofOptions","id":2}}},"EnumDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"value":{"rule":"repeated","type":"EnumValueDescriptorProto","id":2},"options":{"type":"EnumOptions","id":3},"reservedRange":{"rule":"repeated","type":"EnumReservedRange","id":4},"reservedName":{"rule":"repeated","type":"string","id":5},"visibility":{"type":"SymbolVisibility","id":6}},"nested":{"EnumReservedRange":{"fields":{"start":{"type":"int32","id":1},"end":{"type":"int32","id":2}}}}},"EnumValueDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":2},"options":{"type":"EnumValueOptions","id":3}}},"ServiceDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"method":{"rule":"repeated","type":"MethodDescriptorProto","id":2},"options":{"type":"ServiceOptions","id":3}}},"MethodDescriptorProto":{"edition":"proto2","fields":{"name":{"type":"string","id":1},"inputType":{"type":"string","id":2},"outputType":{"type":"string","id":3},"options":{"type":"MethodOptions","id":4},"clientStreaming":{"type":"bool","id":5},"serverStreaming":{"type":"bool","id":6}}},"FileOptions":{"edition":"proto2","fields":{"javaPackage":{"type":"string","id":1},"javaOuterClassname":{"type":"string","id":8},"javaMultipleFiles":{"type":"bool","id":10},"javaGenerateEqualsAndHash":{"type":"bool","id":20,"options":{"deprecated":true}},"javaStringCheckUtf8":{"type":"bool","id":27},"optimizeFor":{"type":"OptimizeMode","id":9,"options":{"default":"SPEED"}},"goPackage":{"type":"string","id":11},"ccGenericServices":{"type":"bool","id":16},"javaGenericServices":{"type":"bool","id":17},"pyGenericServices":{"type":"bool","id":18},"deprecated":{"type":"bool","id":23},"ccEnableArenas":{"type":"bool","id":31,"options":{"default":true}},"objcClassPrefix":{"type":"string","id":36},"csharpNamespace":{"type":"string","id":37},"swiftPrefix":{"type":"string","id":39},"phpClassPrefix":{"type":"string","id":40},"phpNamespace":{"type":"string","id":41},"phpMetadataNamespace":{"type":"string","id":44},"rubyPackage":{"type":"string","id":45},"features":{"type":"FeatureSet","id":50},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[42,42],"php_generic_services",[38,38]],"nested":{"OptimizeMode":{"values":{"SPEED":1,"CODE_SIZE":2,"LITE_RUNTIME":3}}}},"MessageOptions":{"edition":"proto2","fields":{"messageSetWireFormat":{"type":"bool","id":1},"noStandardDescriptorAccessor":{"type":"bool","id":2},"deprecated":{"type":"bool","id":3},"mapEntry":{"type":"bool","id":7},"deprecatedLegacyJsonFieldConflicts":{"type":"bool","id":11,"options":{"deprecated":true}},"features":{"type":"FeatureSet","id":12},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[4,4],[5,5],[6,6],[8,8],[9,9]]},"FieldOptions":{"edition":"proto2","fields":{"ctype":{"type":"CType","id":1,"options":{"default":"STRING"}},"packed":{"type":"bool","id":2},"jstype":{"type":"JSType","id":6,"options":{"default":"JS_NORMAL"}},"lazy":{"type":"bool","id":5},"unverifiedLazy":{"type":"bool","id":15},"deprecated":{"type":"bool","id":3},"weak":{"type":"bool","id":10,"options":{"deprecated":true}},"debugRedact":{"type":"bool","id":16},"retention":{"type":"OptionRetention","id":17},"targets":{"rule":"repeated","type":"OptionTargetType","id":19},"editionDefaults":{"rule":"repeated","type":"EditionDefault","id":20},"features":{"type":"FeatureSet","id":21},"featureSupport":{"type":"FeatureSupport","id":22},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[4,4],[18,18]],"nested":{"CType":{"values":{"STRING":0,"CORD":1,"STRING_PIECE":2}},"JSType":{"values":{"JS_NORMAL":0,"JS_STRING":1,"JS_NUMBER":2}},"OptionRetention":{"values":{"RETENTION_UNKNOWN":0,"RETENTION_RUNTIME":1,"RETENTION_SOURCE":2}},"OptionTargetType":{"values":{"TARGET_TYPE_UNKNOWN":0,"TARGET_TYPE_FILE":1,"TARGET_TYPE_EXTENSION_RANGE":2,"TARGET_TYPE_MESSAGE":3,"TARGET_TYPE_FIELD":4,"TARGET_TYPE_ONEOF":5,"TARGET_TYPE_ENUM":6,"TARGET_TYPE_ENUM_ENTRY":7,"TARGET_TYPE_SERVICE":8,"TARGET_TYPE_METHOD":9}},"EditionDefault":{"fields":{"edition":{"type":"Edition","id":3},"value":{"type":"string","id":2}}},"FeatureSupport":{"fields":{"editionIntroduced":{"type":"Edition","id":1},"editionDeprecated":{"type":"Edition","id":2},"deprecationWarning":{"type":"string","id":3},"editionRemoved":{"type":"Edition","id":4}}}}},"OneofOptions":{"edition":"proto2","fields":{"features":{"type":"FeatureSet","id":1},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"EnumOptions":{"edition":"proto2","fields":{"allowAlias":{"type":"bool","id":2},"deprecated":{"type":"bool","id":3},"deprecatedLegacyJsonFieldConflicts":{"type":"bool","id":6,"options":{"deprecated":true}},"features":{"type":"FeatureSet","id":7},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"reserved":[[5,5]]},"EnumValueOptions":{"edition":"proto2","fields":{"deprecated":{"type":"bool","id":1},"features":{"type":"FeatureSet","id":2},"debugRedact":{"type":"bool","id":3},"featureSupport":{"type":"FieldOptions.FeatureSupport","id":4},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"ServiceOptions":{"edition":"proto2","fields":{"features":{"type":"FeatureSet","id":34},"deprecated":{"type":"bool","id":33},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]]},"MethodOptions":{"edition":"proto2","fields":{"deprecated":{"type":"bool","id":33},"idempotencyLevel":{"type":"IdempotencyLevel","id":34,"options":{"default":"IDEMPOTENCY_UNKNOWN"}},"features":{"type":"FeatureSet","id":35},"uninterpretedOption":{"rule":"repeated","type":"UninterpretedOption","id":999}},"extensions":[[1000,536870911]],"nested":{"IdempotencyLevel":{"values":{"IDEMPOTENCY_UNKNOWN":0,"NO_SIDE_EFFECTS":1,"IDEMPOTENT":2}}}},"UninterpretedOption":{"edition":"proto2","fields":{"name":{"rule":"repeated","type":"NamePart","id":2},"identifierValue":{"type":"string","id":3},"positiveIntValue":{"type":"uint64","id":4},"negativeIntValue":{"type":"int64","id":5},"doubleValue":{"type":"double","id":6},"stringValue":{"type":"bytes","id":7},"aggregateValue":{"type":"string","id":8}},"nested":{"NamePart":{"fields":{"namePart":{"rule":"required","type":"string","id":1},"isExtension":{"rule":"required","type":"bool","id":2}}}}},"FeatureSet":{"edition":"proto2","fields":{"fieldPresence":{"type":"FieldPresence","id":1,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_2023","edition_defaults.value":"EXPLICIT"}},"enumType":{"type":"EnumType","id":2,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_PROTO3","edition_defaults.value":"OPEN"}},"repeatedFieldEncoding":{"type":"RepeatedFieldEncoding","id":3,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_PROTO3","edition_defaults.value":"PACKED"}},"utf8Validation":{"type":"Utf8Validation","id":4,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_PROTO3","edition_defaults.value":"VERIFY"}},"messageEncoding":{"type":"MessageEncoding","id":5,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_LEGACY","edition_defaults.value":"LENGTH_PREFIXED"}},"jsonFormat":{"type":"JsonFormat","id":6,"options":{"retention":"RETENTION_RUNTIME","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2023","edition_defaults.edition":"EDITION_PROTO3","edition_defaults.value":"ALLOW"}},"enforceNamingStyle":{"type":"EnforceNamingStyle","id":7,"options":{"retention":"RETENTION_SOURCE","targets":"TARGET_TYPE_METHOD","feature_support.edition_introduced":"EDITION_2024","edition_defaults.edition":"EDITION_2024","edition_defaults.value":"STYLE2024"}},"defaultSymbolVisibility":{"type":"VisibilityFeature.DefaultSymbolVisibility","id":8,"options":{"retention":"RETENTION_SOURCE","targets":"TARGET_TYPE_FILE","feature_support.edition_introduced":"EDITION_2024","edition_defaults.edition":"EDITION_2024","edition_defaults.value":"EXPORT_TOP_LEVEL"}}},"extensions":[[1000,9994],[9995,9999],[10000,10000]],"reserved":[[999,999]],"nested":{"FieldPresence":{"values":{"FIELD_PRESENCE_UNKNOWN":0,"EXPLICIT":1,"IMPLICIT":2,"LEGACY_REQUIRED":3}},"EnumType":{"values":{"ENUM_TYPE_UNKNOWN":0,"OPEN":1,"CLOSED":2}},"RepeatedFieldEncoding":{"values":{"REPEATED_FIELD_ENCODING_UNKNOWN":0,"PACKED":1,"EXPANDED":2}},"Utf8Validation":{"values":{"UTF8_VALIDATION_UNKNOWN":0,"VERIFY":2,"NONE":3}},"MessageEncoding":{"values":{"MESSAGE_ENCODING_UNKNOWN":0,"LENGTH_PREFIXED":1,"DELIMITED":2}},"JsonFormat":{"values":{"JSON_FORMAT_UNKNOWN":0,"ALLOW":1,"LEGACY_BEST_EFFORT":2}},"EnforceNamingStyle":{"values":{"ENFORCE_NAMING_STYLE_UNKNOWN":0,"STYLE2024":1,"STYLE_LEGACY":2}},"VisibilityFeature":{"fields":{},"reserved":[[1,536870911]],"nested":{"DefaultSymbolVisibility":{"values":{"DEFAULT_SYMBOL_VISIBILITY_UNKNOWN":0,"EXPORT_ALL":1,"EXPORT_TOP_LEVEL":2,"LOCAL_ALL":3,"STRICT":4}}}}}},"FeatureSetDefaults":{"edition":"proto2","fields":{"defaults":{"rule":"repeated","type":"FeatureSetEditionDefault","id":1},"minimumEdition":{"type":"Edition","id":4},"maximumEdition":{"type":"Edition","id":5}},"nested":{"FeatureSetEditionDefault":{"fields":{"edition":{"type":"Edition","id":3},"overridableFeatures":{"type":"FeatureSet","id":4},"fixedFeatures":{"type":"FeatureSet","id":5}},"reserved":[[1,1],[2,2],"features"]}}},"SourceCodeInfo":{"edition":"proto2","fields":{"location":{"rule":"repeated","type":"Location","id":1}},"extensions":[[536000000,536000000]],"nested":{"Location":{"fields":{"path":{"rule":"repeated","type":"int32","id":1,"options":{"packed":true}},"span":{"rule":"repeated","type":"int32","id":2,"options":{"packed":true}},"leadingComments":{"type":"string","id":3},"trailingComments":{"type":"string","id":4},"leadingDetachedComments":{"rule":"repeated","type":"string","id":6}}}}},"GeneratedCodeInfo":{"edition":"proto2","fields":{"annotation":{"rule":"repeated","type":"Annotation","id":1}},"nested":{"Annotation":{"fields":{"path":{"rule":"repeated","type":"int32","id":1,"options":{"packed":true}},"sourceFile":{"type":"string","id":2},"begin":{"type":"int32","id":3},"end":{"type":"int32","id":4},"semantic":{"type":"Semantic","id":5}},"nested":{"Semantic":{"values":{"NONE":0,"SET":1,"ALIAS":2}}}}}},"SymbolVisibility":{"edition":"proto2","values":{"VISIBILITY_UNSET":0,"VISIBILITY_LOCAL":1,"VISIBILITY_EXPORT":2}}}}}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/source_context.json":
/*!************************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/source_context.json ***!
  \************************************************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}}}}}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/type.json":
/*!**************************************************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/node_modules/protobufjs/google/protobuf/type.json ***!
  \**************************************************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"nested":{"google":{"nested":{"protobuf":{"nested":{"Type":{"fields":{"name":{"type":"string","id":1},"fields":{"rule":"repeated","type":"Field","id":2},"oneofs":{"rule":"repeated","type":"string","id":3},"options":{"rule":"repeated","type":"Option","id":4},"sourceContext":{"type":"SourceContext","id":5},"syntax":{"type":"Syntax","id":6}}},"Field":{"fields":{"kind":{"type":"Kind","id":1},"cardinality":{"type":"Cardinality","id":2},"number":{"type":"int32","id":3},"name":{"type":"string","id":4},"typeUrl":{"type":"string","id":6},"oneofIndex":{"type":"int32","id":7},"packed":{"type":"bool","id":8},"options":{"rule":"repeated","type":"Option","id":9},"jsonName":{"type":"string","id":10},"defaultValue":{"type":"string","id":11}},"nested":{"Kind":{"values":{"TYPE_UNKNOWN":0,"TYPE_DOUBLE":1,"TYPE_FLOAT":2,"TYPE_INT64":3,"TYPE_UINT64":4,"TYPE_INT32":5,"TYPE_FIXED64":6,"TYPE_FIXED32":7,"TYPE_BOOL":8,"TYPE_STRING":9,"TYPE_GROUP":10,"TYPE_MESSAGE":11,"TYPE_BYTES":12,"TYPE_UINT32":13,"TYPE_ENUM":14,"TYPE_SFIXED32":15,"TYPE_SFIXED64":16,"TYPE_SINT32":17,"TYPE_SINT64":18}},"Cardinality":{"values":{"CARDINALITY_UNKNOWN":0,"CARDINALITY_OPTIONAL":1,"CARDINALITY_REQUIRED":2,"CARDINALITY_REPEATED":3}}}},"Enum":{"fields":{"name":{"type":"string","id":1},"enumvalue":{"rule":"repeated","type":"EnumValue","id":2},"options":{"rule":"repeated","type":"Option","id":3},"sourceContext":{"type":"SourceContext","id":4},"syntax":{"type":"Syntax","id":5}}},"EnumValue":{"fields":{"name":{"type":"string","id":1},"number":{"type":"int32","id":2},"options":{"rule":"repeated","type":"Option","id":3}}},"Option":{"fields":{"name":{"type":"string","id":1},"value":{"type":"Any","id":2}}},"Syntax":{"values":{"SYNTAX_PROTO2":0,"SYNTAX_PROTO3":1}},"Any":{"fields":{"type_url":{"type":"string","id":1},"value":{"type":"bytes","id":2}}},"SourceContext":{"fields":{"fileName":{"type":"string","id":1}}}}}}}}}');

/***/ }),

/***/ "(ssr)/./node_modules/@grpc/grpc-js/package.json":
/*!*************************************************!*\
  !*** ./node_modules/@grpc/grpc-js/package.json ***!
  \*************************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"name":"@grpc/grpc-js","version":"1.7.3","description":"gRPC Library for Node - pure JS implementation","homepage":"https://grpc.io/","repository":"https://github.com/grpc/grpc-node/tree/master/packages/grpc-js","main":"build/src/index.js","engines":{"node":"^8.13.0 || >=10.10.0"},"keywords":[],"author":{"name":"Google Inc."},"types":"build/src/index.d.ts","license":"Apache-2.0","devDependencies":{"@types/gulp":"^4.0.6","@types/gulp-mocha":"0.0.32","@types/lodash":"^4.14.108","@types/mocha":"^5.2.6","@types/ncp":"^2.0.1","@types/pify":"^3.0.2","@types/semver":"^7.3.9","clang-format":"^1.0.55","execa":"^2.0.3","gts":"^2.0.0","gulp":"^4.0.2","gulp-mocha":"^6.0.0","lodash":"^4.17.4","madge":"^5.0.1","mocha-jenkins-reporter":"^0.4.1","ncp":"^2.0.0","pify":"^4.0.1","rimraf":"^3.0.2","semver":"^7.3.5","ts-node":"^8.3.0","typescript":"^3.7.2"},"contributors":[{"name":"Google Inc."}],"scripts":{"build":"npm run compile","clean":"rimraf ./build","compile":"tsc -p .","format":"clang-format -i -style=\\"{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}\\" src/*.ts test/*.ts","lint":"npm run check","prepare":"npm run generate-types && npm run compile","test":"gulp test","check":"gts check src/**/*.ts","fix":"gts fix src/*.ts","pretest":"npm run generate-types && npm run generate-test-types && npm run compile","posttest":"npm run check && madge -c ./build/src","generate-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto","generate-test-types":"proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"},"dependencies":{"@grpc/proto-loader":"^0.7.0","@types/node":">=12.12.47"},"files":["src/**/*.ts","build/src/**/*.{js,d.ts,js.map}","proto/*.proto","LICENSE","deps/envoy-api/envoy/api/v2/**/*.proto","deps/envoy-api/envoy/config/**/*.proto","deps/envoy-api/envoy/service/**/*.proto","deps/envoy-api/envoy/type/**/*.proto","deps/udpa/udpa/**/*.proto","deps/googleapis/google/api/*.proto","deps/googleapis/google/rpc/*.proto","deps/protoc-gen-validate/validate/**/*.proto"]}');

/***/ })

};
;